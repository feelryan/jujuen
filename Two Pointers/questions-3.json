[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Two Pointers, Greedy, Array, Container With Most Water",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (left < right) {\n    int currentArea = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, currentArea);\n    if (height[left] < height[right]) {\n        left++;\n    } else {\n        right--;\n    }\n}",
    "question": [
      {
        "t": "在解決「盛最多水的容器」(Container With Most Water) 問題時，我們通常使用雙指針法從陣列的兩端向中間移動。",
        "en": "When solving the 'Container With Most Water' problem, we typically use the two-pointer approach moving from both ends of the array towards the center.",
        "wg": [
          {
            "t": "盛最多水的容器",
            "en": "Container With Most Water",
            "ps": "NP"
          },
          {
            "t": "雙指針法",
            "en": "two-pointer approach",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請參考附帶的程式碼片段，為什麼在每次迭代中，我們總是移動高度較低的那一側指針？",
        "en": "Referring to the attached code snippet, why do we always move the pointer corresponding to the shorter height in each iteration?",
        "wg": [
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          },
          {
            "t": "高度較低",
            "en": "shorter height",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為移動較高的指針可能會導致寬度減小，但高度受限於較低的一邊，因此面積不可能增加。",
        "en": "(A) Because moving the taller pointer decreases the width, but the height is limited by the shorter side, so the area cannot possibly increase.",
        "wg": [
          {
            "t": "受限於",
            "en": "limited by",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 因為移動較低的指針可以保證下一次計算出的面積一定會變大。",
        "en": "(B) Because moving the shorter pointer guarantees that the next calculated area will definitely be larger.",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 這只是為了防止無限迴圈，移動哪一邊並不影響最終結果。",
        "en": "(C) This is just to prevent an infinite loop; which side moves does not affect the final result.",
        "wg": [
          {
            "t": "無限迴圈",
            "en": "infinite loop",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 因為較低的指針代表數值較小，在計算乘積時權重較低，應優先捨棄。",
        "en": "(D) Because the shorter pointer represents a smaller value, it has less weight in the product calculation and should be discarded first.",
        "wg": [
          {
            "t": "權重",
            "en": "weight",
            "ps": "N"
          },
          {
            "t": "捨棄",
            "en": "discard",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "容器的面積由 `min(h[left], h[right]) * width` 決定。如果移動較高的一邊，寬度變小，而高度仍然受限於未移動的較低邊（或變得更低），因此面積一定會變小。只有移動較低的一邊，才有可能找到更高的邊來彌補寬度的損失，從而獲得更大的面積。",
      "en": "The area is determined by `min(h[left], h[right]) * width`. If we move the taller side, the width decreases, and the height remains limited by the unmoved shorter side (or becomes even shorter), so the area will definitely decrease. Only by moving the shorter side is it possible to find a taller line to compensate for the loss in width, potentially yielding a larger area.",
      "wg": [
        {
          "t": "彌補",
          "en": "compensate",
          "ps": "V"
        },
        {
          "t": "損失",
          "en": "loss",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Two Pointers, Array, 3Sum, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「三數之和」(3Sum) 問題時，目標是找出所有和為 0 的不重複三元組。",
        "en": "When solving the '3Sum' problem, the goal is to find all unique triplets that sum up to 0.",
        "wg": [
          {
            "t": "三數之和",
            "en": "3Sum",
            "ps": "NP"
          },
          {
            "t": "三元組",
            "en": "triplets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "通常我們會先將陣列排序，然後固定一個數字 `i`，並使用雙指針 `left` 和 `right` 尋找另外兩個數字。",
        "en": "Typically, we sort the array first, then fix one number `i`, and use two pointers `left` and `right` to find the other two numbers.",
        "wg": [
          {
            "t": "固定",
            "en": "fix",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在處理過程中，為了避免結果中出現重複的三元組，下列哪項操作是**最關鍵**的？",
        "en": "During the process, to avoid duplicate triplets in the result, which of the following operations is **most critical**?",
        "wg": [
          {
            "t": "重複的",
            "en": "duplicate",
            "ps": "Adj"
          },
          {
            "t": "關鍵",
            "en": "critical",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 HashSet 來儲存所有找到的三元組，最後再轉回列表。",
        "en": "(A) Use a HashSet to store all found triplets and convert them back to a list at the end.",
        "wg": [
          {
            "t": "儲存",
            "en": "store",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 在移動 `i`、`left` 或 `right` 時，若遇到與前一個位置數值相同的元素，應直接跳過。",
        "en": "(B) When moving `i`, `left`, or `right`, if the element is the same as the value at the previous position, skip it directly.",
        "wg": [
          {
            "t": "數值",
            "en": "value",
            "ps": "N"
          },
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 限制 `left` 指針只能向右移動，`right` 指針只能向左移動，且不能重置。",
        "en": "(C) Restrict the `left` pointer to only move right and the `right` pointer to only move left, without resetting.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 確保輸入陣列中沒有任何重複的數字。",
        "en": "(D) Ensure that there are no duplicate numbers in the input array.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雖然使用 Set (A) 可以去重，但會增加額外的空間複雜度並可能影響時間效率。在排序後的陣列中，最佳做法是在遍歷時檢測相鄰元素：如果 `nums[i] == nums[i-1]`，則跳過 `i`；同理，當找到一組解後，若 `nums[left] == nums[left+1]` 則繼續移動 `left`，以確保解的唯一性。",
      "en": "While using a Set (A) can remove duplicates, it adds extra space complexity and may affect time efficiency. In a sorted array, the best practice is to check adjacent elements during iteration: if `nums[i] == nums[i-1]`, skip `i`. Similarly, after finding a solution, if `nums[left] == nums[left+1]`, continue moving `left` to ensure the uniqueness of the solution.",
      "wg": [
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "NP"
        },
        {
          "t": "遍歷",
          "en": "iterate/traverse",
          "ps": "V"
        },
        {
          "t": "唯一性",
          "en": "uniqueness",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Two Pointers, Linked List, Cycle Detection, Floyd's Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於使用快慢指針 (Fast and Slow Pointers) 檢測鏈結串列 (Linked List) 是否有環 (Cycle) 的演算法（Floyd's Cycle-Finding Algorithm）。",
        "en": "Regarding the algorithm using Fast and Slow Pointers to detect if a Linked List has a Cycle (Floyd's Cycle-Finding Algorithm).",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "NP"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設慢指針每次走 1 步，快指針每次走 2 步。如果鏈結串列中存在環，下列敘述何者正確？",
        "en": "Assume the slow pointer moves 1 step at a time and the fast pointer moves 2 steps. If a cycle exists in the linked list, which of the following statements is true?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 快指針會因為速度過快而跳過慢指針，導致兩者永遠不會相遇。",
        "en": "(A) The fast pointer will jump over the slow pointer due to its speed, causing them to never meet.",
        "wg": [
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 兩者一定會在環內的某個節點相遇，且時間複雜度為 O(N)。",
        "en": "(B) They will definitely meet at some node within the cycle, and the time complexity is O(N).",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 只有當環的長度是偶數時，兩者才會相遇。",
        "en": "(C) They will only meet if the length of the cycle is an even number.",
        "wg": [
          {
            "t": "偶數",
            "en": "even number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 快指針會在慢指針進入環之前就已經繞完一圈並回到起點。",
        "en": "(D) The fast pointer will complete a full loop and return to the start before the slow pointer enters the cycle.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當快慢指針都進入環後，可以將問題視為快指針在追趕慢指針。由於快指針每次比慢指針多走 1 步，兩者之間的距離每次減少 1。無論距離多遠，距離最終都會歸零（即相遇）。因為指針移動次數與鏈結串列長度成正比，故時間複雜度為 O(N)。",
      "en": "Once both pointers enter the cycle, the problem can be viewed as the fast pointer chasing the slow pointer. Since the fast pointer moves 1 step more than the slow pointer each time, the distance between them decreases by 1 in each step. Regardless of the distance, it will eventually become zero (i.e., they meet). Since the number of moves is proportional to the list length, the time complexity is O(N).",
      "wg": [
        {
          "t": "追趕",
          "en": "chase",
          "ps": "V"
        },
        {
          "t": "成正比",
          "en": "proportional to",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Two Pointers, Dynamic Programming, Trapping Rain Water",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (leftMax < rightMax) {\n    ans += leftMax - height[left];\n    left++;\n} else {\n    ans += rightMax - height[right];\n    right--;\n}",
    "question": [
      {
        "t": "在「接雨水」(Trapping Rain Water) 問題中，我們可以使用雙指針法將空間複雜度優化至 O(1)。",
        "en": "In the 'Trapping Rain Water' problem, we can use the two-pointer method to optimize the space complexity to O(1).",
        "wg": [
          {
            "t": "接雨水",
            "en": "Trapping Rain Water",
            "ps": "NP"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "觀察上方程式碼片段，為什麼當 `leftMax < rightMax` 時，我們只需要關心 `leftMax` 就可以確定當前 `left` 位置能接多少水，而不需要知道 `right` 指針具體指向的數值？",
        "en": "Observing the code snippet above, why is it that when `leftMax < rightMax`, we only need to care about `leftMax` to determine how much water the current `left` position can trap, without needing to know the specific value pointed to by `right`?",
        "wg": [
          {
            "t": "具體的",
            "en": "specific",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為 `rightMax` 必定是整個陣列中的最大值。",
        "en": "(A) Because `rightMax` is guaranteed to be the maximum value in the entire array.",
        "wg": []
      },
      {
        "t": "(B) 因為該位置能接的水量取決於左右兩側最高點的較小值。既然 `leftMax < rightMax`，短板效應決定了瓶頸在左側，右側是否有更高的牆並不影響當前計算。",
        "en": "(B) Because the water trapped at that position depends on the minimum of the highest points on both sides. Since `leftMax < rightMax`, the bucket effect determines that the bottleneck is on the left; whether there is a higher wall on the right does not affect the current calculation.",
        "wg": [
          {
            "t": "短板效應",
            "en": "bucket effect / weak link",
            "ps": "N"
          },
          {
            "t": "瓶頸",
            "en": "bottleneck",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是錯誤的邏輯，我們必須知道 `right` 的確切高度才能計算。",
        "en": "(C) This is flawed logic; we must know the exact height of `right` to calculate.",
        "wg": [
          {
            "t": "有缺陷的",
            "en": "flawed",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 因為水是從左向右流動的，所以右邊的高度不重要。",
        "en": "(D) Because water flows from left to right, the height on the right is unimportant.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "某個位置的蓄水量由 `min(max_left, max_right) - height[i]` 決定。雙指針法中，`rightMax` 代表右側「目前已知」的最大值。如果 `leftMax < rightMax`，那麼真實的 `max_right` 一定大於等於當前的 `rightMax`，因此 `min(leftMax, max_right)` 必定是 `leftMax`。所以我們可以直接根據 `leftMax` 計算蓄水量。",
      "en": "The water trapped at a position is determined by `min(max_left, max_right) - height[i]`. In the two-pointer approach, `rightMax` represents the maximum value 'currently known' on the right. If `leftMax < rightMax`, then the actual `max_right` must be greater than or equal to the current `rightMax`. Therefore, `min(leftMax, max_right)` is definitely `leftMax`. Thus, we can calculate the trapped water directly based on `leftMax`.",
      "wg": [
        {
          "t": "蓄水量",
          "en": "trapped water / capacity",
          "ps": "N"
        },
        {
          "t": "大於等於",
          "en": "greater than or equal to",
          "ps": "Phr"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Two Pointers, Three Pointers, Sorting, Dutch National Flag",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「顏色分類」(Sort Colors / Dutch National Flag) 問題中，我們需要將包含 0 (紅)、1 (白)、2 (藍) 的陣列原地排序。",
        "en": "In the 'Sort Colors' (Dutch National Flag) problem, we need to sort an array containing 0 (red), 1 (white), and 2 (blue) in-place.",
        "wg": [
          {
            "t": "顏色分類",
            "en": "Sort Colors",
            "ps": "NP"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "通常使用三個指針：`low`、`mid` 和 `high`。當 `mid` 指針掃描到數值 `2` 時，應該執行什麼操作？",
        "en": "Typically, three pointers are used: `low`, `mid`, and `high`. When the `mid` pointer scans a value of `2`, what operation should be performed?",
        "wg": [
          {
            "t": "掃描",
            "en": "scan",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設 `low` 和 `mid` 初始為 0，`high` 初始為陣列末端。",
        "en": "Assume `low` and `mid` start at 0, and `high` starts at the end of the array.",
        "wg": [
          {
            "t": "末端",
            "en": "end",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將 `nums[mid]` 與 `nums[low]` 交換，然後 `low` 和 `mid` 都加 1。",
        "en": "(A) Swap `nums[mid]` with `nums[low]`, then increment both `low` and `mid`.",
        "wg": [
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          },
          {
            "t": "加 1",
            "en": "increment",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將 `nums[mid]` 與 `nums[high]` 交換，然後 `high` 減 1，但 `mid` 保持不變。",
        "en": "(B) Swap `nums[mid]` with `nums[high]`, then decrement `high`, but keep `mid` unchanged.",
        "wg": [
          {
            "t": "減 1",
            "en": "decrement",
            "ps": "V"
          },
          {
            "t": "保持不變",
            "en": "unchanged",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 只將 `mid` 加 1，不做任何交換。",
        "en": "(C) Only increment `mid`, without performing any swap.",
        "wg": []
      },
      {
        "t": "(D) 將 `nums[mid]` 與 `nums[high]` 交換，然後 `mid` 加 1，`high` 減 1。",
        "en": "(D) Swap `nums[mid]` with `nums[high]`, then increment `mid` and decrement `high`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "數值 2 屬於藍色，應該放在陣列的尾部。因此我們將其與 `high` 指向的元素交換，並將 `high` 向左縮減。關鍵在於，交換回來的元素（原本在 `high` 的值）尚未被檢查過（可能是 0、1 或 2），所以 `mid` 指針不能移動，必須在下一次迭代中再次檢查這個新交換來的值。",
      "en": "The value 2 corresponds to blue and should be placed at the end of the array. Therefore, we swap it with the element at `high` and decrement `high`. The key point is that the element swapped back (originally at `high`) has not been inspected yet (it could be 0, 1, or 2), so the `mid` pointer must not move; we must check this newly swapped value again in the next iteration.",
      "wg": [
        {
          "t": "尾部",
          "en": "tail/end",
          "ps": "N"
        },
        {
          "t": "檢查",
          "en": "inspect/check",
          "ps": "V"
        }
      ]
    }
  }
]