[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Array, Sorted, Two Sum, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: numbers = [2,7,11,15], target = 9\nOutput: [1,2] // 1-based index",
    "question": [
      {
        "t": "給定一個「已排序」的整數陣列，您需要找出兩個數，使它們的總和等於目標值。",
        "en": "Given a \"sorted\" array of integers, you need to find two numbers such that they add up to a specific target number.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          },
          {
            "t": "整數陣列",
            "en": "array of integers",
            "ps": "NP"
          },
          {
            "t": "總和",
            "en": "add up to",
            "ps": "V"
          }
        ]
      },
      {
        "t": "相較於使用雜湊表 (Hash Map) 的解法，使用雙指標 (Two Pointers) 技巧在這個特定場景下的主要優勢是什麼？",
        "en": "Compared to the Hash Map solution, what is the main advantage of using the Two Pointers technique in this specific scenario?",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          },
          {
            "t": "場景",
            "en": "scenario",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 雙指標法的時間複雜度為 O(log n)，比雜湊表快。",
        "en": "(A) The time complexity of Two Pointers is O(log n), which is faster than Hash Map.",
        "wg": []
      },
      {
        "t": "(B) 雙指標法不需要額外的空間來儲存元素，空間複雜度為 O(1)。",
        "en": "(B) Two Pointers does not require extra space to store elements, resulting in O(1) space complexity.",
        "wg": [
          {
            "t": "額外的空間",
            "en": "extra space",
            "ps": "NP"
          },
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 雙指標法可以處理未排序的陣列。",
        "en": "(C) Two Pointers can handle unsorted arrays.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 雙指標法更容易實作平行處理。",
        "en": "(D) Two Pointers is easier to implement for parallel processing.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在陣列已排序的情況下，雙指標法透過左右夾擠只需一次遍歷 O(n)，且不需要像雜湊表那樣使用 O(n) 的額外空間來儲存訪問過的元素，因此空間效益最佳。",
      "en": "Since the array is sorted, the Two Pointers approach requires only one pass O(n) by narrowing down from both ends, and unlike Hash Map, it does not need O(n) extra space to store visited elements, making it space-efficient.",
      "wg": [
        {
          "t": "夾擠",
          "en": "narrowing down",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "pass / traversal",
          "ps": "N"
        },
        {
          "t": "空間效益",
          "en": "space-efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Linked List, Cycle Detection, Floyd's Algorithm, Fast and Slow Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) return true;\n}",
    "question": [
      {
        "t": "在偵測鏈結串列 (Linked List) 是否有環 (Cycle) 的問題中，我們常使用快慢指標 (Fast and Slow Pointers)。",
        "en": "In the problem of detecting whether a Linked List has a cycle, we often use Fast and Slow Pointers.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若快指標每次移動 2 步，慢指標每次移動 1 步，請問為什麼這種方法能保證兩者一定會相遇？",
        "en": "If the fast pointer moves 2 steps at a time and the slow pointer moves 1 step, why does this method guarantee that they will meet?",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          },
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為快指標會跳過節點，最終會停在慢指標的位置。",
        "en": "(A) Because the fast pointer skips nodes and will eventually stop at the slow pointer's position.",
        "wg": []
      },
      {
        "t": "(B) 快指標相對於慢指標的速度差為 1，這意味著快指標在環中每次都縮短 1 步的距離，最終必能追上慢指標。",
        "en": "(B) The relative speed difference between the fast and slow pointers is 1, meaning the fast pointer reduces the distance by 1 step in each iteration within the cycle, eventually catching up to the slow pointer.",
        "wg": [
          {
            "t": "相對速度",
            "en": "relative speed",
            "ps": "NP"
          },
          {
            "t": "追上",
            "en": "catch up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 因為鏈結串列的長度是有限的，兩者在到達尾端前一定會碰撞。",
        "en": "(C) Because the length of the linked list is finite, they must collide before reaching the end.",
        "wg": []
      },
      {
        "t": "(D) 只有當環的長度為偶數時，兩者才會相遇。",
        "en": "(D) They will meet only if the length of the cycle is an even number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個相對運動的問題。當兩者都進入環中，快指標每次比慢指標多走一步，相當於快指標在「追趕」慢指標，距離每次減少 1，因此不會發生「跳過」慢指標的情況，必定會重合。",
      "en": "This is a relative motion problem. Once both enter the cycle, the fast pointer moves one step more than the slow pointer each time, effectively 'chasing' the slow pointer. The distance decreases by 1 each step, so it will never 'jump over' the slow pointer and is guaranteed to coincide.",
      "wg": [
        {
          "t": "相對運動",
          "en": "relative motion",
          "ps": "NP"
        },
        {
          "t": "重合",
          "en": "coincide",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Array, Greedy, Container With Most Water, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49",
    "question": [
      {
        "t": "在「盛最多水的容器」(Container With Most Water) 問題中，我們使用雙指標分別指向陣列的頭尾。",
        "en": "In the 'Container With Most Water' problem, we use two pointers pointing to the start and end of the array respectively.",
        "wg": [
          {
            "t": "盛最多水的容器",
            "en": "Container With Most Water",
            "ps": "NP"
          },
          {
            "t": "分別",
            "en": "respectively",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "為了找到最大面積，移動指標的正確策略是什麼？",
        "en": "To find the maximum area, what is the correct strategy for moving the pointers?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是移動高度較高的那個指標。",
        "en": "(A) Always move the pointer with the greater height.",
        "wg": []
      },
      {
        "t": "(B) 總是移動高度較低的那個指標。",
        "en": "(B) Always move the pointer with the smaller height.",
        "wg": []
      },
      {
        "t": "(C) 同時向內移動兩個指標。",
        "en": "(C) Move both pointers inward simultaneously.",
        "wg": [
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 隨機移動其中一個指標。",
        "en": "(D) Randomly move one of the pointers.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "容器的面積由較短的邊決定 (短板效應)。如果移動較高的邊，寬度變小且高度受限於原本較短的邊，面積一定變小；只有移動較短的邊，才有可能找到更高的邊來增加面積。",
      "en": "The area of the container is determined by the shorter side (bucket effect). If you move the taller side, the width decreases and the height remains limited by the shorter side, so the area guarantees to decrease. Only by moving the shorter side is it possible to find a taller line to increase the area.",
      "wg": [
        {
          "t": "短板效應",
          "en": "bucket effect",
          "ps": "N"
        },
        {
          "t": "受限於",
          "en": "limited by",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Array, In-place, Remove Duplicates",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int j = 0;\nfor (int i = 1; i < nums.length; i++) {\n    if (nums[i] != nums[j]) {\n        j++;\n        nums[j] = nums[i];\n    }\n}",
    "question": [
      {
        "t": "在「從已排序陣列中移除重複項」(Remove Duplicates from Sorted Array) 的問題中，我們使用快慢指標 (i 為快，j 為慢) 進行原地 (in-place) 修改。",
        "en": "In the 'Remove Duplicates from Sorted Array' problem, we use fast and slow pointers (i as fast, j as slow) for in-place modification.",
        "wg": [
          {
            "t": "移除重複項",
            "en": "remove duplicates",
            "ps": "VP"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問變數 `j` (慢指標) 在此演算法中的主要職責是什麼？",
        "en": "What is the primary responsibility of variable `j` (the slow pointer) in this algorithm?",
        "wg": [
          {
            "t": "職責",
            "en": "responsibility",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 用來遍歷整個陣列以尋找目標值。",
        "en": "(A) Used to traverse the entire array to look for the target value.",
        "wg": []
      },
      {
        "t": "(B) 維護不包含重複元素的子陣列的最後一個有效位置。",
        "en": "(B) Maintains the last valid position of the subarray containing unique elements.",
        "wg": [
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          },
          {
            "t": "有效位置",
            "en": "valid position",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 計算重複元素的總數量。",
        "en": "(C) Counts the total number of duplicate elements.",
        "wg": []
      },
      {
        "t": "(D) 標記陣列的中間點以進行二分搜尋。",
        "en": "(D) Marks the midpoint of the array for binary search.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "慢指標 `j` 始終指向「已處理且無重複」序列的尾端。當快指標 `i` 發現一個新元素時，我們會將其填入 `j+1` 的位置，從而擴展無重複序列。",
      "en": "The slow pointer `j` always points to the tail of the 'processed and unique' sequence. When the fast pointer `i` discovers a new element, we fill it into the `j+1` position, thereby extending the unique sequence.",
      "wg": [
        {
          "t": "序列",
          "en": "sequence",
          "ps": "N"
        },
        {
          "t": "擴展",
          "en": "extend",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Array, 3Sum, Sorting, Deduplication",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (i > 0 && nums[i] == nums[i-1]) continue;",
    "question": [
      {
        "t": "在解決 3Sum (找出三個數總和為 0) 問題時，通常會先將陣列排序，然後固定一個數並使用雙指標尋找另外兩個數。",
        "en": "When solving the 3Sum problem (finding three numbers that sum to 0), we usually sort the array first, then fix one number and use two pointers to find the other two.",
        "wg": [
          {
            "t": "固定",
            "en": "fix",
            "ps": "V"
          },
          {
            "t": "另外",
            "en": "the other",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為什麼在遍歷固定數 (外層迴圈) 時，需要包含如上方代碼片段的檢查？",
        "en": "Why is it necessary to include a check like the code snippet above when iterating through the fixed number (outer loop)?",
        "wg": [
          {
            "t": "代碼片段",
            "en": "code snippet",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免陣列索引越界 (Index Out of Bounds)。",
        "en": "(A) To avoid Index Out of Bounds errors.",
        "wg": [
          {
            "t": "索引越界",
            "en": "Index Out of Bounds",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 為了優化效能，跳過負數。",
        "en": "(B) To optimize performance by skipping negative numbers.",
        "wg": []
      },
      {
        "t": "(C) 為了避免在結果集中產生重複的三元組 (Triplets)。",
        "en": "(C) To avoid generating duplicate triplets in the result set.",
        "wg": [
          {
            "t": "結果集",
            "en": "result set",
            "ps": "N"
          },
          {
            "t": "三元組",
            "en": "triplets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 這是雙指標法收斂的必要條件。",
        "en": "(D) This is a necessary condition for the convergence of the Two Pointers method.",
        "wg": [
          {
            "t": "收斂",
            "en": "convergence",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為陣列已排序，相同的數值會聚在一起。如果目前的數字與前一個數字相同，代表這個數字作為第一個數的所有可能組合都已經在前一次迭代中被處理過了，因此跳過以避免重複。",
      "en": "Since the array is sorted, identical values are grouped together. If the current number is the same as the previous one, it means all possible combinations with this number as the first element have already been processed in the previous iteration, so we skip it to avoid duplicates.",
      "wg": [
        {
          "t": "聚在一起",
          "en": "grouped together",
          "ps": "VP"
        },
        {
          "t": "迭代",
          "en": "iteration",
          "ps": "N"
        }
      ]
    }
  }
]