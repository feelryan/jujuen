[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Linked List, Cycle Detection, Floyd's Cycle-Finding Algorithm, Fast and Slow Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) return true;\n}",
    "question": [
      {
        "t": "在鏈結串列 (Linked List) 中偵測是否存在環 (Cycle) 時，通常使用快慢指針演算法 (Floyd's Cycle-Finding Algorithm)。",
        "en": "When detecting a cycle in a Linked List, Floyd's Cycle-Finding Algorithm (Fast and Slow Pointers) is commonly used.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          },
          {
            "t": "快慢指針",
            "en": "Fast and Slow Pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若快指針每次移動 2 步，慢指針每次移動 1 步，為什麼該演算法保證兩者一定會相遇，而不會永遠錯過？",
        "en": "If the fast pointer moves 2 steps at a time and the slow pointer moves 1 step, why does the algorithm guarantee that they will meet and not miss each other forever?",
        "wg": [
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          },
          {
            "t": "錯過",
            "en": "miss",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為鏈結串列的長度是有限的，快指針最終會追上慢指針。",
        "en": "(A) Because the length of the linked list is finite, the fast pointer will eventually catch up to the slow pointer.",
        "wg": []
      },
      {
        "t": "(B) 因為兩者的相對速度為 1，每次移動後距離縮短 1 步，故一定會重合。",
        "en": "(B) Because their relative speed is 1, the distance shortens by 1 step after each move, so they will definitely coincide.",
        "wg": [
          {
            "t": "相對速度",
            "en": "relative speed",
            "ps": "N"
          },
          {
            "t": "重合",
            "en": "coincide",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 因為快指針移動速度是慢指針的兩倍，這符合二分搜尋法的原理。",
        "en": "(C) Because the fast pointer moves twice as fast as the slow pointer, which aligns with the principle of binary search.",
        "wg": []
      },
      {
        "t": "(D) 只有當環的長度為偶數時，兩者才會相遇。",
        "en": "(D) They will only meet if the length of the cycle is an even number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "從相對運動的角度來看，假設慢指針靜止，快指針每次向慢指針靠近 1 步 (2 - 1 = 1)。無論兩者在環中的初始距離為何，快指針都能以步進為 1 的方式逐步縮小差距，因此不可能跳過慢指針，必然會相遇。",
      "en": "From the perspective of relative motion, assuming the slow pointer is stationary, the fast pointer moves 1 step closer to the slow pointer each time (2 - 1 = 1). Regardless of the initial distance between them in the cycle, the fast pointer closes the gap step by step, making it impossible to skip over the slow pointer; thus, they must meet.",
      "wg": [
        {
          "t": "相對運動",
          "en": "relative motion",
          "ps": "N"
        },
        {
          "t": "步進",
          "en": "step increment",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Array, 3Sum, Sorting, Two Pointers, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「三數之和」(3Sum) 問題：在一個陣列中找出所有不重複的三元組，使其總和為 0。",
        "en": "Regarding the '3Sum' problem: Find all unique triplets in an array that sum up to 0.",
        "wg": [
          {
            "t": "三元組",
            "en": "triplets",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum up to",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用雙指針技巧優化此問題時，通常必須先執行哪一個關鍵的前置步驟？",
        "en": "When optimizing this problem using the Two Pointers technique, what key prerequisite step must usually be performed first?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "前置步驟",
            "en": "prerequisite step",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 建立雜湊表 (Hash Map) 以記錄頻率。",
        "en": "(A) Build a Hash Map to record frequencies.",
        "wg": []
      },
      {
        "t": "(B) 對陣列進行排序 (Sorting)。",
        "en": "(B) Sort the array.",
        "wg": [
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 移除陣列中的所有負數。",
        "en": "(C) Remove all negative numbers from the array.",
        "wg": []
      },
      {
        "t": "(D) 計算前綴和 (Prefix Sum)。",
        "en": "(D) Calculate the Prefix Sum.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雙指針法依賴於數據的單調性來決定指針移動的方向。若陣列未排序，我們無法透過比較當前總和與目標值的大小來決定左指針右移（增大總和）或右指針左移（減小總和）。排序後，固定一個數，剩下的問題就轉化為有序陣列的 Two Sum 問題。",
      "en": "The Two Pointers method relies on the monotonicity of data to determine the direction of pointer movement. If the array is unsorted, we cannot decide whether to move the left pointer right (to increase the sum) or the right pointer left (to decrease the sum) by comparing the current sum with the target. After sorting, by fixing one number, the remaining problem transforms into a Two Sum problem on a sorted array.",
      "wg": [
        {
          "t": "單調性",
          "en": "monotonicity",
          "ps": "N"
        },
        {
          "t": "轉化",
          "en": "transform",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Trapping Rain Water, Space Optimization, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「接雨水」(Trapping Rain Water) 問題時，我們可以使用動態規劃 (DP) 預先計算每個位置的左側最大高度與右側最大高度。",
        "en": "When solving the 'Trapping Rain Water' problem, we can use Dynamic Programming (DP) to pre-calculate the maximum height to the left and right of each position.",
        "wg": [
          {
            "t": "接雨水",
            "en": "Trapping Rain Water",
            "ps": "N"
          },
          {
            "t": "預先計算",
            "en": "pre-calculate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若改用雙指針法 (Two Pointers) 從兩端向中間夾擠，主要能帶來什麼效益？",
        "en": "If we switch to the Two Pointers method, approaching from both ends towards the center, what is the main benefit?",
        "wg": [
          {
            "t": "夾擠",
            "en": "squeeze/approach",
            "ps": "V"
          },
          {
            "t": "效益",
            "en": "benefit",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將時間複雜度從 O(N) 降低到 O(log N)。",
        "en": "(A) Reduce the time complexity from O(N) to O(log N).",
        "wg": []
      },
      {
        "t": "(B) 將空間複雜度從 O(N) 降低到 O(1)。",
        "en": "(B) Reduce the space complexity from O(N) to O(1).",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 避免處理高度為 0 的情況。",
        "en": "(C) Avoid handling cases where height is 0.",
        "wg": []
      },
      {
        "t": "(D) 可以同時計算最大矩形面積。",
        "en": "(D) Can simultaneously calculate the maximum rectangle area.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "DP 解法需要額外的陣列來儲存每個位置的 `left_max` 和 `right_max`，空間複雜度為 O(N)。雙指針法利用「短板效應」，只需維護兩個變數來記錄當前的左右最高點，邊移動邊計算，因此將空間複雜度優化至 O(1)。",
      "en": "The DP solution requires extra arrays to store `left_max` and `right_max` for each position, resulting in O(N) space complexity. The Two Pointers method leverages the 'short plank effect' (bucket effect), needing only two variables to track the current max heights on both sides and calculating as it moves, thus optimizing space complexity to O(1).",
      "wg": [
        {
          "t": "短板效應",
          "en": "short plank effect / bucket effect",
          "ps": "N"
        },
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Merge Sorted Array, In-place, Backwards Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void merge(int[] nums1, int m, int[] nums2, int n) { ... }",
    "question": [
      {
        "t": "給定兩個已排序陣列 `nums1` 和 `nums2`，其中 `nums1` 後端有足夠的空間容納 `nums2`。",
        "en": "Given two sorted arrays `nums1` and `nums2`, where `nums1` has enough space at the end to hold `nums2`.",
        "wg": [
          {
            "t": "容納",
            "en": "hold/accommodate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要將 `nums2` 合併入 `nums1` 並保持排序，且不使用額外空間 (In-place)，最佳的雙指針策略為何？",
        "en": "To merge `nums2` into `nums1` while maintaining sort order and without using extra space (In-place), what is the best Two Pointers strategy?",
        "wg": [
          {
            "t": "原地",
            "en": "In-place",
            "ps": "Adj"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從兩個陣列的開頭 (Index 0) 開始比較，將較小值放入 `nums1` 前端。",
        "en": "(A) Start comparing from the beginning (Index 0) of both arrays and place the smaller value at the front of `nums1`.",
        "wg": []
      },
      {
        "t": "(B) 先將 `nums2` 複製到 `nums1` 後端，再進行泡沫排序 (Bubble Sort)。",
        "en": "(B) First copy `nums2` to the end of `nums1`, then perform Bubble Sort.",
        "wg": []
      },
      {
        "t": "(C) 從兩個陣列的有值尾端 (m-1, n-1) 開始比較，將較大值填入 `nums1` 的最末端。",
        "en": "(C) Start comparing from the end of the valid data (m-1, n-1) of both arrays and place the larger value at the very end of `nums1`.",
        "wg": [
          {
            "t": "尾端",
            "en": "end/tail",
            "ps": "N"
          },
          {
            "t": "填入",
            "en": "fill in",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 使用二分搜尋法將 `nums2` 的每個元素插入 `nums1`。",
        "en": "(D) Use binary search to insert each element of `nums2` into `nums1`.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "如果從前往後合併，`nums1` 原始的數據會被覆蓋，導致需要大量的元素移動 (Shift)。從後往前合併利用了 `nums1` 後端的閒置空間，保證每次填入數據時不會覆蓋尚未處理的有效數據，效率最高且無需額外空間。",
      "en": "Merging from front to back would overwrite the original data in `nums1`, requiring massive element shifting. Merging from back to front utilizes the empty space at the end of `nums1`, ensuring that valid unprocessed data is never overwritten, which is the most efficient and requires no extra space.",
      "wg": [
        {
          "t": "覆蓋",
          "en": "overwrite",
          "ps": "V"
        },
        {
          "t": "閒置空間",
          "en": "empty space / buffer",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Sort Colors, Dutch National Flag Problem, Three Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「顏色分類」(Sort Colors) 問題中，需將包含 0 (紅)、1 (白)、2 (藍) 的陣列原地排序。",
        "en": "In the 'Sort Colors' problem, an array containing 0 (red), 1 (white), and 2 (blue) needs to be sorted in-place.",
        "wg": [
          {
            "t": "顏色分類",
            "en": "Sort Colors",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這通常使用「荷蘭國旗問題」(Dutch National Flag Problem) 的解法，涉及三個指針：`low`, `mid`, `high`。關於 `mid` 指針的移動邏輯，下列何者正確？",
        "en": "This is typically solved using the 'Dutch National Flag Problem' approach, involving three pointers: `low`, `mid`, and `high`. Which of the following is correct regarding the movement logic of the `mid` pointer?",
        "wg": [
          {
            "t": "荷蘭國旗問題",
            "en": "Dutch National Flag Problem",
            "ps": "N"
          },
          {
            "t": "涉及",
            "en": "involve",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當 `nums[mid]` 為 0 時，與 `nums[low]` 交換，`low` 加 1，`mid` 加 1。",
        "en": "(A) When `nums[mid]` is 0, swap with `nums[low]`, increment `low`, and increment `mid`.",
        "wg": [
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 當 `nums[mid]` 為 2 時，與 `nums[high]` 交換，`high` 減 1，`mid` 加 1。",
        "en": "(B) When `nums[mid]` is 2, swap with `nums[high]`, decrement `high`, and increment `mid`.",
        "wg": []
      },
      {
        "t": "(C) `mid` 指針永遠只會向左移動。",
        "en": "(C) The `mid` pointer only ever moves to the left.",
        "wg": []
      },
      {
        "t": "(D) 當 `nums[mid]` 為 1 時，`mid` 保持不動。",
        "en": "(D) When `nums[mid]` is 1, `mid` stays stationary.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "此演算法中，`low` 維護 0 的邊界，`high` 維護 2 的邊界，`mid` 負責遍歷。當 `nums[mid] == 0`，交換到左邊後，我們確定換過來的數字是處理過的（因為 `low` 左邊都是 0），所以 `mid` 可以前進。反之，若 `nums[mid] == 2` 與 `high` 交換，換過來的數字尚未檢查，所以 `mid` 不能前進。選項 (A) 描述正確。",
      "en": "In this algorithm, `low` maintains the boundary for 0s, `high` for 2s, and `mid` traverses. When `nums[mid] == 0`, we swap it to the left; we are certain the number swapped in is processed (since everything left of `low` is 0), so `mid` can advance. Conversely, if `nums[mid] == 2` and we swap with `high`, the number swapped in hasn't been checked yet, so `mid` cannot advance. Option (A) is correct.",
      "wg": [
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  }
]