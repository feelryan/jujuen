[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Two Pointers, Sorted Array, Monotonicity, Two Sum",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在已排序陣列中找兩數和等於 target 的一組索引。",
        "en": "You need to find one pair of indices in a sorted array whose sum equals target.",
        "wg": [
          { "t": "已排序陣列", "en": "sorted array", "ps": "N" },
          { "t": "一組索引", "en": "a pair of indices", "ps": "N" }
        ]
      },
      {
        "t": "在 two pointers 解法中，當目前 sum 小於 target 時，你應該如何移動指針。",
        "en": "In a two-pointers solution, how should you move pointers when the current sum is less than target.",
        "wg": [
          { "t": "移動指針", "en": "move pointers", "ps": "V" },
          { "t": "two pointers", "en": "two pointers", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) r--，因為右側數字較大，往左移更容易增加 sum。",
        "en": "(A) r--, because the right side is larger and moving left is more likely to increase the sum.",
        "wg": [
          { "t": "往左移", "en": "move left", "ps": "V" }
        ]
      },
      {
        "t": "(B) l++，因為要讓左側變大以增加 sum。",
        "en": "(B) l++, because increasing the left value increases the sum.",
        "wg": [
          { "t": "左側變大", "en": "increase the left value", "ps": "V" }
        ]
      },
      {
        "t": "(C) 同時 l++ 與 r--，以縮小搜尋空間。",
        "en": "(C) Move both l++ and r-- to shrink the search space.",
        "wg": [
          { "t": "縮小搜尋空間", "en": "shrink the search space", "ps": "V" }
        ]
      },
      {
        "t": "(D) 隨機移動一端，直到找到答案。",
        "en": "(D) Move one side randomly until you find the answer.",
        "wg": [
          { "t": "隨機", "en": "randomly", "ps": "Adv" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為陣列已排序，固定 r 時，l 往右移只會讓 nums[l] 變大，所以 sum 會單調增加。當 sum < target 時移動 l++ 才會朝目標靠近。選項 (A) 會讓 sum 變小而更遠離 target。選項 (C) 可能跳過唯一解。選項 (D) 沒有單調性保證且不可證明正確。",
      "en": "Because the array is sorted, with r fixed, moving l right makes nums[l] larger, so the sum increases monotonically. When sum < target, l++ moves toward the target. Option (A) decreases the sum and moves away from target. Option (C) can skip the unique solution. Option (D) lacks a monotonicity guarantee and is not provably correct.",
      "wg": [
        { "t": "單調增加", "en": "monotonically increase", "ps": "V" },
        { "t": "可證明正確", "en": "provably correct", "ps": "Adj" },
        { "t": "跳過", "en": "skip", "ps": "V" }
      ]
    }
  },
  {
    "no": "2",
    "level": "hard",
    "keywords": "3Sum, Deduplication, Two Pointers, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要解 3Sum 並回傳所有不重複三元組。",
        "en": "You need to solve 3Sum and return all unique triplets.",
        "wg": [
          { "t": "不重複", "en": "unique", "ps": "Adj" },
          { "t": "三元組", "en": "triplet", "ps": "N" }
        ]
      },
      {
        "t": "下列哪個去重策略最完整且最不容易漏解。",
        "en": "Which dedup strategy is most complete and least likely to miss valid solutions.",
        "wg": [
          { "t": "去重策略", "en": "dedup strategy", "ps": "N" },
          { "t": "漏解", "en": "miss solutions", "ps": "V" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只在最外層 i 做去重，內層 l 與 r 不需處理重複值。",
        "en": "(A) Dedup only on the outer i; no need to handle duplicates for l and r.",
        "wg": [
          { "t": "最外層", "en": "outer layer", "ps": "N" }
        ]
      },
      {
        "t": "(B) 只在找到解後去重 l，r 保持原樣以避免漏解。",
        "en": "(B) After a match, dedup only l; keep r unchanged to avoid missing solutions.",
        "wg": [
          { "t": "保持原樣", "en": "keep unchanged", "ps": "V" }
        ]
      },
      {
        "t": "(C) i 層去重，且每次找到解後同時跳過 l 與 r 的連續重複值。",
        "en": "(C) Dedup at i, and after each match, skip consecutive duplicates for both l and r.",
        "wg": [
          { "t": "連續重複值", "en": "consecutive duplicates", "ps": "N" }
        ]
      },
      {
        "t": "(D) 不需要去重，最後用 Set(JSON.stringify(triplet)) 做全域去重即可。",
        "en": "(D) No need to dedup; just do global dedup with Set(JSON.stringify(triplet)) at the end.",
        "wg": [
          { "t": "全域去重", "en": "global dedup", "ps": "N" }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "3Sum 的重複來源同時存在於 anchor 值與內層指針值，因此必須兩層都去重才不會輸出重複三元組。只去重 i 或只去重 l 都會產生重複答案。事後用 JSON 序列化做 Set 去重雖可能正確，但會增加額外成本，且面試更期待在掃描過程中用等價類規則去重。",
      "en": "In 3Sum, duplicates arise from both the anchor value and inner pointer values, so you must dedup at both levels to avoid duplicate triplets. Deduping only i or only l still emits duplicates. Post-hoc Set dedup via JSON may work but adds overhead, and interviews typically expect in-scan dedup using equivalence-class rules.",
      "wg": [
        { "t": "等價類", "en": "equivalence class", "ps": "N" },
        { "t": "額外成本", "en": "extra overhead", "ps": "N" },
        { "t": "事後", "en": "post-hoc", "ps": "Adv" }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Container With Most Water, Two Pointers, Proof, Elimination",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要用左右夾逼解盛最多水的容器。",
        "en": "You want to solve Container With Most Water using left-right two pointers.",
        "wg": [
          { "t": "左右夾逼", "en": "left-right convergence", "ps": "N" },
          { "t": "盛最多水", "en": "max water container", "ps": "N" }
        ]
      },
      {
        "t": "每一步應該移動哪一側才能保證不漏掉最優解。",
        "en": "Which side should you move each step to guarantee you don’t miss the optimal answer.",
        "wg": [
          { "t": "不漏掉", "en": "not miss", "ps": "V" },
          { "t": "最優解", "en": "optimal solution", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 永遠移動較高的那側，因為保留短板可以保證面積上限。",
        "en": "(A) Always move the taller side, because keeping the shorter side preserves the area cap.",
        "wg": [
          { "t": "短板", "en": "limiting side", "ps": "N" }
        ]
      },
      {
        "t": "(B) 永遠移動較矮的那側，因為只有提升短板才可能增加面積。",
        "en": "(B) Always move the shorter side, because only increasing the limiting height can increase area.",
        "wg": [
          { "t": "提升短板", "en": "raise the limiting height", "ps": "V" }
        ]
      },
      {
        "t": "(C) 兩側都移動，因為寬度縮小越快越能找到最大值。",
        "en": "(C) Move both sides, because shrinking width faster helps find the max sooner.",
        "wg": [
          { "t": "縮小越快", "en": "shrink faster", "ps": "V" }
        ]
      },
      {
        "t": "(D) 隨機選一側移動，最後一定會走遍所有組合。",
        "en": "(D) Move a random side; eventually you’ll cover all pairs.",
        "wg": [
          { "t": "走遍", "en": "cover all", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "面積由 min(height[l], height[r]) 決定短板高度，再乘上寬度。移動較高的一側只會讓寬度變小且短板不變，因此不可能產生更大面積。移動較矮的一側才可能提高短板並抵消寬度縮小。選項 (C)(D) 都缺乏可證明的淘汰規則。",
      "en": "Area is min(height[l], height[r]) times width, so the shorter side is the limiting height. Moving the taller side only shrinks width while keeping the limiting height unchanged, so it cannot yield a larger area. Moving the shorter side is the only move that can raise the limit and potentially offset width shrinkage. Options (C)(D) lack a provable elimination rule.",
      "wg": [
        { "t": "淘汰規則", "en": "elimination rule", "ps": "N" },
        { "t": "抵消", "en": "offset", "ps": "V" },
        { "t": "缺乏", "en": "lack", "ps": "V" }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Trapping Rain Water, Two Pointers, State Compression, Invariant",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要用 O(1) 額外空間解接雨水。",
        "en": "You need an O(1) extra-space solution for Trapping Rain Water.",
        "wg": [
          { "t": "額外空間", "en": "extra space", "ps": "N" },
          { "t": "接雨水", "en": "trapping rain water", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個不變量能支撐每一步只處理較小邊界的一側。",
        "en": "Which invariant justifies processing only the side with the smaller boundary each step.",
        "wg": [
          { "t": "不變量", "en": "invariant", "ps": "N" },
          { "t": "較小邊界", "en": "smaller boundary", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 若 height[l] < height[r]，則位置 l 的水量只取決於 height[l]。",
        "en": "(A) If height[l] < height[r], then water at l depends only on height[l].",
        "wg": [
          { "t": "只取決於", "en": "depends only on", "ps": "V" }
        ]
      },
      {
        "t": "(B) 若 leftMax <= rightMax，則左側位置的水量只取決於 leftMax。",
        "en": "(B) If leftMax <= rightMax, then water on the left depends only on leftMax.",
        "wg": [
          { "t": "leftMax", "en": "leftMax", "ps": "N" },
          { "t": "rightMax", "en": "rightMax", "ps": "N" }
        ]
      },
      {
        "t": "(C) 任何時候都應該先處理高度較大的那側，因為它能擋更多水。",
        "en": "(C) You should always process the taller side first because it blocks more water.",
        "wg": [
          { "t": "擋更多水", "en": "block more water", "ps": "V" }
        ]
      },
      {
        "t": "(D) 只要維護目前的 l 和 r，就不需要維護 leftMax 或 rightMax。",
        "en": "(D) If you track only l and r, you don’t need leftMax or rightMax.",
        "wg": [
          { "t": "維護", "en": "maintain", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "水量由 min(leftMax, rightMax) - height[i] 決定。若 leftMax <= rightMax，則對左側而言右邊界至少有 rightMax，不會成為瓶頸，因此左側水量完全由 leftMax 決定。選項 (A) 只看當前高度而非歷史最大值，遇到平台或凹槽會算錯。選項 (C)(D) 不符合正確性所需的狀態壓縮。",
      "en": "Water is determined by min(leftMax, rightMax) - height[i]. If leftMax <= rightMax, then the right boundary is guaranteed to be at least rightMax and cannot be the bottleneck for the left side, so left-side water depends solely on leftMax. Option (A) uses current heights instead of historical maxima and fails on plateaus/basins. Options (C)(D) ignore the state needed for correct state compression.",
      "wg": [
        { "t": "瓶頸", "en": "bottleneck", "ps": "N" },
        { "t": "狀態壓縮", "en": "state compression", "ps": "N" },
        { "t": "歷史最大值", "en": "historical maximum", "ps": "N" }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Valid Palindrome, Two Pointers, Skipping, Normalization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要判斷字串是否為有效回文，且需忽略非字母數字並忽略大小寫。",
        "en": "You need to check if a string is a valid palindrome, ignoring non-alphanumerics and case.",
        "wg": [
          { "t": "有效回文", "en": "valid palindrome", "ps": "N" },
          { "t": "忽略大小寫", "en": "case-insensitive", "ps": "Adj" }
        ]
      },
      {
        "t": "當左右字元不相同且其中一側是標點符號時，正確處理方式是什麼。",
        "en": "When the two characters differ and one side is punctuation, what is the correct handling.",
        "wg": [
          { "t": "標點符號", "en": "punctuation", "ps": "N" },
          { "t": "正確處理", "en": "correct handling", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 立即回傳 false，因為不相同就不是回文。",
        "en": "(A) Return false immediately, because mismatch means not a palindrome.",
        "wg": []
      },
      {
        "t": "(B) 跳過標點符號那一側的指針，並繼續比較下一個有效字元。",
        "en": "(B) Advance the pointer on the punctuation side and continue comparing the next valid characters.",
        "wg": [
          { "t": "跳過", "en": "skip", "ps": "V" },
          { "t": "有效字元", "en": "valid character", "ps": "N" }
        ]
      },
      {
        "t": "(C) 同時跳過左右兩側，因為只要有標點都應該略過。",
        "en": "(C) Skip both sides, because any punctuation should be ignored.",
        "wg": [
          { "t": "略過", "en": "ignore", "ps": "V" }
        ]
      },
      {
        "t": "(D) 先反轉字串再移除標點，會比較簡單且更快。",
        "en": "(D) Reverse the string first then remove punctuation; it’s simpler and faster.",
        "wg": [
          { "t": "反轉", "en": "reverse", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "題意要求忽略非字母數字，所以遇到標點時不應視為不匹配，而應移動對應指針直到兩側都指向有效字元再比較。選項 (A) 違反忽略規則。選項 (C) 可能跳過另一側的有效字元而漏檢。選項 (D) 會多做一次 O(n) 反轉且仍需掃描過濾，並不更快。",
      "en": "Since non-alphanumerics are ignored, punctuation should not cause a mismatch; you should advance the pointer on that side until both point to valid characters, then compare. Option (A) violates the ignore rule. Option (C) can skip a valid character on the other side and miss checks. Option (D) adds an extra O(n) reversal and still needs filtering, so it’s not faster.",
      "wg": [
        { "t": "忽略規則", "en": "ignore rule", "ps": "N" },
        { "t": "漏檢", "en": "miss checks", "ps": "V" },
        { "t": "過濾", "en": "filter", "ps": "V" }
      ]
    }
  },
  {
    "no": "6",
    "level": "hard",
    "keywords": "Valid Palindrome II, Two Pointers, Branching, At Most One Deletion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要判斷字串是否能透過刪除最多一個字元變成回文。",
        "en": "You need to check if a string can become a palindrome by deleting at most one character.",
        "wg": [
          { "t": "最多一個字元", "en": "at most one character", "ps": "N" },
          { "t": "變成回文", "en": "become a palindrome", "ps": "V" }
        ]
      },
      {
        "t": "當第一次遇到左右不相等時，最佳策略是什麼。",
        "en": "What is the best strategy when you encounter the first left-right mismatch.",
        "wg": [
          { "t": "第一次遇到", "en": "first encounter", "ps": "Adv" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接刪除左右兩個字元，因為至少要消除不相等。",
        "en": "(A) Delete both characters, because you must eliminate the mismatch.",
        "wg": []
      },
      {
        "t": "(B) 分別嘗試跳過左字元或跳過右字元，並檢查剩下子字串是否為回文。",
        "en": "(B) Try skipping the left character or the right character, and check if the remaining substring is a palindrome.",
        "wg": [
          { "t": "分別嘗試", "en": "try separately", "ps": "V" },
          { "t": "子字串", "en": "substring", "ps": "N" }
        ]
      },
      {
        "t": "(C) 之後改用 Hash Map 記錄字元頻率即可判斷回文。",
        "en": "(C) Switch to a Hash Map of character frequencies to decide palindrome.",
        "wg": [
          { "t": "字元頻率", "en": "character frequency", "ps": "N" }
        ]
      },
      {
        "t": "(D) 從不相等的位置開始往外擴張，尋找更大的回文區間。",
        "en": "(D) Expand outward from the mismatch to search for a larger palindromic interval.",
        "wg": [
          { "t": "往外擴張", "en": "expand outward", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最多刪除一次意味著在第一次不相等時只可能刪左或刪右，兩種分支各檢查一次即可保持 O(n)。選項 (A) 超過允許刪除次數。選項 (C) 只看頻率無法保證字元順序對稱。選項 (D) 是不同問題模型，不能保證涵蓋所有刪除選擇。",
      "en": "With at most one deletion, at the first mismatch you can only delete the left or the right character, so checking both branches once keeps O(n). Option (A) exceeds the allowed deletion. Option (C) uses frequency only and cannot enforce symmetric order. Option (D) addresses a different model and does not guarantee covering all deletion choices.",
      "wg": [
        { "t": "分支", "en": "branch", "ps": "N" },
        { "t": "問題模型", "en": "problem model", "ps": "N" },
        { "t": "對稱", "en": "symmetric", "ps": "Adj" }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Remove Duplicates, Fast Slow Pointers, In-place, Sorted Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在排序陣列中原地移除重複元素並回傳新長度。",
        "en": "You need to remove duplicates in-place from a sorted array and return the new length.",
        "wg": [
          { "t": "原地", "en": "in-place", "ps": "Adj" },
          { "t": "新長度", "en": "new length", "ps": "N" }
        ]
      },
      {
        "t": "快慢指針中 slow 指針的不變量是什麼。",
        "en": "In fast-slow pointers, what invariant does the slow pointer maintain.",
        "wg": [
          { "t": "不變量", "en": "invariant", "ps": "N" },
          { "t": "快慢指針", "en": "fast-slow pointers", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) slow 左側區間永遠是已去重且保持相對順序的結果。",
        "en": "(A) The region left of slow is always the deduplicated result with stable relative order.",
        "wg": [
          { "t": "相對順序", "en": "relative order", "ps": "N" }
        ]
      },
      {
        "t": "(B) slow 永遠指向陣列的最大值位置。",
        "en": "(B) slow always points to the position of the maximum value.",
        "wg": []
      },
      {
        "t": "(C) slow 只要指向最後一個元素即可，其他都不重要。",
        "en": "(C) slow just needs to point to the last element; the rest doesn’t matter.",
        "wg": []
      },
      {
        "t": "(D) slow 左側區間永遠包含所有原始元素，只是順序可能改變。",
        "en": "(D) The region left of slow always contains all original elements, but order may change.",
        "wg": [
          { "t": "順序可能改變", "en": "order may change", "ps": "V" }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "去重的穩定覆寫法會讓 slow 左側形成「已完成輸出」，並保留第一次出現的元素順序。這個不變量讓你只要掃描 fast 並在遇到新值時寫入 slow。其他選項不是此題的必要狀態，或描述了 swap 分割而非穩定去重。",
      "en": "Stable overwrite dedup makes the left-of-slow region the finalized output while preserving the order of first occurrences. This invariant lets fast scan and write to slow only when a new value appears. The other options either track irrelevant state or describe swap partition rather than stable dedup.",
      "wg": [
        { "t": "穩定覆寫", "en": "stable overwrite", "ps": "N" },
        { "t": "已完成輸出", "en": "finalized output", "ps": "N" },
        { "t": "分割", "en": "partition", "ps": "N" }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "Remove Duplicates II, At Most Twice, Fast Slow Pointers, In-place",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在排序陣列中原地去重，但允許每個值最多保留兩次。",
        "en": "You need in-place dedup on a sorted array, but allow each value to appear at most twice.",
        "wg": [
          { "t": "最多保留兩次", "en": "keep at most twice", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個判斷條件最常用且最不容易出錯。",
        "en": "Which condition is most commonly used and least error-prone.",
        "wg": [
          { "t": "判斷條件", "en": "condition check", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 若 nums[fast] != nums[slow-1] 就寫入。",
        "en": "(A) Write if nums[fast] != nums[slow-1].",
        "wg": []
      },
      {
        "t": "(B) 若 slow < 2 或 nums[fast] != nums[slow-2] 就寫入。",
        "en": "(B) Write if slow < 2 or nums[fast] != nums[slow-2].",
        "wg": [
          { "t": "slow < 2", "en": "slow < 2", "ps": "N" }
        ]
      },
      {
        "t": "(C) 若 nums[fast] == nums[slow] 就寫入。",
        "en": "(C) Write if nums[fast] == nums[slow].",
        "wg": []
      },
      {
        "t": "(D) 只要 fast 遇到重複就跳過，slow 永遠不寫入重複值。",
        "en": "(D) Skip duplicates whenever fast sees them; slow never writes duplicates.",
        "wg": [
          { "t": "永遠不寫入", "en": "never write", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "允許最多兩次的關鍵是比較「寫入結果的倒數第二個」是否與當前值相同。當 slow < 2 時一定可以寫入，之後只有在 nums[fast] != nums[slow-2] 時才寫入以避免第三次出現。選項 (A) 只能保證最多一次。選項 (C) 不符合寫入語義。選項 (D) 會錯失第二次允許的寫入。",
      "en": "Allowing at most twice hinges on comparing against the element two slots behind the write position. When slow < 2 you can always write; afterward, write only if nums[fast] != nums[slow-2] to prevent a third occurrence. Option (A) enforces at most once. Option (C) breaks the write semantics. Option (D) misses the allowed second copy.",
      "wg": [
        { "t": "倒數第二個", "en": "second last", "ps": "N" },
        { "t": "寫入語義", "en": "write semantics", "ps": "N" },
        { "t": "第三次出現", "en": "third occurrence", "ps": "N" }
      ]
    }
  },
  {
    "no": "9",
    "level": "easy",
    "keywords": "Remove Element, Two Pointers, Stable Compaction, In-place",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在陣列中原地移除所有等於 val 的元素並回傳新長度。",
        "en": "You need to remove all elements equal to val in-place and return the new length.",
        "wg": [
          { "t": "原地移除", "en": "in-place removal", "ps": "N" }
        ]
      },
      {
        "t": "如果題目要求保留非 val 元素的相對順序，最佳做法是什麼。",
        "en": "If the problem requires preserving relative order of non-val elements, what is the best approach.",
        "wg": [
          { "t": "相對順序", "en": "relative order", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 用 swap 把 val 跟尾端交換，並縮短尾端。",
        "en": "(A) Swap val with the tail and shrink the tail.",
        "wg": [
          { "t": "縮短尾端", "en": "shrink the tail", "ps": "V" }
        ]
      },
      {
        "t": "(B) 用快慢指針，fast 掃描，遇到非 val 就寫到 slow 並 slow++。",
        "en": "(B) Use fast-slow pointers: fast scans, write non-val to slow then slow++.",
        "wg": [
          { "t": "快慢指針", "en": "fast-slow pointers", "ps": "N" }
        ]
      },
      {
        "t": "(C) 先排序陣列把 val 聚集，再切掉尾端。",
        "en": "(C) Sort the array to cluster val, then cut the tail.",
        "wg": [
          { "t": "聚集", "en": "cluster", "ps": "V" }
        ]
      },
      {
        "t": "(D) 用 Set 去除 val，因為 Set 會自動移除元素。",
        "en": "(D) Use a Set to remove val, because Set removes elements automatically.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "保序需求意味著你需要穩定覆寫，快慢指針能在 O(n) 內完成且保持相對順序。swap 分割法可能打亂順序。排序會改變整體順序並增加 O(n log n) 成本。Set 會去重且無法保留重複元素的相對位置，與題意不符。",
      "en": "Preserving order requires stable compaction; fast-slow overwrite achieves O(n) while keeping relative order. Swap partition can reorder elements. Sorting changes the overall order and adds O(n log n) cost. A Set deduplicates and cannot preserve duplicates’ positions, so it doesn’t match the requirement.",
      "wg": [
        { "t": "保序", "en": "order-preserving", "ps": "Adj" },
        { "t": "穩定覆寫", "en": "stable overwrite", "ps": "N" },
        { "t": "打亂順序", "en": "disrupt order", "ps": "V" }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Move Zeroes, Two Pointers, Stable Partition, In-place",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要把陣列中的所有 0 移到尾端，且保持非 0 元素的相對順序。",
        "en": "You need to move all zeros to the end while preserving the relative order of non-zero elements.",
        "wg": [
          { "t": "移到尾端", "en": "move to the end", "ps": "V" },
          { "t": "保持相對順序", "en": "preserve relative order", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個 two pointers 寫法最符合穩定分割的語義。",
        "en": "Which two-pointers approach best matches stable partition semantics.",
        "wg": [
          { "t": "穩定分割", "en": "stable partition", "ps": "N" },
          { "t": "語義", "en": "semantics", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 用 l,r 從兩端 swap 0 與非 0，直到指針交錯。",
        "en": "(A) Use l,r from both ends and swap 0 with non-0 until pointers cross.",
        "wg": [
          { "t": "交錯", "en": "cross", "ps": "V" }
        ]
      },
      {
        "t": "(B) fast 掃描，遇到非 0 就寫到 slow，最後把剩餘位置補 0。",
        "en": "(B) Let fast scan; write non-zeros to slow; then fill the rest with zeros.",
        "wg": [
          { "t": "補 0", "en": "fill with zeros", "ps": "V" }
        ]
      },
      {
        "t": "(C) 每看到 0 就立刻與下一個非 0 swap，保證局部正確即可。",
        "en": "(C) Whenever you see 0, swap it with the next non-zero to ensure local correctness.",
        "wg": [
          { "t": "局部正確", "en": "locally correct", "ps": "Adj" }
        ]
      },
      {
        "t": "(D) 先排序陣列，因為 0 會自然排到前面或後面。",
        "en": "(D) Sort the array so zeros naturally go to one side.",
        "wg": [
          { "t": "自然排到", "en": "naturally move to", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "穩定分割要求非 0 的相對順序不變，快慢指針的穩定覆寫正好符合。兩端 swap 會打亂相對順序。逐個 swap 可能退化成 O(n^2) 且仍可能破壞穩定性。排序會改變元素順序並引入 O(n log n)。",
      "en": "Stable partition requires keeping non-zeros in the same relative order, which fast-slow stable overwrite provides. Two-end swapping breaks relative order. Repeated local swaps can degrade to O(n^2) and can still break stability. Sorting changes order and adds O(n log n).",
      "wg": [
        { "t": "退化", "en": "degrade", "ps": "V" },
        { "t": "穩定性", "en": "stability", "ps": "N" },
        { "t": "引入", "en": "introduce", "ps": "V" }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Merge Sorted Array, Two Pointers, From Back, In-place",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要把兩個已排序陣列合併到 nums1，且 nums1 尾端有足夠空間。",
        "en": "You need to merge two sorted arrays into nums1, and nums1 has enough trailing space.",
        "wg": [
          { "t": "足夠空間", "en": "enough space", "ps": "N" },
          { "t": "合併", "en": "merge", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個指針方向最能避免覆寫尚未比較的元素。",
        "en": "Which pointer direction best avoids overwriting elements that haven’t been compared yet.",
        "wg": [
          { "t": "覆寫", "en": "overwrite", "ps": "V" },
          { "t": "尚未比較", "en": "not yet compared", "ps": "Adj" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從前往後合併，因為比較直覺。",
        "en": "(A) Merge from front to back because it’s more intuitive.",
        "wg": [
          { "t": "直覺", "en": "intuitive", "ps": "Adj" }
        ]
      },
      {
        "t": "(B) 從後往前合併，使用 i 指向 nums1 有效尾端，j 指向 nums2 尾端，k 指向 nums1 最尾端。",
        "en": "(B) Merge from back to front using i at nums1’s valid tail, j at nums2’s tail, and k at nums1’s very end.",
        "wg": [
          { "t": "從後往前", "en": "from back to front", "ps": "PrepP" }
        ]
      },
      {
        "t": "(C) 先把 nums1 全部複製到暫存陣列，再從前往後合併。",
        "en": "(C) Copy nums1 into a temporary array, then merge from front to back.",
        "wg": [
          { "t": "暫存陣列", "en": "temporary array", "ps": "N" }
        ]
      },
      {
        "t": "(D) 直接把 nums2 append 到 nums1 後 sort 一次即可。",
        "en": "(D) Append nums2 to nums1 and sort once.",
        "wg": [
          { "t": "append", "en": "append", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "原地合併的關鍵是避免覆寫 nums1 前段尚未讀取的值，所以應從尾端開始寫入。選項 (A) 會覆寫掉還沒比較的 nums1 元素。選項 (C) 可行但使用 O(n) 額外空間。選項 (D) 成本是 O((m+n) log (m+n)) 且不符合面試期待的線性合併。",
      "en": "In-place merge must avoid overwriting unread values in nums1’s front region, so you should write from the end. Option (A) overwrites nums1 elements before they’re compared. Option (C) works but uses O(n) extra space. Option (D) costs O((m+n) log (m+n)) and misses the expected linear merge.",
      "wg": [
        { "t": "原地合併", "en": "in-place merge", "ps": "N" },
        { "t": "線性合併", "en": "linear merge", "ps": "N" },
        { "t": "面試期待", "en": "interview expectation", "ps": "N" }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Squares of a Sorted Array, Two Pointers, Non-decreasing, From Ends",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要把已排序陣列每個元素平方後，輸出仍為非遞減排序的陣列。",
        "en": "You need to square each element of a sorted array and output a non-decreasing sorted array.",
        "wg": [
          { "t": "非遞減", "en": "non-decreasing", "ps": "Adj" },
          { "t": "平方", "en": "square", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個 two pointers 策略最常用且能達到 O(n)。",
        "en": "Which two-pointers strategy is most common and achieves O(n).",
        "wg": [
          { "t": "策略", "en": "strategy", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接平方後 sort，因為平方不會破壞排序。",
        "en": "(A) Square then sort, because squaring doesn’t break order.",
        "wg": []
      },
      {
        "t": "(B) 用左右指針比較絕對值，較大者平方後從結果陣列尾端填入。",
        "en": "(B) Use two pointers on both ends, compare absolute values, and fill the result from the back with the larger square.",
        "wg": [
          { "t": "絕對值", "en": "absolute value", "ps": "N" },
          { "t": "從尾端填入", "en": "fill from the back", "ps": "V" }
        ]
      },
      {
        "t": "(C) 用快慢指針把負數搬到後面，再平方。",
        "en": "(C) Use fast-slow pointers to move negatives to the end, then square.",
        "wg": [
          { "t": "搬到後面", "en": "move to the end", "ps": "V" }
        ]
      },
      {
        "t": "(D) 只要找到最小負數位置，往右掃描即可。",
        "en": "(D) Just find the smallest negative and scan right.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "平方後的最大值可能來自兩端的最大絕對值，所以應比較兩端絕對值並把較大平方放到輸出尾端。這樣每個指針只走一次，總 O(n)。選項 (A) 是 O(n log n)。選項 (C) 不會自動得到排序結果。選項 (D) 忽略了左側負數平方可能比右側更大。",
      "en": "After squaring, the largest values come from the ends with the largest absolute values, so compare abs at both ends and place the larger square at the back. Each pointer moves once, giving O(n). Option (A) is O(n log n). Option (C) does not ensure sorted squares. Option (D) ignores that left-side negatives can yield large squares.",
      "wg": [
        { "t": "最大絕對值", "en": "largest absolute value", "ps": "N" },
        { "t": "輸出尾端", "en": "output tail", "ps": "N" },
        { "t": "忽略", "en": "ignore", "ps": "V" }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Sort Colors, Dutch National Flag, Two Pointers, Partition",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要原地排序只包含 0、1、2 的陣列，且只用常數額外空間。",
        "en": "You need to sort an array containing only 0, 1, and 2 in-place with constant extra space.",
        "wg": [
          { "t": "常數額外空間", "en": "constant extra space", "ps": "N" },
          { "t": "原地排序", "en": "in-place sort", "ps": "N" }
        ]
      },
      {
        "t": "Dutch National Flag 解法中，以下哪個不變量描述正確。",
        "en": "In the Dutch National Flag solution, which invariant is correctly described.",
        "wg": [
          { "t": "Dutch National Flag", "en": "Dutch National Flag", "ps": "N" },
          { "t": "不變量", "en": "invariant", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [0..low) 全是 0，(low..mid) 全是 1，(high..end] 全是 2。",
        "en": "(A) [0..low) are all 0s, (low..mid) are all 1s, (high..end] are all 2s.",
        "wg": [
          { "t": "不含端點", "en": "half-open interval", "ps": "N" }
        ]
      },
      {
        "t": "(B) [0..low) 全是 0，(low..mid) 未分類，(high..end] 全是 2。",
        "en": "(B) [0..low) are all 0s, (low..mid) are unknown, (high..end] are all 2s.",
        "wg": [
          { "t": "未分類", "en": "unclassified", "ps": "Adj" }
        ]
      },
      {
        "t": "(C) [0..low) 全是 0，[low..mid) 全是 1，[mid..high] 未分類，[high+1..end) 全是 2。",
        "en": "(C) [0..low) are 0s, [low..mid) are 1s, [mid..high] are unknown, [high+1..end) are 2s.",
        "wg": [
          { "t": "未知區間", "en": "unknown region", "ps": "N" }
        ]
      },
      {
        "t": "(D) 只要把 0 全 swap 到前面就完成排序，不需要處理 2。",
        "en": "(D) Just swap all 0s to the front; no need to handle 2s.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "正統不變量是把陣列分成四段：0 區、1 區、未知區、2 區。mid 掃描未知區，遇到 0 與 low 交換並 low++、mid++，遇到 2 與 high 交換並 high--，遇到 1 則 mid++。其他描述不是缺段就是把區間端點混淆，會導致錯誤移動或漏處理。",
      "en": "The canonical invariant splits the array into four regions: 0s, 1s, unknown, and 2s. mid scans the unknown; on 0 swap with low then low++ and mid++; on 2 swap with high then high--; on 1 just mid++. The other descriptions either miss a region or confuse interval endpoints, leading to wrong moves or missed handling.",
      "wg": [
        { "t": "正統不變量", "en": "canonical invariant", "ps": "N" },
        { "t": "未知區", "en": "unknown region", "ps": "N" },
        { "t": "端點混淆", "en": "endpoint confusion", "ps": "N" }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Counting Pairs, Two Pointers, Sum Less Than Target, Sorted",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在排序陣列中計算有多少對 (i,j) 使得 nums[i] + nums[j] < target。",
        "en": "You need to count how many pairs (i,j) in a sorted array satisfy nums[i] + nums[j] < target.",
        "wg": [
          { "t": "計算有多少對", "en": "count pairs", "ps": "V" },
          { "t": "排序陣列", "en": "sorted array", "ps": "N" }
        ]
      },
      {
        "t": "當固定 l 且 nums[l] + nums[r] < target 時，你可以一次加多少個配對。",
        "en": "When l is fixed and nums[l] + nums[r] < target, how many pairs can you add at once.",
        "wg": [
          { "t": "固定", "en": "fix", "ps": "V" },
          { "t": "一次加", "en": "add in one shot", "ps": "V" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只能加 1，因為只知道 (l,r) 這一對。",
        "en": "(A) Only add 1 because you only know about (l,r).",
        "wg": []
      },
      {
        "t": "(B) 加 (r - l)，因為所有 (l, k) 對於 l < k <= r 都會滿足不等式。",
        "en": "(B) Add (r - l), because all pairs (l, k) for l < k <= r will satisfy the inequality.",
        "wg": [
          { "t": "不等式", "en": "inequality", "ps": "N" }
        ]
      },
      {
        "t": "(C) 加 (n - r)，因為右邊更大所以更容易小於 target。",
        "en": "(C) Add (n - r), because larger right values are more likely to be below target.",
        "wg": []
      },
      {
        "t": "(D) 加 (l + r)，因為兩個指針都參與計數。",
        "en": "(D) Add (l + r), because both pointers contribute to the count.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "排序性提供單調性：若 nums[l] + nums[r] < target，則對任何 k 介於 (l, r]，都有 nums[l] + nums[k] <= nums[l] + nums[r] < target，因此一次可加 (r-l) 個配對並 l++。選項 (A) 沒有利用排序性所以會變成 O(n^2)。選項 (C)(D) 沒有正確的單調推理。",
      "en": "Sorted order gives monotonicity: if nums[l] + nums[r] < target, then for any k in (l, r], nums[l] + nums[k] <= nums[l] + nums[r] < target, so you can add (r-l) pairs at once and increment l. Option (A) fails to exploit sortedness and becomes O(n^2). Options (C)(D) lack valid monotonic reasoning.",
      "wg": [
        { "t": "單調推理", "en": "monotonic reasoning", "ps": "N" },
        { "t": "介於", "en": "between", "ps": "PrepP" },
        { "t": "利用排序性", "en": "exploit sortedness", "ps": "V" }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "4Sum, Two Pointers, Pruning, Deduplication",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要解 4Sum 並回傳所有不重複四元組使和為 target。",
        "en": "You need to solve 4Sum and return all unique quadruplets that sum to target.",
        "wg": [
          { "t": "四元組", "en": "quadruplet", "ps": "N" },
          { "t": "不重複", "en": "unique", "ps": "Adj" }
        ]
      },
      {
        "t": "在排序後的解法中，哪一種剪枝最合理且最常見。",
        "en": "In a sorted approach, which pruning is most reasonable and commonly used.",
        "wg": [
          { "t": "剪枝", "en": "pruning", "ps": "N" },
          { "t": "最常見", "en": "most common", "ps": "Adj" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 若最小可能和大於 target，就可 break 當前迴圈。",
        "en": "(A) If the minimum possible sum exceeds target, you can break the current loop.",
        "wg": [
          { "t": "最小可能和", "en": "minimum possible sum", "ps": "N" }
        ]
      },
      {
        "t": "(B) 若最大可能和小於 target，就可 break 當前迴圈。",
        "en": "(B) If the maximum possible sum is less than target, you can break the current loop.",
        "wg": [
          { "t": "最大可能和", "en": "maximum possible sum", "ps": "N" }
        ]
      },
      {
        "t": "(C) 只要遇到重複值就 break，因為重複一定不會有新解。",
        "en": "(C) Break whenever you see duplicates, because duplicates can never yield new solutions.",
        "wg": [
          { "t": "重複一定不會", "en": "duplicates can never", "ps": "N" }
        ]
      },
      {
        "t": "(D) 先用 Hash Map 找 two-sum，再把結果拼成四元組，排序就不需要了。",
        "en": "(D) Use a Hash Map to find two-sums and combine into quadruplets; sorting is unnecessary.",
        "wg": [
          { "t": "拼成", "en": "assemble into", "ps": "V" }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "排序後可估計當前 anchor 下的最小可能和與最大可能和。若最小可能和已經大於 target，後續只會更大，因此可以安全 break。選項 (B) 在最大可能和小於 target 時應該是 continue 到更大的 anchor，而不是 break，因為後面 anchor 可能變大使最大可能和提升。選項 (C) 應該是跳過重複而非整段 break。選項 (D) 會引入大量配對與去重成本，且容易漏掉或重複。",
      "en": "After sorting, you can bound the minimum and maximum achievable sums under current anchors. If the minimum possible sum already exceeds target, later sums only grow, so breaking is safe. For (B), when the maximum is less than target, you should continue to larger anchors rather than break, because later anchors can increase the maximum. For (C), you skip duplicates, not break the whole loop. For (D), pairing via hashing introduces heavy combination/dedup costs and is error-prone.",
      "wg": [
        { "t": "安全 break", "en": "safe break", "ps": "N" },
        { "t": "估計", "en": "bound/estimate", "ps": "V" },
        { "t": "去重成本", "en": "dedup cost", "ps": "N" }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "Minimum Difference Pair, Two Pointers, Two Arrays, Sorted",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在兩個陣列中找一對數，使它們的絕對差最小。",
        "en": "You need to find a pair of numbers, one from each of two arrays, with the minimum absolute difference.",
        "wg": [
          { "t": "絕對差", "en": "absolute difference", "ps": "N" },
          { "t": "最小", "en": "minimum", "ps": "Adj" }
        ]
      },
      {
        "t": "若你先把兩個陣列排序，兩指針 i 與 j 應如何移動以維持單調逼近。",
        "en": "If you sort both arrays, how should pointers i and j move to maintain monotonic convergence.",
        "wg": [
          { "t": "單調逼近", "en": "monotonic convergence", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 若 A[i] < B[j]，移動 i++，否則移動 j++。",
        "en": "(A) If A[i] < B[j], move i++; otherwise move j++.",
        "wg": []
      },
      {
        "t": "(B) 若 A[i] < B[j]，移動 j++，否則移動 i++。",
        "en": "(B) If A[i] < B[j], move j++; otherwise move i++.",
        "wg": []
      },
      {
        "t": "(C) 每一步都同時移動 i++ 與 j++ 以加速收斂。",
        "en": "(C) Move both i++ and j++ every step to converge faster.",
        "wg": [
          { "t": "收斂", "en": "converge", "ps": "V" }
        ]
      },
      {
        "t": "(D) 固定 i 不動，讓 j 從頭掃到尾即可。",
        "en": "(D) Keep i fixed and scan j from start to end.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若 A[i] < B[j]，要縮小差距需要讓較小的一方變大，因此移動 i++。反之移動 j++。這利用了排序的單調性讓差距有機會變小。選項 (B) 會讓差距更大或不必要地跳過更佳配對。選項 (C) 可能略過最佳組合。選項 (D) 退化成 O(n^2) 搜尋。",
      "en": "If A[i] < B[j], to shrink the gap you must increase the smaller side, so move i++; otherwise move j++. This uses sorted monotonicity to potentially reduce the difference. Option (B) can increase the gap or skip better candidates. Option (C) can skip the optimal pair. Option (D) degenerates into O(n^2) search.",
      "wg": [
        { "t": "縮小差距", "en": "shrink the gap", "ps": "V" },
        { "t": "最佳組合", "en": "optimal combination", "ps": "N" },
        { "t": "退化", "en": "degenerate", "ps": "V" }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Reverse String, Two Pointers, In-place, Swap",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要原地反轉字元陣列 s，且只能使用 O(1) 額外空間。",
        "en": "You need to reverse a character array s in-place using only O(1) extra space.",
        "wg": [
          { "t": "字元陣列", "en": "character array", "ps": "N" },
          { "t": "原地反轉", "en": "in-place reverse", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個 two pointers 迴圈條件最安全且最常見。",
        "en": "Which two-pointers loop condition is safest and most common.",
        "wg": [
          { "t": "迴圈條件", "en": "loop condition", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      { "t": "(A) while (l <= r)", "en": "(A) while (l <= r)", "wg": [] },
      { "t": "(B) while (l < r)", "en": "(B) while (l < r)", "wg": [] },
      { "t": "(C) while (l !== r)", "en": "(C) while (l !== r)", "wg": [] },
      { "t": "(D) for (l=0; l< n; l++)", "en": "(D) for (l=0; l< n; l++)", "wg": [] }
    ],
    "answer": "(B)",
    "why": {
      "t": "反轉需要對稱交換，每次交換後 l++ 且 r--。當 l >= r 時表示所有配對都處理完，因此 while (l < r) 最自然且避免多做中間元素的無意義交換。選項 (A) 會在 l==r 時多做一次自交換。選項 (C) 若跳步可能出現錯誤。選項 (D) 需要額外計算對稱位置且更容易 off-by-one。",
      "en": "Reversal swaps symmetric pairs, then l++ and r--. When l >= r, all pairs are processed, so while (l < r) is natural and avoids a pointless self-swap at the center. Option (A) performs an extra self-swap when l==r. Option (C) can behave oddly with pointer jumps. Option (D) needs extra symmetric index math and is more prone to off-by-one.",
      "wg": [
        { "t": "自交換", "en": "self-swap", "ps": "N" },
        { "t": "對稱交換", "en": "symmetric swap", "ps": "N" },
        { "t": "off-by-one", "en": "off-by-one", "ps": "N" }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Two Pointers, Solvability, Monotonicity, When Not Applicable",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你在面試中想用 two pointers 解一個子陣列和問題，但陣列包含負數。",
        "en": "In an interview, you want to use two pointers for a subarray-sum problem, but the array contains negative numbers.",
        "wg": [
          { "t": "子陣列和", "en": "subarray sum", "ps": "N" },
          { "t": "包含負數", "en": "contains negatives", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個說法最能精準描述 two pointers 可能失效的原因。",
        "en": "Which statement best explains why two pointers may fail here.",
        "wg": [
          { "t": "可能失效", "en": "may fail", "ps": "V" },
          { "t": "精準描述", "en": "precise description", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) two pointers 只能用在字串，不能用在數字陣列。",
        "en": "(A) Two pointers only works for strings, not numeric arrays.",
        "wg": []
      },
      {
        "t": "(B) 有負數時，移動指針不一定讓 sum 單調變大或變小，淘汰規則不成立。",
        "en": "(B) With negatives, moving pointers doesn’t make the sum change monotonically, so elimination rules can break.",
        "wg": [
          { "t": "淘汰規則", "en": "elimination rule", "ps": "N" },
          { "t": "不成立", "en": "does not hold", "ps": "V" }
        ]
      },
      {
        "t": "(C) 只要先排序就一定能用 two pointers 解所有子陣列問題。",
        "en": "(C) Sorting always makes two pointers work for any subarray problem.",
        "wg": [
          { "t": "所有", "en": "all", "ps": "Adj" }
        ]
      },
      {
        "t": "(D) two pointers 的空間複雜度太高，所以不適合面試。",
        "en": "(D) Two pointers has too much space complexity, so it’s not interview-friendly.",
        "wg": [
          { "t": "空間複雜度", "en": "space complexity", "ps": "N" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "two pointers 的核心是單調性或可淘汰性。當陣列有負數時，擴張或收縮窗口可能讓 sum 上下震盪，導致你無法保證移動一端就能安全丟棄一批候選。此時更常用 prefix sum + hash 或其他方法。其他選項是錯誤概括或不符合事實。",
      "en": "Two pointers relies on monotonicity or eliminability. With negatives, expanding/shrinking can make the sum oscillate, so you can’t guarantee that moving one end safely discards candidates. In such cases, prefix sum + hash or other approaches are more appropriate. The other options are incorrect generalizations or false claims.",
      "wg": [
        { "t": "上下震盪", "en": "oscillate", "ps": "V" },
        { "t": "安全丟棄", "en": "safely discard", "ps": "V" },
        { "t": "可淘汰性", "en": "eliminability", "ps": "N" }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Two Sum Closest, Two Pointers, Sorted, Greedy Move",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "你要在已排序陣列中找一對數，使得它們的和最接近 target。",
        "en": "You need a pair in a sorted array whose sum is closest to target.",
        "wg": [
          { "t": "最接近", "en": "closest", "ps": "Adj" }
        ]
      },
      {
        "t": "每次更新最佳答案後，指針移動規則應依據什麼來決定。",
        "en": "After updating the best answer, what should determine your pointer move rule.",
        "wg": [
          { "t": "移動規則", "en": "move rule", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據目前 sum 與 target 的大小關係，sum < target 就 l++，否則 r--。",
        "en": "(A) Based on sum vs target: if sum < target then l++, else r--.",
        "wg": [
          { "t": "大小關係", "en": "relative comparison", "ps": "N" }
        ]
      },
      {
        "t": "(B) 永遠移動較大的那一端，因為大數更能調整接近 target。",
        "en": "(B) Always move the larger end because big numbers adjust closeness better.",
        "wg": []
      },
      {
        "t": "(C) 永遠移動較小的那一端，因為小數更細緻。",
        "en": "(C) Always move the smaller end because it’s more fine-grained.",
        "wg": [
          { "t": "更細緻", "en": "more fine-grained", "ps": "Adj" }
        ]
      },
      {
        "t": "(D) 每次都同時移動兩端，避免在局部最小卡住。",
        "en": "(D) Move both ends each time to avoid getting stuck in a local minimum.",
        "wg": [
          { "t": "局部最小", "en": "local minimum", "ps": "N" }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在排序陣列中，sum 對於 l 與 r 的移動是單調可預期的。若 sum 太小就增加 l 以增加 sum，若太大就減少 r 以減少 sum，同時持續更新最接近的差值。其他選項沒有可證明的單調推進，容易錯過最佳配對。",
      "en": "In a sorted array, the sum changes predictably with l and r. If sum is too small, increase l to raise sum; if too large, decrease r to lower sum, while tracking the smallest absolute error. The other options lack provable monotonic progress and can miss the best pair.",
      "wg": [
        { "t": "差值", "en": "error/delta", "ps": "N" },
        { "t": "單調推進", "en": "monotonic progress", "ps": "N" },
        { "t": "錯過", "en": "miss", "ps": "V" }
      ]
    }
  },
  {
    "no": "20",
    "level": "hard",
    "keywords": "Two Pointers, TypeScript Sort, Comparator, Bug",
    "parentNo": null,
    "images": null,
    "codeSnippet": "const nums = [10, 2, 1];\nnums.sort();\n// Expect numeric ascending sort for two pointers.\n",
    "question": [
      {
        "t": "你在 TypeScript 中先排序再用 two pointers，但排序寫成 nums.sort() 沒有提供 comparator。",
        "en": "In TypeScript, you sort before using two pointers, but you wrote nums.sort() without a comparator.",
        "wg": [
          { "t": "提供 comparator", "en": "provide a comparator", "ps": "V" },
          { "t": "two pointers", "en": "two pointers", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個敘述最正確地描述了風險與修正方式。",
        "en": "Which statement most accurately describes the risk and the fix.",
        "wg": [
          { "t": "風險", "en": "risk", "ps": "N" },
          { "t": "修正方式", "en": "fix", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 沒有風險，nums.sort() 會自動以數值排序。",
        "en": "(A) No risk; nums.sort() automatically sorts numerically.",
        "wg": []
      },
      {
        "t": "(B) 風險是字典序排序會破壞單調性，應改成 nums.sort((a,b)=>a-b)。",
        "en": "(B) The risk is lexicographic sorting breaks monotonicity; fix with nums.sort((a,b)=>a-b).",
        "wg": [
          { "t": "字典序排序", "en": "lexicographic sort", "ps": "N" },
          { "t": "破壞單調性", "en": "break monotonicity", "ps": "V" }
        ]
      },
      {
        "t": "(C) 風險是排序不穩定，應改成 stable sort 才能 two pointers。",
        "en": "(C) The risk is unstable sorting; you must use stable sort for two pointers.",
        "wg": [
          { "t": "不穩定", "en": "unstable", "ps": "Adj" }
        ]
      },
      {
        "t": "(D) 風險是時間複雜度變差，應改用 Hash Map 不排序。",
        "en": "(D) The risk is worse time complexity; use a Hash Map instead of sorting.",
        "wg": [
          { "t": "時間複雜度變差", "en": "worse time complexity", "ps": "N" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 JS/TS 中，sort() 預設以字串比較做字典序排序，例如 10 會排在 2 前面，導致 two pointers 依賴的單調性失效。修正方式是提供數值 comparator，例如 (a,b)=>a-b。穩定排序與否通常不是 two pointers 的必要條件。改用 Hash Map 可能適用於不同題型，但不是此 bug 的直接修正。",
      "en": "In JS/TS, sort() defaults to string comparison and lexicographic order, so 10 can appear before 2, breaking the monotonicity that two pointers relies on. The fix is to provide a numeric comparator like (a,b)=>a-b. Stability is usually not required for two pointers. Switching to a Hash Map might solve different problems, but it’s not the direct fix for this bug.",
      "wg": [
        { "t": "字典序", "en": "lexicographic order", "ps": "N" },
        { "t": "直接修正", "en": "direct fix", "ps": "N" },
        { "t": "依賴", "en": "rely on", "ps": "V" }
      ]
    }
  }
]