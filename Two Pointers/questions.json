[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Two Pointers, Array, Time Complexity, Sorted",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: numbers = [2, 7, 11, 15], target = 9\nOutput: [1, 2] // 1-based index",
    "question": [
      {
        "t": "給定一個已按非遞減順序排列的整數陣列，請找出兩個數，使它們相加之和等於特定的目標數。",
        "en": "Given an array of integers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.",
        "wg": [
          {
            "t": "非遞減順序",
            "en": "non-decreasing order",
            "ps": "NP"
          },
          {
            "t": "整數陣列",
            "en": "array of integers",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為了達到最佳的時間複雜度 O(n)，您應該如何初始化並移動雙指標（Two Pointers）？",
        "en": "To achieve the optimal time complexity of O(n), how should you initialize and move the two pointers?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          },
          {
            "t": "初始化",
            "en": "initialize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將兩個指標都放在陣列的起點，若和過小則移動右指標，若和過大則移動左指標。",
        "en": "(A) Place both pointers at the start of the array; move the right pointer if the sum is too small, and the left pointer if the sum is too large.",
        "wg": []
      },
      {
        "t": "(B) 將左指標放在起點，右指標放在終點。若和 < 目標值，左指標向右移；若和 > 目標值，右指標向左移。",
        "en": "(B) Place the left pointer at the start and the right pointer at the end. If sum < target, move left pointer right; if sum > target, move right pointer left.",
        "wg": [
          {
            "t": "終點",
            "en": "end",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用巢狀迴圈遍歷所有可能的配對。",
        "en": "(C) Use nested loops to iterate through all possible pairs.",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "NP"
          },
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 將左指標放在起點，右指標放在中間位置，同時向右移動。",
        "en": "(D) Place the left pointer at the start and the right pointer at the middle, moving both to the right simultaneously.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為陣列已排序，當兩數之和此目標值小時，必須增加數值（左指標右移）；當和比目標值大時，必須減少數值（右指標左移），這樣才能在 O(n) 時間內找到答案。",
      "en": "Since the array is sorted, when the sum is smaller than the target, we must increase the value (move left pointer right); when the sum is larger, we must decrease the value (move right pointer left), allowing us to find the answer in O(n) time.",
      "wg": [
        {
          "t": "已排序",
          "en": "sorted",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Two Pointers, Linked List, Cycle Detection, Floyd's Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};",
    "question": [
      {
        "t": "在使用快慢指標（Fast and Slow Pointers）檢測連結串列（Linked List）中是否存在環（Cycle）時，",
        "en": "When using Fast and Slow Pointers to detect if a cycle exists in a Linked List,",
        "wg": [
          {
            "t": "連結串列",
            "en": "Linked List",
            "ps": "NP"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "通常設定慢指標每次移動 1 步，快指標每次移動 2 步。",
        "en": "Typically, the slow pointer moves 1 step at a time, and the fast pointer moves 2 steps at a time.",
        "wg": []
      },
      {
        "t": "為什麼這種配置保證兩者若有環必定會相遇，而不會永遠錯過？",
        "en": "Why does this configuration guarantee that they will meet if there is a cycle, rather than missing each other forever?",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          },
          {
            "t": "錯過",
            "en": "miss",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為快指標的速度是慢指標的兩倍，這是一個經驗法則，沒有數學依據。",
        "en": "(A) Because the fast pointer is twice as fast as the slow pointer; this is a rule of thumb with no mathematical basis.",
        "wg": [
          {
            "t": "經驗法則",
            "en": "rule of thumb",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 因為兩者的相對速度為 1，這意味著快指標每次都在以 1 步的距離「追趕」慢指標，最終距離會縮減為 0。",
        "en": "(B) Because their relative speed is 1, meaning the fast pointer is 'catching up' to the slow pointer by 1 step each time, eventually reducing the distance to 0.",
        "wg": [
          {
            "t": "相對速度",
            "en": "relative speed",
            "ps": "NP"
          },
          {
            "t": "追趕",
            "en": "catch up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 只有當環的長度為偶數時，它們才會相遇。",
        "en": "(C) They will only meet if the length of the cycle is an even number.",
        "wg": []
      },
      {
        "t": "(D) 快指標移動 3 步或 4 步也能保證相遇，選擇 2 步只是為了節省運算資源。",
        "en": "(D) Moving the fast pointer 3 or 4 steps also guarantees a meeting; choosing 2 steps is just to save computational resources.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個相對運動問題。在環中，快指標相對於慢指標的速度是 1 步/次。無論兩者相距多遠，距離都會以每次 1 步的速度遞減，因此不可能「跳過」慢指標。",
      "en": "This is a relative motion problem. In the cycle, the fast pointer's speed relative to the slow pointer is 1 step/iteration. No matter the distance, it decreases by 1 step each time, so it's impossible to 'jump over' the slow pointer.",
      "wg": [
        {
          "t": "遞減",
          "en": "decrease",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Two Pointers, Greedy, Container With Most Water",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在經典題目「盛最多水的容器」（Container With Most Water）中，我們使用雙指標分別指向陣列的頭和尾。",
        "en": "In the classic problem 'Container With Most Water', we use two pointers pointing to the start and end of the array respectively.",
        "wg": [
          {
            "t": "盛最多水的容器",
            "en": "Container With Most Water",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "每一輪移動指標的策略是什麼？其背後的邏輯為何？",
        "en": "What is the strategy for moving the pointers in each round, and what is the logic behind it?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          },
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 移動高度較高的指標。因為我們希望保留較高的邊來容納更多水。",
        "en": "(A) Move the pointer with the greater height. Because we want to keep the taller edge to hold more water.",
        "wg": []
      },
      {
        "t": "(B) 移動高度較低的指標。因為容器的容量受限於較短的邊，移動短邊才有可能找到更高的邊來增加面積。",
        "en": "(B) Move the pointer with the smaller height. Because the container's capacity is limited by the shorter edge, moving the shorter edge is the only way to potentially find a taller edge to increase the area.",
        "wg": [
          {
            "t": "受限於",
            "en": "limited by",
            "ps": "V"
          },
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 同時向內移動兩個指標，這樣可以最快遍歷完陣列。",
        "en": "(C) Move both pointers inward simultaneously to traverse the array as quickly as possible.",
        "wg": []
      },
      {
        "t": "(D) 計算當前兩指標的平均高度，若平均值小於某個閾值則移動左指標。",
        "en": "(D) Calculate the average height of the two pointers; if the average is below a threshold, move the left pointer.",
        "wg": [
          {
            "t": "閾值",
            "en": "threshold",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "面積 = 寬度 × 較短邊的高度。當我們向內移動指標時，寬度一定變小。若移動較高的邊，高度限制仍是原本較短的那邊（或更短），面積必減小；唯有移動較短邊，才有可能遇到更高的邊而使面積變大。",
      "en": "Area = Width × Height of the shorter edge. When we move pointers inward, the width decreases. If we move the taller edge, the height limit remains the original shorter edge (or becomes even shorter), so the area must decrease. Only by moving the shorter edge can we potentially find a taller edge to increase the area.",
      "wg": [
        {
          "t": "寬度",
          "en": "width",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Two Pointers, In-place, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if (nums[j] != nums[i]) {\n            // Missing Code\n        }\n    }\n    return i + 1;\n}",
    "question": [
      {
        "t": "在一個已排序的陣列中原地（In-place）移除重複元素，使得每個元素只出現一次。",
        "en": "Remove duplicates from a sorted array in-place such that each element appears only once.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          },
          {
            "t": "重複元素",
            "en": "duplicates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上方程式碼使用雙指標技巧，`i` 是慢指標，`j` 是快指標。",
        "en": "The code above uses the two-pointer technique, where `i` is the slow pointer and `j` is the fast pointer.",
        "wg": []
      },
      {
        "t": "請問 `// Missing Code` 處應該填入什麼，才能正確將不重複的元素移到陣列前方？",
        "en": "What should be filled in `// Missing Code` to correctly move unique elements to the front of the array?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `i++; nums[i] = nums[j];`",
        "en": "(A) `i++; nums[i] = nums[j];`",
        "wg": []
      },
      {
        "t": "(B) `nums[i] = nums[j]; i++;`",
        "en": "(B) `nums[i] = nums[j]; i++;`",
        "wg": []
      },
      {
        "t": "(C) `nums[i+1] = nums[j];`",
        "en": "(C) `nums[i+1] = nums[j];`",
        "wg": []
      },
      {
        "t": "(D) `swap(nums[i], nums[j]); i++;`",
        "en": "(D) `swap(nums[i], nums[j]); i++;`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "當發現一個新的不重複元素（`nums[j] != nums[i]`）時，我們需要先將慢指標 `i` 向前移動一步，以便騰出位置，然後將新的值 `nums[j]` 寫入 `nums[i]`。",
      "en": "When a new unique element is found (`nums[j] != nums[i]`), we need to first advance the slow pointer `i` by one step to make space, and then write the new value `nums[j]` into `nums[i]`.",
      "wg": [
        {
          "t": "騰出位置",
          "en": "make space",
          "ps": "VP"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "easy",
    "keywords": "Two Pointers, Array, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [-4, -1, 0, 3, 10]\nOutput: [0, 1, 9, 16, 100]",
    "question": [
      {
        "t": "給定一個按非遞減順序排序的整數陣列，返回每個數字的平方組成的新陣列，且新陣列也需按非遞減順序排序。",
        "en": "Given an integer array sorted in non-decreasing order, return an array of the squares of each number, also sorted in non-decreasing order.",
        "wg": [
          {
            "t": "平方",
            "en": "squares",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用雙指標法來解決此問題（避免直接排序帶來的 O(n log n)），指標應如何放置與移動？",
        "en": "If using the two-pointer method to solve this problem (avoiding the O(n log n) from direct sorting), how should the pointers be placed and moved?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 兩個指標都從中間（0 的位置）開始，向兩邊擴散。",
        "en": "(A) Start both pointers from the middle (where 0 is) and expand outwards.",
        "wg": [
          {
            "t": "擴散",
            "en": "expand",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 一個指標在起點，一個指標在終點。比較兩者絕對值的大小，將較大平方值放入結果陣列的末端，並移動相應指標。",
        "en": "(B) One pointer at the start, one at the end. Compare the absolute values; place the larger square at the end of the result array and move the corresponding pointer.",
        "wg": [
          {
            "t": "絕對值",
            "en": "absolute value",
            "ps": "NP"
          },
          {
            "t": "末端",
            "en": "end",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 一個指標在起點，一個指標在終點。比較兩者絕對值的大小，將較小平方值放入結果陣列的開頭。",
        "en": "(C) One pointer at the start, one at the end. Compare the absolute values; place the smaller square at the beginning of the result array.",
        "wg": []
      },
      {
        "t": "(D) 雙指標法不適用於此題，必須先平方後再使用快速排序。",
        "en": "(D) The two-pointer method is not applicable here; you must square first and then use Quick Sort.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為原陣列已排序，平方後的最大值一定出現在陣列的最左端（負數）或最右端（正數）。透過比較兩端，我們可以從後往前填充結果陣列，達到 O(n) 時間複雜度。",
      "en": "Since the original array is sorted, the largest squared values must appear at the far left (negatives) or far right (positives). By comparing the ends, we can fill the result array from back to front, achieving O(n) time complexity.",
      "wg": [
        {
          "t": "填充",
          "en": "fill",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Linked List, Cycle Detection, Fast and Slow Pointers, Floyd's Cycle-Finding Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理連結串列（Linked List）的題目時，若需要檢測是否存在環（Cycle），且限制空間複雜度為 O(1)。",
        "en": "When dealing with Linked List problems, if you need to detect the existence of a cycle with a space complexity constraint of O(1).",
        "wg": [
          {
            "t": "連結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          },
          {
            "t": "空間複雜度",
            "en": "Space Complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種雙指標策略最為合適？",
        "en": "Which of the following Two Pointers strategies is most appropriate?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          },
          {
            "t": "合適",
            "en": "appropriate",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 左右指標：一個指標從頭開始，另一個從尾端開始，向中間移動。",
        "en": "(A) Left-Right Pointers: One pointer starts from the head, the other from the tail, moving towards the center.",
        "wg": []
      },
      {
        "t": "(B) 快慢指標：兩個指標皆從頭開始，慢指標每次走一步，快指標每次走兩步。",
        "en": "(B) Fast and Slow Pointers: Both pointers start from the head; the slow pointer moves one step at a time, and the fast pointer moves two steps.",
        "wg": [
          {
            "t": "快慢指標",
            "en": "Fast and Slow Pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 滑動視窗：維護一個固定大小的區間，同時移動左右邊界。",
        "en": "(C) Sliding Window: Maintain a fixed-size interval while moving both left and right boundaries.",
        "wg": [
          {
            "t": "滑動視窗",
            "en": "Sliding Window",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 合併指標：將兩個連結串列進行排序後再進行遍歷。",
        "en": "(D) Merge Pointers: Sort the two linked lists and then traverse them.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是經典的 Floyd 判圈演算法（龜兔賽跑演算法）。若串列中有環，快指標最終會追上慢指標；若無環，快指標會先抵達終點 (null)。此方法不需要額外的儲存空間 (O(1))。",
      "en": "This is the classic Floyd's Cycle-Finding Algorithm (Tortoise and Hare). If there is a cycle, the fast pointer will eventually catch up to the slow pointer; if not, the fast pointer will reach the end (null) first. This method requires no extra storage space (O(1)).",
      "wg": [
        {
          "t": "判圈演算法",
          "en": "Cycle-Finding Algorithm",
          "ps": "N"
        },
        {
          "t": "追上",
          "en": "catch up",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Array, In-place, Remove Duplicates, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}",
    "question": [
      {
        "t": "給定一個「已排序」的陣列，我們希望原地（In-place）移除重複的元素，並回傳新的長度。",
        "en": "Given a 'sorted' array, we want to remove duplicate elements in-place and return the new length.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          },
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          }
        ]
      },
      {
        "t": "參考上方程式碼片段，關於變數 `i` 與 `j` 的角色，下列敘述何者正確？",
        "en": "Referring to the code snippet above, which of the following statements about the roles of variables `i` and `j` is correct?",
        "wg": [
          {
            "t": "變數",
            "en": "variable",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `i` 是快指標用於遍歷陣列，`j` 是慢指標用於標記不重複元素的位置。",
        "en": "(A) `i` is the fast pointer used to traverse the array, and `j` is the slow pointer used to mark the position of unique elements.",
        "wg": []
      },
      {
        "t": "(B) `j` 是快指標用於掃描新元素，`i` 是慢指標維護目前唯一元素的邊界。",
        "en": "(B) `j` is the fast pointer used to scan for new elements, and `i` is the slow pointer maintaining the boundary of current unique elements.",
        "wg": [
          {
            "t": "掃描",
            "en": "scan",
            "ps": "V"
          },
          {
            "t": "邊界",
            "en": "boundary",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) `i` 與 `j` 分別從陣列的頭尾出發，向中間移動以交換元素。",
        "en": "(C) `i` and `j` start from the head and tail of the array respectively, moving towards the center to swap elements.",
        "wg": []
      },
      {
        "t": "(D) 此演算法的時間複雜度為 O(N^2)，因為涉及元素搬移。",
        "en": "(D) The time complexity of this algorithm is O(N^2) because it involves moving elements.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在此模式中，`j` (快指標) 負責尋找下一個不同的數值，而 `i` (慢指標) 始終指向「已處理好的不重複序列」的最後一個位置。當發現新數值時，將其複製到 `i+1` 的位置。",
      "en": "In this pattern, `j` (fast pointer) is responsible for finding the next distinct value, while `i` (slow pointer) always points to the last position of the 'processed unique sequence'. When a new value is found, it is copied to the `i+1` position.",
      "wg": [
        {
          "t": "序列",
          "en": "sequence",
          "ps": "N"
        },
        {
          "t": "複製",
          "en": "copy",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Array, Greedy, Container With Most Water, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「盛最多水的容器 (Container With Most Water)」問題中，我們使用雙指標從陣列兩端向內移動。",
        "en": "In the 'Container With Most Water' problem, we use two pointers moving inward from both ends of the array.",
        "wg": [
          {
            "t": "容器",
            "en": "container",
            "ps": "N"
          },
          {
            "t": "向內",
            "en": "inward",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "每一次移動指標的決策邏輯應該是甚麼？",
        "en": "What should be the decision logic for moving the pointers at each step?",
        "wg": [
          {
            "t": "決策",
            "en": "decision",
            "ps": "N"
          },
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是移動高度較高的那一邊，希望能找到更高的邊。",
        "en": "(A) Always move the side with the greater height, hoping to find an even taller edge.",
        "wg": []
      },
      {
        "t": "(B) 總是移動高度較低的那一邊，因為容器的高度受限於短邊。",
        "en": "(B) Always move the side with the lower height, because the container's height is limited by the shorter edge.",
        "wg": [
          {
            "t": "受限於",
            "en": "limited by",
            "ps": "Phr"
          }
        ]
      },
      {
        "t": "(C) 同時移動兩邊，直到相遇。",
        "en": "(C) Move both sides simultaneously until they meet.",
        "wg": []
      },
      {
        "t": "(D) 隨機選擇一邊移動。",
        "en": "(D) Randomly choose a side to move.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "容器的面積由 `寬度 * 短邊高度` 決定。若移動長邊，寬度變小且高度受限於原本的短邊，面積一定變小；唯有移動短邊，才有可能找到更高的邊來增加面積。這是貪婪演算法與雙指標的結合。",
      "en": "The area of the container is determined by `width * shorter edge height`. If you move the longer edge, the width decreases and the height remains limited by the original shorter edge, so the area definitely decreases. Only by moving the shorter edge is it possible to find a taller edge to increase the area. This is a combination of Greedy Algorithm and Two Pointers.",
      "wg": [
        {
          "t": "貪婪演算法",
          "en": "Greedy Algorithm",
          "ps": "N"
        },
        {
          "t": "結合",
          "en": "combination",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Array, 3Sum, Sorting, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於 3Sum (三數之和) 問題：在陣列中找出所有不重複的三元組，使其總和為 0。",
        "en": "Regarding the 3Sum problem: Find all unique triplets in the array such that their sum is 0.",
        "wg": [
          {
            "t": "三元組",
            "en": "triplet",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼通常建議先將陣列「排序 (Sort)」，再使用雙指標解題？",
        "en": "Why is it usually recommended to 'Sort' the array first before using Two Pointers to solve it?",
        "wg": [
          {
            "t": "建議",
            "en": "recommend",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 排序是為了讓時間複雜度降到 O(N)。",
        "en": "(A) Sorting is done to reduce the time complexity to O(N).",
        "wg": []
      },
      {
        "t": "(B) 排序後可以固定一個數，剩下的問題轉化為有序陣列的 2Sum 問題，且容易跳過重複元素。",
        "en": "(B) After sorting, one number can be fixed, transforming the remaining problem into a 2Sum problem on a sorted array, and it makes skipping duplicates easier.",
        "wg": [
          {
            "t": "轉化",
            "en": "transform",
            "ps": "V"
          },
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 排序是為了使用二分搜尋法 (Binary Search) 來找第三個數。",
        "en": "(C) Sorting is done to use Binary Search to find the third number.",
        "wg": []
      },
      {
        "t": "(D) 排序只是為了輸出美觀，對演算法邏輯無影響。",
        "en": "(D) Sorting is just for aesthetic output and has no effect on the algorithm logic.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "3Sum 的標準解法是 O(N^2)。排序後，我們可以遍歷每一個數作為第一個數，然後用雙指標 (Left, Right) 在剩餘區間尋找另外兩個數。排序最大的好處是可以簡單地透過 `nums[i] == nums[i-1]` 來去重。",
      "en": "The standard solution for 3Sum is O(N^2). After sorting, we can iterate through each number as the first number, and then use two pointers (Left, Right) to find the other two numbers in the remaining interval. The biggest advantage of sorting is that duplicates can be easily removed by checking `nums[i] == nums[i-1]`.",
      "wg": [
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        },
        {
          "t": "去重",
          "en": "deduplicate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "easy",
    "keywords": "Array, Merge Sorted Array, Two Pointers, Backward Iteration",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個已排序陣列 A 與 B，其中 A 有足夠的緩衝空間容納 B。",
        "en": "Given two sorted arrays A and B, where A has enough buffer space to accommodate B.",
        "wg": [
          {
            "t": "緩衝空間",
            "en": "buffer space",
            "ps": "N"
          },
          {
            "t": "容納",
            "en": "accommodate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要將 B 合併入 A 並保持排序，最佳的雙指標操作方向為何？",
        "en": "To merge B into A while maintaining the sort order, what is the optimal direction for the two-pointer operation?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "操作",
            "en": "operation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從前往後：比較 A 與 B 的開頭元素，將較小者放入 A 的前端。",
        "en": "(A) Front-to-back: Compare the starting elements of A and B, placing the smaller one at the front of A.",
        "wg": []
      },
      {
        "t": "(B) 從後往前：比較 A 與 B 的有效尾端元素，將較大者填入 A 的最尾端緩衝區。",
        "en": "(B) Back-to-front: Compare the effective tail elements of A and B, placing the larger one into the very end of A's buffer.",
        "wg": [
          {
            "t": "有效",
            "en": "effective",
            "ps": "Adj"
          },
          {
            "t": "尾端",
            "en": "tail/end",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 先將 B 複製到 A 的尾端，再使用快速排序 (Quick Sort)。",
        "en": "(C) First copy B to the end of A, then use Quick Sort.",
        "wg": []
      },
      {
        "t": "(D) 建立一個新的陣列 C，合併完後再複製回 A。",
        "en": "(D) Create a new array C, merge into it, and then copy back to A.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "從前往後合併會導致 A 陣列中的元素需要不斷向後移動 (Shift)，造成 O(N*M) 的複雜度。從後往前填入則可以直接利用 A 尾端的空位，無需移動現有元素，時間複雜度為 O(N+M)。",
      "en": "Merging from front to back would require constant shifting of elements in array A, resulting in O(N*M) complexity. Filling from back to front allows direct use of the empty space at the end of A without moving existing elements, resulting in O(N+M) time complexity.",
      "wg": [
        {
          "t": "不斷",
          "en": "constantly",
          "ps": "Adv"
        },
        {
          "t": "空位",
          "en": "empty space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "Medium",
    "keywords": "Linked List, Cycle Detection, Floyd's Algorithm, Fast and Slow Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode *slow = head, *fast = head;\nwhile (fast && fast->next) {\n    slow = slow->next;\n    fast = fast->next->next;\n    if (slow == fast) break;\n}",
    "question": [
      {
        "t": "在使用快慢指標演算法檢測連結串列（Linked List）中的環時，假設快指標與慢指標在環中相遇。",
        "en": "When using the Fast and Slow Pointers algorithm to detect a cycle in a Linked List, assume the fast and slow pointers meet inside the cycle.",
        "wg": [
          {
            "t": "連結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          },
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了找到環的「起始節點」，接下來應該採取什麼步驟？",
        "en": "To find the 'starting node' of the cycle, what step should be taken next?",
        "wg": [
          {
            "t": "起始節點",
            "en": "starting node",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將慢指標移回頭部，快指標保持在相遇點，兩者每次移動一步直到再次相遇。",
        "en": "(A) Move the slow pointer back to the head, keep the fast pointer at the meeting point, and move both one step at a time until they meet again.",
        "wg": [
          {
            "t": "頭部",
            "en": "head",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將快指標移回頭部，慢指標保持在相遇點，快指標每次移動兩步，慢指標移動一步。",
        "en": "(B) Move the fast pointer back to the head, keep the slow pointer at the meeting point, move the fast pointer two steps and the slow pointer one step at a time.",
        "wg": []
      },
      {
        "t": "(C) 從相遇點開始，計算環的長度，然後從頭部重新遍歷。",
        "en": "(C) Calculate the length of the cycle starting from the meeting point, then traverse from the head again.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 直接返回目前的相遇點，即為環的起始點。",
        "en": "(D) Directly return the current meeting point as it is the start of the cycle.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "根據數學推導，當快慢指標相遇時，若將其中一個指標移回起點，另一個留在相遇點，兩者以相同速度移動，它們必將在環的入口處相遇。",
      "en": "According to mathematical derivation, when the fast and slow pointers meet, if one pointer is moved back to the start and the other stays at the meeting point, moving both at the same speed ensures they will meet at the entry of the cycle.",
      "wg": [
        {
          "t": "推導",
          "en": "derivation",
          "ps": "N"
        },
        {
          "t": "入口",
          "en": "entry",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "Medium",
    "keywords": "Array, Two Pointers, Greedy, Container With Most Water",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (left < right) {\n    int currentArea = min(height[left], height[right]) * (right - left);\n    maxArea = max(maxArea, currentArea);\n    // Missing Logic Here\n}",
    "question": [
      {
        "t": "在「盛最多水的容器」（Container With Most Water）問題中，我們使用雙指標從陣列兩端向中間移動。",
        "en": "In the 'Container With Most Water' problem, we use two pointers moving from both ends of the array towards the center.",
        "wg": [
          {
            "t": "盛最多水的容器",
            "en": "Container With Most Water",
            "ps": "Proper Noun"
          },
          {
            "t": "兩端",
            "en": "both ends",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了確保能找到最大面積，移動指標的正確策略是什麼？",
        "en": "To ensure finding the maximum area, what is the correct strategy for moving the pointers?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是移動高度較低的那一邊的指標。",
        "en": "(A) Always move the pointer on the side with the lower height.",
        "wg": [
          {
            "t": "高度",
            "en": "height",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 總是移動高度較高的那一邊的指標。",
        "en": "(B) Always move the pointer on the side with the higher height.",
        "wg": []
      },
      {
        "t": "(C) 同時向內移動兩個指標。",
        "en": "(C) Move both pointers inward simultaneously.",
        "wg": [
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 如果高度相同，則停止移動並返回結果。",
        "en": "(D) If heights are equal, stop moving and return the result.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "容器的面積由較短的邊決定。若移動較高的邊，寬度變小且高度受限於短邊，面積不可能增加；只有移動短邊才有可能找到更高的邊來彌補寬度的損失。",
      "en": "The area of the container is determined by the shorter side. If you move the taller side, the width decreases and the height is limited by the short side, so the area cannot increase; only by moving the short side is it possible to find a taller edge to compensate for the loss in width.",
      "wg": [
        {
          "t": "受限於",
          "en": "limited by",
          "ps": "V"
        },
        {
          "t": "彌補",
          "en": "compensate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "Medium",
    "keywords": "Sliding Window, Subarray, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「長度最小的子陣列總和」（Minimum Size Subarray Sum）問題時，我們使用滑動視窗（Sliding Window）技巧。",
        "en": "When solving the 'Minimum Size Subarray Sum' problem, we use the Sliding Window technique.",
        "wg": [
          {
            "t": "子陣列",
            "en": "subarray",
            "ps": "N"
          },
          {
            "t": "滑動視窗",
            "en": "Sliding Window",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當視窗內的元素總和「大於或等於」目標值時，下一步應該如何操作視窗？",
        "en": "When the sum of elements inside the window is 'greater than or equal to' the target value, how should the window be manipulated next?",
        "wg": [
          {
            "t": "大於或等於",
            "en": "greater than or equal to",
            "ps": "Phrase"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 擴大視窗右邊界（Right Pointer），繼續尋找更多元素。",
        "en": "(A) Expand the right boundary (Right Pointer) to look for more elements.",
        "wg": [
          {
            "t": "邊界",
            "en": "boundary",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 收縮視窗左邊界（Left Pointer），嘗試縮短長度並更新最小長度紀錄。",
        "en": "(B) Shrink the left boundary (Left Pointer) to try to shorten the length and update the minimum length record.",
        "wg": [
          {
            "t": "收縮",
            "en": "shrink",
            "ps": "V"
          },
          {
            "t": "更新",
            "en": "update",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 重置視窗，將左指標移至右指標的位置。",
        "en": "(C) Reset the window by moving the left pointer to the position of the right pointer.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 停止演算法，因為已經找到一組解。",
        "en": "(D) Stop the algorithm because a solution has been found.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當總和滿足條件時，我們希望找到「更短」的子陣列，因此應嘗試移除左邊的元素（收縮視窗），直到總和小於目標值為止。",
      "en": "When the sum meets the condition, we want to find a 'shorter' subarray, so we should try to remove elements from the left (shrink the window) until the sum is less than the target value.",
      "wg": [
        {
          "t": "滿足條件",
          "en": "meet the condition",
          "ps": "Phrase"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "Medium",
    "keywords": "3Sum, Sorting, Duplicate Handling, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (sum == 0) {\n    res.push_back({nums[i], nums[left], nums[right]});\n    // What comes next to avoid duplicates?\n}",
    "question": [
      {
        "t": "在解決 3Sum 問題（找出陣列中三個數相加為 0 的所有組合）時，陣列已經經過排序。",
        "en": "When solving the 3Sum problem (finding all unique triplets in an array that sum to 0), the array is already sorted.",
        "wg": [
          {
            "t": "組合",
            "en": "combination/triplet",
            "ps": "N"
          },
          {
            "t": "排序",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "當找到一組符合條件的解 `(nums[i], nums[left], nums[right])` 後，為了避免重複的組合，必須執行什麼操作？",
        "en": "After finding a valid solution `(nums[i], nums[left], nums[right])`, what operation must be performed to avoid duplicate triplets?",
        "wg": [
          {
            "t": "符合條件",
            "en": "valid / satisfying condition",
            "ps": "Adj"
          },
          {
            "t": "避免",
            "en": "avoid",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 僅將 `left` 指標向右移動一步。",
        "en": "(A) Only move the `left` pointer one step to the right.",
        "wg": []
      },
      {
        "t": "(B) 僅將 `right` 指標向左移動一步。",
        "en": "(B) Only move the `right` pointer one step to the left.",
        "wg": []
      },
      {
        "t": "(C) 移動 `left` 和 `right`，並跳過所有與當前數值相同的元素。",
        "en": "(C) Move both `left` and `right`, and skip all elements that are identical to the current values.",
        "wg": [
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          },
          {
            "t": "數值",
            "en": "value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 直接結束內層迴圈，換下一個 `i`。",
        "en": "(D) Directly terminate the inner loop and move to the next `i`.",
        "wg": [
          {
            "t": "內層迴圈",
            "en": "inner loop",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為陣列已排序，相同的數值會相鄰。若不跳過重複的數值，會產生重複的解答組合（例如 `[-1, -1, 2]` 可能被計算兩次）。",
      "en": "Since the array is sorted, identical values are adjacent. If duplicate values are not skipped, duplicate solution triplets will be generated (e.g., `[-1, -1, 2]` might be counted twice).",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "Medium",
    "keywords": "Dutch National Flag Problem, Three Pointers, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (mid <= high) {\n    if (nums[mid] == 2) {\n        swap(nums[mid], nums[high]);\n        high--;\n        // Note: mid is NOT incremented here\n    }\n}",
    "question": [
      {
        "t": "在「顏色分類」（Sort Colors / Dutch National Flag）問題中，我們使用三個指標 `low`、`mid` 和 `high` 來將陣列分為 0, 1, 2 三區。",
        "en": "In the 'Sort Colors' (Dutch National Flag) problem, we use three pointers `low`, `mid`, and `high` to partition the array into three sections: 0, 1, and 2.",
        "wg": [
          {
            "t": "顏色分類",
            "en": "Sort Colors",
            "ps": "Proper Noun"
          },
          {
            "t": "區",
            "en": "section/region",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 `nums[mid]` 的值為 2 時，我們會將其與 `nums[high]` 交換並將 `high` 減 1。",
        "en": "When the value of `nums[mid]` is 2, we swap it with `nums[high]` and decrement `high`.",
        "wg": [
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為什麼交換後**不能**立即增加 `mid` 指標？",
        "en": "Why must we **not** immediately increment the `mid` pointer after the swap?",
        "wg": [
          {
            "t": "立即",
            "en": "immediately",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為交換回來的數字可能是 0 或 1，需要再次由 `mid` 進行判斷。",
        "en": "(A) Because the number swapped back could be 0 or 1, it needs to be evaluated by `mid` again.",
        "wg": [
          {
            "t": "判斷",
            "en": "evaluate/check",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 因為 `high` 指標尚未確認該位置是否正確。",
        "en": "(B) Because the `high` pointer has not yet confirmed if that position is correct.",
        "wg": []
      },
      {
        "t": "(C) 這是為了防止陣列越界錯誤（Index Out of Bounds）。",
        "en": "(C) This is to prevent an Index Out of Bounds error.",
        "wg": [
          {
            "t": "越界",
            "en": "out of bounds",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 實際上應該要增加 `mid`，題目描述的邏輯是錯的。",
        "en": "(D) Actually, `mid` should be incremented; the logic described in the question is incorrect.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "`mid` 指標負責掃描未知區域。從 `high` 交換回來的元素是未經檢查的（可能是 0，應該被換到前面；也可能是 1），因此 `mid` 必須停留在原地再次檢查該數值。",
      "en": "The `mid` pointer is responsible for scanning the unknown region. The element swapped back from `high` is unchecked (it could be 0, which should be moved to the front, or 1), so `mid` must stay in place to check that value again.",
      "wg": [
        {
          "t": "未知區域",
          "en": "unknown region",
          "ps": "N"
        },
        {
          "t": "未經檢查",
          "en": "unchecked",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Linked List, Cycle Detection, Floyd's Algorithm, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在使用快慢指針 (Floyd's Cycle-Finding Algorithm) 偵測鏈結串列 (Linked List) 是否有環時，",
        "en": "When using Fast and Slow Pointers (Floyd's Cycle-Finding Algorithm) to detect if a Linked List has a cycle,",
        "wg": [
          {
            "t": "快慢指針",
            "en": "Fast and Slow Pointers",
            "ps": "N"
          },
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若快指針與慢指針在環中相遇，我們該如何找到環的起始節點 (Entry Point)？",
        "en": "If the fast pointer and slow pointer meet inside the cycle, how do we find the entry point of the cycle?",
        "wg": [
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          },
          {
            "t": "起始節點",
            "en": "entry point",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將慢指針移回鏈結串列的頭部，快指針保持在相遇點，兩者皆以每次一步的速度移動，再次相遇點即為起點。",
        "en": "(A) Move the slow pointer back to the head of the linked list, keep the fast pointer at the meeting point, move both one step at a time; the point where they meet again is the entry point.",
        "wg": [
          {
            "t": "頭部",
            "en": "head",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將快指針移回鏈結串列的頭部，慢指針保持在相遇點，快指針每次走兩步，慢指針走一步。",
        "en": "(B) Move the fast pointer back to the head of the linked list, keep the slow pointer at the meeting point, move the fast pointer two steps and the slow pointer one step at a time.",
        "wg": []
      },
      {
        "t": "(C) 直接計算相遇點到頭部的距離，該距離即為環的長度。",
        "en": "(C) Directly calculate the distance from the meeting point to the head; this distance is the length of the cycle.",
        "wg": []
      },
      {
        "t": "(D) 快慢指針相遇的位置必定就是環的起始節點。",
        "en": "(D) The position where the fast and slow pointers meet is necessarily the entry point of the cycle.",
        "wg": [
          {
            "t": "必定",
            "en": "necessarily",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "根據數學推導，當快慢指針相遇時，將其中一個指針移回起點，另一個保留在相遇點，兩者以相同速度移動，必會在環的入口處相遇。",
      "en": "According to mathematical derivation, when the fast and slow pointers meet, moving one pointer back to the start and keeping the other at the meeting point, then moving both at the same speed, ensures they will meet at the cycle's entry point.",
      "wg": [
        {
          "t": "數學推導",
          "en": "mathematical derivation",
          "ps": "N"
        },
        {
          "t": "入口處",
          "en": "entry point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Array, 3Sum, Sorting, Deduplication",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums.sort()",
    "question": [
      {
        "t": "在解決「三數之和 (3Sum)」問題時，通常會先將陣列進行排序。",
        "en": "When solving the '3Sum' problem, the array is usually sorted first.",
        "wg": [
          {
            "t": "三數之和",
            "en": "3Sum",
            "ps": "N"
          },
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "除了方便使用雙指針逼近目標值外，排序對於處理結果集有什麼關鍵作用？",
        "en": "Besides facilitating the use of two pointers to approach the target value, what is the key role of sorting in handling the result set?",
        "wg": [
          {
            "t": "逼近",
            "en": "approach",
            "ps": "V"
          },
          {
            "t": "結果集",
            "en": "result set",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 排序後可以將時間複雜度降低至 O(n)。",
        "en": "(A) Sorting can reduce the time complexity to O(n).",
        "wg": []
      },
      {
        "t": "(B) 排序後能更容易地跳過重複元素，避免產出重複的三元組。",
        "en": "(B) Sorting makes it easier to skip duplicate elements, avoiding the generation of duplicate triplets.",
        "wg": [
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          },
          {
            "t": "三元組",
            "en": "triplets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 排序是為了使用雜湊表 (Hash Map) 來儲存索引。",
        "en": "(C) Sorting is for using a Hash Map to store indices.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 排序是為了確保陣列中沒有負數。",
        "en": "(D) Sorting is to ensure there are no negative numbers in the array.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在排序後的陣列中，相同的數值會相鄰排列，這使得在遍歷及移動指針時，可以輕易判斷並跳過重複的值，從而確保解的唯一性。",
      "en": "In a sorted array, identical values are arranged adjacently, which allows for easy detection and skipping of duplicate values during traversal and pointer movement, thereby ensuring the uniqueness of the solution.",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        },
        {
          "t": "遍歷",
          "en": "traversal",
          "ps": "N"
        },
        {
          "t": "唯一性",
          "en": "uniqueness",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Two Pointers, Trapping Rain Water, Greedy Strategy",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while left < right:\n  if height[left] < height[right]:\n    ...",
    "question": [
      {
        "t": "在「接雨水 (Trapping Rain Water)」問題的雙指針解法中，我們維護左右兩端的最大高度 (`left_max`, `right_max`)。",
        "en": "In the two-pointer solution for the 'Trapping Rain Water' problem, we maintain the maximum heights at both ends (`left_max`, `right_max`).",
        "wg": [
          {
            "t": "接雨水",
            "en": "Trapping Rain Water",
            "ps": "N"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為什麼在移動指針時，總是優先移動高度較低的那一側？",
        "en": "Why do we always prioritize moving the pointer on the side with the lower height?",
        "wg": [
          {
            "t": "優先",
            "en": "prioritize",
            "ps": "V"
          },
          {
            "t": "側",
            "en": "side",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為該位置的蓄水量是由較低的一邊決定的，移動較低邊可以安全地計算該位置的蓄水量。",
        "en": "(A) Because the water capacity at that position is determined by the lower side, moving the lower side allows for safely calculating the water capacity at that position.",
        "wg": [
          {
            "t": "蓄水量",
            "en": "water capacity",
            "ps": "N"
          },
          {
            "t": "決定",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 因為移動較高的一側會導致 `left_max` 或 `right_max` 更新錯誤。",
        "en": "(B) Because moving the higher side would cause `left_max` or `right_max` to update incorrectly.",
        "wg": []
      },
      {
        "t": "(C) 這是為了讓左右指針最終在陣列正中央相遇。",
        "en": "(C) This is to ensure the left and right pointers eventually meet in the exact center of the array.",
        "wg": []
      },
      {
        "t": "(D) 移動較低的一側是為了尋找更高的牆壁以結束迴圈。",
        "en": "(D) Moving the lower side is to find a higher wall to terminate the loop.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "根據木桶原理，水位高度受限於短板。當確定某一側較低時，該側的當前格子能接多少水，完全取決於該側的最高牆 (`left_max` 或 `right_max`)，而不受另一側更高牆的影響。",
      "en": "According to the bucket principle, the water level is limited by the shorter plank. When one side is determined to be lower, the amount of water the current cell on that side can hold depends entirely on that side's max wall (`left_max` or `right_max`), regardless of the higher wall on the other side.",
      "wg": [
        {
          "t": "木桶原理",
          "en": "bucket principle",
          "ps": "N"
        },
        {
          "t": "短板",
          "en": "shorter plank",
          "ps": "N"
        },
        {
          "t": "受限於",
          "en": "limited by",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Array, Merge, In-place, Backwards Iteration",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)",
    "question": [
      {
        "t": "給定兩個已排序陣列 `nums1` 和 `nums2`，其中 `nums1` 後端有足夠空間容納 `nums2`。",
        "en": "Given two sorted arrays `nums1` and `nums2`, where `nums1` has enough space at the end to accommodate `nums2`.",
        "wg": [
          {
            "t": "容納",
            "en": "accommodate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要將 `nums2` 合併入 `nums1` 並保持排序，為什麼使用雙指針從後往前填寫是最佳策略？",
        "en": "If you want to merge `nums2` into `nums1` while maintaining sort order, why is using two pointers to fill from the back the best strategy?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "從後往前",
            "en": "from the back",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從後往前填寫可以避免覆蓋 `nums1` 中尚未比較的有效元素，實現原地 (In-place) 操作。",
        "en": "(A) Filling from the back avoids overwriting valid elements in `nums1` that haven't been compared yet, achieving in-place operation.",
        "wg": [
          {
            "t": "覆蓋",
            "en": "overwrite",
            "ps": "V"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 從後往前填寫可以減少比較次數。",
        "en": "(B) Filling from the back reduces the number of comparisons.",
        "wg": []
      },
      {
        "t": "(C) 因為 `nums2` 的元素通常比 `nums1` 大。",
        "en": "(C) Because elements in `nums2` are usually larger than in `nums1`.",
        "wg": []
      },
      {
        "t": "(D) 這樣做可以避免使用額外的變數來儲存索引。",
        "en": "(D) This avoids using extra variables to store indices.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若從前往後合併，需要將 `nums1` 的元素向後移動以騰出空間，這會增加時間複雜度或需要額外空間。從後往前利用了 `nums1` 尾端的閒置空間，保證每個元素只被移動一次。",
      "en": "Merging from the front would require shifting elements in `nums1` backward to make space, increasing time complexity or requiring extra space. Merging from the back utilizes the empty space at the end of `nums1`, ensuring each element is moved only once.",
      "wg": [
        {
          "t": "騰出空間",
          "en": "make space",
          "ps": "V"
        },
        {
          "t": "閒置空間",
          "en": "empty space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Sliding Window, Substring, Constraint",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「滑動視窗 (Sliding Window)」問題中，例如「尋找最多包含 K 個不同字元的最長子字串」。",
        "en": "In 'Sliding Window' problems, such as 'Find the longest substring with at most K distinct characters'.",
        "wg": [
          {
            "t": "滑動視窗",
            "en": "Sliding Window",
            "ps": "N"
          },
          {
            "t": "子字串",
            "en": "substring",
            "ps": "N"
          },
          {
            "t": "不同字元",
            "en": "distinct characters",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們通常移動右指針來擴大視窗，那麼在什麼條件下需要移動左指針來縮小視窗？",
        "en": "We usually move the right pointer to expand the window, so under what condition do we need to move the left pointer to shrink the window?",
        "wg": [
          {
            "t": "擴大",
            "en": "expand",
            "ps": "V"
          },
          {
            "t": "縮小",
            "en": "shrink",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當視窗內的字元數量小於 K 時。",
        "en": "(A) When the number of characters in the window is less than K.",
        "wg": []
      },
      {
        "t": "(B) 當視窗內的「不同字元數量」超過 K 時，這表示當前視窗已不符合題目限制。",
        "en": "(B) When the number of 'distinct characters' in the window exceeds K, indicating the current window no longer meets the problem constraints.",
        "wg": [
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          },
          {
            "t": "超過",
            "en": "exceed",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 當右指針到達字串末端時，必須開始移動左指針。",
        "en": "(C) When the right pointer reaches the end of the string, the left pointer must start moving.",
        "wg": []
      },
      {
        "t": "(D) 每次右指針移動一步，左指針也必須跟著移動一步。",
        "en": "(D) Every time the right pointer moves one step, the left pointer must also move one step.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "滑動視窗的核心邏輯是：右指針負責尋找可行解的邊界，當視窗狀態違反限制條件（如不同字元數 > K）時，左指針必須移動以移除元素，直到視窗再次符合條件。",
      "en": "The core logic of the sliding window is: the right pointer seeks the boundary of a feasible solution. When the window state violates constraints (e.g., distinct char count > K), the left pointer must move to remove elements until the window becomes valid again.",
      "wg": [
        {
          "t": "核心邏輯",
          "en": "core logic",
          "ps": "N"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        },
        {
          "t": "可行解",
          "en": "feasible solution",
          "ps": "N"
        }
      ]
    }
  }
]