[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Two Pointers, Linked List, Cycle Detection, Floyd's Cycle-Finding Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) return true;\n}",
    "question": [
      {
        "t": "在鏈結串列 (Linked List) 中偵測是否存在環 (Cycle) 時，通常使用快慢指針 (Fast & Slow Pointers) 演算法。",
        "en": "When detecting if a cycle exists in a Linked List, the Fast & Slow Pointers algorithm is commonly used.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          },
          {
            "t": "偵測",
            "en": "detect",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若快指針每次移動 2 步，慢指針每次移動 1 步，請問為什麼這個方法能保證兩者一定會在環內相遇，而不會永遠錯過？",
        "en": "If the fast pointer moves 2 steps at a time and the slow pointer moves 1 step, why does this method guarantee that they will meet inside the cycle and not miss each other forever?",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          },
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          },
          {
            "t": "錯過",
            "en": "miss",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為快指針的速度是慢指針的兩倍，所以一定會在環的起點相遇。",
        "en": "(A) Because the fast pointer is twice as fast as the slow pointer, they will definitely meet at the start of the cycle.",
        "wg": []
      },
      {
        "t": "(B) 因為兩者的相對速度為 1，這就像慢指針靜止，快指針以每次 1 步的速度縮短距離，最終必定重合。",
        "en": "(B) Because their relative speed is 1, it is as if the slow pointer is stationary while the fast pointer closes the gap by 1 step at a time, eventually coinciding.",
        "wg": [
          {
            "t": "相對速度",
            "en": "relative speed",
            "ps": "N"
          },
          {
            "t": "重合",
            "en": "coincide",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 這取決於環的長度，如果是奇數長度則會相遇，偶數長度則會永遠錯過。",
        "en": "(C) It depends on the length of the cycle; they will meet if the length is odd, but miss forever if it is even.",
        "wg": []
      },
      {
        "t": "(D) 只有當鏈結串列的總長度為質數時，兩者才會相遇。",
        "en": "(D) They will only meet if the total length of the linked list is a prime number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當兩指針都進入環中，快指針每次比慢指針多走一步（相對速度為 1）。這意味著快指針正在以每次一步的速度從後方追趕慢指針，無論兩者距離多遠，距離最終都會縮減為 0，因此必定相遇且不會跳過彼此。",
      "en": "Once both pointers are in the cycle, the fast pointer moves one step more than the slow pointer (relative speed of 1). This means the fast pointer is chasing the slow pointer from behind, closing the gap by one step at a time. Regardless of the distance, it will eventually reduce to 0, ensuring they meet without skipping each other.",
      "wg": [
        {
          "t": "追趕",
          "en": "chase",
          "ps": "V"
        },
        {
          "t": "縮減",
          "en": "reduce",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Two Pointers, Array, In-place, Remove Duplicates",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]",
    "question": [
      {
        "t": "給定一個「已排序」的整數陣列，您需要原地 (in-place) 刪除重複出現的元素，使得每個元素只出現一次，並返回新的長度。",
        "en": "Given a 'sorted' integer array, you need to remove the duplicates in-place such that each element appears only once and return the new length.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          },
          {
            "t": "重複",
            "en": "duplicate",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在使用雙指針技巧（一個讀取指針 `i`，一個寫入指針 `j`）時，下列哪種邏輯是正確的？",
        "en": "When using the two-pointer technique (one read pointer `i`, one write pointer `j`), which of the following logic is correct?",
        "wg": [
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當 `nums[i] == nums[j]` 時，移動寫入指針 `j`。",
        "en": "(A) When `nums[i] == nums[j]`, move the write pointer `j`.",
        "wg": []
      },
      {
        "t": "(B) 總是移動寫入指針 `j`，並將 `nums[i]` 複製到 `nums[j]`。",
        "en": "(B) Always move the write pointer `j` and copy `nums[i]` to `nums[j]`.",
        "wg": []
      },
      {
        "t": "(C) 當 `nums[i] != nums[j]` (或 `nums[i] != nums[i-1]`) 時，將 `nums[i]` 複製到 `j` 的下一個位置，並移動 `j`。",
        "en": "(C) When `nums[i] != nums[j]` (or `nums[i] != nums[i-1]`), copy `nums[i]` to the next position of `j`, and move `j`.",
        "wg": [
          {
            "t": "位置",
            "en": "position",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 需要使用額外的陣列來儲存不重複的數字，然後再複製回原陣列。",
        "en": "(D) Need to use an extra array to store unique numbers and then copy them back to the original array.",
        "wg": [
          {
            "t": "額外的",
            "en": "extra",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "由於陣列已排序，重複的元素必定相鄰。我們利用 `j` 指向當前「不重複序列」的最後一個位置。當讀取指針 `i` 發現一個與當前 `nums[j]` 不同的新值時，表示發現了下一個唯一元素，將其填入 `j+1` 並推進 `j`。",
      "en": "Since the array is sorted, duplicates are adjacent. We use `j` to point to the last position of the current 'unique sequence'. When the read pointer `i` finds a new value different from `nums[j]`, it indicates the next unique element is found, so we fill it into `j+1` and advance `j`.",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        },
        {
          "t": "唯一",
          "en": "unique",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Two Pointers, Greedy, Container With Most Water, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: height = [1,8,6,2,5,4,8,3,7]\n// Find two lines that form a container with the x-axis to hold the most water.",
    "question": [
      {
        "t": "在「盛最多水的容器 (Container With Most Water)」問題中，我們使用左右指針從陣列兩端向中間移動。",
        "en": "In the 'Container With Most Water' problem, we use left and right pointers moving from the ends of the array towards the center.",
        "wg": [
          {
            "t": "容器",
            "en": "container",
            "ps": "N"
          },
          {
            "t": "兩端",
            "en": "ends",
            "ps": "N"
          }
        ]
      },
      {
        "t": "每一次迭代中，決定移動哪一個指針的關鍵策略是什麼？",
        "en": "What is the key strategy for deciding which pointer to move in each iteration?",
        "wg": [
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是移動高度較高的那個指針，希望能找到更高的邊。",
        "en": "(A) Always move the pointer with the greater height, hoping to find a taller edge.",
        "wg": []
      },
      {
        "t": "(B) 總是移動高度較低的那個指針。",
        "en": "(B) Always move the pointer with the smaller height.",
        "wg": []
      },
      {
        "t": "(C) 同時移動兩個指針，直到它們相遇。",
        "en": "(C) Move both pointers simultaneously until they meet.",
        "wg": [
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 計算移動左邊或右邊後的預期面積，移動能產生較大面積的那一邊。",
        "en": "(D) Calculate the expected area after moving either left or right, and move the one that produces a larger area.",
        "wg": [
          {
            "t": "預期",
            "en": "expected",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "容器的面積由 `寬度 * 較短邊的高度` 決定。移動指針會使寬度減小，若移動「較高」的邊，高度受限於原本「較短」的那一邊，面積必定變小或不變；唯有移動「較短」的邊，才有可能找到更高的邊來彌補寬度的損失，進而獲得更大的面積。",
      "en": "The area of the container is determined by `width * height of the shorter side`. Moving a pointer decreases the width. If you move the 'taller' side, the height is still limited by the original 'shorter' side, so the area will definitely decrease or stay the same. Only by moving the 'shorter' side is it possible to find a taller edge to compensate for the loss in width and potentially gain a larger area.",
      "wg": [
        {
          "t": "受限於",
          "en": "limited by",
          "ps": "V"
        },
        {
          "t": "彌補",
          "en": "compensate",
          "ps": "V"
        },
        {
          "t": "損失",
          "en": "loss",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Two Pointers, Sorting, 3Sum, Deduplication",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [-1, 0, 1, 2, -1, -4]\n// Find all unique triplets [nums[i], nums[j], nums[k]] such that sum is 0.",
    "question": [
      {
        "t": "在解決 3Sum (三數之和) 問題時，通常會先將陣列排序，然後固定一個數字 `i`，再利用雙指針尋找另外兩個數字。",
        "en": "When solving the 3Sum problem, we usually sort the array first, fix one number `i`, and then use two pointers to find the other two numbers.",
        "wg": [
          {
            "t": "固定",
            "en": "fix",
            "ps": "V"
          },
          {
            "t": "尋找",
            "en": "find",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了避免產出重複的三元組 (Triplets)，在移動指針時需要特別注意什麼？",
        "en": "To avoid generating duplicate triplets, what should be paid special attention to when moving the pointers?",
        "wg": [
          {
            "t": "三元組",
            "en": "triplets",
            "ps": "N"
          },
          {
            "t": "避免",
            "en": "avoid",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "複選題",
    "options": [
      {
        "t": "(A) 在迭代固定數字 `i` 時，若 `nums[i] == nums[i-1]`，應跳過該次迭代。",
        "en": "(A) When iterating the fixed number `i`, if `nums[i] == nums[i-1]`, skip this iteration.",
        "wg": [
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 只要找到一組解，就立刻終止所有迴圈。",
        "en": "(B) Terminate all loops immediately once a solution is found.",
        "wg": [
          {
            "t": "終止",
            "en": "terminate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 當找到一組解後，移動左指針 `L` 和右指針 `R` 時，若遇到與前一個位置相同的數值，應繼續移動直到數值不同。",
        "en": "(C) After finding a solution, when moving the left pointer `L` and right pointer `R`, if the value is the same as the previous position, continue moving until the value is different.",
        "wg": []
      },
      {
        "t": "(D) 必須使用 `Set` 資料結構來儲存結果以去除重複，無法在指針移動時處理。",
        "en": "(D) Must use a `Set` data structure to store results for deduplication; it cannot be handled during pointer movement.",
        "wg": []
      }
    ],
    "answer": "(A), (C)",
    "why": {
      "t": "排序後相同的數字會相鄰。選項 (A) 確保了第一個數字不會重複選取相同的值；選項 (C) 確保了在固定第一個數字的情況下，後兩個數字的組合不會重複。這兩個步驟結合即可在過程中直接去重，無需額外的 Set。",
      "en": "After sorting, identical numbers are adjacent. Option (A) ensures that the first number does not repeatedly select the same value. Option (C) ensures that, with the first number fixed, the combination of the latter two numbers is not duplicated. Combining these two steps allows for deduplication directly during the process without needing an extra Set.",
      "wg": [
        {
          "t": "去重",
          "en": "deduplication",
          "ps": "N"
        },
        {
          "t": "組合",
          "en": "combination",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "easy",
    "keywords": "Two Pointers, Array, Squares of a Sorted Array, Merge Strategy",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]",
    "question": [
      {
        "t": "給定一個按「非遞減」順序排序的整數陣列（包含負數），要求返回每個數字的平方組成的新陣列，且新陣列也需按非遞減順序排序。",
        "en": "Given an integer array sorted in 'non-decreasing' order (including negatives), return a new array of the squares of each number, also sorted in non-decreasing order.",
        "wg": [
          {
            "t": "非遞減",
            "en": "non-decreasing",
            "ps": "Adj"
          },
          {
            "t": "平方",
            "en": "square",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼使用雙指針從陣列的「兩端向中間」處理是最佳解法？",
        "en": "Why is using two pointers processing from the 'ends towards the center' the optimal solution?",
        "wg": [
          {
            "t": "最佳",
            "en": "optimal",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為負數平方後會變大，陣列中絕對值最大的元素一定在最左邊或最右邊。",
        "en": "(A) Because squaring negatives makes them larger, the elements with the largest absolute values are definitely at the leftmost or rightmost ends.",
        "wg": [
          {
            "t": "絕對值",
            "en": "absolute value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 因為這樣可以原地修改陣列，不需要額外空間。",
        "en": "(B) Because this allows modifying the array in-place without needing extra space.",
        "wg": []
      },
      {
        "t": "(C) 因為中間的元素平方後通常最小，所以應該先處理中間。",
        "en": "(C) Because the middle elements usually have the smallest squares, so the middle should be processed first.",
        "wg": []
      },
      {
        "t": "(D) 這不是最佳解法，直接將所有數平方後再進行一次快速排序 (Quick Sort) 更快。",
        "en": "(D) This is not the optimal solution; simply squaring all numbers and then performing a Quick Sort is faster.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "原始陣列雖已排序，但包含負數。平方後，原本極小的負數（如 -10）會變成極大的正數（100）。因此，平方後的最大值必定出現在原陣列的兩端（最左或最右）。利用雙指針比較兩端絕對值大小，並從新陣列的尾部開始填充，可達到 O(n) 的時間複雜度，優於 O(n log n) 的排序法。",
      "en": "Although the original array is sorted, it contains negatives. After squaring, very small negatives (like -10) become very large positives (100). Therefore, the maximum squared values must appear at the ends (leftmost or rightmost) of the original array. Using two pointers to compare the absolute values at both ends and filling the new array from the back achieves O(n) time complexity, which is better than the O(n log n) of sorting.",
      "wg": [
        {
          "t": "填充",
          "en": "fill",
          "ps": "V"
        },
        {
          "t": "複雜度",
          "en": "complexity",
          "ps": "N"
        }
      ]
    }
  }
]