[
  {
    "no": "16",
    "level": "Medium",
    "keywords": "HashSet, Sequence, Time Complexity, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Set<Integer> numSet = new HashSet<>(nums);\nfor (int num : nums) {\n  if (!numSet.contains(num - 1)) {\n    // Start counting sequence...\n  }\n}",
    "question": [
      {
        "t": "在解決「最長連續序列」(Longest Consecutive Sequence) 問題時，為了達到 O(n) 的時間複雜度，我們通常會將陣列轉換為 HashSet。",
        "en": "When solving the 'Longest Consecutive Sequence' problem, we typically convert the array to a HashSet to achieve O(n) time complexity.",
        "wg": [
          {
            "t": "連續序列",
            "en": "consecutive sequence",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在迭代集合中的每個數字時，為什麼我們需要檢查 `num - 1` 是否存在於集合中？",
        "en": "When iterating through each number in the set, why do we need to check if `num - 1` exists in the set?",
        "wg": [
          {
            "t": "迭代",
            "en": "iterating",
            "ps": "V"
          },
          {
            "t": "存在",
            "en": "exists",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了確保我們只從序列的第一個數字開始計算長度，避免重複計算。",
        "en": "(A) To ensure we only start counting the length from the first number of a sequence, avoiding redundant calculations.",
        "wg": [
          {
            "t": "重複計算",
            "en": "redundant calculations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 為了檢查該數字是否為序列的最後一個數字。",
        "en": "(B) To check if the number is the last number of the sequence.",
        "wg": []
      },
      {
        "t": "(C) 這是為了處理陣列中的重複元素。",
        "en": "(C) This is to handle duplicate elements in the array.",
        "wg": []
      },
      {
        "t": "(D) 這是為了將 Hash Set 重新排序為 List。",
        "en": "(D) This is to resort the Hash Set into a List.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若 `num - 1` 存在，表示 `num` 並非序列的起點，我們應該跳過它以保持 O(n) 效率；只有當 `num` 是序列起點時，我們才開始向後尋找 `num + 1`。",
      "en": "If `num - 1` exists, it means `num` is not the start of the sequence, so we should skip it to maintain O(n) efficiency; we only start looking for `num + 1` when `num` is the start of a sequence.",
      "wg": [
        {
          "t": "起點",
          "en": "start/beginning",
          "ps": "N"
        },
        {
          "t": "效率",
          "en": "efficiency",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "Medium",
    "keywords": "Prefix Sum, HashMap, Subarray",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Map<Integer, Integer> map = new HashMap<>();\nmap.put(0, 1);\nint currentSum = 0;\nfor (int num : nums) { ... }",
    "question": [
      {
        "t": "在「和為 K 的子陣列」(Subarray Sum Equals K) 問題中，我們使用 HashMap 來儲存前綴和及其出現次數。",
        "en": "In the 'Subarray Sum Equals K' problem, we use a HashMap to store prefix sums and their frequencies.",
        "wg": [
          {
            "t": "前綴和",
            "en": "prefix sum",
            "ps": "N"
          },
          {
            "t": "出現次數",
            "en": "frequency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼在開始迭代之前，必須先執行 `map.put(0, 1)`？",
        "en": "Why must we execute `map.put(0, 1)` before starting the iteration?",
        "wg": [
          {
            "t": "執行",
            "en": "execute",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免 HashMap 在第一次查詢時拋出 NullPointerException。",
        "en": "(A) To prevent the HashMap from throwing a NullPointerException on the first query.",
        "wg": []
      },
      {
        "t": "(B) 為了處理那些「從索引 0 開始且總和剛好為 K」的子陣列。",
        "en": "(B) To handle subarrays that start at index 0 and sum exactly to K.",
        "wg": [
          {
            "t": "剛好",
            "en": "exactly",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 這是為了記錄陣列中數值為 0 的元素個數。",
        "en": "(C) This is to count the number of elements with value 0 in the array.",
        "wg": []
      },
      {
        "t": "(D) 這是 HashMap 的預設初始化語法，與演算法邏輯無關。",
        "en": "(D) This is the default initialization syntax for HashMap and is unrelated to the algorithm logic.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若子陣列從頭開始且和為 K，則 `currentSum - K` 會等於 0。若 map 中沒有 `(0, 1)`，我們將會漏算這些從頭開始的合法子陣列。",
      "en": "If a subarray starts from the beginning and sums to K, `currentSum - K` will be 0. If `(0, 1)` is not in the map, we will miss counting these valid subarrays starting from the beginning.",
      "wg": [
        {
          "t": "漏算",
          "en": "miss counting",
          "ps": "V"
        },
        {
          "t": "合法",
          "en": "valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "Medium",
    "keywords": "Array, Prefix Product, Suffix Product, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "針對題目「除自身以外陣列的乘積」(Product of Array Except Self)，題目要求在 O(n) 時間內完成且不能使用除法。",
        "en": "For the problem 'Product of Array Except Self', it requires O(n) time complexity and no division.",
        "wg": [
          {
            "t": "除法",
            "en": "division",
            "ps": "N"
          },
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要進一步將空間複雜度優化至 O(1)（不計輸出陣列），應採取什麼策略？",
        "en": "To further optimize space complexity to O(1) (excluding the output array), what strategy should be adopted?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用遞迴來計算乘積。",
        "en": "(A) Use recursion to calculate the products.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 先計算所有數字的總乘積，再對每個元素取倒數。",
        "en": "(B) Calculate the total product of all numbers first, then take the reciprocal for each element.",
        "wg": [
          {
            "t": "倒數",
            "en": "reciprocal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用兩層巢狀迴圈來計算每個位置的乘積。",
        "en": "(C) Use two nested loops to calculate the product for each position.",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 先利用輸出陣列儲存前綴乘積，再動態維護一個後綴乘積變數並反向更新陣列。",
        "en": "(D) Use the output array to store prefix products first, then maintain a running suffix product variable and update the array in reverse.",
        "wg": [
          {
            "t": "動態維護",
            "en": "maintain dynamically/running",
            "ps": "V"
          },
          {
            "t": "反向",
            "en": "reverse",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "透過重複利用輸出陣列來儲存前綴乘積，並在第二次遍歷時使用一個變數計算後綴乘積，我們省去了額外的陣列空間。",
      "en": "By reusing the output array to store prefix products and using a single variable for suffix products during a second pass, we save extra array space.",
      "wg": [
        {
          "t": "重複利用",
          "en": "reuse",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "traversal/pass",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "Medium",
    "keywords": "Bucket Sort, Frequency, Heap, Top K",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「前 K 個高頻元素」(Top K Frequent Elements) 時，若輸入陣列的大小為 N，我們希望演算法優於 O(N log N)。",
        "en": "When solving 'Top K Frequent Elements', if the input array size is N, we want an algorithm better than O(N log N).",
        "wg": [
          {
            "t": "高頻",
            "en": "frequent",
            "ps": "Adj"
          },
          {
            "t": "優於",
            "en": "better than",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "以下哪種方法可以達到 O(N) 的時間複雜度？",
        "en": "Which of the following methods can achieve O(N) time complexity?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對整個陣列進行快速排序 (Quick Sort)。",
        "en": "(A) Perform Quick Sort on the entire array.",
        "wg": []
      },
      {
        "t": "(B) 使用桶子排序 (Bucket Sort)，將頻率作為陣列索引，該頻率對應的數字列表作為值。",
        "en": "(B) Use Bucket Sort, using frequency as the array index and the list of numbers with that frequency as the value.",
        "wg": [
          {
            "t": "桶子排序",
            "en": "Bucket Sort",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用最大堆積 (Max Heap) 儲存所有元素的頻率並彈出 K 次。",
        "en": "(C) Use a Max Heap to store frequencies of all elements and pop K times.",
        "wg": [
          {
            "t": "堆積",
            "en": "heap",
            "ps": "N"
          },
          {
            "t": "彈出",
            "en": "pop",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 使用二元搜尋樹 (BST) 儲存頻率。",
        "en": "(D) Use a Binary Search Tree (BST) to store frequencies.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為頻率的最大值不會超過陣列長度 N，我們可以建立一個大小為 N+1 的桶子陣列。這避免了排序的 log N 開銷，達到線性時間。",
      "en": "Since the maximum frequency cannot exceed the array length N, we can create a bucket array of size N+1. This avoids the log N overhead of sorting, achieving linear time.",
      "wg": [
        {
          "t": "開銷",
          "en": "overhead/cost",
          "ps": "N"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "Medium",
    "keywords": "Hashing, Anagrams, Key Generation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
    "question": [
      {
        "t": "在「字母異位詞分組」(Group Anagrams) 問題中，我們需要將由相同字母組成的字串歸類在一起。",
        "en": "In the 'Group Anagrams' problem, we need to categorize strings composed of the same letters together.",
        "wg": [
          {
            "t": "字母異位詞",
            "en": "anagram",
            "ps": "N"
          },
          {
            "t": "歸類",
            "en": "categorize/group",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若字串平均長度為 M，字串總數為 N，哪種雜湊鍵(Key)的生成方式在理論上時間複雜度最低？",
        "en": "If the average string length is M and the total number of strings is N, which Hash Key generation method has the lowest theoretical time complexity?",
        "wg": [
          {
            "t": "雜湊鍵",
            "en": "Hash Key",
            "ps": "N"
          },
          {
            "t": "生成方式",
            "en": "generation method",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將每個字串內的字元進行排序 (Sorting) 後作為 Key。",
        "en": "(A) Sort the characters within each string and use the result as the Key.",
        "wg": []
      },
      {
        "t": "(B) 使用長度為 26 的整數陣列 (或 Tuple) 記錄每個字母的出現次數作為 Key。",
        "en": "(B) Use an integer array (or Tuple) of size 26 to record the count of each letter as the Key.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將字串中每個字元的 ASCII 數值相加作為 Key。",
        "en": "(C) Sum the ASCII values of each character in the string as the Key.",
        "wg": [
          {
            "t": "數值",
            "en": "value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用字串的第一個和最後一個字母作為 Key。",
        "en": "(D) Use the first and last letter of the string as the Key.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 的複雜度為 O(N * M log M)；選項 (B) 僅需遍歷字串一次，複雜度為 O(N * M)。選項 (C) 和 (D) 會產生雜湊碰撞 (Collision)，導致錯誤的分組。",
      "en": "Option (A) has a complexity of O(N * M log M); Option (B) only requires iterating through the string once, with complexity O(N * M). Options (C) and (D) will cause hash collisions, leading to incorrect grouping.",
      "wg": [
        {
          "t": "雜湊碰撞",
          "en": "hash collision",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        }
      ]
    }
  }
]