[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Array, Prefix Sum, Suffix Product, Algorithm Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
    "question": [
      {
        "t": "給定一個整數陣列 nums，您需要回傳一個陣列 answer，其中 answer[i] 等於 nums 中除了 nums[i] 之外所有元素的乘積。",
        "en": "Given an integer array nums, you need to return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          },
          {
            "t": "除了...之外",
            "en": "except",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "題目要求必須在 O(n) 時間複雜度內完成，且不能使用除法運算。",
        "en": "The problem requires solving it in O(n) time complexity and without using the division operation.",
        "wg": [
          {
            "t": "除法運算",
            "en": "division operation",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問下列哪種策略最適合解決此問題？",
        "en": "Which of the following strategies is best suited to solve this problem?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用巢狀迴圈計算每個元素的乘積。",
        "en": "(A) Use nested loops to calculate the product for each element.",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 計算所有元素的總乘積，然後除以當前元素。",
        "en": "(B) Calculate the total product of all elements and then divide by the current element.",
        "wg": []
      },
      {
        "t": "(C) 先對陣列進行排序，然後使用雙指針法。",
        "en": "(C) Sort the array first, then use the two-pointer approach.",
        "wg": [
          {
            "t": "雙指針",
            "en": "two-pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 利用前綴乘積 (Prefix Product) 與後綴乘積 (Suffix Product) 的組合。",
        "en": "(D) Utilize a combination of Prefix Product and Suffix Product.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "後綴",
            "en": "suffix",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "題目明確禁止使用除法，且要求 O(n) 時間複雜度。巢狀迴圈是 O(n^2)，排序是 O(n log n)。最佳解法是計算每個位置左邊所有數的乘積 (前綴) 和右邊所有數的乘積 (後綴)，將兩者相乘即可得到答案。",
      "en": "The problem explicitly forbids division and requires O(n) time complexity. Nested loops are O(n^2), and sorting is O(n log n). The optimal solution is to calculate the product of all numbers to the left (prefix) and all numbers to the right (suffix) of each position, then multiply them to get the answer.",
      "wg": [
        {
          "t": "明確禁止",
          "en": "explicitly forbids",
          "ps": "V"
        },
        {
          "t": "最佳解法",
          "en": "optimal solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Hashing, HashSet, Sequence, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [100, 4, 200, 1, 3, 2]\nOutput: 4 (The sequence is [1, 2, 3, 4])",
    "question": [
      {
        "t": "給定一個未排序的整數陣列，找出其中最長連續序列的長度。",
        "en": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.",
        "wg": [
          {
            "t": "未排序的",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "連續序列",
            "en": "consecutive sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "演算法的時間複雜度必須是 O(n)。",
        "en": "The algorithm must have a time complexity of O(n).",
        "wg": []
      },
      {
        "t": "在使用 HashSet 儲存所有數字後，應該如何遍歷以確保效率？",
        "en": "After storing all numbers in a HashSet, how should you iterate to ensure efficiency?",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          },
          {
            "t": "確保",
            "en": "ensure",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個數字 x，檢查 x+1 是否存在，並持續計數。",
        "en": "(A) For every number x, check if x+1 exists and keep counting.",
        "wg": []
      },
      {
        "t": "(B) 只有當 x-1 不在 Set 中時（即 x 為序列起點），才開始計算序列長度。",
        "en": "(B) Only start counting the sequence length if x-1 is not in the Set (meaning x is the start of a sequence).",
        "wg": [
          {
            "t": "起點",
            "en": "start/beginning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 先將陣列轉換為 List 並排序，然後計算連續元素。",
        "en": "(C) Convert the array to a List and sort it first, then count consecutive elements.",
        "wg": []
      },
      {
        "t": "(D) 使用遞迴檢查每個數字的所有可能相鄰數字。",
        "en": "(D) Use recursion to check all possible adjacent numbers for each number.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若對每個數字都嘗試建立序列，時間複雜度會退化。選項 (B) 確保每個序列只被遍歷一次（從最小值開始），這保證了整體時間複雜度維持在 O(n)。選項 (C) 的排序會導致 O(n log n)。",
      "en": "If you attempt to build a sequence for every number, the time complexity degrades. Option (B) ensures that each sequence is traversed only once (starting from the minimum value), which guarantees the overall time complexity remains O(n). Option (C) involves sorting, which results in O(n log n).",
      "wg": [
        {
          "t": "退化",
          "en": "degrade",
          "ps": "V"
        },
        {
          "t": "最小值",
          "en": "minimum value",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Array, Hashing, Prefix Sum, Subarray",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, 1, 1], k = 2\nOutput: 2",
    "question": [
      {
        "t": "在解決「和為 K 的子陣列」(Subarray Sum Equals K) 問題時，我們通常使用 HashMap 來優化。",
        "en": "When solving the 'Subarray Sum Equals K' problem, we typically use a HashMap for optimization.",
        "wg": [
          {
            "t": "子陣列",
            "en": "subarray",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimization",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這個 HashMap 的 Key 和 Value 分別代表什麼意義？",
        "en": "What do the Key and Value of this HashMap represent respectively?",
        "wg": [
          {
            "t": "分別",
            "en": "respectively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Key: 當前索引 (Index); Value: 該位置的元素值。",
        "en": "(A) Key: Current Index; Value: Element value at that position.",
        "wg": []
      },
      {
        "t": "(B) Key: 元素值; Value: 該元素出現的次數。",
        "en": "(B) Key: Element value; Value: Frequency of that element.",
        "wg": []
      },
      {
        "t": "(C) Key: 前綴和 (Prefix Sum); Value: 該前綴和出現的次數。",
        "en": "(C) Key: Prefix Sum; Value: Count of occurrences of that prefix sum.",
        "wg": [
          {
            "t": "前綴和",
            "en": "prefix sum",
            "ps": "N"
          },
          {
            "t": "出現",
            "en": "occurrence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Key: 目標值 K 減去當前值; Value: 索引值。",
        "en": "(D) Key: Target value K minus current value; Value: Index value.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "此問題的核心公式是 `sum[i] - sum[j] = k`。我們需要查找是否存在一個之前的 `sum[j]` 等於 `sum[i] - k`。因此，HashMap 需要儲存「前綴和」作為 Key，並儲存該前綴和「出現的次數」作為 Value，以便計算有多少個子陣列符合條件。",
      "en": "The core formula for this problem is `sum[i] - sum[j] = k`. We need to check if there exists a previous `sum[j]` equal to `sum[i] - k`. Therefore, the HashMap needs to store the 'Prefix Sum' as the Key and the 'count of occurrences' of that prefix sum as the Value to calculate how many subarrays satisfy the condition.",
      "wg": [
        {
          "t": "核心公式",
          "en": "core formula",
          "ps": "N"
        },
        {
          "t": "符合條件",
          "en": "satisfy the condition",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Matrix, Hashing, Validation, Sudoku",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在驗證數獨 (Valid Sudoku) 是否有效時，我們需要檢查每一列、每一行以及每一個 3x3 的宮格。",
        "en": "When validating if a Sudoku is valid, we need to check every row, every column, and every 3x3 sub-box.",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "宮格",
            "en": "sub-box/grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若希望只遍歷一次矩陣就完成檢查，下列哪種 Hashing 策略最為合適？",
        "en": "If we want to complete the check by traversing the matrix only once, which of the following Hashing strategies is most appropriate?",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "矩陣",
            "en": "matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設當前數字為 `val`，位於第 `i` 列與第 `j` 行。",
        "en": "Assume the current number is `val`, located at row `i` and column `j`.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 建立三個獨立的 HashSet，分別存儲 `(i, val)`、`(j, val)` 和 `(i/3, j/3, val)` 的字串標識。",
        "en": "(A) Create three separate HashSets to store string identifiers for `(i, val)`, `(j, val)`, and `(i/3, j/3, val)`.",
        "wg": [
          {
            "t": "獨立的",
            "en": "separate",
            "ps": "Adj"
          },
          {
            "t": "標識",
            "en": "identifier",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將所有數字相加，檢查總和是否等於 405。",
        "en": "(B) Sum all numbers and check if the total equals 405.",
        "wg": []
      },
      {
        "t": "(C) 使用遞迴深度優先搜尋 (DFS) 來尋找重複值。",
        "en": "(C) Use recursive Depth-First Search (DFS) to find duplicate values.",
        "wg": []
      },
      {
        "t": "(D) 僅檢查行與列，因為 3x3 宮格會自動符合規則。",
        "en": "(D) Only check rows and columns, as the 3x3 sub-boxes will automatically comply with the rules.",
        "wg": [
          {
            "t": "自動",
            "en": "automatically",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "為了在一次遍歷中完成檢查，我們需要將數字在「行」、「列」和「3x3 宮格」中的存在狀態編碼為唯一的 Key (例如字串 \"row-0-5\") 並存入 HashSet。若插入失敗，表示該規則下有重複數字。選項 (B) 無法檢測位置錯誤，選項 (D) 觀念錯誤。",
      "en": "To complete the check in a single pass, we need to encode the presence of the number in the 'row', 'column', and '3x3 sub-box' into unique Keys (e.g., string \"row-0-5\") and store them in a HashSet. If insertion fails, it means there is a duplicate number under that rule. Option (B) cannot detect positional errors, and Option (D) is conceptually incorrect.",
      "wg": [
        {
          "t": "編碼",
          "en": "encode",
          "ps": "V"
        },
        {
          "t": "檢測",
          "en": "detect",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Array, Hashing, Bucket Sort, Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]",
    "question": [
      {
        "t": "給定一個整數陣列 nums 和一個整數 k，請找出出現頻率最高的 k 個元素。",
        "en": "Given an integer array nums and an integer k, return the k most frequent elements.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要達到優於 O(n log n) 的時間複雜度（例如 O(n)），應該結合哪兩種資料結構或演算法？",
        "en": "To achieve a time complexity better than O(n log n) (e.g., O(n)), which two data structures or algorithms should be combined?",
        "wg": [
          {
            "t": "結合",
            "en": "combine",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) HashMap (計數) + Merge Sort (合併排序)。",
        "en": "(A) HashMap (Counting) + Merge Sort.",
        "wg": []
      },
      {
        "t": "(B) HashMap (計數) + Bucket Sort (桶排序)。",
        "en": "(B) HashMap (Counting) + Bucket Sort.",
        "wg": [
          {
            "t": "桶排序",
            "en": "Bucket Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Binary Search Tree (二元搜尋樹) + Stack。",
        "en": "(C) Binary Search Tree + Stack.",
        "wg": []
      },
      {
        "t": "(D) Queue (佇列) + Bubble Sort (氣泡排序)。",
        "en": "(D) Queue + Bubble Sort.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "一般的排序算法需要 O(n log n)。使用 HashMap 計算頻率後，我們可以利用 Bucket Sort，將「頻率」作為陣列的索引 (Index)，將對應的數字放入桶中。因為頻率上限為陣列長度 n，這樣的排序過程僅需 O(n) 時間。",
      "en": "Standard sorting algorithms require O(n log n). After counting frequencies with a HashMap, we can use Bucket Sort by using the 'frequency' as the array index and placing corresponding numbers into buckets. Since the maximum frequency is the array length n, this sorting process takes only O(n) time.",
      "wg": [
        {
          "t": "上限",
          "en": "upper bound/maximum",
          "ps": "N"
        },
        {
          "t": "僅需",
          "en": "takes only",
          "ps": "V"
        }
      ]
    }
  }
]