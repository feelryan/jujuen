[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Hashing, Matrix, Sudoku, Set",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「驗證數獨」(Valid Sudoku) 問題時，我們需要檢查每一行、每一列以及每一個 3x3 的子方格是否包含重複的數字。",
        "en": "When solving the 'Valid Sudoku' problem, we need to check if every row, every column, and every 3x3 sub-box contains duplicate numbers.",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "子方格",
            "en": "sub-box",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了達到最佳的時間複雜度，應該使用哪種資料結構來追蹤已經出現過的數字？",
        "en": "To achieve optimal time complexity, which data structure should be used to track the numbers that have already appeared?",
        "wg": [
          {
            "t": "追蹤",
            "en": "track",
            "ps": "V"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用三個雜湊集合 (HashSet)，分別記錄行、列和子方格中出現的數字。",
        "en": "(A) Use three HashSets to separately record numbers appearing in rows, columns, and sub-boxes.",
        "wg": [
          {
            "t": "雜湊集合",
            "en": "HashSet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 對每一行、每一列和每一個子方格進行排序 (Sorting)，然後檢查相鄰元素。",
        "en": "(B) Sort every row, every column, and every sub-box, then check adjacent elements.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 使用遞迴 (Recursion) 遍歷所有可能的填法。",
        "en": "(C) Use recursion to traverse all possible fillings.",
        "wg": []
      },
      {
        "t": "(D) 使用動態規劃 (Dynamic Programming) 計算每個格子的可能性。",
        "en": "(D) Use Dynamic Programming to calculate possibilities for each cell.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "選項 (A) 是正確的，因為雜湊集合 (HashSet) 提供 O(1) 的查找與插入時間，能在遍歷矩陣一次的情況下完成檢查 (O(9^2))。",
      "en": "Option (A) is correct because a HashSet provides O(1) lookup and insertion time, allowing the check to be completed in a single pass of the matrix (O(9^2)).",
      "wg": [
        {
          "t": "查找",
          "en": "lookup",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Array, Product, Prefix Sum, Suffix Sum",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 2, 3, 4]\nOutput: [24, 12, 8, 6]",
    "question": [
      {
        "t": "給定一個整數陣列 `nums`，您需要回傳一個陣列，其中每個元素是 `nums` 中除了該位置自身以外所有元素的乘積。",
        "en": "Given an integer array `nums`, you need to return an array where each element is the product of all elements in `nums` except the one at that position itself.",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          },
          {
            "t": "除了...以外",
            "en": "except",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "題目要求時間複雜度為 O(n) 且**不能使用除法**。",
        "en": "The problem requires O(n) time complexity and **cannot use division**.",
        "wg": [
          {
            "t": "除法",
            "en": "division",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問下列哪種策略最適合解決此問題？",
        "en": "Which of the following strategies is best suited to solve this problem?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計算所有元素的總乘積，然後對每個元素做除法。",
        "en": "(A) Calculate the total product of all elements, then perform division for each element.",
        "wg": []
      },
      {
        "t": "(B) 使用巢狀迴圈，對每個元素重新遍歷陣列計算乘積。",
        "en": "(B) Use nested loops to iterate through the array again for each element to calculate the product.",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 計算前綴乘積 (Prefix Product) 與後綴乘積 (Suffix Product)，並將兩者相乘。",
        "en": "(C) Calculate Prefix Products and Suffix Products, then multiply them together.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "後綴",
            "en": "suffix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將陣列排序後，取最大值與最小值的乘積。",
        "en": "(D) Sort the array, then take the product of the maximum and minimum values.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 正確。透過兩次遍歷分別計算每個位置左邊所有數的乘積 (Prefix) 與右邊所有數的乘積 (Suffix)，相乘即可得到答案，且符合 O(n) 時間複雜度與不使用除法的要求。",
      "en": "Option (C) is correct. By traversing twice to calculate the product of all numbers to the left (Prefix) and all numbers to the right (Suffix) for each position, multiplying them yields the answer, meeting the O(n) time complexity and no-division requirements.",
      "wg": [
        {
          "t": "符合",
          "en": "meet/comply with",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Hashing, Sequence, Set, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「最長連續序列」(Longest Consecutive Sequence) 問題中，我們需要在未排序的陣列中找出數字連續的最長長度。",
        "en": "In the 'Longest Consecutive Sequence' problem, we need to find the length of the longest consecutive elements sequence in an unsorted array.",
        "wg": [
          {
            "t": "連續",
            "en": "consecutive",
            "ps": "Adj"
          },
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若要達到 O(n) 的時間複雜度，我們通常會將所有數字放入 Hash Set。",
        "en": "To achieve O(n) time complexity, we typically put all numbers into a Hash Set.",
        "wg": []
      },
      {
        "t": "在遍歷 Set 時，為了避免重複計算並確保線性時間，我們應該只在什麼情況下開始計算序列長度？",
        "en": "When iterating through the Set, to avoid redundant calculations and ensure linear time, under what condition should we start counting the sequence length?",
        "wg": [
          {
            "t": "重複計算",
            "en": "redundant calculations",
            "ps": "N"
          },
          {
            "t": "線性時間",
            "en": "linear time",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當目前的數字 `x` 是偶數時。",
        "en": "(A) When the current number `x` is even.",
        "wg": []
      },
      {
        "t": "(B) 當 Set 中存在 `x - 1` 時。",
        "en": "(B) When `x - 1` exists in the Set.",
        "wg": []
      },
      {
        "t": "(C) 當 Set 中**不存在** `x - 1` 時 (即 `x` 是序列的起點)。",
        "en": "(C) When `x - 1` does **not** exist in the Set (i.e., `x` is the start of a sequence).",
        "wg": [
          {
            "t": "起點",
            "en": "start/beginning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 當 Set 中存在 `x + 1` 時。",
        "en": "(D) When `x + 1` exists in the Set.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 是關鍵優化。只有當 `x` 沒有前一個數字 (`x-1`) 時，它才是一個序列的開頭。這樣可以確保每個序列只被處理一次，從而將整體複雜度控制在 O(n)。",
      "en": "Option (C) is the key optimization. Only when `x` has no predecessor (`x-1`) is it the start of a sequence. This ensures each sequence is processed only once, keeping the overall complexity at O(n).",
      "wg": [
        {
          "t": "優化",
          "en": "optimization",
          "ps": "N"
        },
        {
          "t": "前一個",
          "en": "predecessor",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Heap, Bucket Sort, Frequency, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要找出一個整數陣列中出現頻率最高的 k 個元素 (Top K Frequent Elements)。",
        "en": "You need to find the k most frequent elements in an integer array.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若輸入陣列的大小為 n，哪種演算法可以在優於 O(n log n) 的時間複雜度內解決此問題？",
        "en": "If the input array size is n, which algorithm can solve this problem with a time complexity better than O(n log n)?",
        "wg": [
          {
            "t": "優於",
            "en": "better than",
            "ps": "Prep"
          }
        ]
      }
    ],
    "type": "複選題",
    "options": [
      {
        "t": "(A) 使用快速排序 (Quick Sort) 對整個陣列排序，然後計算頻率。",
        "en": "(A) Use Quick Sort to sort the entire array, then count frequencies.",
        "wg": []
      },
      {
        "t": "(B) 使用雜湊表計算頻率，接著使用大小為 k 的最小堆積 (Min-Heap)。",
        "en": "(B) Use a hash map to count frequencies, then use a Min-Heap of size k.",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用桶排序 (Bucket Sort)，將頻率作為陣列索引。",
        "en": "(C) Use Bucket Sort, using frequency as the array index.",
        "wg": [
          {
            "t": "桶排序",
            "en": "Bucket Sort",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 對雜湊表的所有鍵值對進行氣泡排序 (Bubble Sort)。",
        "en": "(D) Perform Bubble Sort on all key-value pairs of the hash map.",
        "wg": []
      }
    ],
    "answer": "(B), (C)",
    "why": {
      "t": "選項 (B) 的時間複雜度為 O(n log k)，優於 O(n log n)。選項 (C) 使用桶排序技巧，時間複雜度為 O(n)，是此題最高效的解法。選項 (A) 需要 O(n log n)。",
      "en": "Option (B) has a time complexity of O(n log k), which is better than O(n log n). Option (C) uses the Bucket Sort technique with a time complexity of O(n), making it the most efficient solution. Option (A) requires O(n log n).",
      "wg": [
        {
          "t": "技巧",
          "en": "technique",
          "ps": "N"
        },
        {
          "t": "高效",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "String, Design, Encoding, Decoding",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"hello\", \"world\"]\nEncoded: \"5#hello5#world\"",
    "question": [
      {
        "t": "設計一個演算法來將字串列表編碼 (Encode) 為單一字串，並能解碼 (Decode) 回原列表。",
        "en": "Design an algorithm to encode a list of strings into a single string and decode it back to the original list.",
        "wg": [
          {
            "t": "編碼",
            "en": "encode",
            "ps": "V"
          },
          {
            "t": "解碼",
            "en": "decode",
            "ps": "V"
          }
        ]
      },
      {
        "t": "單純使用特殊符號（如 `#` 或 `,`）作為分隔符號可能會遇到什麼問題？",
        "en": "What problem might arise from simply using a special character (like `#` or `,`) as a delimiter?",
        "wg": [
          {
            "t": "分隔符號",
            "en": "delimiter",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 字串太長會導致記憶體溢出。",
        "en": "(A) The string being too long will cause a memory overflow.",
        "wg": [
          {
            "t": "記憶體溢出",
            "en": "memory overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 原始字串內容本身可能包含該分隔符號，導致解碼邏輯混淆。",
        "en": "(B) The original string content might contain the delimiter itself, causing confusion in the decoding logic.",
        "wg": [
          {
            "t": "混淆",
            "en": "confusion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這種方法無法處理空字串。",
        "en": "(C) This method cannot handle empty strings.",
        "wg": []
      },
      {
        "t": "(D) ASCII 編碼不支援特殊符號。",
        "en": "(D) ASCII encoding does not support special characters.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "如果原始字串中包含了分隔符號，解碼器會錯誤地將字串切斷。常見的解決方案是使用「長度前綴」(Length-prefixing)，例如 `4#code`，明確指出接下來要讀取多少字元。",
      "en": "If the original string contains the delimiter, the decoder will incorrectly split the string. A common solution is 'Length-prefixing', such as `4#code`, which explicitly states how many characters to read next.",
      "wg": [
        {
          "t": "切斷",
          "en": "split/cut off",
          "ps": "V"
        },
        {
          "t": "明確指出",
          "en": "explicitly state",
          "ps": "V"
        }
      ]
    }
  }
]