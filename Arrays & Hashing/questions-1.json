[
  {
    "no": "1",
    "level": "Easy",
    "keywords": "Array, Memory, Time Complexity, Random Access",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "陣列 (Array) 支援以 O(1) 的時間複雜度進行隨機存取。",
        "en": "Arrays support random access with O(1) time complexity.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問是什麼底層特性使得這種效率成為可能？",
        "en": "What underlying characteristic makes this efficiency possible?",
        "wg": [
          {
            "t": "底層",
            "en": "underlying",
            "ps": "Adj"
          },
          {
            "t": "特性",
            "en": "characteristic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 陣列總是儲存整數，因此處理速度較快。",
        "en": "(A) Arrays always store integers, so processing is faster.",
        "wg": []
      },
      {
        "t": "(B) 元素儲存在連續的記憶體位置，允許透過簡單的數學公式計算位址。",
        "en": "(B) Elements are stored in contiguous memory locations, allowing address calculation via a simple formula.",
        "wg": [
          {
            "t": "連續的",
            "en": "contiguous",
            "ps": "Adj"
          },
          {
            "t": "公式",
            "en": "formula",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 編譯器會預先快取所有陣列元素以供快速檢索。",
        "en": "(C) The compiler pre-caches all array elements for quick retrieval.",
        "wg": [
          {
            "t": "預先快取",
            "en": "pre-cache",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 陣列使用雜湊函數將索引映射到記憶體位址。",
        "en": "(D) Arrays use a hash function to map indices to memory addresses.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "陣列佔用連續的記憶體區塊。若要存取索引 `i`，系統只需計算 `基底位址 + (i * 元素大小)`，這是一個常數時間的操作。選項 (A) 錯誤，因為陣列可儲存任何類型；選項 (C) 不切實際且非標準行為；選項 (D) 描述的是雜湊表而非陣列。",
      "en": "Arrays occupy a contiguous block of memory. To access index `i`, the system simply calculates `Base Address + (i * Element Size)`, which is a constant time operation. Option (A) is wrong as arrays can store any type; (C) is impractical and not standard behavior; (D) describes Hash Maps, not Arrays.",
      "wg": [
        {
          "t": "基底位址",
          "en": "base address",
          "ps": "N"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "Medium",
    "keywords": "Hash Map, Collision, Chaining, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作雜湊表 (Hash Map) 時，當兩個不同的鍵 (Keys) 產生相同的雜湊值，這種情況稱為碰撞 (Collision)。",
        "en": "When implementing a Hash Map, a situation where two different keys produce the same hash value is called a collision.",
        "wg": [
          {
            "t": "碰撞",
            "en": "collision",
            "ps": "N"
          },
          {
            "t": "雜湊值",
            "en": "hash value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種碰撞處理技術，涉及在每個陣列索引處維護一個鏈結串列 (Linked List) 來儲存所有雜湊到該索引的元素？",
        "en": "Which collision resolution technique involves maintaining a linked list at each array index to store all elements hashed to that index?",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "linked list",
            "ps": "N"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 線性探測 (Linear Probing)",
        "en": "(A) Linear Probing",
        "wg": []
      },
      {
        "t": "(B) 鏈結法 (Chaining)",
        "en": "(B) Chaining",
        "wg": []
      },
      {
        "t": "(C) 雙重雜湊 (Double Hashing)",
        "en": "(C) Double Hashing",
        "wg": []
      },
      {
        "t": "(D) 動態調整大小 (Dynamic Resizing)",
        "en": "(D) Dynamic Resizing",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "鏈結法 (Chaining) 使用鏈結串列（或其他結構）在同一個桶 (Bucket) 中儲存多個項目。選項 (A) 和 (C) 屬於開放定址法 (Open Addressing)，它們會在陣列中尋找下一個空位而非堆疊在同一位置；選項 (D) 是當負載因子過高時擴增雜湊表大小的機制，而非直接處理單一碰撞的方法。",
      "en": "Chaining uses a linked list (or other structure) to store multiple items in the same bucket. Options (A) and (C) are forms of Open Addressing, which look for the next available slot in the array rather than stacking at the same location; (D) is a mechanism to expand the hash map when the load factor is too high, not a direct method for handling a single collision.",
      "wg": [
        {
          "t": "桶",
          "en": "bucket",
          "ps": "N"
        },
        {
          "t": "開放定址法",
          "en": "open addressing",
          "ps": "N"
        },
        {
          "t": "負載因子",
          "en": "load factor",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "Medium",
    "keywords": "Two Sum, Hash Map, Optimization, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [2, 7, 11, 15], target = 9\nOutput: [0, 1] // Because nums[0] + nums[1] == 9",
    "question": [
      {
        "t": "針對經典的「兩數之和」(Two Sum) 問題（如上方程式碼所示），暴力解法使用巢狀迴圈，時間複雜度為 O(n^2)。",
        "en": "For the classic 'Two Sum' problem (as shown in the code snippet above), the brute force solution uses nested loops with a time complexity of O(n^2).",
        "wg": [
          {
            "t": "暴力解法",
            "en": "brute force solution",
            "ps": "N"
          },
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要將時間複雜度優化至 O(n)，我們應該使用哪種資料結構來儲存已訪問過的數字及其索引？",
        "en": "To optimize the time complexity to O(n), which data structure should we use to store visited numbers and their indices?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "已訪問過的",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)",
        "en": "(A) Stack",
        "wg": []
      },
      {
        "t": "(B) 佇列 (Queue)",
        "en": "(B) Queue",
        "wg": []
      },
      {
        "t": "(C) 雜湊表 (Hash Map)",
        "en": "(C) Hash Map",
        "wg": []
      },
      {
        "t": "(D) 最大堆積 (Max Heap)",
        "en": "(D) Max Heap",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "使用雜湊表可以讓我們在 O(1) 時間內檢查 `target - current_value` 是否存在。這使得我們只需遍歷陣列一次。堆疊和佇列僅提供順序存取，搜尋仍需 O(n)；堆積的搜尋效率不如雜湊表。",
      "en": "Using a Hash Map allows us to check if `target - current_value` exists in O(1) time. This enables us to solve the problem in a single pass through the array. Stacks and Queues only provide sequential access, making search O(n); Heaps are less efficient for searching than Hash Maps.",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "單次",
          "en": "single pass",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "Medium",
    "keywords": "Dynamic Array, Amortized Analysis, Resizing, Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "動態陣列（如 Java 的 ArrayList 或 C++ 的 std::vector）在容量已滿時需要調整大小。",
        "en": "Dynamic arrays (like Java's ArrayList or C++'s std::vector) need to resize when their capacity is full.",
        "wg": [
          {
            "t": "動態陣列",
            "en": "dynamic array",
            "ps": "N"
          },
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於將元素新增至動態陣列末端的「攤銷時間複雜度」(Amortized Time Complexity)，下列敘述何者正確？",
        "en": "Which statement is correct regarding the 'Amortized Time Complexity' of appending an element to the end of a dynamic array?",
        "wg": [
          {
            "t": "攤銷時間複雜度",
            "en": "amortized time complexity",
            "ps": "N"
          },
          {
            "t": "新增",
            "en": "append",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 始終為 O(1)。",
        "en": "(A) Always O(1).",
        "wg": []
      },
      {
        "t": "(B) 攤銷後為 O(1)，但最差情況為 O(n)。",
        "en": "(B) Amortized O(1), but worst-case O(n).",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 始終為 O(n)，因為每次都需要複製陣列。",
        "en": "(C) Always O(n), because the array needs to be copied every time.",
        "wg": []
      },
      {
        "t": "(D) 為 O(log n)，因為容量通常會加倍。",
        "en": "(D) O(log n), because the capacity usually doubles.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "大多數新增操作只需 O(1) 時間放入元素。當陣列滿時，需要分配新的記憶體（通常是兩倍大）並複製所有元素，這需要 O(n)。然而，這種昂貴的操作很少發生，因此平均（攤銷）下來每個操作的成本是 O(1)。",
      "en": "Most append operations take O(1) time to simply place the element. When the array is full, allocating new memory (usually double the size) and copying all elements takes O(n). However, this expensive operation happens rarely, so the average (amortized) cost per operation is O(1).",
      "wg": [
        {
          "t": "分配",
          "en": "allocate",
          "ps": "V"
        },
        {
          "t": "昂貴的",
          "en": "expensive",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "Easy",
    "keywords": "Anagram, Frequency Counter, Array, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"anagram\", t = \"nagaram\"",
    "question": [
      {
        "t": "要判斷兩個字串 `s` 和 `t` 是否為「異位構詞」(Anagram，即字母相同但順序不同)，且字串僅包含小寫英文字母。",
        "en": "To determine if two strings `s` and `t` are 'Anagrams' (containing the same characters but in a different order), assuming the strings contain only lowercase English letters.",
        "wg": [
          {
            "t": "異位構詞",
            "en": "anagram",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於使用完整的雜湊表 (Hash Map)，使用大小為 26 的整數陣列來計算字元頻率有什麼優勢？",
        "en": "What is the advantage of using an integer array of size 26 to count character frequencies compared to using a full Hash Map?",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "優勢",
            "en": "advantage",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 降低時間複雜度從 O(n) 到 O(log n)。",
        "en": "(A) Reduces time complexity from O(n) to O(log n).",
        "wg": []
      },
      {
        "t": "(B) 減少空間開銷並消除雜湊函數的計算成本，提升常數因子的執行效率。",
        "en": "(B) Reduces space overhead and eliminates hash function computation costs, improving constant factor execution efficiency.",
        "wg": [
          {
            "t": "空間開銷",
            "en": "space overhead",
            "ps": "N"
          },
          {
            "t": "常數因子",
            "en": "constant factor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 陣列可以自動處理 Unicode 字元，而雜湊表不行。",
        "en": "(C) Arrays can automatically handle Unicode characters, while Hash Maps cannot.",
        "wg": []
      },
      {
        "t": "(D) 使用陣列可以避免遍歷字串。",
        "en": "(D) Using an array allows avoiding string traversal.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雖然兩者在時間複雜度上都是 O(n)，但固定大小的陣列不需要處理雜湊碰撞、雜湊計算或動態記憶體分配，因此在空間更精簡且執行速度（常數時間）上通常比通用的雜湊表更快。",
      "en": "Although both have a time complexity of O(n), a fixed-size array does not require handling hash collisions, hash computations, or dynamic memory allocation. Therefore, it is more space-efficient and typically faster (in terms of constant time) than a generic Hash Map.",
      "wg": [
        {
          "t": "通用的",
          "en": "generic",
          "ps": "Adj"
        },
        {
          "t": "精簡",
          "en": "efficient/compact",
          "ps": "Adj"
        }
      ]
    }
  }
]