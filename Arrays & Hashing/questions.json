[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Prefix Sum, Hash Map, Frequency, Subarray Count",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要計算和為 k 的連續子陣列數量，並使用前綴和搭配雜湊表。",
        "en": "You need to count the number of contiguous subarrays whose sum equals k, using prefix sums with a hash map.",
        "wg": [
          { "t": "連續子陣列", "en": "contiguous subarray", "ps": "N" },
          { "t": "前綴和", "en": "prefix sum", "ps": "N" },
          { "t": "雜湊表", "en": "hash map", "ps": "N" }
        ]
      },
      {
        "t": "下列哪個更新順序能避免漏算或多算。",
        "en": "Which update order avoids undercounting or overcounting.",
        "wg": [
          { "t": "更新順序", "en": "update order", "ps": "N" },
          { "t": "漏算", "en": "undercounting", "ps": "N" },
          { "t": "多算", "en": "overcounting", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將當前 prefix 加入 map，再查找 prefix-k 的次數並累加答案。",
        "en": "(A) Insert the current prefix into the map first, then query prefix-k frequency and add to the answer.",
        "wg": [
          { "t": "累加答案", "en": "accumulate the answer", "ps": "V" }
        ]
      },
      {
        "t": "(B) 先查找 prefix-k 的次數並累加答案，再將當前 prefix 加入 map。",
        "en": "(B) Query prefix-k frequency and add to the answer first, then insert the current prefix into the map.",
        "wg": [
          { "t": "次數", "en": "frequency", "ps": "N" }
        ]
      },
      {
        "t": "(C) 每次只用 Set 記錄 prefix 是否出現過即可，不需要次數。",
        "en": "(C) A Set of seen prefixes is enough; you don’t need frequencies.",
        "wg": [
          { "t": "是否出現過", "en": "whether it has appeared", "ps": "V" }
        ]
      },
      {
        "t": "(D) 先排序 nums 後再做 prefix sum 會更容易計數。",
        "en": "(D) Sorting nums before prefix sums makes counting easier.",
        "wg": [
          { "t": "排序", "en": "sort", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "正確做法是先查詢歷史再寫入當前狀態，因為你要配對的是「之前」出現過的 prefix 值而不是包含自己。使用 Set 會漏掉同一 prefix 重複出現所對應的多種起點，因此會少算。排序會破壞連續子陣列的語義，導致題意改變。",
      "en": "The correct approach is to query history before writing the current state, because you must pair with prefixes that occurred earlier, not including the current prefix itself. Using a Set loses multiplicity when the same prefix occurs multiple times, causing undercounting. Sorting destroys contiguity semantics, changing the problem.",
      "wg": [
        { "t": "查詢歷史", "en": "query history", "ps": "V" },
        { "t": "多種起點", "en": "multiple start indices", "ps": "N" },
        { "t": "語義", "en": "semantics", "ps": "N" }
      ]
    }
  },
  {
    "no": "2",
    "level": "hard",
    "keywords": "Prefix Mod, Congruence, Negative Mod, JavaScript",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要計算「子陣列和可被 k 整除」的數量，並在 TypeScript 中使用 prefix % k 作為 key。",
        "en": "You are counting subarrays whose sum is divisible by k, using prefix % k as the key in TypeScript.",
        "wg": [
          { "t": "可被整除", "en": "divisible", "ps": "Adj" },
          { "t": "作為 key", "en": "as a key", "ps": "PrepP" }
        ]
      },
      {
        "t": "以下哪個餘數正規化方式最正確且最常用。",
        "en": "Which remainder normalization is the most correct and commonly used.",
        "wg": [
          { "t": "餘數正規化", "en": "remainder normalization", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) rem = prefix % k。",
        "en": "(A) rem = prefix % k.",
        "wg": []
      },
      {
        "t": "(B) rem = (prefix % k + k)。",
        "en": "(B) rem = (prefix % k + k).",
        "wg": []
      },
      {
        "t": "(C) rem = ((prefix % k) + k) % k。",
        "en": "(C) rem = ((prefix % k) + k) % k.",
        "wg": []
      },
      {
        "t": "(D) rem = Math.abs(prefix % k)。",
        "en": "(D) rem = Math.abs(prefix % k).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 JS/TS 中負數取模會得到負值，因此需要把結果搬回到 [0, k-1] 的同餘類代表。選項 (B) 少了再取一次 % k，當 prefix%k 原本是 0 時會得到 k 造成越界類別。選項 (D) 會把不同同餘類錯誤合併，例如 -1 與 1 在 mod 5 下不是同一類。",
      "en": "In JS/TS, negative modulo yields a negative value, so you must map it back into the canonical class [0, k-1]. Option (B) misses the final % k, so when prefix%k is 0 it becomes k and falls outside the range. Option (D) incorrectly merges different congruence classes, e.g., -1 and 1 are not equivalent mod 5.",
      "wg": [
        { "t": "同餘類", "en": "congruence class", "ps": "N" },
        { "t": "越界", "en": "out of range", "ps": "Adj" },
        { "t": "錯誤合併", "en": "incorrectly merge", "ps": "V" }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Canonicalization, Slope, GCD, Max Points on a Line",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要用雜湊表統計同一 anchor 點出發的斜率來解 Max Points on a Line。",
        "en": "You hash-count slopes from the same anchor point to solve Max Points on a Line.",
        "wg": [
          { "t": "斜率", "en": "slope", "ps": "N" },
          { "t": "anchor 點", "en": "anchor point", "ps": "N" }
        ]
      },
      {
        "t": "以下哪種 key 表示法最安全且可避免浮點誤差與符號歧義。",
        "en": "Which key representation is safest to avoid floating errors and sign ambiguity.",
        "wg": [
          { "t": "符號歧義", "en": "sign ambiguity", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) key = (dy / dx) 的 double 浮點字串化。",
        "en": "(A) key = stringified double of (dy / dx).",
        "wg": [
          { "t": "浮點字串化", "en": "stringify floating-point", "ps": "V" }
        ]
      },
      {
        "t": "(B) key = dy + \"/\" + dx，不做約分與符號統一。",
        "en": "(B) key = dy + \"/\" + dx, without reduction or sign normalization.",
        "wg": [
          { "t": "約分", "en": "reduce fraction", "ps": "V" },
          { "t": "符號統一", "en": "sign normalization", "ps": "N" }
        ]
      },
      {
        "t": "(C) key = (dy/g)#(dx/g)，並強制 dx>0，且處理 dx=0 與 dy=0 特例。",
        "en": "(C) key = (dy/g)#(dx/g), enforce dx>0, and handle dx=0 and dy=0 as special cases.",
        "wg": [
          { "t": "特例", "en": "special case", "ps": "N" }
        ]
      },
      {
        "t": "(D) key = JSON.stringify([dy, dx])，並依照 dy 大小排序 dy 與 dx。",
        "en": "(D) key = JSON.stringify([dy, dx]), and sort dy and dx by dy’s magnitude.",
        "wg": [
          { "t": "依照", "en": "according to", "ps": "PrepP" }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "斜率本質是方向向量的等價類，因此必須用 gcd 約分並統一符號來保證等價斜率映射到同一 key。浮點表示會因精度誤差拆散同一斜率。未約分或不統一符號會把 (2,4) 與 (1,2) 或 (1,-1) 與 (-1,1) 分成不同 key。把 dy 與 dx 排序會改變向量方向，直接破壞斜率語義。",
      "en": "A slope is an equivalence class of direction vectors, so you must reduce by gcd and normalize sign so equivalent slopes map to the same key. Floating representations can split equal slopes due to precision issues. Not reducing or not normalizing sign separates (2,4) vs (1,2), or (1,-1) vs (-1,1). Sorting dy and dx changes vector direction and breaks slope semantics.",
      "wg": [
        { "t": "方向向量", "en": "direction vector", "ps": "N" },
        { "t": "等價類", "en": "equivalence class", "ps": "N" },
        { "t": "破壞語義", "en": "break semantics", "ps": "V" }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Anagrams, Signature, Key Collision, Frequency Vector",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要分組變位詞並選擇一種穩定的 signature 當作 Map 的 key。",
        "en": "You need to group anagrams and choose a stable signature as the Map key.",
        "wg": [
          { "t": "變位詞", "en": "anagram", "ps": "N" },
          { "t": "穩定", "en": "stable", "ps": "Adj" },
          { "t": "signature", "en": "signature", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個作法最能避免 key 碰撞且時間複雜度最佳。",
        "en": "Which approach best avoids key collisions and has the best time complexity.",
        "wg": [
          { "t": "key 碰撞", "en": "key collision", "ps": "N" },
          { "t": "時間複雜度", "en": "time complexity", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個字串排序後作為 key。",
        "en": "(A) Sort each string and use it as the key.",
        "wg": []
      },
      {
        "t": "(B) 建 26 長度的計數向量並用 counts.join(\"\") 當 key。",
        "en": "(B) Build a length-26 count vector and use counts.join(\"\") as the key.",
        "wg": [
          { "t": "計數向量", "en": "count vector", "ps": "N" }
        ]
      },
      {
        "t": "(C) 建 26 長度的計數向量並用 counts.join(\"#\") 當 key。",
        "en": "(C) Build a length-26 count vector and use counts.join(\"#\") as the key.",
        "wg": [
          { "t": "分隔符", "en": "delimiter", "ps": "N" }
        ]
      },
      {
        "t": "(D) 用 Set 判斷是否看過字串即可，不需要分組資料結構。",
        "en": "(D) A Set is enough; you don’t need grouping data structures.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "計數向量可在 O(L) 生成 signature，通常比排序的 O(L log L) 更快。使用 join(\"\") 可能造成模稜兩可的序列化而碰撞，因此需要明確分隔符或固定格式。Set 無法把同 key 的字串收集成同一組，所以不符合輸出需求。",
      "en": "A count vector produces a signature in O(L), usually faster than sorting at O(L log L). Using join(\"\") can create ambiguous serialization and collisions, so you need a delimiter or fixed formatting. A Set cannot collect strings into groups by key, so it does not meet the output requirement.",
      "wg": [
        { "t": "模稜兩可", "en": "ambiguous", "ps": "Adj" },
        { "t": "序列化", "en": "serialization", "ps": "N" },
        { "t": "輸出需求", "en": "output requirement", "ps": "N" }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Top K Frequent, Bucket Sort, Heap, Frequency Map",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要找出出現頻率最高的 k 個元素，且希望整體時間接近 O(n)。",
        "en": "You need the k most frequent elements and want overall time close to O(n).",
        "wg": [
          { "t": "整體時間", "en": "overall time", "ps": "N" },
          { "t": "接近", "en": "close to", "ps": "Adv" }
        ]
      },
      {
        "t": "以下哪個策略最符合這個目標。",
        "en": "Which strategy best matches this goal.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 用 Map 計數後把所有元素按頻率排序，再取前 k 個。",
        "en": "(A) Count with a Map, sort all elements by frequency, then take top k.",
        "wg": []
      },
      {
        "t": "(B) 用 Map 計數後用桶排序，buckets[f] 存放頻率為 f 的元素，從高到低取 k 個。",
        "en": "(B) Count with a Map, then bucket sort: buckets[f] holds elements with frequency f, scan from high to low to take k.",
        "wg": [
          { "t": "桶排序", "en": "bucket sort", "ps": "N" }
        ]
      },
      {
        "t": "(C) 對原陣列做 quickselect，直接找第 k 大的值。",
        "en": "(C) Run quickselect on the original array to find the k-th largest value.",
        "wg": []
      },
      {
        "t": "(D) 用 Set 去重後回傳前 k 個不同元素。",
        "en": "(D) Deduplicate with a Set and return the first k distinct elements.",
        "wg": [
          { "t": "去重", "en": "deduplicate", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "桶排序利用頻率上限是 n 的特性，可以在 O(n) 內完成分桶與反向掃描。全排序通常是 O(m log m)，其中 m 是不同元素數，未必接近 O(n)。Quickselect 針對值大小而非頻率，問題模型不匹配。Set 去重不會考慮頻率，因此答案不正確。",
      "en": "Bucket sort leverages the fact that frequency is at most n, enabling O(n) bucketing and a reverse scan. Full sorting is typically O(m log m) where m is the number of distinct elements, not necessarily close to O(n). Quickselect targets value order, not frequency, so it mismatches the problem. Set dedup ignores frequency, so it is incorrect.",
      "wg": [
        { "t": "分桶", "en": "bucketing", "ps": "N" },
        { "t": "問題模型", "en": "problem model", "ps": "N" },
        { "t": "不匹配", "en": "mismatch", "ps": "V" }
      ]
    }
  },
  {
    "no": "6",
    "level": "hard",
    "keywords": "Exactly K Distinct, Sliding Window, At Most K, Frequency Map",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要計算恰好包含 K 種不同整數的子陣列數量。",
        "en": "You need to count subarrays that contain exactly K distinct integers.",
        "wg": [
          { "t": "恰好", "en": "exactly", "ps": "Adv" },
          { "t": "不同整數", "en": "distinct integers", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個等式最常用且可把問題轉為兩次 atMost 計算。",
        "en": "Which identity is most commonly used to reduce this into two atMost computations.",
        "wg": [
          { "t": "等式", "en": "identity", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) exactly(K) = atMost(K) + atMost(K-1)。",
        "en": "(A) exactly(K) = atMost(K) + atMost(K-1).",
        "wg": []
      },
      {
        "t": "(B) exactly(K) = atMost(K) - atMost(K-1)。",
        "en": "(B) exactly(K) = atMost(K) - atMost(K-1).",
        "wg": []
      },
      {
        "t": "(C) exactly(K) = atLeast(K) - atLeast(K+1)。",
        "en": "(C) exactly(K) = atLeast(K) - atLeast(K+1).",
        "wg": []
      },
      {
        "t": "(D) exactly(K) = totalSubarrays - atMost(K-1)。",
        "en": "(D) exactly(K) = totalSubarrays - atMost(K-1).",
        "wg": [
          { "t": "總子陣列", "en": "total subarrays", "ps": "N" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "恰好 K 種不同元素等於「至多 K」減去「至多 K-1」，因為後者正好覆蓋了所有不足 K 的情況。選項 (A) 會雙重計數。選項 (C) 也可成立但需要 atLeast 的實作，面試中更常用 atMost 版。選項 (D) 無法排除包含超過 K 的子陣列，因此不正確。",
      "en": "Exactly K distinct equals “at most K” minus “at most K-1,” because the latter precisely covers all cases with fewer than K distinct values. Option (A) double-counts. Option (C) can be valid but requires implementing atLeast; interviews more commonly use the atMost version. Option (D) cannot exclude subarrays with more than K distinct values, so it’s incorrect.",
      "wg": [
        { "t": "雙重計數", "en": "double-count", "ps": "V" },
        { "t": "覆蓋", "en": "cover", "ps": "V" },
        { "t": "排除", "en": "exclude", "ps": "V" }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Longest Consecutive Sequence, Set, Start Detection",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要在未排序陣列中找最長連續整數序列長度，並允許 O(n) 解法。",
        "en": "You need the longest consecutive integer sequence length in an unsorted array, allowing an O(n) solution.",
        "wg": [
          { "t": "未排序", "en": "unsorted", "ps": "Adj" },
          { "t": "連續整數序列", "en": "consecutive integer sequence", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個策略能避免重複延伸並保證總時間是線性。",
        "en": "Which strategy avoids repeated expansions and guarantees overall linear time.",
        "wg": [
          { "t": "重複延伸", "en": "repeated expansion", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先排序陣列再線性掃描。",
        "en": "(A) Sort the array first, then scan linearly.",
        "wg": []
      },
      {
        "t": "(B) 把所有數放進 Set，只從滿足 x-1 不在 Set 的 x 開始向上延伸。",
        "en": "(B) Put all numbers into a Set, and only expand upward from x where x-1 is not in the Set.",
        "wg": [
          { "t": "向上延伸", "en": "expand upward", "ps": "V" }
        ]
      },
      {
        "t": "(C) 對每個數都從它開始 while x+1 存在就延伸。",
        "en": "(C) For every number, expand while x+1 exists starting from it.",
        "wg": []
      },
      {
        "t": "(D) 用 Map 記錄每個數的索引並做二分搜尋連續段。",
        "en": "(D) Record indices in a Map and binary search for runs.",
        "wg": [
          { "t": "二分搜尋", "en": "binary search", "ps": "N" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "只從「序列起點」擴展可確保每個元素最多被走訪常數次，因此總時間為 O(n)。排序法是 O(n log n)，不符合線性目標。對每個元素都擴展會在長序列上退化到 O(n^2)。索引與二分不必要且難以保證線性。",
      "en": "Expanding only from “sequence starts” ensures each element is visited O(1) times overall, giving O(n) total time. Sorting is O(n log n), missing the linear goal. Expanding from every element can degrade to O(n^2) on long runs. Indexing with binary search is unnecessary and does not guarantee linear time.",
      "wg": [
        { "t": "序列起點", "en": "sequence start", "ps": "N" },
        { "t": "退化", "en": "degrade", "ps": "V" },
        { "t": "走訪", "en": "visit/traverse", "ps": "V" }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "2D Submatrix, Row Compression, Prefix Sum, Hash Map",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要計算矩陣中和為 target 的子矩形數量。",
        "en": "You need to count submatrices whose sum equals target.",
        "wg": [
          { "t": "子矩形", "en": "submatrix/sub-rectangle", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個方法最標準且能把問題轉成多次的一維 subarray sum 計數。",
        "en": "Which method is standard and reduces the problem into repeated 1D subarray-sum counting.",
        "wg": [
          { "t": "轉成", "en": "reduce into", "ps": "V" },
          { "t": "一維", "en": "one-dimensional", "ps": "Adj" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個子矩形做四層迴圈並直接累加。",
        "en": "(A) Use four nested loops and sum each submatrix directly.",
        "wg": []
      },
      {
        "t": "(B) 固定左與右邊界，對每一列做前綴和後用二分找 target。",
        "en": "(B) Fix left/right boundaries, compute per-row prefix sums, then binary search for target.",
        "wg": [
          { "t": "邊界", "en": "boundary", "ps": "N" }
        ]
      },
      {
        "t": "(C) 固定上與下邊界，把每一欄的和壓縮成一維陣列，然後用 prefix sum + hash 計數等於 target 的子陣列。",
        "en": "(C) Fix top/bottom boundaries, compress column sums into a 1D array, then use prefix sum + hash to count subarrays equal to target.",
        "wg": [
          { "t": "壓縮", "en": "compress", "ps": "V" }
        ]
      },
      {
        "t": "(D) 先把矩陣所有元素排序後再用 two pointers 找到 target。",
        "en": "(D) Sort all matrix values and use two pointers to find target.",
        "wg": [
          { "t": "two pointers", "en": "two pointers", "ps": "N" }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "固定上下邊界可把 2D 子矩形和轉為「欄向量」的一維子陣列和問題，再用 prefix sum + frequency map 在 O(C) 內計數，總體是 O(R^2 * C)。四層迴圈通常是 O(R^2 * C^2) 太慢。二分不適用於包含負數的子陣列和。排序會破壞連續子矩形的結構。",
      "en": "Fixing top/bottom boundaries turns each 2D submatrix sum into a 1D subarray-sum over compressed column totals, then prefix sum + frequency map counts in O(C) per boundary pair, totaling O(R^2 * C). Four loops are typically O(R^2 * C^2) and too slow. Binary search doesn’t apply to subarray sums with negatives. Sorting destroys the contiguity structure of submatrices.",
      "wg": [
        { "t": "欄向量", "en": "column vector", "ps": "N" },
        { "t": "總體", "en": "overall", "ps": "Adv" },
        { "t": "結構", "en": "structure", "ps": "N" }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Two Sum, Hash Map, Single Pass, Indices",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要回傳 Two Sum 的兩個索引，並保證同一元素不能使用兩次。",
        "en": "You must return Two Sum indices, ensuring the same element is not used twice.",
        "wg": [
          { "t": "索引", "en": "index", "ps": "N" },
          { "t": "不能使用兩次", "en": "cannot be used twice", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個一趟掃描策略最正確。",
        "en": "Which one-pass strategy is most correct.",
        "wg": [
          { "t": "一趟掃描", "en": "one-pass scan", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先把所有數放進 Map，再第二趟找 target-x 是否存在。",
        "en": "(A) Insert all values into a Map first, then do a second pass to check if target-x exists.",
        "wg": []
      },
      {
        "t": "(B) 一邊掃描，一邊先查 complement 是否在 Map，若在就回傳；否則把當前值與索引放入 Map。",
        "en": "(B) Scan once: first check whether the complement is in the Map; if yes return; otherwise store current value and index in the Map.",
        "wg": [
          { "t": "complement", "en": "complement", "ps": "N" }
        ]
      },
      {
        "t": "(C) 一邊掃描，一邊先把當前值放入 Map，再查 complement 是否在 Map。",
        "en": "(C) Scan once: first store the current value in the Map, then check whether the complement is in the Map.",
        "wg": []
      },
      {
        "t": "(D) 先排序陣列用 two pointers 找到後再回推索引。",
        "en": "(D) Sort and use two pointers, then backtrack to original indices.",
        "wg": [
          { "t": "回推", "en": "backtrack", "ps": "V" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "先查 complement 再寫入可避免在 target=2x 時把同一元素配對到自己。選項 (C) 可能在同一位置就命中 complement 而錯用同一元素。兩趟法 (A) 若 Map 只存一個索引，會被重複值覆蓋而出錯。排序回推索引可行但額外 O(n log n) 且實作更複雜。",
      "en": "Checking the complement before insertion prevents pairing an element with itself when target=2x. Option (C) can hit the complement at the same position and reuse the same element incorrectly. The two-pass approach (A) can fail if the Map stores only one index and gets overwritten by duplicates. Sorting with backtracking can work but costs O(n log n) and is more complex.",
      "wg": [
        { "t": "覆蓋", "en": "overwrite", "ps": "V" },
        { "t": "重複值", "en": "duplicate values", "ps": "N" },
        { "t": "實作更複雜", "en": "more complex to implement", "ps": "Adj" }
      ]
    }
  },
  {
    "no": "10",
    "level": "hard",
    "keywords": "Key Packing, Tuple Hashing, BigInt, Collision Avoidance",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要把二元組 (a,b) 當作 Map key，且希望避免大量字串分配造成的 GC 壓力。",
        "en": "You want to use a tuple (a,b) as a Map key and avoid heavy string allocations that cause GC pressure.",
        "wg": [
          { "t": "二元組", "en": "tuple/pair", "ps": "N" },
          { "t": "字串分配", "en": "string allocation", "ps": "N" },
          { "t": "GC 壓力", "en": "GC pressure", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個方案在 JS/TS 中最可靠且可控。",
        "en": "Which approach is most reliable and controllable in JS/TS.",
        "wg": [
          { "t": "可控", "en": "controllable", "ps": "Adj" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接用物件 {a,b} 當 key，因為內容相同會自動視為相同 key。",
        "en": "(A) Use an object {a,b} as the key, because identical contents will be treated as the same key.",
        "wg": []
      },
      {
        "t": "(B) 用 BigInt 做 64-bit packing，例如 key = (BigInt(a) << 32n) ^ BigInt(b)，並確保 a,b 落在 32-bit 範圍。",
        "en": "(B) Use BigInt 64-bit packing, e.g., key = (BigInt(a) << 32n) ^ BigInt(b), ensuring a,b fit in 32-bit range.",
        "wg": [
          { "t": "64-bit packing", "en": "64-bit packing", "ps": "N" },
          { "t": "範圍", "en": "range", "ps": "N" }
        ]
      },
      {
        "t": "(C) 用 Number 做 key = a * 1e9 + b，因為 Number 足夠大不會碰撞。",
        "en": "(C) Use Number key = a * 1e9 + b, because Number is large enough to avoid collisions.",
        "wg": [
          { "t": "不會碰撞", "en": "collision-free", "ps": "Adj" }
        ]
      },
      {
        "t": "(D) 用 JSON.stringify([a,b])，因為 JSON.stringify 不會分配新字串。",
        "en": "(D) Use JSON.stringify([a,b]), because JSON.stringify does not allocate new strings.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 JS/TS 中物件作為 Map key 是以參考相等判斷，內容相同不代表同 key。用 Number 做線性組合可能超出安全整數或因選擇係數不當而碰撞。JSON.stringify 會產生新字串並帶來分配成本。BigInt packing 在你能保證位寬與範圍時可做到可預測且低碰撞的 tuple key。",
      "en": "In JS/TS, objects used as Map keys are compared by reference, so identical contents do not imply the same key. A linear Number combination can exceed safe-integer range or collide if the multiplier is poorly chosen. JSON.stringify allocates new strings and adds allocation cost. BigInt packing is predictable and low-collision when you can guarantee bit width and bounds.",
      "wg": [
        { "t": "參考相等", "en": "reference equality", "ps": "N" },
        { "t": "安全整數", "en": "safe integer", "ps": "N" },
        { "t": "可預測", "en": "predictable", "ps": "Adj" }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Contiguous Array, Prefix Sum, Earliest Index, Map",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你要找出 0/1 陣列中 0 與 1 數量相同的最長連續子陣列長度。",
        "en": "You need the longest contiguous subarray with equal numbers of 0s and 1s in a binary array.",
        "wg": [
          { "t": "最長連續子陣列", "en": "longest contiguous subarray", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個 Map 儲存策略最關鍵且正確。",
        "en": "Which Map storage strategy is the key and correct one.",
        "wg": [
          { "t": "儲存策略", "en": "storage strategy", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Map 存 prefixSum 的最新索引，確保更新到最新資訊。",
        "en": "(A) Store the latest index for each prefixSum to keep information fresh.",
        "wg": [
          { "t": "最新索引", "en": "latest index", "ps": "N" }
        ]
      },
      {
        "t": "(B) Map 存 prefixSum 的最早索引，只在第一次出現時寫入。",
        "en": "(B) Store the earliest index for each prefixSum, writing only on first occurrence.",
        "wg": [
          { "t": "最早索引", "en": "earliest index", "ps": "N" }
        ]
      },
      {
        "t": "(C) 用 Set 存 prefixSum 即可，因為只需要知道是否出現過。",
        "en": "(C) A Set of prefix sums is sufficient; you only need to know if it appeared.",
        "wg": []
      },
      {
        "t": "(D) 先排序陣列再做 prefixSum 會得到最長區間。",
        "en": "(D) Sorting before prefixSum will yield the longest interval.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "要最大化長度，你需要同一 prefixSum 的最早位置，因為最早到當前的距離最長。存最新索引會縮短可形成的最大距離。Set 只能判斷存在性，無法計算距離。排序會破壞連續性定義。",
      "en": "To maximize length, you need the earliest position of the same prefixSum, because earliest-to-current gives the longest distance. Storing the latest index shortens the maximum attainable span. A Set provides membership only and cannot compute distances. Sorting breaks contiguity definition.",
      "wg": [
        { "t": "最大化", "en": "maximize", "ps": "V" },
        { "t": "距離", "en": "distance/span", "ps": "N" },
        { "t": "連續性", "en": "contiguity", "ps": "N" }
      ]
    }
  },
  {
    "no": "12",
    "level": "hard",
    "keywords": "Subarray Sum, BigInt, Safe Integer, TypeScript",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你在 TS 中做 prefix sum 計數，但輸入值與長度可能讓累積和超過 2^53-1。",
        "en": "You are doing prefix-sum counting in TS, but values and length may push cumulative sums beyond 2^53-1.",
        "wg": [
          { "t": "累積和", "en": "cumulative sum", "ps": "N" },
          { "t": "超過", "en": "exceed", "ps": "V" }
        ]
      },
      {
        "t": "以下哪個做法最能維持正確性。",
        "en": "Which approach best preserves correctness.",
        "wg": [
          { "t": "維持正確性", "en": "preserve correctness", "ps": "V" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 繼續用 number，因為 Map 會自動處理精度問題。",
        "en": "(A) Keep using number because Map will handle precision automatically.",
        "wg": [
          { "t": "精度問題", "en": "precision issue", "ps": "N" }
        ]
      },
      {
        "t": "(B) 改用 BigInt 做累加與 key，並且把 k 也轉成 BigInt 做運算。",
        "en": "(B) Use BigInt for accumulation and keys, and convert k to BigInt as well for operations.",
        "wg": [
          { "t": "改用", "en": "switch to", "ps": "V" }
        ]
      },
      {
        "t": "(C) 用 Math.round(prefix) 讓 number 變回整數。",
        "en": "(C) Use Math.round(prefix) to turn number back into an integer.",
        "wg": []
      },
      {
        "t": "(D) 用 prefix.toString() 當 key 就能避免精度問題。",
        "en": "(D) Using prefix.toString() as the key avoids precision issues.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "超過安全整數範圍時 number 會失去整數精確性，導致不同前綴和被視為相同或相反。BigInt 能保持精確加法並可作為 Map key，但需要避免與 number 混用。四捨五入與字串化都建立在已經失真的值上，無法恢復正確性。",
      "en": "Beyond the safe-integer range, number loses integer exactness, causing distinct prefix sums to collapse or drift. BigInt preserves exact addition and can be used as a Map key, but you must avoid mixing it with number. Rounding or stringifying operates on already-corrupted values and cannot restore correctness.",
      "wg": [
        { "t": "安全整數範圍", "en": "safe-integer range", "ps": "N" },
        { "t": "失真", "en": "distortion", "ps": "N" },
        { "t": "混用", "en": "mix types", "ps": "V" }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Hash Map vs Object, Prototype, Performance, Key Types",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你在 TS/JS 中需要做大量 key 查找與更新，key 可能是 number 且數量很大。",
        "en": "In TS/JS, you need heavy key lookups/updates, and keys may be numbers with large cardinality.",
        "wg": [
          { "t": "查找與更新", "en": "lookup and update", "ps": "N" },
          { "t": "數量很大", "en": "large cardinality", "ps": "Adj" }
        ]
      },
      {
        "t": "以下哪個結構通常更合適且語義更清晰。",
        "en": "Which structure is typically more suitable and semantically clearer.",
        "wg": [
          { "t": "語義更清晰", "en": "semantically clearer", "ps": "Adj" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用一般物件 {}，因為物件對任何 key 都是 O(1)。",
        "en": "(A) Use a plain object {}, because objects are O(1) for any key.",
        "wg": []
      },
      {
        "t": "(B) 使用 Map<number, number>，因為它對非字串 key 更自然並避免原型鏈陷阱。",
        "en": "(B) Use Map<number, number>, because it naturally supports non-string keys and avoids prototype-chain pitfalls.",
        "wg": [
          { "t": "原型鏈陷阱", "en": "prototype-chain pitfalls", "ps": "N" }
        ]
      },
      {
        "t": "(C) 使用 WeakMap，因為它會自動釋放 key 記憶體。",
        "en": "(C) Use WeakMap, because it automatically frees key memory.",
        "wg": []
      },
      {
        "t": "(D) 使用 Array 並用 key 當索引，不管 key 有多大都沒問題。",
        "en": "(D) Use an Array and use keys as indices; it’s fine no matter how large keys are.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Map 對 number key 的語義更直接，並且避免物件 key 被字串化與原型屬性干擾。WeakMap 只接受物件 key，不適用 number。用 Array 當索引只有在 key 稠密且範圍不大時合理，否則會造成巨大稀疏陣列與記憶體浪費。",
      "en": "Map provides direct semantics for number keys and avoids object-key stringification and prototype property interference. WeakMap only accepts object keys, so it doesn’t work for numbers. Using an Array as an index is only reasonable when keys are dense and bounded; otherwise it creates huge sparse arrays and wastes memory.",
      "wg": [
        { "t": "字串化", "en": "stringification", "ps": "N" },
        { "t": "稀疏陣列", "en": "sparse array", "ps": "N" },
        { "t": "記憶體浪費", "en": "memory waste", "ps": "N" }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Collision, Delimiter, Serialization, Anagram Signature",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你用計數向量做 key 來分組字串，但同事提議用 counts.join(\"\") 以省下分隔符。",
        "en": "You use a count-vector key to group strings, but a teammate suggests counts.join(\"\") to avoid delimiters.",
        "wg": [
          { "t": "省下", "en": "save/omit", "ps": "V" },
          { "t": "分隔符", "en": "delimiter", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個反例最能說明 counts.join(\"\") 可能碰撞。",
        "en": "Which counterexample best shows counts.join(\"\") can collide.",
        "wg": [
          { "t": "反例", "en": "counterexample", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [1,0,0] 與 [0,1,0] 會產生不同字串。",
        "en": "(A) [1,0,0] and [0,1,0] produce different strings.",
        "wg": []
      },
      {
        "t": "(B) [1,11] 與 [11,1] 都可能序列化成 \"111\"。",
        "en": "(B) [1,11] and [11,1] can both serialize to \"111\".",
        "wg": [
          { "t": "序列化", "en": "serialize", "ps": "V" }
        ]
      },
      {
        "t": "(C) [2,2] 與 [2,2] 會產生同字串。",
        "en": "(C) [2,2] and [2,2] produce the same string.",
        "wg": []
      },
      {
        "t": "(D) [0,0,0] 與 [0,0] 長度不同所以不可能碰撞。",
        "en": "(D) [0,0,0] and [0,0] have different lengths so they cannot collide.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "join(\"\") 沒有邊界資訊，會把多位數的切分點消失，因此不同向量可能映射到同一字串。選項 (B) 展示了最典型的歧義。選項 (A) 只是說明不一定碰撞，但不能保證永不碰撞。選項 (D) 依賴長度資訊但 Map key 不會自動保留原始向量長度，且在固定 26 維場景之外仍可能出錯。",
      "en": "join(\"\") lacks boundary information, so digit splits disappear and different vectors can map to the same string. Option (B) shows the canonical ambiguity. Option (A) only shows it won’t always collide, but it doesn’t guarantee collision-freedom. Option (D) relies on length, but Map keys don’t preserve original vector length automatically, and outside a fixed 26-dim setup it can still fail.",
      "wg": [
        { "t": "邊界資訊", "en": "boundary information", "ps": "N" },
        { "t": "歧義", "en": "ambiguity", "ps": "N" },
        { "t": "保證", "en": "guarantee", "ps": "V" }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Subarray Count, Frequency vs Seen, Correctness Proof, Invariant",
    "parentNo": null,
    "images": null,
    "question": [
      {
        "t": "你在面試中被問到為什麼 prefix-sum 類題需要 Map 記錄「次數」而不是「是否出現過」。",
        "en": "In an interview, you are asked why prefix-sum problems need a Map of frequencies rather than a seen/not-seen flag.",
        "wg": [
          { "t": "是否出現過", "en": "seen/not-seen", "ps": "N" },
          { "t": "面試", "en": "interview", "ps": "N" }
        ]
      },
      {
        "t": "以下哪個敘述最能構成正確性論證的核心。",
        "en": "Which statement best forms the core of a correctness argument.",
        "wg": [
          { "t": "正確性論證", "en": "correctness argument", "ps": "N" }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為 Map 比 Set 更快，所以一定要用 Map。",
        "en": "(A) Because Map is faster than Set, you must use Map.",
        "wg": []
      },
      {
        "t": "(B) 因為同一個 prefix 值可能出現多次，而每一次都代表不同的起點會形成不同的有效子陣列。",
        "en": "(B) Because the same prefix value can occur multiple times, and each occurrence represents a distinct start index that forms a different valid subarray.",
        "wg": [
          { "t": "有效子陣列", "en": "valid subarray", "ps": "N" }
        ]
      },
      {
        "t": "(C) 因為 Set 不能存 number key，所以只能用 Map。",
        "en": "(C) Because Set cannot store number keys, you must use Map.",
        "wg": []
      },
      {
        "t": "(D) 因為只要記錄最新的 prefix 就足夠，歷史不重要。",
        "en": "(D) Because keeping only the latest prefix is enough; history does not matter.",
        "wg": [
          { "t": "歷史不重要", "en": "history does not matter", "ps": "N" }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "prefix-sum 計數的本質是配對「所有」符合條件的歷史前綴，因此需要記錄每個前綴值出現的次數。只記 seen 會把多個起點折疊成一個，導致少算。效能並不是論證核心，且 Set 可存 number。只留最新 prefix 會遺失可配對的歷史資訊，直接破壞不變量。",
      "en": "Prefix-sum counting is fundamentally about pairing with “all” historical prefixes that satisfy the condition, so you must track how many times each prefix value occurred. A seen-only flag collapses multiple start indices into one and undercounts. Performance is not the core argument, and Set can store number keys. Keeping only the latest prefix discards pairable history and breaks the invariant.",
      "wg": [
        { "t": "配對", "en": "pairing", "ps": "N" },
        { "t": "折疊", "en": "collapse", "ps": "V" },
        { "t": "不變量", "en": "invariant", "ps": "N" }
      ]
    }
  }
]