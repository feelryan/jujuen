[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Dynamic Array, Time Complexity, Resizing, Amortized Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "動態陣列（如 Java 的 ArrayList 或 C++ 的 std::vector）在新增元素時提供攤銷後的 O(1) 時間複雜度。",
        "en": "Dynamic arrays (such as Java's ArrayList or C++'s std::vector) provide amortized O(1) time complexity when adding elements.",
        "wg": [
          {
            "t": "動態陣列",
            "en": "dynamic array",
            "ps": "N"
          },
          {
            "t": "攤銷",
            "en": "amortized",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "然而，當陣列達到其當前容量上限時，必須進行調整大小的操作。",
        "en": "However, when the array reaches its current capacity limit, a resizing operation must occur.",
        "wg": [
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          },
          {
            "t": "調整大小",
            "en": "resizing",
            "ps": "Gerund"
          }
        ]
      },
      {
        "t": "請問觸發調整大小的那一次插入操作，其最差時間複雜度是多少？",
        "en": "What is the worst-case time complexity of the specific insertion operation that triggers this resize?",
        "wg": [
          {
            "t": "最差時間複雜度",
            "en": "worst-case time complexity",
            "ps": "N"
          },
          {
            "t": "觸發",
            "en": "trigger",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log n)",
        "en": "(B) O(log n)",
        "wg": []
      },
      {
        "t": "(C) O(n)",
        "en": "(C) O(n)",
        "wg": []
      },
      {
        "t": "(D) O(n log n)",
        "en": "(D) O(n log n)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當動態陣列需要擴充時，它必須分配一個更大的新記憶體區塊（通常是原本的兩倍），並將所有現有的 n 個元素複製過去，這個複製過程需要 O(n) 的時間。",
      "en": "When a dynamic array needs to expand, it must allocate a new, larger block of memory (usually double the size) and copy all existing n elements to it, which takes O(n) time.",
      "wg": [
        {
          "t": "分配",
          "en": "allocate",
          "ps": "V"
        },
        {
          "t": "複製",
          "en": "copy",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Hash Map, Collision, Separate Chaining, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在雜湊表（Hash Map）的實作中，「碰撞」是指兩個不同的鍵（Key）經過雜湊函數計算後得到相同的索引。",
        "en": "In a Hash Map implementation, a 'collision' occurs when two different keys map to the same index after being processed by the hash function.",
        "wg": [
          {
            "t": "碰撞",
            "en": "collision",
            "ps": "N"
          },
          {
            "t": "雜湊函數",
            "en": "hash function",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用「分離鏈結法（Separate Chaining）」來處理碰撞，下列敘述何者正確？",
        "en": "If 'Separate Chaining' is used to handle collisions, which of the following statements is true?",
        "wg": [
          {
            "t": "分離鏈結法",
            "en": "separate chaining",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 新的元素會覆蓋舊的元素。",
        "en": "(A) The new element overwrites the old element.",
        "wg": [
          {
            "t": "覆蓋",
            "en": "overwrite",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 雜湊表會立即重新調整大小以消除碰撞。",
        "en": "(B) The hash map immediately resizes to eliminate the collision.",
        "wg": []
      },
      {
        "t": "(C) 發生碰撞的元素會被儲存在同一個桶（Bucket）中的鏈結串列或樹狀結構裡。",
        "en": "(C) Colliding elements are stored in a linked list or tree structure within the same bucket.",
        "wg": [
          {
            "t": "桶",
            "en": "bucket",
            "ps": "N"
          },
          {
            "t": "鏈結串列",
            "en": "linked list",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 演算法會尋找下一個可用的空插槽（Open Addressing）。",
        "en": "(D) The algorithm searches for the next available empty slot (Open Addressing).",
        "wg": [
          {
            "t": "空插槽",
            "en": "empty slot",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "分離鏈結法透過在每個雜湊索引處維護一個資料結構（如鏈結串列）來儲存所有雜湊到該位置的元素，選項 (D) 描述的是開放定址法（Open Addressing）。",
      "en": "Separate chaining maintains a data structure (like a linked list) at each hash index to store all elements hashing to that location; option (D) describes Open Addressing.",
      "wg": [
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "開放定址法",
          "en": "open addressing",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "easy",
    "keywords": "Two Sum, Hash Map, Optimization, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]",
    "question": [
      {
        "t": "在解決「兩數之和（Two Sum）」問題時，我們希望將時間複雜度從暴力解法的 O(n^2) 優化到 O(n)。",
        "en": "When solving the 'Two Sum' problem, we aim to optimize the time complexity from the brute-force O(n^2) to O(n).",
        "wg": [
          {
            "t": "暴力解法",
            "en": "brute-force",
            "ps": "Adj"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了達成此目標，我們通常使用雜湊表（Hash Map）。",
        "en": "To achieve this, we typically use a Hash Map.",
        "wg": []
      },
      {
        "t": "請問在遍歷陣列時，我們應該在雜湊表中儲存什麼資訊作為 Key 和 Value？",
        "en": "When iterating through the array, what information should we store as the Key and Value in the Hash Map?",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Key: 索引 (Index), Value: 數值 (Number)",
        "en": "(A) Key: Index, Value: Number",
        "wg": []
      },
      {
        "t": "(B) Key: 數值 (Number), Value: 索引 (Index)",
        "en": "(B) Key: Number, Value: Index",
        "wg": []
      },
      {
        "t": "(C) Key: 目標值減去數值 (Target - Number), Value: 數值 (Number)",
        "en": "(C) Key: Target - Number, Value: Number",
        "wg": []
      },
      {
        "t": "(D) Key: 數值 (Number), Value: 該數值出現的次數 (Count)",
        "en": "(D) Key: Number, Value: Count of occurrences",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們需要快速查詢「補數」（Target - Current Number）是否存在，因此將數值當作 Key 以利用 O(1) 的查詢特性，並將索引當作 Value 以便回傳答案。",
      "en": "We need to quickly check if the 'complement' (Target - Current Number) exists, so we use the number as the Key for O(1) lookup and the index as the Value to return the answer.",
      "wg": [
        {
          "t": "補數",
          "en": "complement",
          "ps": "N"
        },
        {
          "t": "查詢",
          "en": "lookup",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Anagram, Frequency Array, Space Complexity, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "題目要求判斷兩個字串是否為「異位構詞（Anagram）」，且已知輸入僅包含小寫英文字母（a-z）。",
        "en": "The problem asks to determine if two strings are 'Anagrams', and it is known that the input contains only lowercase English letters (a-z).",
        "wg": [
          {
            "t": "異位構詞",
            "en": "anagram",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於使用通用的 Hash Map，為什麼使用長度為 26 的整數陣列（Frequency Array）通常是較佳的選擇？",
        "en": "Compared to using a generic Hash Map, why is using an integer array of length 26 (Frequency Array) often a better choice?",
        "wg": [
          {
            "t": "通用",
            "en": "generic",
            "ps": "Adj"
          },
          {
            "t": "頻率陣列",
            "en": "frequency array",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 陣列的時間複雜度是 O(log n)，而 Hash Map 是 O(1)。",
        "en": "(A) The time complexity of an array is O(log n), while a Hash Map is O(1).",
        "wg": []
      },
      {
        "t": "(B) 陣列可以處理 Unicode 字元，而 Hash Map 不行。",
        "en": "(B) Arrays can handle Unicode characters, while Hash Maps cannot.",
        "wg": []
      },
      {
        "t": "(C) 陣列減少了雜湊計算的開銷與記憶體負擔，且空間複雜度為常數 O(1)。",
        "en": "(C) The array reduces hashing overhead and memory usage, and the space complexity is constant O(1).",
        "wg": [
          {
            "t": "開銷",
            "en": "overhead",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 陣列會自動排序字元，簡化比較過程。",
        "en": "(D) The array automatically sorts the characters, simplifying the comparison process.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "由於字元集範圍固定且很小（26個字母），直接使用陣列索引存取比計算雜湊函數更快，且沒有 Hash Map 的額外物件結構開銷。",
      "en": "Since the character set is fixed and small (26 letters), direct array index access is faster than computing hash functions and avoids the extra object structure overhead of a Hash Map.",
      "wg": [
        {
          "t": "字元集",
          "en": "character set",
          "ps": "N"
        },
        {
          "t": "存取",
          "en": "access",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "easy",
    "keywords": "Contains Duplicate, HashSet, Time Complexity, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, 2, 3, 1]",
    "question": [
      {
        "t": "給定一個整數陣列，如果任一數值在陣列中出現至少兩次，則回傳 true。",
        "en": "Given an integer array, return true if any value appears at least twice in the array.",
        "wg": [
          {
            "t": "至少",
            "en": "at least",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "若要以最有效率的時間複雜度 O(n) 完成此檢查，應該選用哪種資料結構？",
        "en": "To complete this check with the most efficient time complexity O(n), which data structure should be used?",
        "wg": [
          {
            "t": "有效率",
            "en": "efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) ArrayList (動態陣列)",
        "en": "(A) ArrayList",
        "wg": []
      },
      {
        "t": "(B) HashSet (雜湊集合)",
        "en": "(B) HashSet",
        "wg": [
          {
            "t": "雜湊集合",
            "en": "hash set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Stack (堆疊)",
        "en": "(C) Stack",
        "wg": []
      },
      {
        "t": "(D) Priority Queue (優先佇列)",
        "en": "(D) Priority Queue",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "HashSet 支援平均 O(1) 的插入與查詢操作，讓我們能在遍歷陣列時快速檢查元素是否已存在。ArrayList 的查詢為 O(n)，會導致總時間變為 O(n^2)。",
      "en": "HashSet supports average O(1) insertion and lookup operations, allowing us to quickly check if an element already exists while iterating. ArrayList lookup is O(n), which would result in a total time of O(n^2).",
      "wg": [
        {
          "t": "插入",
          "en": "insertion",
          "ps": "N"
        },
        {
          "t": "查詢",
          "en": "lookup",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Hash Table, Collision Resolution, Chaining, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在設計雜湊表（Hash Table）時，當兩個不同的鍵（Keys）經過雜湊函數計算後得到相同的索引值，這種情況稱為什麼？",
        "en": "In Hash Table design, what is the situation called when two different keys yield the same index after being processed by the hash function?",
        "wg": [
          {
            "t": "雜湊函數",
            "en": "hash function",
            "ps": "N"
          },
          {
            "t": "索引值",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "此外，下列哪一種機制是解決此問題的常見方法，透過在該索引位置維護一個連結串列來儲存多個項目？",
        "en": "Furthermore, which of the following mechanisms is a common method to resolve this issue by maintaining a linked list at that index to store multiple items?",
        "wg": [
          {
            "t": "機制",
            "en": "mechanism",
            "ps": "N"
          },
          {
            "t": "連結串列",
            "en": "linked list",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 死結 (Deadlock)；使用開放定址法 (Open Addressing)。",
        "en": "(A) Deadlock; use Open Addressing.",
        "wg": []
      },
      {
        "t": "(B) 碰撞 (Collision)；使用鏈結法 (Chaining)。",
        "en": "(B) Collision; use Chaining.",
        "wg": [
          {
            "t": "碰撞",
            "en": "collision",
            "ps": "N"
          },
          {
            "t": "鏈結法",
            "en": "chaining",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 溢位 (Overflow)；使用動態陣列 (Dynamic Array)。",
        "en": "(C) Overflow; use Dynamic Array.",
        "wg": []
      },
      {
        "t": "(D) 分段錯誤 (Segmentation Fault)；使用遞迴 (Recursion)。",
        "en": "(D) Segmentation Fault; use Recursion.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當不同的鍵映射到同一個索引時，稱為「碰撞」。鏈結法 (Chaining) 透過在每個桶 (Bucket) 中儲存一個連結串列來解決此問題，允許同一位置存放多個元素。",
      "en": "When different keys map to the same index, it is called a 'collision'. Chaining resolves this by storing a linked list in each bucket, allowing multiple elements to exist at the same location.",
      "wg": [
        {
          "t": "映射",
          "en": "map",
          "ps": "V"
        },
        {
          "t": "桶",
          "en": "bucket",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Arrays, Hashing, Anagram, Sorting, Frequency Count",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"anagram\", t = \"nagaram\"",
    "question": [
      {
        "t": "給定兩個字串 `s` 和 `t`，您需要判斷 `t` 是否為 `s` 的重組字 (Anagram)。",
        "en": "Given two strings `s` and `t`, you need to determine if `t` is an anagram of `s`.",
        "wg": [
          {
            "t": "重組字",
            "en": "anagram",
            "ps": "N"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若僅考慮時間複雜度，下列哪種方法在字串長度極長時通常最為高效？",
        "en": "Considering only time complexity, which of the following methods is generally most efficient when the string length is very long?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "高效",
            "en": "efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將兩個字串分別排序後比較，時間複雜度為 O(N log N)。",
        "en": "(A) Sort both strings and compare them, with a time complexity of O(N log N).",
        "wg": []
      },
      {
        "t": "(B) 使用兩個巢狀迴圈比對每個字元，時間複雜度為 O(N^2)。",
        "en": "(B) Use two nested loops to compare each character, with a time complexity of O(N^2).",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用雜湊表或固定大小的陣列計算字元頻率，時間複雜度為 O(N)。",
        "en": "(C) Use a hash map or a fixed-size array to count character frequencies, with a time complexity of O(N).",
        "wg": [
          {
            "t": "字元頻率",
            "en": "character frequencies",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 產生 `s` 的所有可能排列組合並檢查是否包含 `t`，時間複雜度為 O(N!)。",
        "en": "(D) Generate all possible permutations of `s` and check if `t` is included, with a time complexity of O(N!).",
        "wg": [
          {
            "t": "排列組合",
            "en": "permutations",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雖然排序法 (A) 實作簡單且空間複雜度較低，但其時間複雜度受限於排序演算法 (O(N log N))。使用頻率計數陣列 (C) 僅需遍歷字串一次 (O(N))，在處理長字串時效能最佳。",
      "en": "While sorting (A) is simple to implement and has lower space complexity, its time complexity is limited by the sorting algorithm (O(N log N)). Using a frequency count array (C) requires only one pass through the strings (O(N)), offering the best performance for long strings.",
      "wg": [
        {
          "t": "受限於",
          "en": "limited by",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "easy",
    "keywords": "Two Sum, Hash Map, Complement, One-pass",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [2, 7, 11, 15], target = 9",
    "question": [
      {
        "t": "在解決「兩數之和」(Two Sum) 問題時，我們希望在遍歷陣列的過程中，能快速找到與當前數字相加等於目標值 (`target`) 的另一個數字。",
        "en": "When solving the 'Two Sum' problem, we want to quickly find another number that adds up to the `target` with the current number while traversing the array.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traversing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為什麼使用雜湊表 (Hash Map) 儲存 `{數值: 索引}` 是此問題的最佳解法之一？",
        "en": "Why is using a Hash Map to store `{value: index}` considered one of the best solutions for this problem?",
        "wg": [
          {
            "t": "最佳解法",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為雜湊表會自動將鍵值排序，方便使用雙指標法。",
        "en": "(A) Because Hash Maps automatically sort keys, facilitating the two-pointer approach.",
        "wg": [
          {
            "t": "雙指標",
            "en": "two-pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 因為雜湊表允許我們在 O(1) 的時間內查詢當前數字的「補數」(target - current) 是否存在。",
        "en": "(B) Because Hash Maps allow us to check if the 'complement' (target - current) of the current number exists in O(1) time.",
        "wg": [
          {
            "t": "補數",
            "en": "complement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 因為雜湊表不佔用額外的記憶體空間。",
        "en": "(C) Because Hash Maps do not consume additional memory space.",
        "wg": []
      },
      {
        "t": "(D) 因為雜湊表可以處理重複的鍵值，這對於此問題是必須的。",
        "en": "(D) Because Hash Maps can handle duplicate keys, which is mandatory for this problem.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Two Sum 的核心在於尋找 `target - nums[i]`。雜湊表提供平均 O(1) 的查詢時間，使整體演算法能在一次遍歷 O(N) 內完成。選項 (A) 錯誤，因為標準雜湊表不保證順序；選項 (C) 錯誤，雜湊表需要 O(N) 空間。",
      "en": "The core of Two Sum is finding `target - nums[i]`. Hash Maps provide O(1) average lookup time, allowing the algorithm to complete in one pass O(N). Option (A) is incorrect as standard Hash Maps do not guarantee order; Option (C) is incorrect as Hash Maps require O(N) space.",
      "wg": [
        {
          "t": "保證",
          "en": "guarantee",
          "ps": "V"
        },
        {
          "t": "查詢時間",
          "en": "lookup time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Group Anagrams, Hash Key, Categorization, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
    "question": [
      {
        "t": "您需要將一組字串陣列中的重組字 (Anagrams) 進行分組（例如將 \"eat\", \"tea\", \"ate\" 分在同一組）。",
        "en": "You need to group anagrams from an array of strings (e.g., grouping \"eat\", \"tea\", \"ate\" together).",
        "wg": [
          {
            "t": "分組",
            "en": "group",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在使用雜湊表 (Hash Map) 進行分組時，下列哪一種方式最適合用來作為雜湊表的「鍵」(Key)？",
        "en": "When using a Hash Map for grouping, which of the following is the most suitable method to use as the 'Key'?",
        "wg": [
          {
            "t": "適合",
            "en": "suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 字串中所有字元的 ASCII 數值總和。",
        "en": "(A) The sum of ASCII values of all characters in the string.",
        "wg": []
      },
      {
        "t": "(B) 字串的長度。",
        "en": "(B) The length of the string.",
        "wg": []
      },
      {
        "t": "(C) 將字串內的字元依照字母順序排序後的新字串（例如 \"aet\"）。",
        "en": "(C) The new string formed by sorting the characters within the string alphabetically (e.g., \"aet\").",
        "wg": [
          {
            "t": "字母順序",
            "en": "alphabetical order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 字串的第一個和最後一個字元。",
        "en": "(D) The first and last characters of the string.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "重組字 (Anagrams) 的定義是字元組成相同但順序不同，因此將它們排序後會得到完全相同的字串，這是一個唯一且可靠的鍵值。選項 (A) 和 (B) 會產生大量碰撞（例如 \"ac\" 和 \"bb\" 的 ASCII 總和可能相同），無法準確區分不同的重組字組。",
      "en": "Anagrams are defined by having the same character composition but different orders, so sorting them results in an identical string, which serves as a unique and reliable key. Options (A) and (B) would cause many collisions (e.g., \"ac\" and \"bb\" might have the same ASCII sum) and cannot accurately distinguish between different anagram groups.",
      "wg": [
        {
          "t": "組成",
          "en": "composition",
          "ps": "N"
        },
        {
          "t": "區分",
          "en": "distinguish",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Top K Frequent, Bucket Sort, Heap, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1,1,1,2,2,3], k = 2",
    "question": [
      {
        "t": "給定一個整數陣列 `nums` 和一個整數 `k`，請找出出現頻率最高的 `k` 個元素。",
        "en": "Given an integer array `nums` and an integer `k`, find the `k` most frequent elements.",
        "wg": [
          {
            "t": "出現頻率",
            "en": "frequency of occurrence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若陣列長度 `N` 非常大，為了達到優於 O(N log N) 的時間複雜度，下列哪種演算法策略最為合適？",
        "en": "If the array length `N` is very large, which algorithm strategy is most suitable to achieve a time complexity better than O(N log N)?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 快速排序法 (Quick Sort)：先排序整個陣列，再計算頻率。",
        "en": "(A) Quick Sort: Sort the entire array first, then count frequencies.",
        "wg": []
      },
      {
        "t": "(B) 桶子排序 (Bucket Sort)：以「頻率」作為索引，將元素放入對應的桶中。",
        "en": "(B) Bucket Sort: Use 'frequency' as the index and place elements into the corresponding buckets.",
        "wg": [
          {
            "t": "桶子排序",
            "en": "Bucket Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 深度優先搜尋 (DFS)：遍歷所有可能的子集。",
        "en": "(C) Depth-First Search (DFS): Traverse all possible subsets.",
        "wg": []
      },
      {
        "t": "(D) 二分搜尋法 (Binary Search)：在未排序的陣列中搜尋頻率。",
        "en": "(D) Binary Search: Search for frequencies in an unsorted array.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "桶子排序法可以將時間複雜度優化至 O(N)。我們先計算每個數字的頻率，然後建立一個陣列，索引代表「出現次數」，值為該次數對應的數字列表。這樣我們只需從後往前讀取桶子即可取得前 k 高頻的元素。一般排序法 (A) 至少需要 O(N log N)。",
      "en": "Bucket Sort can optimize the time complexity to O(N). We first count the frequency of each number, then create an array where the index represents the 'count' and the value is the list of numbers with that count. We then simply read the buckets from the end to get the top k frequent elements. Standard sorting (A) requires at least O(N log N).",
      "wg": [
        {
          "t": "優化",
          "en": "optimize",
          "ps": "V"
        },
        {
          "t": "對應的",
          "en": "corresponding",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "easy",
    "keywords": "Prefix Sum, Array, Range Query, Immutable",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class NumArray {\n    public NumArray(int[] nums) { ... }\n    public int sumRange(int left, int right) { ... }\n}",
    "question": [
      {
        "t": "給定一個整數陣列 `nums`，您需要設計一個類別來處理多次關於特定範圍內元素總和的查詢。",
        "en": "Given an integer array `nums`, you need to design a class to handle multiple queries for the sum of elements within a specific range.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "N"
          },
          {
            "t": "查詢",
            "en": "queries",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設陣列內容不會改變，但 `sumRange` 函數會被非常頻繁地呼叫。",
        "en": "Assume the array content does not change, but the `sumRange` function will be called very frequently.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "為了達到最佳的時間複雜度，您應該在建構子 (Constructor) 中預先計算什麼？",
        "en": "To achieve optimal time complexity, what should you precompute in the constructor?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "建構子",
            "en": "constructor",
            "ps": "N"
          },
          {
            "t": "預先計算",
            "en": "precompute",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 儲存原始陣列，並在每次查詢時使用迴圈計算總和。",
        "en": "(A) Store the original array and calculate the sum using a loop for each query.",
        "wg": []
      },
      {
        "t": "(B) 建立一個雜湊表 (Hash Map)，儲存所有可能的 (left, right) 組合及其總和。",
        "en": "(B) Create a Hash Map to store all possible (left, right) combinations and their sums.",
        "wg": []
      },
      {
        "t": "(C) 計算前綴和 (Prefix Sum) 陣列，使得查詢時間為 O(1)。",
        "en": "(C) Compute a Prefix Sum array so that the query time is O(1).",
        "wg": [
          {
            "t": "前綴和",
            "en": "Prefix Sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 對陣列進行排序，以便使用二分搜尋法查找範圍。",
        "en": "(D) Sort the array to use binary search for finding the range.",
        "wg": [
          {
            "t": "二分搜尋法",
            "en": "binary search",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "透過預先計算前綴和陣列 `P`，其中 `P[i]` 是 `nums[0]` 到 `nums[i]` 的總和，任何範圍 `[left, right]` 的總和都可以透過 `P[right] - P[left-1]` 在 O(1) 時間內計算出來。選項 (A) 的查詢時間為 O(n)，效率太低；選項 (B) 的空間複雜度為 O(n^2)，消耗過大。",
      "en": "By precomputing a prefix sum array `P`, where `P[i]` is the sum of `nums[0]` through `nums[i]`, the sum of any range `[left, right]` can be calculated in O(1) time using `P[right] - P[left-1]`. Option (A) has O(n) query time, which is inefficient; Option (B) has O(n^2) space complexity, which is too costly.",
      "wg": [
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Array, Product, Prefix/Suffix, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 2, 3, 4]\nOutput: [24, 12, 8, 6]",
    "question": [
      {
        "t": "給定一個整數陣列 `nums`，您需要回傳一個陣列 `answer`，其中 `answer[i]` 等於 `nums` 中除了 `nums[i]` 之外所有元素的乘積。",
        "en": "Given an integer array `nums`, you need to return an array `answer` where `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          }
        ]
      },
      {
        "t": "題目要求必須在 O(n) 時間複雜度內完成，且**不能使用除法**。",
        "en": "The problem requires solving it in O(n) time complexity and **without using division**.",
        "wg": [
          {
            "t": "除法",
            "en": "division",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種策略是正確的？",
        "en": "Which of the following strategies is correct?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計算所有元素的總乘積，然後對每個位置執行除法。",
        "en": "(A) Calculate the total product of all elements, then perform division for each position.",
        "wg": []
      },
      {
        "t": "(B) 使用巢狀迴圈，對每個元素遍歷陣列其餘部分進行相乘。",
        "en": "(B) Use nested loops to iterate through the rest of the array and multiply for each element.",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 分別計算每個位置的「前綴乘積」與「後綴乘積」，並將兩者相乘。",
        "en": "(C) Calculate the 'prefix product' and 'suffix product' for each position separately, and multiply them together.",
        "wg": [
          {
            "t": "前綴乘積",
            "en": "prefix product",
            "ps": "N"
          },
          {
            "t": "後綴乘積",
            "en": "suffix product",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將陣列排序後，取最大值與最小值的乘積。",
        "en": "(D) Sort the array and take the product of the maximum and minimum values.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "題目明確禁止使用除法，且要求 O(n)。選項 (A) 使用了除法（且若有 0 會出錯）；選項 (B) 是 O(n^2)；選項 (D) 邏輯完全錯誤。正確做法是利用兩個陣列（或兩次遍歷）分別計算元素左邊所有數的乘積與右邊所有數的乘積。",
      "en": "The problem explicitly forbids division and requires O(n). Option (A) uses division (and fails if there are zeros); Option (B) is O(n^2); Option (D) is logically incorrect. The correct approach is to use two arrays (or two passes) to calculate the product of all numbers to the left and all numbers to the right of the element.",
      "wg": [
        {
          "t": "明確",
          "en": "explicitly",
          "ps": "Adv"
        },
        {
          "t": "禁止",
          "en": "forbids",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Hashing, Sequence, Set, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [100, 4, 200, 1, 3, 2]\nOutput: 4  // [1, 2, 3, 4]",
    "question": [
      {
        "t": "給定一個未排序的整數陣列 `nums`，請找出其中「最長連續序列」的長度。",
        "en": "Given an unsorted integer array `nums`, find the length of the 'longest consecutive sequence'.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "連續序列",
            "en": "consecutive sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "演算法的時間複雜度必須是 O(n)。",
        "en": "The algorithm's time complexity must be O(n).",
        "wg": []
      },
      {
        "t": "在使用 HashSet 儲存所有數字後，為了確保 O(n) 的複雜度，我們在遍歷集合時應該加入什麼判斷條件？",
        "en": "After storing all numbers in a HashSet, what condition should we add when iterating through the set to ensure O(n) complexity?",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterating",
            "ps": "V"
          },
          {
            "t": "判斷條件",
            "en": "condition",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個數字 `n`，檢查 `n+1` 是否存在於集合中。",
        "en": "(A) For each number `n`, check if `n+1` exists in the set.",
        "wg": []
      },
      {
        "t": "(B) 只有當 `n-1` **不**存在於集合中時，才開始計算序列長度。",
        "en": "(B) Only start counting the sequence length if `n-1` does **not** exist in the set.",
        "wg": []
      },
      {
        "t": "(C) 將集合轉換回陣列並進行排序。",
        "en": "(C) Convert the set back to an array and sort it.",
        "wg": []
      },
      {
        "t": "(D) 對每個數字使用遞迴尋找所有相鄰數字。",
        "en": "(D) Use recursion for each number to find all adjacent numbers.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          },
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若對每個數字都嘗試向後數，最差情況會退化成 O(n^2)。選項 (B) 確保了我們只從序列的「起點」開始計算，這樣每個數字最多只會被訪問兩次（一次檢查起點，一次被計數），保證了 O(n)。選項 (C) 的排序會導致 O(n log n)。",
      "en": "If we try to count forward for every number, the worst case degrades to O(n^2). Option (B) ensures we only start counting from the 'start' of a sequence, so each number is visited at most twice (once to check if it's a start, once counted), guaranteeing O(n). Option (C)'s sorting results in O(n log n).",
      "wg": [
        {
          "t": "退化",
          "en": "degrades",
          "ps": "V"
        },
        {
          "t": "起點",
          "en": "start/beginning",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Matrix, Hashing, Sudoku, Validation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在驗證一個 9x9 的數獨 (Sudoku) 是否有效時，我們需要檢查每一列、每一行以及每一個 3x3 的子方格。",
        "en": "When validating if a 9x9 Sudoku is valid, we need to check every row, every column, and every 3x3 sub-box.",
        "wg": [
          {
            "t": "驗證",
            "en": "validating",
            "ps": "V"
          },
          {
            "t": "子方格",
            "en": "sub-box",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用 HashSet 來檢查重複，對於位於 `board[r][c]` 的元素，該如何計算它屬於哪一個 3x3 子方格的索引？",
        "en": "If using HashSets to check for duplicates, how do you calculate the index of the 3x3 sub-box that the element at `board[r][c]` belongs to?",
        "wg": [
          {
            "t": "重複",
            "en": "duplicates",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `(r / 3) * 3 + (c / 3)`",
        "en": "(A) `(r / 3) * 3 + (c / 3)`",
        "wg": []
      },
      {
        "t": "(B) `(r % 3) * 3 + (c % 3)`",
        "en": "(B) `(r % 3) * 3 + (c % 3)`",
        "wg": []
      },
      {
        "t": "(C) `r * 3 + c`",
        "en": "(C) `r * 3 + c`",
        "wg": []
      },
      {
        "t": "(D) `(r + c) / 3`",
        "en": "(D) `(r + c) / 3`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "數獨板被分為 9 個 3x3 的子方格，編號從 0 到 8。列索引 `r` 除以 3 決定了垂直方向的區塊（0, 1, 2），行索引 `c` 除以 3 決定了水平方向的區塊。公式 `(r / 3) * 3 + (c / 3)` 能正確地將座標映射到 0-8 的唯一子方格索引。",
      "en": "The Sudoku board is divided into nine 3x3 sub-boxes, indexed 0 to 8. The row index `r` divided by 3 determines the vertical block (0, 1, 2), and the column index `c` divided by 3 determines the horizontal block. The formula `(r / 3) * 3 + (c / 3)` correctly maps the coordinates to a unique sub-box index from 0-8.",
      "wg": [
        {
          "t": "映射",
          "en": "maps",
          "ps": "V"
        },
        {
          "t": "座標",
          "en": "coordinates",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "String, Array, Encoding, Delimiter",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"hello\", \"world\"]\nEncoded: \"5#hello5#world\"",
    "question": [
      {
        "t": "您需要設計一個演算法將字串列表 (List of Strings) 編碼成單一字串，並能解碼回原列表。",
        "en": "You need to design an algorithm to encode a list of strings into a single string and decode it back to the original list.",
        "wg": [
          {
            "t": "編碼",
            "en": "encode",
            "ps": "V"
          },
          {
            "t": "解碼",
            "en": "decode",
            "ps": "V"
          }
        ]
      },
      {
        "t": "如果僅使用簡單的分隔符號（例如 ',' 或 '#'）連接字串，會遇到什麼主要問題？",
        "en": "What is the main problem if you simply join strings using a simple delimiter (e.g., ',' or '#')?",
        "wg": [
          {
            "t": "分隔符號",
            "en": "delimiter",
            "ps": "N"
          }
        ]
      },
      {
        "t": "最佳的解決方案通常包含什麼技巧？",
        "en": "What technique does the best solution usually involve?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 原始字串可能包含分隔符號，導致解碼時分割錯誤；應使用「長度前綴」標記。",
        "en": "(A) The original strings might contain the delimiter, causing incorrect splitting during decoding; 'length prefixing' should be used.",
        "wg": [
          {
            "t": "長度前綴",
            "en": "length prefixing",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 字串太長會導致記憶體溢位；應限制字串長度。",
        "en": "(B) Strings being too long will cause memory overflow; string length should be limited.",
        "wg": [
          {
            "t": "記憶體溢位",
            "en": "memory overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) ASCII 編碼不支援所有字元；應轉成二進位。",
        "en": "(C) ASCII encoding does not support all characters; convert to binary.",
        "wg": []
      },
      {
        "t": "(D) 簡單分隔符號效率太低；應使用 JSON 格式。",
        "en": "(D) Simple delimiters are too inefficient; JSON format should be used.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若原始字串中剛好包含選定的分隔符號（例如輸入為 `[\"a,b\", \"c\"]` 且用 `,` 分隔），解碼時會產生混淆。最佳做法是在每個字串前加上「字串長度」和一個特殊符號（如 `4#test`），這樣解碼時可以精確知道要讀取多少字元，而不受內容影響。",
      "en": "If the original strings contain the chosen delimiter (e.g., input is `[\"a,b\", \"c\"]` and separated by `,`), decoding will be ambiguous. The best practice is to prepend the 'string length' and a special symbol (e.g., `4#test`) to each string, so the decoder knows exactly how many characters to read regardless of the content.",
      "wg": [
        {
          "t": "混淆",
          "en": "ambiguous/confusion",
          "ps": "Adj/N"
        },
        {
          "t": "精確知道",
          "en": "know exactly",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "easy",
    "keywords": "Prefix Sum, Array, Design, Immutable",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class NumArray {\n    public NumArray(int[] nums) { ... }\n    public int sumRange(int left, int right) { ... }\n}",
    "question": [
      {
        "t": "您正在設計一個類別 `NumArray`，該類別需要處理一個整數陣列，並頻繁地計算特定索引範圍內的元素總和。",
        "en": "You are designing a class `NumArray` that handles an integer array and frequently calculates the sum of elements within specific index ranges.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "NP"
          },
          {
            "t": "索引範圍",
            "en": "index ranges",
            "ps": "NP"
          },
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "假設陣列在初始化後不會發生變化，但 `sumRange` 查詢會被呼叫非常多次。",
        "en": "Assume the array does not change after initialization, but `sumRange` queries are called very many times.",
        "wg": [
          {
            "t": "初始化",
            "en": "initialization",
            "ps": "N"
          },
          {
            "t": "呼叫",
            "en": "called",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了達到最佳的時間複雜度，您應該如何在建構函式中預處理資料？",
        "en": "To achieve the optimal time complexity, how should you pre-process the data in the constructor?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          },
          {
            "t": "建構函式",
            "en": "constructor",
            "ps": "N"
          },
          {
            "t": "預處理",
            "en": "pre-process",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 不做任何預處理，每次查詢時使用迴圈計算總和。",
        "en": "(A) Do no pre-processing; calculate the sum using a loop for each query.",
        "wg": []
      },
      {
        "t": "(B) 計算前綴和陣列 (Prefix Sum Array)，使得查詢時間為 O(1)。",
        "en": "(B) Calculate a Prefix Sum Array, allowing for O(1) query time.",
        "wg": [
          {
            "t": "前綴和",
            "en": "Prefix Sum",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 使用雜湊表 (Hash Map) 儲存所有可能的子陣列總和。",
        "en": "(C) Use a Hash Map to store sums of all possible subarrays.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "NP"
          },
          {
            "t": "子陣列",
            "en": "subarrays",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將陣列排序以加速範圍搜尋。",
        "en": "(D) Sort the array to accelerate range searching.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "對於不可變陣列的頻繁範圍求和查詢，建立前綴和陣列是標準解法。透過 `P[i]` 儲存 `nums[0]` 到 `nums[i]` 的總和，任意範圍 `[L, R]` 的和可以透過 `P[R] - P[L-1]` 在 O(1) 時間內算出。選項 (A) 查詢為 O(n) 太慢；選項 (C) 空間複雜度為 O(n^2) 太高；選項 (D) 排序會破壞原始索引順序，導致答案錯誤。",
      "en": "For frequent range sum queries on an immutable array, creating a Prefix Sum Array is the standard solution. By storing the sum of `nums[0]` through `nums[i]` in `P[i]`, the sum of any range `[L, R]` can be calculated as `P[R] - P[L-1]` in O(1) time. Option (A) has O(n) query time, which is too slow; Option (C) has O(n^2) space complexity, which is too high; Option (D) sorting destroys the original index order, leading to incorrect answers.",
      "wg": [
        {
          "t": "不可變",
          "en": "immutable",
          "ps": "Adj"
        },
        {
          "t": "標準解法",
          "en": "standard solution",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Hash Set, Array, Sequence, O(n)",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [100, 4, 200, 1, 3, 2]\nOutput: 4 (The sequence is [1, 2, 3, 4])",
    "question": [
      {
        "t": "給定一個未排序的整數陣列，請找出其中「最長連續序列」的長度。",
        "en": "Given an unsorted array of integers, find the length of the \"longest consecutive elements sequence\".",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "連續序列",
            "en": "consecutive sequence",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "演算法的時間複雜度必須是 O(n)。",
        "en": "The algorithm must run in O(n) time complexity.",
        "wg": []
      },
      {
        "t": "下列哪種策略最符合此要求？",
        "en": "Which of the following strategies best fits this requirement?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          },
          {
            "t": "符合",
            "en": "fits",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將陣列排序，然後遍歷一次計算最長連續長度。",
        "en": "(A) Sort the array first, then iterate once to count the longest consecutive length.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用 HashSet 儲存所有數字，僅當一個數字是序列的起點（即 `num - 1` 不在集合中）時才開始計算長度。",
        "en": "(B) Use a HashSet to store all numbers, and only start counting length if a number is the start of a sequence (i.e., `num - 1` is not in the set).",
        "wg": [
          {
            "t": "起點",
            "en": "start/beginning",
            "ps": "N"
          },
          {
            "t": "集合",
            "en": "set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用雙重迴圈，對每個數字檢查其後續數字是否存在。",
        "en": "(C) Use nested loops to check if the subsequent number exists for each number.",
        "wg": [
          {
            "t": "雙重迴圈",
            "en": "nested loops",
            "ps": "NP"
          },
          {
            "t": "後續",
            "en": "subsequent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 使用二元搜尋樹 (BST) 儲存數字，並進行中序遍歷。",
        "en": "(D) Use a Binary Search Tree (BST) to store numbers and perform an in-order traversal.",
        "wg": [
          {
            "t": "中序遍歷",
            "en": "in-order traversal",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "題目要求 O(n) 時間複雜度。選項 (A) 排序需要 O(n log n)，不符要求。選項 (C) 是暴力解，需 O(n^2) 或 O(n^3)。選項 (B) 利用 HashSet 進行 O(1) 查詢，且透過「只從序列起點開始計算」的邏輯，確保每個數字最多只被訪問兩次（一次存入，一次查詢），因此總體時間複雜度為 O(n)。",
      "en": "The problem requires O(n) time complexity. Option (A) sorting takes O(n log n), which does not meet the requirement. Option (C) is a brute-force solution taking O(n^2) or O(n^3). Option (B) uses a HashSet for O(1) lookups and, by the logic of \"only counting from the start of a sequence\", ensures each number is visited at most twice (once for insertion, once for lookup), resulting in an overall O(n) time complexity.",
      "wg": [
        {
          "t": "暴力解",
          "en": "brute-force solution",
          "ps": "NP"
        },
        {
          "t": "訪問",
          "en": "visited",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Array, Prefix Product, Suffix Product, Division",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 2, 3, 4]\nOutput: [24, 12, 8, 6]",
    "question": [
      {
        "t": "給定一個整數陣列 `nums`，請回傳一個陣列 `answer`，其中 `answer[i]` 等於 `nums` 中除了 `nums[i]` 之外所有元素的乘積。",
        "en": "Given an integer array `nums`, return an array `answer` where `answer[i]` is equal to the product of all elements in `nums` except `nums[i]`.",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          },
          {
            "t": "除了...之外",
            "en": "except",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "題目限制：請不要使用除法，且需在 O(n) 時間內完成。",
        "en": "Constraint: Do not use division, and complete it in O(n) time.",
        "wg": [
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          },
          {
            "t": "除法",
            "en": "division",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪個演算法概念是解決此問題的最佳方法？",
        "en": "Which of the following algorithmic concepts is the best approach to solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計算所有元素的總乘積，然後對每個元素執行除法。",
        "en": "(A) Calculate the total product of all elements, then perform division for each element.",
        "wg": []
      },
      {
        "t": "(B) 滑動視窗 (Sliding Window)。",
        "en": "(B) Sliding Window.",
        "wg": [
          {
            "t": "滑動視窗",
            "en": "Sliding Window",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 計算前綴乘積 (Prefix Product) 與後綴乘積 (Suffix Product) 陣列。",
        "en": "(C) Calculate Prefix Product and Suffix Product arrays.",
        "wg": [
          {
            "t": "前綴乘積",
            "en": "Prefix Product",
            "ps": "NP"
          },
          {
            "t": "後綴乘積",
            "en": "Suffix Product",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 深度優先搜尋 (DFS)。",
        "en": "(D) Depth-First Search (DFS).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "題目明確禁止使用除法（選項 A 違反此點，且若有 0 會出錯）。正確解法是利用「前綴乘積」（該元素左邊所有數的乘積）與「後綴乘積」（該元素右邊所有數的乘積）。`answer[i]` 即為 `prefix[i] * suffix[i]`。這可以在兩次遍歷中完成，符合 O(n) 時間複雜度。",
      "en": "The problem explicitly forbids division (Option A violates this and fails with zeros). The correct solution uses \"Prefix Products\" (product of all numbers to the left) and \"Suffix Products\" (product of all numbers to the right). `answer[i]` is simply `prefix[i] * suffix[i]`. This can be done in two passes, meeting the O(n) time complexity requirement.",
      "wg": [
        {
          "t": "禁止",
          "en": "forbids",
          "ps": "V"
        },
        {
          "t": "違反",
          "en": "violates",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "String, Encoding, Decoding, Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"Hello\", \"World\"]\nEncoded: \"5#Hello5#World\"",
    "question": [
      {
        "t": "您需要設計一個演算法來將字串列表 (List of Strings) 編碼為單一字串，並能將其解碼回原始列表。",
        "en": "You need to design an algorithm to encode a list of strings into a single string and decode it back to the original list.",
        "wg": [
          {
            "t": "編碼",
            "en": "encode",
            "ps": "V"
          },
          {
            "t": "解碼",
            "en": "decode",
            "ps": "V"
          },
          {
            "t": "原始列表",
            "en": "original list",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "輸入的字串可能包含任何 ASCII 字元（包括特殊符號）。",
        "en": "The input strings may contain any ASCII characters (including special symbols).",
        "wg": [
          {
            "t": "特殊符號",
            "en": "special symbols",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為了避免解碼時發生歧義，下列哪種編碼格式最為穩健？",
        "en": "To avoid ambiguity during decoding, which of the following encoding formats is the most robust?",
        "wg": [
          {
            "t": "歧義",
            "en": "ambiguity",
            "ps": "N"
          },
          {
            "t": "穩健",
            "en": "robust",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用特殊字元（如 `#` 或 `,`）作為分隔符號直接串接。",
        "en": "(A) Concatenate directly using a special character (like `#` or `,`) as a delimiter.",
        "wg": [
          {
            "t": "分隔符號",
            "en": "delimiter",
            "ps": "N"
          },
          {
            "t": "串接",
            "en": "concatenate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用「長度 + 分隔符 + 內容」的格式（例如 `4#Code`）。",
        "en": "(B) Use a \"Length + Delimiter + Content\" format (e.g., `4#Code`).",
        "wg": []
      },
      {
        "t": "(C) 將所有字串轉換為大寫後再串接。",
        "en": "(C) Convert all strings to uppercase before concatenating.",
        "wg": []
      },
      {
        "t": "(D) 僅依賴固定長度來儲存每個字串。",
        "en": "(D) Rely solely on fixed lengths to store each string.",
        "wg": [
          {
            "t": "依賴",
            "en": "rely on",
            "ps": "V"
          },
          {
            "t": "固定長度",
            "en": "fixed lengths",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 是無效的，因為如果原始字串內容本身就包含分隔符號，解碼時會發生錯誤。選項 (B) 是標準做法，透過先讀取長度，程式確切知道接下來要讀取多少字元作為內容，因此內容中包含任何符號（包括分隔符本身）都不會造成混淆。選項 (C) 會遺失大小寫資訊。選項 (D) 浪費空間且不靈活。",
      "en": "Option (A) is invalid because if the original string content contains the delimiter itself, decoding errors will occur. Option (B) is the standard approach; by reading the length first, the program knows exactly how many characters to read as content, so any symbols within the content (including the delimiter itself) will not cause confusion. Option (C) loses case information. Option (D) wastes space and is inflexible.",
      "wg": [
        {
          "t": "混淆",
          "en": "confusion",
          "ps": "N"
        },
        {
          "t": "遺失",
          "en": "lose",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Hash Map, Prefix Sum, Subarray",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 1, 1], k = 2\nOutput: 2 ([1,1] and [1,1])",
    "question": [
      {
        "t": "給定一個整數陣列 `nums` 和一個整數 `k`，請找出和為 `k` 的連續子陣列總數。",
        "en": "Given an integer array `nums` and an integer `k`, find the total number of continuous subarrays whose sum equals `k`.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "continuous subarrays",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為了在 O(n) 時間內解決此問題，您應該使用什麼資料結構來輔助前綴和 (Prefix Sum) 的計算？",
        "en": "To solve this problem in O(n) time, what data structure should you use to assist with the Prefix Sum calculation?",
        "wg": [
          {
            "t": "輔助",
            "en": "assist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)。",
        "en": "(A) Stack.",
        "wg": []
      },
      {
        "t": "(B) 佇列 (Queue)。",
        "en": "(B) Queue.",
        "wg": []
      },
      {
        "t": "(C) 雜湊表 (Hash Map)，儲存 `{前綴和: 出現次數}`。",
        "en": "(C) Hash Map, storing `{prefix_sum: count}`.",
        "wg": [
          {
            "t": "出現次數",
            "en": "count/frequency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 最小堆積 (Min Heap)。",
        "en": "(D) Min Heap.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是一個經典問題。若當前的前綴和為 `curr`，我們想知道是否存在一個之前的 `prefix` 使得 `curr - prefix = k`。移項得 `prefix = curr - k`。透過雜湊表儲存每個前綴和出現的次數，我們可以直接查詢 `curr - k` 出現過幾次，並將其加到答案中，從而避免 O(n^2) 的巢狀迴圈。",
      "en": "This is a classic problem. If the current prefix sum is `curr`, we want to know if there exists a previous `prefix` such that `curr - prefix = k`. Rearranging gives `prefix = curr - k`. By using a Hash Map to store the frequency of each prefix sum, we can directly look up how many times `curr - k` has occurred and add that to the answer, avoiding O(n^2) nested loops.",
      "wg": [
        {
          "t": "移項",
          "en": "rearranging (terms)",
          "ps": "V"
        },
        {
          "t": "巢狀迴圈",
          "en": "nested loops",
          "ps": "NP"
        }
      ]
    }
  }
]