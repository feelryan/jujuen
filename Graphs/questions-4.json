[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Cycle Detection, Directed Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理任務排程或編譯相依性問題時，我們常使用拓撲排序。",
        "en": "We often use topological sort when dealing with task scheduling or compilation dependency issues.",
        "wg": [
          {
            "t": "任務排程",
            "en": "task scheduling",
            "ps": "NP"
          },
          {
            "t": "相依性",
            "en": "dependency",
            "ps": "N"
          },
          {
            "t": "拓撲排序",
            "en": "topological sort",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "下列哪種情況會導致無法對有向圖進行有效的拓撲排序？",
        "en": "Which of the following conditions makes it impossible to perform a valid topological sort on a directed graph?",
        "wg": [
          {
            "t": "有向圖",
            "en": "directed graph",
            "ps": "NP"
          },
          {
            "t": "有效的",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 圖中包含多個連通分量 (Connected Components)。",
        "en": "(A) The graph contains multiple connected components.",
        "wg": [
          {
            "t": "連通分量",
            "en": "connected components",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 圖中存在至少一個環 (Cycle)。",
        "en": "(B) There is at least one cycle in the graph.",
        "wg": [
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 圖中存在權重為負的邊。",
        "en": "(C) There are edges with negative weights in the graph.",
        "wg": [
          {
            "t": "權重",
            "en": "weights",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 某個節點的入度 (In-degree) 為零。",
        "en": "(D) A node has an in-degree of zero.",
        "wg": [
          {
            "t": "入度",
            "en": "in-degree",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "拓撲排序僅適用於有向無環圖 (DAG)。如果圖中存在環，則無法確定節點的線性順序，因為循環依賴導致沒有起點或終點。",
      "en": "Topological sorting is only applicable to Directed Acyclic Graphs (DAGs). If a cycle exists, a linear ordering of nodes cannot be determined because cyclic dependencies mean there is no start or end.",
      "wg": [
        {
          "t": "有向無環圖",
          "en": "Directed Acyclic Graph (DAG)",
          "ps": "NP"
        },
        {
          "t": "循環依賴",
          "en": "cyclic dependency",
          "ps": "NP"
        },
        {
          "t": "線性順序",
          "en": "linear ordering",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "MST, Prim's Algorithm, Kruskal's Algorithm, Dense Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要為一個網路拓撲計算最小生成樹 (MST)。",
        "en": "You need to compute the Minimum Spanning Tree (MST) for a network topology.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "NP"
          },
          {
            "t": "網路拓撲",
            "en": "network topology",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "已知該圖是一個稠密圖 (Dense Graph)，即邊的數量接近頂點數量的平方 ($E \\approx V^2$)。",
        "en": "It is known that the graph is a dense graph, meaning the number of edges is close to the square of the number of vertices ($E \\approx V^2$).",
        "wg": [
          {
            "t": "稠密圖",
            "en": "dense graph",
            "ps": "NP"
          },
          {
            "t": "頂點",
            "en": "vertices",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了獲得最佳的時間複雜度，您應該選擇哪種演算法與資料結構的組合？",
        "en": "To achieve the best time complexity, which combination of algorithm and data structure should you choose?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 Kruskal 演算法搭配併查集 (Union-Find)。",
        "en": "(A) Use Kruskal's algorithm with Union-Find.",
        "wg": [
          {
            "t": "併查集",
            "en": "Union-Find",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 使用 Prim 演算法搭配二元堆積 (Binary Heap)。",
        "en": "(B) Use Prim's algorithm with a Binary Heap.",
        "wg": [
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 使用 Prim 演算法搭配陣列 (Array) 或費氏堆積 (Fibonacci Heap)。",
        "en": "(C) Use Prim's algorithm with an Array or Fibonacci Heap.",
        "wg": [
          {
            "t": "費氏堆積",
            "en": "Fibonacci Heap",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 使用 Bellman-Ford 演算法。",
        "en": "(D) Use the Bellman-Ford algorithm.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在稠密圖中，$E$ 很大。Kruskal 的複雜度為 $O(E \\log E)$，而在稠密圖中這接近 $O(V^2 \\log V)$。Prim 演算法若使用簡單陣列搜尋最小值，複雜度為 $O(V^2)$，這在稠密圖中優於基於堆積的方法 ($O(E \\log V)$)。",
      "en": "In a dense graph, $E$ is large. Kruskal's complexity is $O(E \\log E)$, which approaches $O(V^2 \\log V)$ in dense graphs. Prim's algorithm using a simple array to find the minimum takes $O(V^2)$, which outperforms heap-based methods ($O(E \\log V)$) in dense graphs.",
      "wg": [
        {
          "t": "堆積",
          "en": "heap",
          "ps": "N"
        },
        {
          "t": "優於",
          "en": "outperform",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Shortest Path, Bellman-Ford, Dijkstra, Negative Weights",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在尋找單源最短路徑 (Single-Source Shortest Path) 時，Dijkstra 演算法通常比 Bellman-Ford 演算法更有效率。",
        "en": "When finding the Single-Source Shortest Path, Dijkstra's algorithm is usually more efficient than the Bellman-Ford algorithm.",
        "wg": [
          {
            "t": "單源最短路徑",
            "en": "Single-Source Shortest Path",
            "ps": "NP"
          },
          {
            "t": "有效率",
            "en": "efficient",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "然而，在下列哪種特定場景下，我們**必須**選用 Bellman-Ford 而非 Dijkstra？",
        "en": "However, in which of the following specific scenarios **must** we choose Bellman-Ford over Dijkstra?",
        "wg": [
          {
            "t": "特定場景",
            "en": "specific scenarios",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 圖中包含權重為負的邊。",
        "en": "(A) The graph contains edges with negative weights.",
        "wg": [
          {
            "t": "負",
            "en": "negative",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 圖是非常稀疏的 (Sparse)。",
        "en": "(B) The graph is very sparse.",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 我們需要找出所有節點對之間的最短路徑。",
        "en": "(C) We need to find the shortest paths between all pairs of nodes.",
        "wg": [
          {
            "t": "節點對",
            "en": "pairs of nodes",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 圖是有向無環圖 (DAG)。",
        "en": "(D) The graph is a Directed Acyclic Graph (DAG).",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "Dijkstra 演算法基於貪婪策略，假設一旦節點被處理，其最短路徑就已確定，這在有負權重邊時會失效。Bellman-Ford 可以處理負權重邊，甚至能偵測負權重環 (Negative Cycle)。",
      "en": "Dijkstra's algorithm is based on a greedy strategy, assuming that once a node is processed, its shortest path is finalized, which fails with negative edge weights. Bellman-Ford can handle negative weights and even detect negative cycles.",
      "wg": [
        {
          "t": "貪婪策略",
          "en": "greedy strategy",
          "ps": "NP"
        },
        {
          "t": "失效",
          "en": "fail",
          "ps": "V"
        },
        {
          "t": "負權重環",
          "en": "negative cycle",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "SCC, Connectivity, Directed Graph, Kosaraju",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於有向圖中的強連通分量 (Strongly Connected Components, SCC)，下列敘述何者正確？",
        "en": "Which of the following statements about Strongly Connected Components (SCC) in a directed graph is correct?",
        "wg": [
          {
            "t": "強連通分量",
            "en": "Strongly Connected Components",
            "ps": "NP"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 如果將 SCC 視為單一節點，則縮減後的圖 (Condensation Graph) 必定是一個 DAG。",
        "en": "(A) If each SCC is treated as a single node, the resulting condensation graph must be a DAG.",
        "wg": [
          {
            "t": "縮減後的圖",
            "en": "condensation graph",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 一個圖中只能有一個強連通分量。",
        "en": "(B) A graph can have only one strongly connected component.",
        "wg": []
      },
      {
        "t": "(C) 在 SCC 中，並非每對頂點都必須互相可達 (Mutually Reachable)。",
        "en": "(C) Within an SCC, not every pair of vertices needs to be mutually reachable.",
        "wg": [
          {
            "t": "互相可達",
            "en": "mutually reachable",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 使用 BFS 演算法比 DFS 更適合用來尋找 SCC。",
        "en": "(D) Using BFS algorithm is more suitable than DFS for finding SCCs.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "強連通分量的定義是子圖中任意兩點皆可互相到達。若縮減後的圖仍有環，則該環上的所有 SCC 應該合併為一個更大的 SCC，因此縮減圖必然是無環的 (DAG)。",
      "en": "An SCC is defined such that any two nodes in the subgraph are mutually reachable. If the condensation graph still had a cycle, all SCCs on that cycle should be merged into a larger SCC, so the condensation graph must be acyclic (DAG).",
      "wg": [
        {
          "t": "子圖",
          "en": "subgraph",
          "ps": "N"
        },
        {
          "t": "合併",
          "en": "merge",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Graph Representation, Space Complexity, Adjacency List, Adjacency Matrix",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個儲存社交網絡關係的系統，該圖包含 10,000 個使用者 (節點)，但平均每位使用者只有 50 位朋友 (邊)。",
        "en": "You are designing a system to store social network relationships. The graph contains 10,000 users (nodes), but on average, each user has only 50 friends (edges).",
        "wg": [
          {
            "t": "社交網絡",
            "en": "social network",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "考量空間複雜度，下列哪種圖的表示法最為合適？",
        "en": "Considering space complexity, which graph representation is most suitable?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "NP"
          },
          {
            "t": "表示法",
            "en": "representation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鄰接矩陣 (Adjacency Matrix)，因為查詢兩點是否相連的時間為 O(1)。",
        "en": "(A) Adjacency Matrix, because the time to query if two nodes are connected is O(1).",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "Adjacency Matrix",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 鄰接串列 (Adjacency List)，因為此圖為稀疏圖，矩陣會浪費大量空間。",
        "en": "(B) Adjacency List, because this is a sparse graph and a matrix would waste a lot of space.",
        "wg": [
          {
            "t": "鄰接串列",
            "en": "Adjacency List",
            "ps": "NP"
          },
          {
            "t": "浪費",
            "en": "waste",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 邊緣列表 (Edge List)，因為它支援最快的遍歷速度。",
        "en": "(C) Edge List, because it supports the fastest traversal speed.",
        "wg": [
          {
            "t": "邊緣列表",
            "en": "Edge List",
            "ps": "NP"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 關聯矩陣 (Incidence Matrix)，因為它能清楚表示邊的方向。",
        "en": "(D) Incidence Matrix, because it clearly represents the direction of edges.",
        "wg": [
          {
            "t": "關聯矩陣",
            "en": "Incidence Matrix",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "此圖節點數 $V=10,000$，總邊數約 $E=500,000$ (若為無向圖則除以2)。鄰接矩陣需要 $10,000^2 = 100,000,000$ 個單位空間，極為浪費。鄰接串列僅需 $O(V+E)$ 空間，對於這種稀疏圖 (Sparse Graph) 是最佳選擇。",
      "en": "The graph has $V=10,000$ nodes and total edges approx $E=500,000$. An Adjacency Matrix requires $10,000^2 = 100,000,000$ units of space, which is extremely wasteful. An Adjacency List requires only $O(V+E)$ space, making it the best choice for this sparse graph.",
      "wg": [
        {
          "t": "單位空間",
          "en": "units of space",
          "ps": "NP"
        }
      ]
    }
  }
]