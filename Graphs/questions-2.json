[
  {
    "no": "6",
    "level": "easy",
    "keywords": "BFS, Shortest Path, Unweighted Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個無權重的圖形中，您想要找到從起點節點到終點節點的最短路徑。",
        "en": "In an unweighted graph, you want to find the shortest path from a start node to a target node.",
        "wg": [
          {
            "t": "無權重",
            "en": "unweighted",
            "ps": "Adj"
          },
          {
            "t": "最短路徑",
            "en": "shortest path",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問哪一種演算法最適合此任務，且能保證找到經過邊數最少的路徑？",
        "en": "Which algorithm is most suitable for this task and guarantees finding the path with the minimum number of edges?",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          },
          {
            "t": "邊",
            "en": "edges",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 深度優先搜尋 (DFS)",
        "en": "(A) Depth-First Search (DFS)",
        "wg": []
      },
      {
        "t": "(B) 廣度優先搜尋 (BFS)",
        "en": "(B) Breadth-First Search (BFS)",
        "wg": []
      },
      {
        "t": "(C) 拓撲排序 (Topological Sort)",
        "en": "(C) Topological Sort",
        "wg": []
      },
      {
        "t": "(D) 普林演算法 (Prim's Algorithm)",
        "en": "(D) Prim's Algorithm",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "BFS 以層次遍歷的方式探索圖形，它會先訪問所有距離起點為 1 的節點，然後是距離為 2 的節點，依此類推。因此，BFS 首次到達目標節點時，該路徑保證是無權重圖中的最短路徑。DFS 可能會深入探索一條很長的路徑才找到目標，無法保證最短。",
      "en": "BFS explores the graph layer by layer; it visits all nodes at distance 1 from the start, then distance 2, and so on. Therefore, when BFS first reaches the target node, that path is guaranteed to be the shortest in an unweighted graph. DFS might explore a very long path deeply before finding the target, offering no guarantee of shortness.",
      "wg": [
        {
          "t": "層次遍歷",
          "en": "level-order traversal",
          "ps": "NP"
        },
        {
          "t": "依此類推",
          "en": "and so on",
          "ps": "Phrase"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "DFS, Cycle Detection, Directed Graph, Recursion Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在使用深度優先搜尋 (DFS) 偵測「有向圖」中的環 (Cycle) 時，我們通常會維護節點的訪問狀態。",
        "en": "When using Depth-First Search (DFS) to detect a cycle in a 'directed graph', we usually maintain the visitation state of nodes.",
        "wg": [
          {
            "t": "有向圖",
            "en": "directed graph",
            "ps": "NP"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問遇到下列哪種情況時，我們可以確定圖中存在環？",
        "en": "Under which of the following conditions can we confirm that a cycle exists in the graph?",
        "wg": [
          {
            "t": "確定",
            "en": "confirm",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 訪問到一個已經被標記為「已訪問 (Visited)」且不在當前遞迴堆疊中的節點。",
        "en": "(A) Visiting a node that is already marked as 'Visited' and is not in the current recursion stack.",
        "wg": [
          {
            "t": "遞迴堆疊",
            "en": "recursion stack",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 訪問到一個正在當前遞迴堆疊 (Recursion Stack) 中的節點。",
        "en": "(B) Visiting a node that is currently in the recursion stack.",
        "wg": []
      },
      {
        "t": "(C) 訪問到一個沒有出邊 (Out-degree) 的節點。",
        "en": "(C) Visiting a node with no out-degree.",
        "wg": [
          {
            "t": "出邊",
            "en": "out-degree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遍歷完所有節點都沒有遇到重複節點。",
        "en": "(D) Traversing all nodes without encountering any duplicate nodes.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在有向圖中，如果 DFS 遍歷時遇到一個節點，而該節點已經在「當前遞迴堆疊」中（即該節點的處理尚未結束，屬於灰色節點），這表示我們找到了一條指向祖先節點的「後向邊 (Back Edge)」，從而形成了一個環。選項 (A) 僅表示兩條不同路徑匯合到同一個已處理完畢的節點（交叉邊），並不一定構成環。",
      "en": "In a directed graph, if DFS encounters a node that is already in the 'current recursion stack' (meaning the node's processing is not finished, often marked as gray), it indicates a 'back edge' pointing to an ancestor, thus forming a cycle. Option (A) only implies that two different paths converge to a fully processed node (cross edge), which does not necessarily constitute a cycle.",
      "wg": [
        {
          "t": "後向邊",
          "en": "back edge",
          "ps": "NP"
        },
        {
          "t": "祖先節點",
          "en": "ancestor node",
          "ps": "NP"
        },
        {
          "t": "匯合",
          "en": "converge",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Dependency",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個任務排程系統，其中某些任務必須在其他任務完成後才能開始（例如：編譯程式碼的相依性）。",
        "en": "You are designing a task scheduling system where certain tasks must start only after others are completed (e.g., code compilation dependencies).",
        "wg": [
          {
            "t": "排程系統",
            "en": "scheduling system",
            "ps": "NP"
          },
          {
            "t": "相依性",
            "en": "dependency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了產生一個有效的執行順序，您打算使用拓撲排序 (Topological Sort)。",
        "en": "To generate a valid execution order, you plan to use Topological Sort.",
        "wg": [
          {
            "t": "執行順序",
            "en": "execution order",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問拓撲排序能夠成功運行的必要條件是什麼？",
        "en": "What is the necessary condition for Topological Sort to run successfully?",
        "wg": [
          {
            "t": "必要條件",
            "en": "necessary condition",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 圖形必須是無向的。",
        "en": "(A) The graph must be undirected.",
        "wg": []
      },
      {
        "t": "(B) 圖形必須是完全連通的。",
        "en": "(B) The graph must be fully connected.",
        "wg": []
      },
      {
        "t": "(C) 圖形必須是有向無環圖 (DAG)。",
        "en": "(C) The graph must be a Directed Acyclic Graph (DAG).",
        "wg": [
          {
            "t": "有向無環圖",
            "en": "Directed Acyclic Graph",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 圖形必須是二分圖 (Bipartite Graph)。",
        "en": "(D) The graph must be a Bipartite Graph.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "拓撲排序是對有向圖節點的一種線性排序，使得對於每一條從節點 u 到 v 的有向邊，u 都在排序中出現在 v 之前。如果圖中存在環 (Cycle)，則無法確定先後順序（例如 A->B->A，無法決定誰先誰後），因此圖形必須是「有向無環圖 (DAG)」。",
      "en": "Topological sort is a linear ordering of vertices in a directed graph such that for every directed edge from u to v, u comes before v in the ordering. If a cycle exists (e.g., A->B->A), precedence cannot be determined. Therefore, the graph must be a 'Directed Acyclic Graph (DAG)'.",
      "wg": [
        {
          "t": "線性排序",
          "en": "linear ordering",
          "ps": "NP"
        },
        {
          "t": "先後順序",
          "en": "precedence",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Graph Representation, Space Complexity, Adjacency Matrix, Adjacency List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在選擇圖形的資料結構表示法時，我們通常會比較「鄰接矩陣 (Adjacency Matrix)」與「鄰接串列 (Adjacency List)」。",
        "en": "When choosing a data structure representation for a graph, we often compare 'Adjacency Matrix' and 'Adjacency List'.",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "Adjacency Matrix",
            "ps": "NP"
          },
          {
            "t": "鄰接串列",
            "en": "Adjacency List",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "如果您的應用場景是一個包含 10,000 個節點但只有 20,000 條邊的「稀疏圖 (Sparse Graph)」，",
        "en": "If your scenario involves a 'Sparse Graph' with 10,000 nodes but only 20,000 edges,",
        "wg": [
          {
            "t": "稀疏圖",
            "en": "Sparse Graph",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問為什麼通常建議使用鄰接串列？",
        "en": "Why is it generally recommended to use an Adjacency List?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為鄰接串列檢查任意兩點是否相連的時間複雜度為 O(1)。",
        "en": "(A) Because the time complexity to check if any two nodes are connected is O(1) for an Adjacency List.",
        "wg": []
      },
      {
        "t": "(B) 因為鄰接串列的空間複雜度接近 O(V + E)，而鄰接矩陣為 O(V^2)，在稀疏圖中前者更節省記憶體。",
        "en": "(B) Because the space complexity of an Adjacency List is close to O(V + E), whereas an Adjacency Matrix is O(V^2), making the former more memory-efficient for sparse graphs.",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "NP"
          },
          {
            "t": "節省記憶體",
            "en": "memory-efficient",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 因為鄰接串列更容易實作矩陣乘法運算。",
        "en": "(C) Because Adjacency Lists are easier to implement for matrix multiplication operations.",
        "wg": []
      },
      {
        "t": "(D) 因為鄰接矩陣無法處理有向圖。",
        "en": "(D) Because Adjacency Matrices cannot handle directed graphs.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "對於稀疏圖，邊的數量 E 遠小於 V^2。鄰接矩陣需要 O(V^2) 的空間來儲存所有可能的連接（大部分為 0），這會造成巨大的浪費。鄰接串列僅儲存實際存在的邊，空間複雜度為 O(V + E)，對於稀疏圖來說效率極高。選項 (A) 是錯誤的，鄰接矩陣的查詢才是 O(1)。",
      "en": "For a sparse graph, the number of edges E is much smaller than V^2. An Adjacency Matrix requires O(V^2) space to store all possible connections (mostly zeros), which is hugely wasteful. An Adjacency List stores only existing edges, with a space complexity of O(V + E), making it highly efficient for sparse graphs. Option (A) is incorrect; Adjacency Matrix lookups are O(1).",
      "wg": [
        {
          "t": "浪費",
          "en": "wasteful",
          "ps": "Adj"
        },
        {
          "t": "查詢",
          "en": "lookup",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Bipartite Graph, BFS, Coloring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要判斷一個無向圖是否為「二分圖 (Bipartite Graph)」。",
        "en": "You need to determine if an undirected graph is a 'Bipartite Graph'.",
        "wg": [
          {
            "t": "二分圖",
            "en": "Bipartite Graph",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "這意味著圖中的頂點可以分為兩個互斥的集合，且所有邊都跨越這兩個集合。",
        "en": "This means the vertices can be divided into two disjoint sets such that every edge crosses between these two sets.",
        "wg": [
          {
            "t": "互斥",
            "en": "disjoint",
            "ps": "Adj"
          },
          {
            "t": "跨越",
            "en": "cross",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問下列哪種演算法策略最適合用來解決這個問題？",
        "en": "Which of the following algorithmic strategies is best suited to solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 Dijkstra 演算法計算所有節點的最短路徑。",
        "en": "(A) Use Dijkstra's algorithm to compute shortest paths for all nodes.",
        "wg": []
      },
      {
        "t": "(B) 使用 BFS 或 DFS 進行「雙著色 (2-Coloring)」，嘗試將相鄰節點塗上不同顏色。",
        "en": "(B) Use BFS or DFS for '2-Coloring', attempting to color adjacent nodes with different colors.",
        "wg": [
          {
            "t": "雙著色",
            "en": "2-Coloring",
            "ps": "NP"
          },
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 使用 Kruskal 演算法尋找最小生成樹。",
        "en": "(C) Use Kruskal's algorithm to find the Minimum Spanning Tree.",
        "wg": []
      },
      {
        "t": "(D) 計算圖中所有節點的入度 (In-degree) 和出度 (Out-degree)。",
        "en": "(D) Calculate the In-degree and Out-degree for all nodes in the graph.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二分圖檢測的標準方法是使用 BFS 或 DFS 進行染色。我們從任意節點開始塗色（例如紅色），然後將其所有鄰居塗上相反顏色（例如藍色）。如果在遍歷過程中遇到一個鄰居已經被塗上「相同」的顏色，則該圖不是二分圖。這本質上是在檢測圖中是否存在奇數長度的環。",
      "en": "The standard method for bipartite detection is coloring using BFS or DFS. We start coloring an arbitrary node (e.g., red) and color all its neighbors the opposite color (e.g., blue). If we encounter a neighbor during traversal that is already colored with the 'same' color, the graph is not bipartite. This essentially checks for the existence of odd-length cycles.",
      "wg": [
        {
          "t": "染色",
          "en": "coloring",
          "ps": "Gerund"
        },
        {
          "t": "奇數長度",
          "en": "odd-length",
          "ps": "Adj"
        }
      ]
    }
  }
]