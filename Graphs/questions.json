[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Graph Representation, Space Complexity, Sparse Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統來儲存擁有一百萬個節點的圖形結構，且已知每個節點平均只有 5 個邊。",
        "en": "You are designing a system to store a graph structure with one million nodes, knowing that each node has an average of only 5 edges.",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "邊",
            "en": "edge",
            "ps": "N"
          },
          {
            "t": "平均",
            "en": "average",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了優化記憶體使用空間，您應該選擇哪種圖形表示法？",
        "en": "To optimize memory usage, which graph representation should you choose?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "圖形表示法",
            "en": "graph representation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鄰接矩陣 (Adjacency Matrix)",
        "en": "(A) Adjacency Matrix",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "adjacency matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 鄰接串列 (Adjacency List)",
        "en": "(B) Adjacency List",
        "wg": [
          {
            "t": "鄰接串列",
            "en": "adjacency list",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 關聯矩陣 (Incidence Matrix)",
        "en": "(C) Incidence Matrix",
        "wg": [
          {
            "t": "關聯矩陣",
            "en": "incidence matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 邊列表 (Edge List) 搭配雜湊表",
        "en": "(D) Edge List with Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個典型的稀疏圖 (Sparse Graph)。鄰接矩陣的空間複雜度為 O(V^2)，對於一百萬個節點來說將消耗巨大的記憶體；而鄰接串列的空間複雜度為 O(V+E)，在邊數很少的情況下非常節省空間。",
      "en": "This is a typical Sparse Graph. The space complexity of an Adjacency Matrix is O(V^2), which would consume enormous memory for one million nodes; whereas the Adjacency List has a space complexity of O(V+E), making it very space-efficient when there are few edges.",
      "wg": [
        {
          "t": "稀疏圖",
          "en": "sparse graph",
          "ps": "N"
        },
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "BFS, DFS, Shortest Path, Unweighted Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個無權重的無向圖，您需要找到從起點 A 到終點 B 的最短路徑（經過最少的邊）。",
        "en": "Given an unweighted undirected graph, you need to find the shortest path (traversing the fewest edges) from start node A to end node B.",
        "wg": [
          {
            "t": "無權重",
            "en": "unweighted",
            "ps": "Adj"
          },
          {
            "t": "無向圖",
            "en": "undirected graph",
            "ps": "N"
          },
          {
            "t": "最短路徑",
            "en": "shortest path",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種演算法最適合解決此問題？",
        "en": "Which of the following algorithms is most suitable for solving this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 深度優先搜尋 (DFS)",
        "en": "(A) Depth-First Search (DFS)",
        "wg": [
          {
            "t": "深度優先搜尋",
            "en": "depth-first search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 廣度優先搜尋 (BFS)",
        "en": "(B) Breadth-First Search (BFS)",
        "wg": [
          {
            "t": "廣度優先搜尋",
            "en": "breadth-first search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Dijkstra 演算法",
        "en": "(C) Dijkstra's Algorithm",
        "wg": []
      },
      {
        "t": "(D) Bellman-Ford 演算法",
        "en": "(D) Bellman-Ford Algorithm",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在無權重圖中，BFS 透過逐層探索的方式，保證第一次到達目標節點時的路徑即為最短路徑。DFS 不保證最短路徑；雖然 Dijkstra 也可以解決，但對於無權重圖來說 BFS 更簡單且效率更高。",
      "en": "In an unweighted graph, BFS explores layer by layer, guaranteeing that the path is the shortest when the target node is first reached. DFS does not guarantee the shortest path; while Dijkstra can also solve it, BFS is simpler and more efficient for unweighted graphs.",
      "wg": [
        {
          "t": "逐層",
          "en": "layer by layer",
          "ps": "Adv"
        },
        {
          "t": "保證",
          "en": "guarantee",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Cycle Detection, Directed Graph, DFS, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在使用深度優先搜尋 (DFS) 檢測有向圖中是否存在環 (Cycle) 時，我們通常會使用三種顏色標記節點狀態：白色 (未訪問)、灰色 (訪問中/遞迴堆疊中)、黑色 (已完成)。",
        "en": "When using Depth-First Search (DFS) to detect a cycle in a directed graph, we typically use three colors to mark node states: White (unvisited), Gray (visiting/in recursion stack), and Black (finished).",
        "wg": [
          {
            "t": "有向圖",
            "en": "directed graph",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          },
          {
            "t": "遞迴堆疊",
            "en": "recursion stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在什麼情況下，我們可以判定圖中存在環？",
        "en": "Under what condition can we determine that a cycle exists in the graph?",
        "wg": [
          {
            "t": "判定",
            "en": "determine",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當 DFS 遇到一個白色節點時。",
        "en": "(A) When DFS encounters a White node.",
        "wg": []
      },
      {
        "t": "(B) 當 DFS 遇到一個灰色節點時。",
        "en": "(B) When DFS encounters a Gray node.",
        "wg": []
      },
      {
        "t": "(C) 當 DFS 遇到一個黑色節點時。",
        "en": "(C) When DFS encounters a Black node.",
        "wg": []
      },
      {
        "t": "(D) 當所有節點都變成黑色時。",
        "en": "(D) When all nodes become Black.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遇到灰色節點意味著該節點已經在當前的遞迴堆疊中，表示我們從該節點出發，經過若干路徑後又回到了該節點，這證實了「後向邊 (Back Edge)」的存在，即存在環。",
      "en": "Encountering a Gray node means the node is already in the current recursion stack, indicating that we started from this node and returned to it after some path, confirming the existence of a 'Back Edge', and thus a cycle.",
      "wg": [
        {
          "t": "後向邊",
          "en": "back edge",
          "ps": "N"
        },
        {
          "t": "證實",
          "en": "confirm",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Prerequisites",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在開發一個課程排程系統，某些課程有先修限制（例如：修習課程 B 之前必須先修完課程 A）。",
        "en": "You are developing a course scheduling system where some courses have prerequisites (e.g., Course A must be completed before taking Course B).",
        "wg": [
          {
            "t": "排程系統",
            "en": "scheduling system",
            "ps": "N"
          },
          {
            "t": "先修限制",
            "en": "prerequisites",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要產生一個合法的修課順序，下列關於拓撲排序 (Topological Sort) 的敘述何者正確？",
        "en": "To generate a valid course sequence, which of the following statements about Topological Sort is correct?",
        "wg": [
          {
            "t": "拓撲排序",
            "en": "topological sort",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 拓撲排序可以用於任何有向圖，包含有環的圖。",
        "en": "(A) Topological sort can be used on any directed graph, including those with cycles.",
        "wg": []
      },
      {
        "t": "(B) 只有無向圖 (Undirected Graph) 才能進行拓撲排序。",
        "en": "(B) Only undirected graphs can undergo topological sorting.",
        "wg": []
      },
      {
        "t": "(C) 只有有向無環圖 (DAG) 才能進行拓撲排序。",
        "en": "(C) Only Directed Acyclic Graphs (DAG) can undergo topological sorting.",
        "wg": [
          {
            "t": "有向無環圖",
            "en": "Directed Acyclic Graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 拓撲排序的結果是唯一的。",
        "en": "(D) The result of a topological sort is unique.",
        "wg": [
          {
            "t": "唯一的",
            "en": "unique",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "拓撲排序是針對有向圖節點的線性排序，若圖中存在環 (Cycle)，則無法確定節點的先後順序（例如 A->B->A，無法決定誰先誰後），因此必須是 DAG。",
      "en": "Topological sort is a linear ordering of nodes in a directed graph. If a cycle exists in the graph (e.g., A->B->A), the precedence of nodes cannot be determined, so it must be a DAG.",
      "wg": [
        {
          "t": "線性排序",
          "en": "linear ordering",
          "ps": "N"
        },
        {
          "t": "先後順序",
          "en": "precedence",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Connected Components, Undirected Graph, Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個無向圖，您想要計算圖中共有幾個「連通分量」(Connected Components)。",
        "en": "Given an undirected graph, you want to count the total number of 'Connected Components'.",
        "wg": [
          {
            "t": "連通分量",
            "en": "connected components",
            "ps": "N"
          }
        ]
      },
      {
        "t": "以下哪種策略是正確的？",
        "en": "Which of the following strategies is correct?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對圖中任意一個節點執行一次 BFS 即可。",
        "en": "(A) Perform BFS once starting from any node in the graph.",
        "wg": []
      },
      {
        "t": "(B) 遍歷所有節點，若該節點未被訪問過，則計數加一並從該節點開始執行一次完整的 BFS/DFS。",
        "en": "(B) Iterate through all nodes; if a node has not been visited, increment the count and perform a complete BFS/DFS starting from that node.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate/traverse",
            "ps": "V"
          },
          {
            "t": "計數",
            "en": "count",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 計算圖中邊的數量減去節點數量的結果。",
        "en": "(C) Calculate the result of the number of edges minus the number of nodes.",
        "wg": []
      },
      {
        "t": "(D) 檢查鄰接矩陣中是否有任何值為 0。",
        "en": "(D) Check if there are any zero values in the adjacency matrix.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "一次 BFS/DFS 只能走訪單一連通分量中的所有節點。為了找出所有的連通分量，必須使用迴圈檢查每個節點；如果發現未訪問的節點，代表發現了一個新的連通分量，此時才觸發遍歷。",
      "en": "A single BFS/DFS can only traverse all nodes within a single connected component. To find all connected components, you must loop through every node; finding an unvisited node indicates a new connected component has been found, which then triggers a traversal.",
      "wg": [
        {
          "t": "觸發",
          "en": "trigger",
          "ps": "V"
        },
        {
          "t": "走訪",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Dependencies",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個構建系統（Build System），其中某些任務必須在其他任務開始之前完成。",
        "en": "You are designing a build system where certain tasks must be completed before others can begin.",
        "wg": [
          {
            "t": "構建系統",
            "en": "build system",
            "ps": "N"
          },
          {
            "t": "任務",
            "en": "task",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這些依賴關係可以表示為有向圖。",
        "en": "These dependencies can be represented as a directed graph.",
        "wg": [
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          },
          {
            "t": "有向圖",
            "en": "directed graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了找到有效的執行順序，應該使用哪種演算法？",
        "en": "Which algorithm should be used to find a valid execution order?",
        "wg": [
          {
            "t": "執行順序",
            "en": "execution order",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 廣度優先搜尋 (BFS) 尋找最短路徑。",
        "en": "(A) Breadth-First Search (BFS) for shortest path.",
        "wg": []
      },
      {
        "t": "(B) 拓撲排序 (Topological Sort)。",
        "en": "(B) Topological Sort.",
        "wg": [
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 普林演算法 (Prim's Algorithm)。",
        "en": "(C) Prim's Algorithm.",
        "wg": []
      },
      {
        "t": "(D) 戴克斯特拉演算法 (Dijkstra's Algorithm)。",
        "en": "(D) Dijkstra's Algorithm.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "拓撲排序專門用於對有向無環圖 (DAG) 的節點進行線性排序，使得對於每一條有向邊 u -> v，u 都在 v 之前，這正是處理依賴關係所需的。",
      "en": "Topological Sort is specifically designed to linearly order the nodes of a Directed Acyclic Graph (DAG) such that for every directed edge u -> v, u comes before v, which is exactly what is needed for handling dependencies.",
      "wg": [
        {
          "t": "有向無環圖",
          "en": "Directed Acyclic Graph (DAG)",
          "ps": "N"
        },
        {
          "t": "線性排序",
          "en": "linear ordering",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "hard",
    "keywords": "Cycle Detection, DFS, Recursion Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在使用深度優先搜尋 (DFS) 檢測有向圖中的環 (Cycle) 時，我們通常維護節點的三種狀態：未訪問、訪問中、已完成。",
        "en": "When detecting a cycle in a directed graph using Depth-First Search (DFS), we typically maintain three states for nodes: unvisited, visiting, and visited.",
        "wg": [
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          },
          {
            "t": "未訪問",
            "en": "unvisited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問遇到什麼情況時，表示圖中存在環？",
        "en": "Under what condition does it indicate that a cycle exists in the graph?",
        "wg": [
          {
            "t": "表示",
            "en": "indicate",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遇到一個標記為「未訪問」的鄰居節點。",
        "en": "(A) Encountering a neighbor node marked as 'unvisited'.",
        "wg": []
      },
      {
        "t": "(B) 遇到一個標記為「已完成」的鄰居節點。",
        "en": "(B) Encountering a neighbor node marked as 'visited' (completed).",
        "wg": []
      },
      {
        "t": "(C) 遇到一個標記為「訪問中」(在目前的遞迴堆疊中) 的鄰居節點。",
        "en": "(C) Encountering a neighbor node marked as 'visiting' (currently in the recursion stack).",
        "wg": [
          {
            "t": "遞迴堆疊",
            "en": "recursion stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遍歷完所有節點都沒有重複訪問。",
        "en": "(D) Traversing all nodes without any repeated visits.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在有向圖的 DFS 中，如果遇到一個狀態為「訪問中」的節點，表示該節點是當前路徑上的祖先，這意味著存在一條「後向邊」(Back Edge)，從而形成環。",
      "en": "In a DFS of a directed graph, if you encounter a node with the status 'visiting', it means the node is an ancestor in the current path, implying the existence of a 'Back Edge', thus forming a cycle.",
      "wg": [
        {
          "t": "祖先",
          "en": "ancestor",
          "ps": "N"
        },
        {
          "t": "後向邊",
          "en": "Back Edge",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Bipartite Graph, Graph Coloring, Odd Cycle",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二分圖 (Bipartite Graph) 是一個可以將頂點分割成兩個獨立集合的圖，使得每條邊都連接不同集合的頂點。",
        "en": "A Bipartite Graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects vertices in different sets.",
        "wg": [
          {
            "t": "二分圖",
            "en": "Bipartite Graph",
            "ps": "N"
          },
          {
            "t": "獨立集合",
            "en": "disjoint sets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種情況會導致一個無向圖「無法」成為二分圖？",
        "en": "Which of the following conditions makes it 'impossible' for an undirected graph to be bipartite?",
        "wg": [
          {
            "t": "無向圖",
            "en": "undirected graph",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 圖中包含偶數長度的環。",
        "en": "(A) The graph contains a cycle of even length.",
        "wg": [
          {
            "t": "偶數長度",
            "en": "even length",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 圖中包含奇數長度的環。",
        "en": "(B) The graph contains a cycle of odd length.",
        "wg": [
          {
            "t": "奇數長度",
            "en": "odd length",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 圖是非連通的。",
        "en": "(C) The graph is disconnected.",
        "wg": [
          {
            "t": "非連通",
            "en": "disconnected",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 圖中存在度數為 0 的節點。",
        "en": "(D) There is a node with a degree of 0 in the graph.",
        "wg": [
          {
            "t": "度數",
            "en": "degree",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二分圖可以使用兩種顏色進行著色，若存在奇數長度的環，則無法交替著色而不發生衝突（即最後一個節點會與第一個節點顏色相同且相連），因此包含奇數環的圖一定不是二分圖。",
      "en": "A bipartite graph can be colored with two colors. If an odd-length cycle exists, it is impossible to alternate colors without a conflict (the last node would have the same color as the first and be connected), so a graph with an odd cycle cannot be bipartite.",
      "wg": [
        {
          "t": "著色",
          "en": "coloring",
          "ps": "N"
        },
        {
          "t": "衝突",
          "en": "conflict",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "BFS, Shortest Path, Unweighted Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個「無權重」的圖中尋找起點到終點的最短路徑時，為什麼通常首選廣度優先搜尋 (BFS) 而不是深度優先搜尋 (DFS)？",
        "en": "When finding the shortest path from a start node to a target node in an 'unweighted' graph, why is Breadth-First Search (BFS) usually preferred over Depth-First Search (DFS)?",
        "wg": [
          {
            "t": "無權重",
            "en": "unweighted",
            "ps": "Adj"
          },
          {
            "t": "首選",
            "en": "preferred",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) BFS 使用較少的記憶體。",
        "en": "(A) BFS uses less memory.",
        "wg": []
      },
      {
        "t": "(B) BFS 保證在第一次到達目標節點時，所經過的路徑即為最短路徑。",
        "en": "(B) BFS guarantees that the first time the target node is reached, the path taken is the shortest.",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) DFS 無法處理有環的圖。",
        "en": "(C) DFS cannot handle graphs with cycles.",
        "wg": []
      },
      {
        "t": "(D) BFS 的實作比 DFS 簡單。",
        "en": "(D) The implementation of BFS is simpler than DFS.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "BFS 是逐層向外擴展的，因此它保證在訪問到距離起點距離為 k+1 的節點之前，已經訪問完所有距離為 k 的節點。",
      "en": "BFS expands layer by layer, so it guarantees that all nodes at distance k are visited before any node at distance k+1.",
      "wg": [
        {
          "t": "逐層",
          "en": "layer by layer",
          "ps": "Adv"
        },
        {
          "t": "擴展",
          "en": "expand",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "easy",
    "keywords": "Connected Components, Time Complexity, Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個使用鄰接串列 (Adjacency List) 表示的無向圖，包含 V 個頂點和 E 條邊。",
        "en": "Given an undirected graph represented by an Adjacency List, containing V vertices and E edges.",
        "wg": [
          {
            "t": "鄰接串列",
            "en": "Adjacency List",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要找出圖中所有的連通分量 (Connected Components)，使用 BFS 或 DFS 遍歷的時間複雜度是多少？",
        "en": "What is the time complexity to find all Connected Components using BFS or DFS traversal?",
        "wg": [
          {
            "t": "連通分量",
            "en": "Connected Components",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(V)",
        "en": "(A) O(V)",
        "wg": []
      },
      {
        "t": "(B) O(E)",
        "en": "(B) O(E)",
        "wg": []
      },
      {
        "t": "(C) O(V + E)",
        "en": "(C) O(V + E)",
        "wg": []
      },
      {
        "t": "(D) O(V * E)",
        "en": "(D) O(V * E)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "為了找出所有連通分量，演算法必須訪問每個頂點一次 (O(V))，並且在遍歷過程中檢查每一條邊 (對於無向圖，每條邊在鄰接串列中出現兩次，即 2E)。",
      "en": "To find all connected components, the algorithm must visit every vertex once (O(V)) and check every edge during the traversal (for an undirected graph, each edge appears twice in the adjacency list, i.e., 2E).",
      "wg": [
        {
          "t": "遍歷",
          "en": "traversal",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Graph, Topological Sort, DAG, Dependency Resolution",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個大型軟體專案的自動化建置系統，該系統包含數百個互相依賴的模組。",
        "en": "You are designing an automated build system for a large software project containing hundreds of interdependent modules.",
        "wg": [
          {
            "t": "建置系統",
            "en": "build system",
            "ps": "N"
          },
          {
            "t": "互相依賴",
            "en": "interdependent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了確保編譯順序正確，必須先編譯被依賴的模組，且系統中不能存在循環依賴。",
        "en": "To ensure the correct compilation order, dependencies must be compiled first, and there must be no circular dependencies in the system.",
        "wg": [
          {
            "t": "循環依賴",
            "en": "circular dependencies",
            "ps": "N"
          },
          {
            "t": "編譯",
            "en": "compile",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問您應該使用哪種圖演算法來決定模組的線性編譯順序？",
        "en": "Which graph algorithm should you use to determine the linear compilation order of the modules?",
        "wg": [
          {
            "t": "線性",
            "en": "linear",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 戴克斯特拉演算法 (Dijkstra's Algorithm)",
        "en": "(A) Dijkstra's Algorithm",
        "wg": []
      },
      {
        "t": "(B) 拓撲排序 (Topological Sort)",
        "en": "(B) Topological Sort",
        "wg": [
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 普林演算法 (Prim's Algorithm)",
        "en": "(C) Prim's Algorithm",
        "wg": []
      },
      {
        "t": "(D) 雙向廣度優先搜尋 (Bidirectional BFS)",
        "en": "(D) Bidirectional BFS",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "拓撲排序專門用於有向無環圖 (DAG) 中，將節點排列成線性序列，使得對於每一條有向邊 (u, v)，u 都在 v 之前，這正是解決依賴關係排序的標準方法。Dijkstra 用於最短路徑，Prim 用於最小生成樹，BFS 用於遍歷或尋找無權重圖的最短路徑，皆不適合此場景。",
      "en": "Topological Sort is specifically designed for Directed Acyclic Graphs (DAGs) to arrange nodes in a linear sequence such that for every directed edge (u, v), u comes before v, which is the standard method for resolving dependency ordering. Dijkstra is for shortest paths, Prim is for Minimum Spanning Trees, and BFS is for traversal or unweighted shortest paths, none of which fit this scenario.",
      "wg": [
        {
          "t": "有向無環圖",
          "en": "Directed Acyclic Graph (DAG)",
          "ps": "N"
        },
        {
          "t": "依賴關係",
          "en": "dependency",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "hard",
    "keywords": "Graph, Shortest Path, Bellman-Ford, Negative Weights",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在金融交易網路中，節點代表貨幣，邊的權重代表匯率轉換的成本（取對數後可能為負值，以計算套利機會）。",
        "en": "In a financial transaction network, nodes represent currencies, and edge weights represent the cost of exchange rate conversion (which may be negative after taking the logarithm to calculate arbitrage opportunities).",
        "wg": [
          {
            "t": "匯率",
            "en": "exchange rate",
            "ps": "N"
          },
          {
            "t": "套利",
            "en": "arbitrage",
            "ps": "N"
          },
          {
            "t": "對數",
            "en": "logarithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要尋找兩個貨幣之間的最短路徑，且圖中可能包含負權重的邊。",
        "en": "You need to find the shortest path between two currencies, and the graph may contain edges with negative weights.",
        "wg": [
          {
            "t": "負權重",
            "en": "negative weights",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼標準的 Dijkstra 演算法不適合此場景，以及應該改用什麼演算法？",
        "en": "Why is the standard Dijkstra algorithm unsuitable for this scenario, and what algorithm should be used instead?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 無法處理負權重邊，應改用 Bellman-Ford 演算法。",
        "en": "(A) Dijkstra cannot handle negative weight edges; use the Bellman-Ford algorithm instead.",
        "wg": []
      },
      {
        "t": "(B) Dijkstra 的時間複雜度太高，應改用 Floyd-Warshall 演算法。",
        "en": "(B) Dijkstra's time complexity is too high; use the Floyd-Warshall algorithm instead.",
        "wg": []
      },
      {
        "t": "(C) Dijkstra 只能處理無向圖，應改用 Kruskal 演算法。",
        "en": "(C) Dijkstra can only handle undirected graphs; use Kruskal's algorithm instead.",
        "wg": []
      },
      {
        "t": "(D) Dijkstra 會陷入無窮迴圈，應改用 DFS。",
        "en": "(D) Dijkstra will enter an infinite loop; use DFS instead.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "Dijkstra 演算法基於貪婪策略，假設一旦節點被標記為已訪問，其最短路徑就已確定，因此遇到負權重邊時會導致計算錯誤。Bellman-Ford 透過對所有邊進行 V-1 次鬆弛操作，能夠正確處理負權重邊，甚至能偵測負權重環 (Negative Cycle)。",
      "en": "Dijkstra's algorithm relies on a greedy strategy, assuming that once a node is visited, its shortest path is finalized, which leads to incorrect calculations when negative edges exist. Bellman-Ford correctly handles negative weights by relaxing all edges V-1 times and can even detect negative cycles.",
      "wg": [
        {
          "t": "貪婪策略",
          "en": "greedy strategy",
          "ps": "N"
        },
        {
          "t": "鬆弛",
          "en": "relax (relaxation)",
          "ps": "V"
        },
        {
          "t": "負權重環",
          "en": "negative cycle",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Graph, Cycle Detection, DFS, Recursion Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def has_cycle(graph, node, visited, rec_stack):\n    visited.add(node)\n    rec_stack.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if has_cycle(graph, neighbor, visited, rec_stack):\n                return True\n        elif neighbor in rec_stack:\n            return True\n    rec_stack.remove(node)\n    return False",
    "question": [
      {
        "t": "請參考上方的 Python 程式碼片段，這是一個用於偵測圖中是否存在環 (Cycle) 的函式。",
        "en": "Please refer to the Python code snippet above, which is a function used to detect if a cycle exists in a graph.",
        "wg": []
      },
      {
        "t": "這段程式碼特別使用了 `rec_stack` (遞迴堆疊) 來追蹤當前路徑上的節點。",
        "en": "This code specifically uses a `rec_stack` (recursion stack) to track nodes on the current path.",
        "wg": [
          {
            "t": "遞迴堆疊",
            "en": "recursion stack",
            "ps": "N"
          },
          {
            "t": "追蹤",
            "en": "track",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問這種實作方式最主要是為了解決哪種類型圖的環偵測問題？",
        "en": "For which type of graph is this implementation primarily designed to solve the cycle detection problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 無向圖 (Undirected Graph)，因為無向圖需要區分父節點。",
        "en": "(A) Undirected Graph, because undirected graphs need to distinguish the parent node.",
        "wg": []
      },
      {
        "t": "(B) 有向圖 (Directed Graph)，因為需要區分「背向邊」與「交叉邊/前向邊」。",
        "en": "(B) Directed Graph, because it is necessary to distinguish 'back edges' from 'cross edges/forward edges'.",
        "wg": [
          {
            "t": "背向邊",
            "en": "back edge",
            "ps": "N"
          },
          {
            "t": "交叉邊",
            "en": "cross edge",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 加權圖 (Weighted Graph)，因為權重可能影響環的形成。",
        "en": "(C) Weighted Graph, because weights might affect cycle formation.",
        "wg": []
      },
      {
        "t": "(D) 二分圖 (Bipartite Graph)，因為需要檢查著色衝突。",
        "en": "(D) Bipartite Graph, because coloring conflicts need to be checked.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在有向圖中，單純遇到「已訪問」的節點不代表有環（可能是交叉邊指向已處理完的分支）。只有當邊指向「當前遞迴堆疊中」的節點時，才代表指向了祖先節點，形成環（背向邊）。無向圖通常只需要檢查是否訪問到非父節點的已訪問節點即可。",
      "en": "In a directed graph, simply encountering a 'visited' node does not imply a cycle (it could be a cross edge to a finished branch). A cycle is confirmed only when an edge points to a node in the 'current recursion stack', indicating a link to an ancestor (back edge). For undirected graphs, checking if a visited node is not the parent is usually sufficient.",
      "wg": [
        {
          "t": "祖先節點",
          "en": "ancestor node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Graph, MST, Kruskal, Union-Find",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要以最低成本連接多個分散的島嶼，已知每對島嶼之間建造橋樑的成本。",
        "en": "You need to connect multiple scattered islands at the lowest cost, given the cost of building bridges between each pair of islands.",
        "wg": [
          {
            "t": "分散的",
            "en": "scattered",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "您決定使用克魯斯克爾演算法 (Kruskal's Algorithm) 來解決這個最小生成樹 (MST) 問題。",
        "en": "You decide to use Kruskal's Algorithm to solve this Minimum Spanning Tree (MST) problem.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在該演算法中，通常會搭配哪種資料結構來高效地判斷加入一條邊是否會形成環？",
        "en": "Which data structure is typically paired with this algorithm to efficiently determine if adding an edge would form a cycle?",
        "wg": [
          {
            "t": "高效地",
            "en": "efficiently",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先佇列 (Priority Queue / Heap)",
        "en": "(A) Priority Queue / Heap",
        "wg": []
      },
      {
        "t": "(B) 互斥集 / 並查集 (Disjoint Set / Union-Find)",
        "en": "(B) Disjoint Set / Union-Find",
        "wg": [
          {
            "t": "互斥集",
            "en": "Disjoint Set",
            "ps": "N"
          },
          {
            "t": "並查集",
            "en": "Union-Find",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 雜湊表 (Hash Map)",
        "en": "(C) Hash Map",
        "wg": []
      },
      {
        "t": "(D) 區段樹 (Segment Tree)",
        "en": "(D) Segment Tree",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Kruskal 演算法依權重排序邊，並依序嘗試加入圖中。為了判斷兩個節點是否已經連通（即加入邊是否會形成環），使用互斥集 (Union-Find) 是最有效率的方法，其 Find 和 Union 操作接近常數時間複雜度。",
      "en": "Kruskal's algorithm sorts edges by weight and adds them sequentially. To check if two nodes are already connected (i.e., if adding the edge would form a cycle), Union-Find is the most efficient method, with Find and Union operations having nearly constant time complexity.",
      "wg": [
        {
          "t": "連通",
          "en": "connected",
          "ps": "Adj"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Graph, Bipartite Graph, BFS, Coloring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要將一群伺服器劃分為兩個叢集 (Cluster A 和 Cluster B)。",
        "en": "You need to divide a group of servers into two clusters (Cluster A and Cluster B).",
        "wg": [
          {
            "t": "叢集",
            "en": "cluster",
            "ps": "N"
          }
        ]
      },
      {
        "t": "某些伺服器之間存在硬體連線，為了避免干擾，有直接連線的伺服器不能被分配到同一個叢集中。",
        "en": "Some servers have hardware connections between them; to avoid interference, directly connected servers cannot be assigned to the same cluster.",
        "wg": [
          {
            "t": "干擾",
            "en": "interference",
            "ps": "N"
          },
          {
            "t": "分配",
            "en": "assign",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這個問題可以轉化為檢查圖是否具備什麼特性？",
        "en": "This problem can be transformed into checking if the graph possesses which property?",
        "wg": [
          {
            "t": "轉化",
            "en": "transform",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 是否為強連通分量 (Strongly Connected Component)",
        "en": "(A) Whether it is a Strongly Connected Component",
        "wg": [
          {
            "t": "強連通分量",
            "en": "Strongly Connected Component",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 是否為二分圖 (Bipartite Graph)",
        "en": "(B) Whether it is a Bipartite Graph",
        "wg": [
          {
            "t": "二分圖",
            "en": "Bipartite Graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 是否包含尤拉路徑 (Eulerian Path)",
        "en": "(C) Whether it contains an Eulerian Path",
        "wg": []
      },
      {
        "t": "(D) 是否為完全圖 (Complete Graph)",
        "en": "(D) Whether it is a Complete Graph",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二分圖的定義是頂點集可以分割為兩個互斥的集合，且圖中所有邊都連接著兩個不同集合的頂點。這完全符合題目中「相鄰伺服器必須在不同叢集」的要求（即 2-Coloring 問題）。",
      "en": "A Bipartite Graph is defined as a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to one in the other. This perfectly matches the requirement that 'adjacent servers must be in different clusters' (i.e., the 2-Coloring problem).",
      "wg": [
        {
          "t": "互斥的",
          "en": "disjoint",
          "ps": "Adj"
        },
        {
          "t": "頂點",
          "en": "vertex (vertices)",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "Minimum Spanning Tree, Kruskal's Algorithm, Greedy, Union-Find",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在庫魯斯克爾演算法 (Kruskal's Algorithm) 建構最小生成樹 (MST) 的過程中，我們通常會將所有邊依照權重由小到大排序。",
        "en": "In the process of constructing a Minimum Spanning Tree (MST) using Kruskal's Algorithm, we typically sort all edges by weight in ascending order.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "NP"
          },
          {
            "t": "權重",
            "en": "weight",
            "ps": "N"
          },
          {
            "t": "由小到大",
            "en": "ascending",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了避免加入某條邊時形成迴圈 (Cycle)，最常搭配哪種資料結構來高效地檢查兩個頂點是否屬於同一個連通分量？",
        "en": "To avoid forming a cycle when adding an edge, which data structure is most commonly used to efficiently check if two vertices belong to the same connected component?",
        "wg": [
          {
            "t": "迴圈",
            "en": "cycle",
            "ps": "N"
          },
          {
            "t": "連通分量",
            "en": "connected component",
            "ps": "NP"
          },
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)",
        "en": "(A) Stack",
        "wg": []
      },
      {
        "t": "(B) 雜湊表 (Hash Table)",
        "en": "(B) Hash Table",
        "wg": []
      },
      {
        "t": "(C) 並查集 (Disjoint Set / Union-Find)",
        "en": "(C) Disjoint Set / Union-Find",
        "wg": [
          {
            "t": "並查集",
            "en": "Disjoint Set",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 優先佇列 (Priority Queue)",
        "en": "(D) Priority Queue",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Kruskal 演算法利用並查集 (Union-Find) 來管理頂點的集合。",
      "en": "Kruskal's algorithm uses the Union-Find (Disjoint Set) data structure to manage sets of vertices.",
      "wg": []
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Shortest Path, Dijkstra, Bellman-Ford, Negative Weights",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個金融交易路徑分析系統，其中邊的權重代表交易成本，但某些特殊促銷路徑的成本可能為負值 (即獲得回饋)。",
        "en": "You are designing a financial transaction path analysis system where edge weights represent transaction costs, but some special promotional paths may have negative costs (i.e., earning a rebate).",
        "wg": [
          {
            "t": "交易成本",
            "en": "transaction cost",
            "ps": "NP"
          },
          {
            "t": "負值",
            "en": "negative value",
            "ps": "N"
          },
          {
            "t": "回饋",
            "en": "rebate",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要計算從單一源點到其他所有節點的最短路徑，且圖中可能包含負權重邊，應使用下列哪種演算法？",
        "en": "If you need to calculate the shortest paths from a single source to all other nodes, and the graph may contain negative weight edges, which algorithm should be used?",
        "wg": [
          {
            "t": "單一源點",
            "en": "single source",
            "ps": "NP"
          },
          {
            "t": "負權重邊",
            "en": "negative weight edges",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 演算法",
        "en": "(A) Dijkstra's Algorithm",
        "wg": []
      },
      {
        "t": "(B) Bellman-Ford 演算法",
        "en": "(B) Bellman-Ford Algorithm",
        "wg": []
      },
      {
        "t": "(C) Prim 演算法",
        "en": "(C) Prim's Algorithm",
        "wg": []
      },
      {
        "t": "(D) 深度優先搜尋 (DFS)",
        "en": "(D) Depth-First Search (DFS)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 演算法基於貪婪策略，假設一旦節點被處理，其最短路徑就已確定，因此無法正確處理負權重邊。",
      "en": "Dijkstra's algorithm is based on a greedy strategy and assumes that once a node is processed, its shortest path is finalized, so it cannot correctly handle negative weight edges.",
      "wg": [
        {
          "t": "貪婪策略",
          "en": "greedy strategy",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Topological Sort, DAG, Dependency Resolution, Cycle Detection",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在編譯系統中，我們需要決定檔案編譯的順序，這通常被建模為一個有向圖的拓撲排序 (Topological Sort) 問題。",
        "en": "In a compilation system, we need to determine the order of file compilation, which is typically modeled as a Topological Sort problem on a directed graph.",
        "wg": [
          {
            "t": "編譯",
            "en": "compilation",
            "ps": "N"
          },
          {
            "t": "建模",
            "en": "modeled",
            "ps": "V"
          },
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "關於拓撲排序，下列哪項敘述是**錯誤**的？",
        "en": "Regarding Topological Sort, which of the following statements is **FALSE**?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只有「有向無環圖」(DAG) 才能進行拓撲排序。",
        "en": "(A) Only a 'Directed Acyclic Graph' (DAG) can undergo topological sorting.",
        "wg": [
          {
            "t": "有向無環圖",
            "en": "Directed Acyclic Graph",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 如果圖中存在迴圈，拓撲排序演算法將無法產生包含所有節點的有效序列。",
        "en": "(B) If a cycle exists in the graph, the topological sort algorithm cannot produce a valid sequence containing all nodes.",
        "wg": []
      },
      {
        "t": "(C) 一個圖的拓撲排序結果是唯一的。",
        "en": "(C) The result of a topological sort for a graph is unique.",
        "wg": [
          {
            "t": "唯一的",
            "en": "unique",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) Kahn 演算法利用「入度」(In-degree) 為 0 的概念來實作拓撲排序。",
        "en": "(D) Kahn's algorithm implements topological sorting using the concept of 'In-degree' being 0.",
        "wg": [
          {
            "t": "入度",
            "en": "In-degree",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "拓撲排序的結果通常不唯一；只要滿足所有依賴關係，可能存在多種合法的排序順序。",
      "en": "The result of a topological sort is typically not unique; as long as all dependencies are satisfied, there may be multiple valid sorting orders.",
      "wg": [
        {
          "t": "依賴關係",
          "en": "dependencies",
          "ps": "N"
        },
        {
          "t": "合法的",
          "en": "valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Graph Representation, Adjacency Matrix, Adjacency List, Space Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在選擇圖的儲存方式時，我們通常會在「鄰接矩陣」(Adjacency Matrix) 與「鄰接串列」(Adjacency List) 之間做選擇。",
        "en": "When choosing a storage method for a graph, we usually choose between an 'Adjacency Matrix' and an 'Adjacency List'.",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "Adjacency Matrix",
            "ps": "NP"
          },
          {
            "t": "鄰接串列",
            "en": "Adjacency List",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "對於一個頂點數為 V、邊數為 E 的「稠密圖」(Dense Graph，即 E 接近 V²)，下列敘述何者正確？",
        "en": "For a 'Dense Graph' (where E is close to V²) with V vertices and E edges, which of the following statements is correct?",
        "wg": [
          {
            "t": "稠密圖",
            "en": "Dense Graph",
            "ps": "NP"
          },
          {
            "t": "接近",
            "en": "close to",
            "ps": "Prep"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鄰接串列的空間複雜度較低，且查詢兩點是否相鄰的時間為 O(1)。",
        "en": "(A) The Adjacency List has lower space complexity, and the time to query if two points are adjacent is O(1).",
        "wg": []
      },
      {
        "t": "(B) 鄰接矩陣在稠密圖中較為適用，因為其查詢兩點是否相鄰的時間為 O(1)，且空間浪費相對較少。",
        "en": "(B) The Adjacency Matrix is more suitable for dense graphs because the time to query if two points are adjacent is O(1), and the space waste is relatively low.",
        "wg": [
          {
            "t": "適用",
            "en": "suitable",
            "ps": "Adj"
          },
          {
            "t": "浪費",
            "en": "waste",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 鄰接串列在稠密圖中總是比鄰接矩陣消耗更多記憶體。",
        "en": "(C) The Adjacency List always consumes more memory than the Adjacency Matrix in a dense graph.",
        "wg": []
      },
      {
        "t": "(D) 鄰接矩陣無法處理加權圖 (Weighted Graph)。",
        "en": "(D) The Adjacency Matrix cannot handle Weighted Graphs.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "鄰接矩陣的空間複雜度固定為 O(V²)，對於稠密圖 (E ≈ V²) 而言，這與鄰接串列的 O(V+E) 空間相差不大，但矩陣提供了 O(1) 的邊查詢優勢。",
      "en": "The space complexity of an Adjacency Matrix is fixed at O(V²). For a dense graph (E ≈ V²), this is comparable to the O(V+E) space of an Adjacency List, but the matrix offers the advantage of O(1) edge lookups.",
      "wg": [
        {
          "t": "相差不大",
          "en": "comparable / not much difference",
          "ps": "Ph"
        },
        {
          "t": "優勢",
          "en": "advantage",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "hard",
    "keywords": "Union-Find, Path Compression, Optimization, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "function find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x]) // ???\n    return parent[x]",
    "question": [
      {
        "t": "在並查集 (Union-Find) 的實作中，為了加速後續的查詢操作，我們常在 `find` 函式中加入一種優化技術 (如程式碼片段所示)。",
        "en": "In the implementation of Union-Find, to accelerate subsequent query operations, we often add an optimization technique in the `find` function (as shown in the code snippet).",
        "wg": [
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          },
          {
            "t": "加速",
            "en": "accelerate",
            "ps": "V"
          },
          {
            "t": "優化技術",
            "en": "optimization technique",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問這種技術稱為什麼，以及它如何影響時間複雜度？",
        "en": "What is this technique called, and how does it affect time complexity?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 按秩合併 (Union by Rank)；它將樹的高度保持在對數級別。",
        "en": "(A) Union by Rank; it keeps the tree height at a logarithmic level.",
        "wg": [
          {
            "t": "按秩合併",
            "en": "Union by Rank",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 路徑壓縮 (Path Compression)；它將節點直接連接到根節點，使後續查詢接近 O(1)。",
        "en": "(B) Path Compression; it connects nodes directly to the root, making subsequent queries close to O(1).",
        "wg": [
          {
            "t": "路徑壓縮",
            "en": "Path Compression",
            "ps": "NP"
          },
          {
            "t": "根節點",
            "en": "root node",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 迴圈偵測 (Cycle Detection)；它防止無限遞迴。",
        "en": "(C) Cycle Detection; it prevents infinite recursion.",
        "wg": []
      },
      {
        "t": "(D) 記憶化搜索 (Memoization)；它將複雜度降為 O(N)。",
        "en": "(D) Memoization; it reduces complexity to O(N).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "程式碼中的 `parent[x] = find(parent[x])` 是路徑壓縮的實作，它在遞迴過程中將路徑上的所有節點直接指向根節點，大幅扁平化樹的結構。",
      "en": "The code `parent[x] = find(parent[x])` implements Path Compression, which points all nodes on the path directly to the root during recursion, significantly flattening the tree structure.",
      "wg": [
        {
          "t": "遞迴",
          "en": "recursion",
          "ps": "N"
        },
        {
          "t": "扁平化",
          "en": "flattening",
          "ps": "V"
        }
      ]
    }
  }
]