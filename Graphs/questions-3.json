[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Graph, Topological Sort, Dependency Resolution, DAG",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個構建系統（Build System），需要決定一系列有依賴關係的軟體套件的編譯順序。",
        "en": "You are designing a build system and need to determine the compilation order for a series of software packages with dependencies.",
        "wg": [
          {
            "t": "構建系統",
            "en": "build system",
            "ps": "N"
          },
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          },
          {
            "t": "編譯順序",
            "en": "compilation order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果將套件視為節點，依賴關係視為有向邊，哪種演算法最適合用來產生合法的線性執行序列？",
        "en": "If packages are viewed as nodes and dependencies as directed edges, which algorithm is best suited to generate a valid linear execution sequence?",
        "wg": [
          {
            "t": "有向邊",
            "en": "directed edges",
            "ps": "N"
          },
          {
            "t": "線性執行序列",
            "en": "linear execution sequence",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 廣度優先搜尋 (BFS) 用於最短路徑。",
        "en": "(A) Breadth-First Search (BFS) for shortest paths.",
        "wg": []
      },
      {
        "t": "(B) 拓撲排序 (Topological Sort)。",
        "en": "(B) Topological Sort.",
        "wg": [
          {
            "t": "拓撲排序",
            "en": "topological sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Prim 的最小生成樹演算法。",
        "en": "(C) Prim's Minimum Spanning Tree algorithm.",
        "wg": []
      },
      {
        "t": "(D) Floyd-Warshall 演算法。",
        "en": "(D) Floyd-Warshall algorithm.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "拓撲排序專門用於有向無環圖 (DAG) 中，將節點排列成線性序列，使得對於每一條從節點 u 到 v 的有向邊，u 都在 v 之前出現，這正是解決依賴關係問題的標準方法。",
      "en": "Topological Sort is specifically designed for Directed Acyclic Graphs (DAGs) to arrange nodes in a linear sequence such that for every directed edge from node u to v, u comes before v, which is the standard method for resolving dependencies.",
      "wg": [
        {
          "t": "有向無環圖",
          "en": "Directed Acyclic Graph (DAG)",
          "ps": "N"
        },
        {
          "t": "標準方法",
          "en": "standard method",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Shortest Path, Dijkstra, Bellman-Ford, Negative Weights",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理圖的最短路徑問題時，如果圖中包含帶有「負權重」的邊，為什麼標準的 Dijkstra 演算法可能會給出錯誤的答案？",
        "en": "When dealing with the shortest path problem in a graph, why might the standard Dijkstra's algorithm provide an incorrect answer if the graph contains edges with 'negative weights'?",
        "wg": [
          {
            "t": "負權重",
            "en": "negative weights",
            "ps": "N"
          },
          {
            "t": "最短路徑",
            "en": "shortest path",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 演算法的時間複雜度太高，無法處理負數。",
        "en": "(A) The time complexity of Dijkstra's algorithm is too high to handle negative numbers.",
        "wg": []
      },
      {
        "t": "(B) Dijkstra 演算法基於貪婪策略，假設一旦節點被標記為已訪問，其最短路徑就已確定，無法回頭修正因負邊而變得更短的路徑。",
        "en": "(B) Dijkstra's algorithm is based on a greedy strategy, assuming that once a node is marked as visited, its shortest path is determined, and it cannot look back to correct paths that become shorter due to negative edges.",
        "wg": [
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          },
          {
            "t": "已訪問",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) Dijkstra 演算法只能用於無向圖。",
        "en": "(C) Dijkstra's algorithm can only be used on undirected graphs.",
        "wg": []
      },
      {
        "t": "(D) 負權重會導致整數溢位 (Integer Overflow)。",
        "en": "(D) Negative weights cause Integer Overflow.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 假設路徑權重是單調遞增的，當它選定一個節點的最短距離後就不會再更新；負權重邊可能導致後續路徑的總成本反而降低，破壞了這個假設（此時應使用 Bellman-Ford）。",
      "en": "Dijkstra assumes that path weights are monotonically increasing, and once it selects the shortest distance for a node, it does not update it again; negative weight edges can cause the total cost of subsequent paths to decrease, violating this assumption (Bellman-Ford should be used in this case).",
      "wg": [
        {
          "t": "單調遞增",
          "en": "monotonically increasing",
          "ps": "Adj"
        },
        {
          "t": "破壞",
          "en": "violate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Graph Representation, Space Complexity, Sparse Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個擁有 100 萬個使用者節點的社交網絡系統，但平均每位使用者只有約 50 位朋友（邊）。",
        "en": "You are designing a social network system with 1 million user nodes, but on average, each user has only about 50 friends (edges).",
        "wg": [
          {
            "t": "社交網絡",
            "en": "social network",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了優化記憶體空間，您應該選擇哪種圖的儲存方式？",
        "en": "To optimize memory space, which graph storage method should you choose?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "儲存方式",
            "en": "storage method",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鄰接矩陣 (Adjacency Matrix)。",
        "en": "(A) Adjacency Matrix.",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "adjacency matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 鄰接串列 (Adjacency List)。",
        "en": "(B) Adjacency List.",
        "wg": [
          {
            "t": "鄰接串列",
            "en": "adjacency list",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 兩個都一樣好。",
        "en": "(C) Both are equally good.",
        "wg": []
      },
      {
        "t": "(D) 遞迴樹 (Recursion Tree)。",
        "en": "(D) Recursion Tree.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個典型的稀疏圖 (Sparse Graph)。鄰接矩陣需要 O(V^2) 的空間，對於 100 萬個節點來說是巨大的浪費；而鄰接串列只需要 O(V + E) 的空間，非常適合邊數遠小於節點數平方的情況。",
      "en": "This is a typical sparse graph. An Adjacency Matrix requires O(V^2) space, which is a huge waste for 1 million nodes; whereas an Adjacency List requires only O(V + E) space, making it very suitable when the number of edges is far less than the square of the number of nodes.",
      "wg": [
        {
          "t": "稀疏圖",
          "en": "sparse graph",
          "ps": "N"
        },
        {
          "t": "巨大的浪費",
          "en": "huge waste",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "BFS, Unweighted Graph, Shortest Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個「無權重」的圖中，若要尋找從起點 A 到終點 B 的最短路徑（經過最少的邊），最適合的演算法是？",
        "en": "In an 'unweighted' graph, if you want to find the shortest path from start point A to end point B (passing through the fewest edges), what is the most suitable algorithm?",
        "wg": [
          {
            "t": "無權重",
            "en": "unweighted",
            "ps": "Adj"
          },
          {
            "t": "最適合",
            "en": "most suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 深度優先搜尋 (DFS)。",
        "en": "(A) Depth-First Search (DFS).",
        "wg": []
      },
      {
        "t": "(B) 廣度優先搜尋 (BFS)。",
        "en": "(B) Breadth-First Search (BFS).",
        "wg": [
          {
            "t": "廣度優先搜尋",
            "en": "Breadth-First Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Kruskal 演算法。",
        "en": "(C) Kruskal's Algorithm.",
        "wg": []
      },
      {
        "t": "(D) 拓撲排序。",
        "en": "(D) Topological Sort.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "BFS 以層級的方式向外擴展，保證了第一次訪問到目標節點時，所經過的路徑即為最短路徑（邊數最少）；DFS 雖然也能到達目標，但不保證路徑最短。",
      "en": "BFS expands outward in levels, guaranteeing that the first time the target node is visited, the path taken is the shortest (fewest edges); while DFS can also reach the target, it does not guarantee the shortest path.",
      "wg": [
        {
          "t": "層級",
          "en": "levels",
          "ps": "N"
        },
        {
          "t": "保證",
          "en": "guarantee",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "MST, Kruskal, Union-Find, Cycle Detection",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Kruskal 演算法透過貪婪地選擇權重最小的邊來構建最小生成樹 (MST)。",
        "en": "Kruskal's algorithm constructs a Minimum Spanning Tree (MST) by greedily selecting the edges with the smallest weights.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          },
          {
            "t": "貪婪地",
            "en": "greedily",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "為了確保加入的邊不會形成環，通常會搭配哪種資料結構來高效運作？",
        "en": "To ensure that the added edges do not form a cycle, which data structure is typically used for efficient operation?",
        "wg": [
          {
            "t": "形成環",
            "en": "form a cycle",
            "ps": "V"
          },
          {
            "t": "高效運作",
            "en": "efficient operation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)。",
        "en": "(A) Stack.",
        "wg": []
      },
      {
        "t": "(B) 雜湊表 (Hash Map)。",
        "en": "(B) Hash Map.",
        "wg": []
      },
      {
        "t": "(C) 互斥集合 / 並查集 (Disjoint Set / Union-Find)。",
        "en": "(C) Disjoint Set / Union-Find.",
        "wg": [
          {
            "t": "互斥集合",
            "en": "Disjoint Set",
            "ps": "N"
          },
          {
            "t": "並查集",
            "en": "Union-Find",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 二元搜尋樹 (BST)。",
        "en": "(D) Binary Search Tree (BST).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Union-Find 資料結構提供了 `find` 和 `union` 操作，能在接近常數時間內判斷兩個節點是否屬於同一個連通分量，從而快速檢測加入新邊是否會構成環。",
      "en": "The Union-Find data structure provides `find` and `union` operations, which can determine in near-constant time whether two nodes belong to the same connected component, thereby quickly detecting if adding a new edge would form a cycle.",
      "wg": [
        {
          "t": "連通分量",
          "en": "connected component",
          "ps": "N"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        }
      ]
    }
  }
]