[
  {
    "no": "1",
    "level": "Easy",
    "keywords": "Graph Representation, Space Complexity, Adjacency List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個社交網絡系統，其中使用者被視為節點，而好友關係被視為邊。",
        "en": "You are designing a social network system where users are considered nodes and friendships are considered edges.",
        "wg": [
          {
            "t": "社交網絡",
            "en": "social network",
            "ps": "N"
          },
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "邊",
            "en": "edge",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設該圖非常稀疏（使用者數百萬，但每人平均只有 50 位好友）。",
        "en": "Assume the graph is very sparse (millions of users, but only 50 friends on average per person).",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了節省記憶體空間，您應該選擇哪種圖形表示法？",
        "en": "To save memory space, which graph representation should you choose?",
        "wg": [
          {
            "t": "表示法",
            "en": "representation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鄰接矩陣 (Adjacency Matrix)",
        "en": "(A) Adjacency Matrix",
        "wg": [
          {
            "t": "鄰接矩陣",
            "en": "Adjacency Matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 鄰接串列 (Adjacency List)",
        "en": "(B) Adjacency List",
        "wg": [
          {
            "t": "鄰接串列",
            "en": "Adjacency List",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 關聯矩陣 (Incidence Matrix)",
        "en": "(C) Incidence Matrix",
        "wg": [
          {
            "t": "關聯矩陣",
            "en": "Incidence Matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 雜湊表矩陣 (Hash Map Matrix)",
        "en": "(D) Hash Map Matrix",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "對於稀疏圖，鄰接串列的空間複雜度為 O(V+E)，遠優於鄰接矩陣的 O(V^2)。因為在稀疏圖中 E 遠小於 V^2，使用矩陣會浪費大量空間儲存 '0' (無邊的關係)。",
      "en": "For sparse graphs, the space complexity of an Adjacency List is O(V+E), which is far superior to the O(V^2) of an Adjacency Matrix. Since E is much smaller than V^2 in a sparse graph, using a matrix would waste a lot of space storing '0's (non-existent edges).",
      "wg": [
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "Medium",
    "keywords": "BFS, Shortest Path, Unweighted Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個無權重的圖形中，您需要找出從起點 A 到終點 B 的最短路徑（最少邊數）。",
        "en": "In an unweighted graph, you need to find the shortest path (minimum number of edges) from start node A to end node B.",
        "wg": [
          {
            "t": "無權重",
            "en": "unweighted",
            "ps": "Adj"
          },
          {
            "t": "最短路徑",
            "en": "shortest path",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種演算法最適合且效率最高？",
        "en": "Which of the following algorithms is the most suitable and efficient?",
        "wg": [
          {
            "t": "演算法",
            "en": "algorithm",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 深度優先搜尋 (DFS)",
        "en": "(A) Depth-First Search (DFS)",
        "wg": []
      },
      {
        "t": "(B) 廣度優先搜尋 (BFS)",
        "en": "(B) Breadth-First Search (BFS)",
        "wg": []
      },
      {
        "t": "(C) 貝爾曼-福特演算法 (Bellman-Ford)",
        "en": "(C) Bellman-Ford Algorithm",
        "wg": []
      },
      {
        "t": "(D) 普林演算法 (Prim's Algorithm)",
        "en": "(D) Prim's Algorithm",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "BFS 透過逐層探索的方式遍歷圖形，保證在第一次到達目標節點時，經過的路徑即為最短路徑（最少邊數）。DFS 不保證最短路徑；Bellman-Ford 雖然可以解但效率較差且主要用於有權重圖。",
      "en": "BFS traverses the graph layer by layer, guaranteeing that the path taken when the target node is first reached is the shortest path (fewest edges). DFS does not guarantee the shortest path; Bellman-Ford can solve it but is less efficient and primarily used for weighted graphs.",
      "wg": [
        {
          "t": "逐層",
          "en": "layer by layer",
          "ps": "Adv"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "Medium",
    "keywords": "Cycle Detection, DFS, Directed Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理任務依賴性時，我們將系統建模為有向圖。",
        "en": "When handling task dependencies, we model the system as a directed graph.",
        "wg": [
          {
            "t": "依賴性",
            "en": "dependency",
            "ps": "N"
          },
          {
            "t": "有向圖",
            "en": "directed graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用深度優先搜尋 (DFS) 來偵測圖中是否存在「循環依賴」(Cycle)，判斷依據為何？",
        "en": "If using Depth-First Search (DFS) to detect if a 'circular dependency' (Cycle) exists in the graph, what is the criterion?",
        "wg": [
          {
            "t": "循環依賴",
            "en": "circular dependency",
            "ps": "N"
          },
          {
            "t": "判斷依據",
            "en": "criterion",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遇到任何已經訪問過 (Visited) 的節點。",
        "en": "(A) Encountering any node that has already been visited.",
        "wg": []
      },
      {
        "t": "(B) 遇到一個目前正處於遞迴堆疊 (Recursion Stack) 中的節點。",
        "en": "(B) Encountering a node that is currently in the recursion stack.",
        "wg": [
          {
            "t": "遞迴堆疊",
            "en": "recursion stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 遇到一個沒有出邊 (Outgoing Edge) 的節點。",
        "en": "(C) Encountering a node with no outgoing edges.",
        "wg": [
          {
            "t": "出邊",
            "en": "outgoing edge",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遍歷完所有節點都沒有重複。",
        "en": "(D) Traversing all nodes without any repetition.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在有向圖中，單純遇到「已訪問」的節點不代表有環（可能是兩條路徑匯聚到同一點）。必須是遇到「當前遞迴路徑上」的節點（即還在堆疊中、尚未結束處理的節點），才代表發現了後向邊 (Back Edge)，形成環。",
      "en": "In a directed graph, simply encountering a 'visited' node does not imply a cycle (it could be two paths converging at the same point). It must be encountering a node on the 'current recursion path' (i.e., in the stack and not yet finished processing) to signify a back edge, forming a cycle.",
      "wg": [
        {
          "t": "匯聚",
          "en": "converge",
          "ps": "V"
        },
        {
          "t": "後向邊",
          "en": "back edge",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "Medium",
    "keywords": "Topological Sort, DAG, Scheduling",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您想要對一系列有先後順序的課程進行排程，這是一個典型的拓撲排序 (Topological Sort) 應用。",
        "en": "You want to schedule a series of courses with prerequisites, which is a typical application of Topological Sort.",
        "wg": [
          {
            "t": "排程",
            "en": "schedule",
            "ps": "V"
          },
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了能夠成功執行拓撲排序，該圖形必須滿足什麼條件？",
        "en": "To successfully perform a Topological Sort, what condition must the graph satisfy?",
        "wg": [
          {
            "t": "條件",
            "en": "condition",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 必須是無向圖 (Undirected Graph)。",
        "en": "(A) It must be an Undirected Graph.",
        "wg": []
      },
      {
        "t": "(B) 必須是完全連通圖 (Fully Connected Graph)。",
        "en": "(B) It must be a Fully Connected Graph.",
        "wg": []
      },
      {
        "t": "(C) 必須是有向無環圖 (DAG)。",
        "en": "(C) It must be a Directed Acyclic Graph (DAG).",
        "wg": [
          {
            "t": "有向無環圖",
            "en": "Directed Acyclic Graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 必須是二元樹 (Binary Tree)。",
        "en": "(D) It must be a Binary Tree.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "拓撲排序是將節點線性排列，使得所有有向邊都從排在前面的節點指向後面的節點。如果圖中有環 (Cycle)，則無法確定優先順序（例如 A->B->A），因此必須是 DAG。",
      "en": "Topological sort is a linear ordering of nodes such that for every directed edge, the node comes before the one it points to. If the graph has a cycle (e.g., A->B->A), priority cannot be determined, so it must be a DAG.",
      "wg": [
        {
          "t": "線性排列",
          "en": "linear ordering",
          "ps": "N"
        },
        {
          "t": "優先順序",
          "en": "priority",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "Medium",
    "keywords": "Connected Components, Graph Traversal, Algorithm Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個二維網格地圖，其中 '1' 代表陸地，'0' 代表水域。",
        "en": "Given a 2D grid map where '1' represents land and '0' represents water.",
        "wg": [
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要計算地圖中「島嶼」的數量（相連的 '1' 視為一個島嶼），下列哪種演算法邏輯最為正確？",
        "en": "To count the number of 'islands' (connected '1's are considered one island) in the map, which algorithm logic is most correct?",
        "wg": [
          {
            "t": "島嶼",
            "en": "island",
            "ps": "N"
          },
          {
            "t": "相連的",
            "en": "connected",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對網格中的每個 '1' 執行二元搜尋。",
        "en": "(A) Perform binary search on every '1' in the grid.",
        "wg": []
      },
      {
        "t": "(B) 遍歷網格，每當遇到未訪問的 '1' 時，計數器加 1 並觸發 BFS/DFS 標記所有相連的 '1'。",
        "en": "(B) Iterate through the grid; whenever an unvisited '1' is encountered, increment the counter and trigger BFS/DFS to mark all connected '1's.",
        "wg": [
          {
            "t": "計數器",
            "en": "counter",
            "ps": "N"
          },
          {
            "t": "觸發",
            "en": "trigger",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 計算網格中所有 '1' 的總數，除以 4。",
        "en": "(C) Calculate the total number of '1's in the grid and divide by 4.",
        "wg": []
      },
      {
        "t": "(D) 使用動態規劃計算從左上角到右下角的路徑數。",
        "en": "(D) Use dynamic programming to count the number of paths from the top-left to the bottom-right.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是尋找圖形中「連通分量」(Connected Components) 的經典問題。每當發現一個新的陸地節點，就需要透過遍歷 (BFS 或 DFS) 把整塊相連的陸地都標記為已訪問，這樣主迴圈才不會重複計算同一座島嶼。",
      "en": "This is a classic problem of finding 'Connected Components' in a graph. Whenever a new land node is found, traversal (BFS or DFS) is needed to mark the entire connected landmass as visited so that the main loop does not double-count the same island.",
      "wg": [
        {
          "t": "連通分量",
          "en": "connected components",
          "ps": "N"
        },
        {
          "t": "主迴圈",
          "en": "main loop",
          "ps": "N"
        }
      ]
    }
  }
]