[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Greedy, Interval Scheduling, Activity Selection, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在管理一間會議室的預約系統，收到多個會議請求，每個請求都有明確的開始時間與結束時間。",
        "en": "You are managing a reservation system for a meeting room and have received multiple meeting requests, each with a specific start time and end time.",
        "wg": [
          {
            "t": "預約系統",
            "en": "reservation system",
            "ps": "N"
          },
          {
            "t": "明確的",
            "en": "specific",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若目標是安排「盡可能多」的會議場次（不考慮會議時長），您應該採取哪種貪婪策略（Greedy Strategy）來選擇會議？",
        "en": "If the goal is to schedule as many meetings as possible (regardless of duration), which Greedy strategy should you adopt to select meetings?",
        "wg": [
          {
            "t": "盡可能多",
            "en": "as many as possible",
            "ps": "Phrase"
          },
          {
            "t": "貪婪策略",
            "en": "Greedy strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先選擇「開始時間」最早的會議。",
        "en": "(A) Prioritize the meeting with the earliest start time.",
        "wg": [
          {
            "t": "優先選擇",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 優先選擇「持續時間」最短的會議。",
        "en": "(B) Prioritize the meeting with the shortest duration.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 優先選擇「結束時間」最早的會議。",
        "en": "(C) Prioritize the meeting with the earliest end time.",
        "wg": []
      },
      {
        "t": "(D) 優先選擇與其他會議衝突最少的會議。",
        "en": "(D) Prioritize the meeting that has the fewest conflicts with others.",
        "wg": [
          {
            "t": "衝突",
            "en": "conflict",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是經典的區間排程問題 (Interval Scheduling)。選擇結束時間最早的會議，可以盡早釋放資源給下一個會議使用，從而最大化容納的會議總數。",
      "en": "This is the classic Interval Scheduling problem. Choosing the meeting with the earliest end time frees up the resource as soon as possible for the next meeting, thereby maximizing the total number of meetings accommodated.",
      "wg": [
        {
          "t": "區間排程",
          "en": "Interval Scheduling",
          "ps": "N"
        },
        {
          "t": "釋放",
          "en": "free up",
          "ps": "V"
        },
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Greedy, Fractional Knapsack, 0/1 Knapsack, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "貪婪演算法通常用於尋找最佳解，但在某些情況下只能找到近似解。",
        "en": "Greedy algorithms are often used to find optimal solutions, but in some cases, they only yield approximate solutions.",
        "wg": [
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          },
          {
            "t": "近似解",
            "en": "approximate solution",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在下列哪種背包問題（Knapsack Problem）變體中，貪婪演算法保證能找到全域最佳解？",
        "en": "In which of the following variations of the Knapsack Problem is the Greedy algorithm guaranteed to find the global optimal solution?",
        "wg": [
          {
            "t": "變體",
            "en": "variation",
            "ps": "N"
          },
          {
            "t": "全域最佳解",
            "en": "global optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0/1 背包問題 (0/1 Knapsack Problem)。",
        "en": "(A) 0/1 Knapsack Problem.",
        "wg": []
      },
      {
        "t": "(B) 分數背包問題 (Fractional Knapsack Problem)。",
        "en": "(B) Fractional Knapsack Problem.",
        "wg": [
          {
            "t": "分數背包問題",
            "en": "Fractional Knapsack Problem",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 有界背包問題 (Bounded Knapsack Problem)。",
        "en": "(C) Bounded Knapsack Problem.",
        "wg": [
          {
            "t": "有界",
            "en": "bounded",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 多重背包問題 (Multiple Knapsack Problem)。",
        "en": "(D) Multiple Knapsack Problem.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在分數背包問題中，物品可以被分割（例如金粉），因此每次選擇「單位價值（CP值）」最高的物品填滿背包即可得到最佳解。而在 0/1 背包問題中，物品不可分割，貪婪法可能會因為無法填滿剩餘空間而導致非最佳解（需使用動態規劃）。",
      "en": "In the Fractional Knapsack Problem, items can be divided (e.g., gold dust), so repeatedly selecting the item with the highest 'value per unit' until the bag is full guarantees the optimal solution. In the 0/1 Knapsack Problem, items are indivisible, and the Greedy approach may result in a sub-optimal solution due to unused space (Dynamic Programming is required).",
      "wg": [
        {
          "t": "分割",
          "en": "divide",
          "ps": "V"
        },
        {
          "t": "不可分割",
          "en": "indivisible",
          "ps": "Adj"
        },
        {
          "t": "動態規劃",
          "en": "Dynamic Programming",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Greedy, Huffman Coding, Data Compression, Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼 (Huffman Coding) 是一種廣泛應用於資料壓縮的貪婪演算法。",
        "en": "Huffman Coding is a greedy algorithm widely used in data compression.",
        "wg": [
          {
            "t": "資料壓縮",
            "en": "data compression",
            "ps": "N"
          },
          {
            "t": "廣泛應用",
            "en": "widely used",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，貪婪選擇屬性（Greedy Choice Property）具體體現在哪一個步驟？",
        "en": "In the process of constructing a Huffman Tree, in which step is the Greedy Choice Property specifically embodied?",
        "wg": [
          {
            "t": "建構",
            "en": "construct",
            "ps": "V"
          },
          {
            "t": "體現",
            "en": "embody",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選擇出現頻率最高的兩個節點進行合併。",
        "en": "(A) Always select the two nodes with the highest frequencies to merge.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 每次選擇出現頻率最低的兩個節點進行合併。",
        "en": "(B) Always select the two nodes with the lowest frequencies to merge.",
        "wg": []
      },
      {
        "t": "(C) 隨機選擇兩個節點進行合併。",
        "en": "(C) Randomly select two nodes to merge.",
        "wg": []
      },
      {
        "t": "(D) 依照字元在 ASCII 表中的順序進行合併。",
        "en": "(D) Merge according to the order of characters in the ASCII table.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼編碼的策略是建立一棵由下往上的樹，每次取出頻率最低的兩個節點合併成一個新節點。這樣可以保證頻率低的字元位於樹的底部（編碼較長），而頻率高的字元位於頂部（編碼較短），從而最小化總編碼長度。",
      "en": "The strategy of Huffman Coding is to build a tree bottom-up by repeatedly merging the two nodes with the lowest frequencies into a new node. This ensures that low-frequency characters are at the bottom of the tree (longer codes) and high-frequency characters are at the top (shorter codes), thereby minimizing the total encoding length.",
      "wg": [
        {
          "t": "由下往上",
          "en": "bottom-up",
          "ps": "Adj"
        },
        {
          "t": "字元",
          "en": "character",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Greedy, Coin Change Problem, Counter Example, Algorithm Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮一個找零錢問題：假設硬幣面額系統為 {1, 3, 4}，目標是湊出金額 6。",
        "en": "Consider a coin change problem: suppose the coin denomination system is {1, 3, 4}, and the target amount is 6.",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          },
          {
            "t": "湊出",
            "en": "make up / sum to",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若使用標準的貪婪演算法（每次盡可能拿面額最大的硬幣），結果會是什麼？這是否為最佳解？",
        "en": "If a standard Greedy algorithm is used (taking the largest possible denomination each time), what will be the result? Is this the optimal solution?",
        "wg": [
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪解為 3 枚硬幣 (4, 1, 1)，是最佳解。",
        "en": "(A) Greedy solution is 3 coins (4, 1, 1), which is optimal.",
        "wg": []
      },
      {
        "t": "(B) 貪婪解為 2 枚硬幣 (3, 3)，是最佳解。",
        "en": "(B) Greedy solution is 2 coins (3, 3), which is optimal.",
        "wg": []
      },
      {
        "t": "(C) 貪婪解為 3 枚硬幣 (4, 1, 1)，但最佳解為 2 枚硬幣 (3, 3)。",
        "en": "(C) Greedy solution is 3 coins (4, 1, 1), but the optimal solution is 2 coins (3, 3).",
        "wg": []
      },
      {
        "t": "(D) 貪婪演算法在此情況下無法計算出結果。",
        "en": "(D) The Greedy algorithm cannot compute a result in this case.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "貪婪演算法會先選擇最大的 4，剩下 2，接著只能選兩個 1，總共 3 枚。然而最佳解其實是兩個 3，只需 2 枚。這顯示了貪婪演算法在非標準硬幣系統下不一定能得到最佳解。",
      "en": "The Greedy algorithm selects the largest coin 4 first, leaving 2, which then requires two 1s, totaling 3 coins. However, the optimal solution is actually two 3s, requiring only 2 coins. This demonstrates that Greedy algorithms do not always yield the optimal solution for non-standard coin systems.",
      "wg": [
        {
          "t": "非標準",
          "en": "non-standard",
          "ps": "Adj"
        },
        {
          "t": "顯示",
          "en": "demonstrate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Greedy, Dijkstra, Graph Theory, Shortest Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Dijkstra 演算法是用於解決加權圖中單源最短路徑問題的經典演算法。",
        "en": "Dijkstra's algorithm is a classic algorithm for solving the single-source shortest path problem in weighted graphs.",
        "wg": [
          {
            "t": "加權圖",
            "en": "weighted graph",
            "ps": "N"
          },
          {
            "t": "單源最短路徑",
            "en": "single-source shortest path",
            "ps": "N"
          }
        ]
      },
      {
        "t": "它的核心運作機制是基於貪婪策略。請問以下哪個描述正確解釋了 Dijkstra 的貪婪選擇？",
        "en": "Its core mechanism is based on a greedy strategy. Which of the following descriptions correctly explains Dijkstra's greedy choice?",
        "wg": [
          {
            "t": "核心運作機制",
            "en": "core mechanism",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次隨機選擇一個鄰居節點進行拜訪。",
        "en": "(A) Randomly select a neighbor node to visit each time.",
        "wg": []
      },
      {
        "t": "(B) 每次從「未拜訪集合」中選擇目前距離起點最近的節點，並將其標記為已拜訪。",
        "en": "(B) Always select the node closest to the source from the 'unvisited set' and mark it as visited.",
        "wg": [
          {
            "t": "未拜訪集合",
            "en": "unvisited set",
            "ps": "N"
          },
          {
            "t": "標記",
            "en": "mark",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 每次選擇邊權重最小的邊進行擴展，不論該邊連接哪個節點。",
        "en": "(C) Always select the edge with the smallest weight to expand, regardless of which node it connects.",
        "wg": [
          {
            "t": "擴展",
            "en": "expand",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 總是優先拜訪離終點直線距離最近的節點（啟發式）。",
        "en": "(D) Always prioritize visiting the node closest to the destination in straight-line distance (heuristic).",
        "wg": [
          {
            "t": "直線距離",
            "en": "straight-line distance",
            "ps": "N"
          },
          {
            "t": "啟發式",
            "en": "heuristic",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 的貪婪策略在於「局部最佳選擇」：在所有尚未確定最短路徑的節點中，選擇距離起點最近的那一個。在沒有負權重邊的前提下，這個局部最佳選擇保證了該節點的最短路徑已經被找到（全域最佳）。",
      "en": "Dijkstra's greedy strategy lies in the 'local optimal choice': among all nodes whose shortest path is not yet determined, select the one closest to the source. Assuming no negative weight edges, this local optimal choice guarantees that the shortest path to that node has been found (global optimal).",
      "wg": [
        {
          "t": "局部最佳選擇",
          "en": "local optimal choice",
          "ps": "N"
        },
        {
          "t": "前提",
          "en": "premise / assumption",
          "ps": "N"
        },
        {
          "t": "負權重邊",
          "en": "negative weight edge",
          "ps": "N"
        }
      ]
    }
  }
]