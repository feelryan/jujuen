[
  {
    "no": "1",
    "level": "Easy",
    "keywords": "Greedy Algorithm, Local Optimum, Global Optimum, Concept",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於貪婪演算法（Greedy Algorithm）的核心概念，下列敘述何者最為正確？",
        "en": "Regarding the core concept of the Greedy Algorithm, which of the following statements is most accurate?",
        "wg": [
          {
            "t": "核心概念",
            "en": "core concept",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出描述其決策過程特徵的選項。",
        "en": "Please select the option that describes the characteristics of its decision-making process.",
        "wg": [
          {
            "t": "決策過程",
            "en": "decision-making process",
            "ps": "N"
          },
          {
            "t": "特徵",
            "en": "characteristic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是回溯以尋找所有可能的解決方案，確保找到全域最佳解。",
        "en": "(A) Always backtracks to explore all possible solutions to ensure finding the global optimum.",
        "wg": [
          {
            "t": "回溯",
            "en": "backtrack",
            "ps": "V"
          },
          {
            "t": "全域最佳解",
            "en": "global optimum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 在每一步驟中都做出在當下看來最好的選擇，期望這些局部最佳解能導致全域最佳解。",
        "en": "(B) Makes the choice that looks best at the moment in each step, hoping that these local optima will lead to a global optimum.",
        "wg": [
          {
            "t": "局部最佳解",
            "en": "local optima",
            "ps": "N"
          },
          {
            "t": "當下",
            "en": "at the moment",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 將問題分解為重疊的子問題，並儲存子問題的解以避免重複計算。",
        "en": "(C) Breaks the problem down into overlapping subproblems and stores the solutions to subproblems to avoid redundant calculations.",
        "wg": [
          {
            "t": "重疊的",
            "en": "overlapping",
            "ps": "Adj"
          },
          {
            "t": "重複計算",
            "en": "redundant calculations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 隨機選擇路徑，並透過多次迭代來收斂至最佳解。",
        "en": "(D) Randomly selects paths and converges to the optimal solution through multiple iterations.",
        "wg": [
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          },
          {
            "t": "收斂",
            "en": "converge",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪演算法的定義即是在每一步選擇中都採取當前狀態下最好（局部最佳）的選擇，並假設這會導向最終的結果。",
      "en": "The definition of a Greedy Algorithm is to take the best (local optimal) choice in the current state at each step, assuming this will lead to the final result.",
      "wg": [
        {
          "t": "導向",
          "en": "lead to",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "Medium",
    "keywords": "Interval Scheduling, Activity Selection, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一組活動，每個活動都有開始時間和結束時間。",
        "en": "Given a set of activities, each with a start time and an end time.",
        "wg": []
      },
      {
        "t": "若要安排最多的活動使得它們彼此不重疊（Interval Scheduling Problem），應該依據什麼策略進行排序？",
        "en": "To schedule the maximum number of activities such that they do not overlap (Interval Scheduling Problem), based on what strategy should they be sorted?",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的「開始時間」由早到晚排序。",
        "en": "(A) Sort by the 'start time' of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的「持續時間」（長度）由短到長排序。",
        "en": "(B) Sort by the 'duration' (length) of the activities from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照活動的「結束時間」由早到晚排序。",
        "en": "(C) Sort by the 'end time' of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依照活動的「結束時間」由晚到早排序。",
        "en": "(D) Sort by the 'end time' of the activities from latest to earliest.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選擇最早結束的活動可以為後續的活動騰出最多的時間資源，這是解決活動選擇問題的標準貪婪策略。",
      "en": "Choosing the activity that finishes earliest frees up the most time resources for subsequent activities, which is the standard greedy strategy for solving the Activity Selection Problem.",
      "wg": [
        {
          "t": "騰出",
          "en": "free up",
          "ps": "V"
        },
        {
          "t": "後續的",
          "en": "subsequent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "Medium",
    "keywords": "Knapsack Problem, Fractional Knapsack, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於背包問題（Knapsack Problem），哪一種變體可以使用貪婪演算法求得最佳解？",
        "en": "Regarding the Knapsack Problem, which variation can be solved optimally using a Greedy Algorithm?",
        "wg": [
          {
            "t": "變體",
            "en": "variation",
            "ps": "N"
          },
          {
            "t": "求得",
            "en": "obtain/solve for",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請考慮物品是否可分割的情況。",
        "en": "Please consider the situation where items can be split.",
        "wg": [
          {
            "t": "分割",
            "en": "split",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0/1 背包問題 (0/1 Knapsack Problem)。",
        "en": "(A) 0/1 Knapsack Problem.",
        "wg": []
      },
      {
        "t": "(B) 分數背包問題 (Fractional Knapsack Problem)。",
        "en": "(B) Fractional Knapsack Problem.",
        "wg": [
          {
            "t": "分數",
            "en": "fractional",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 兩者皆可使用貪婪演算法求得最佳解。",
        "en": "(C) Both can be solved optimally using a Greedy Algorithm.",
        "wg": []
      },
      {
        "t": "(D) 兩者皆無法使用貪婪演算法求得最佳解。",
        "en": "(D) Neither can be solved optimally using a Greedy Algorithm.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "分數背包問題允許物品被分割，因此可以優先選擇「單位重量價值」最高的物品填滿背包，這是貪婪策略。",
      "en": "The Fractional Knapsack Problem allows items to be split, so one can prioritize choosing items with the highest 'value per unit weight' to fill the knapsack, which is a greedy strategy.",
      "wg": [
        {
          "t": "單位重量價值",
          "en": "value per unit weight",
          "ps": "N"
        },
        {
          "t": "優先選擇",
          "en": "prioritize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "Medium",
    "keywords": "Huffman Coding, Compression, Prefix Code",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼（Huffman Coding）是一種廣泛使用的資料壓縮技術。",
        "en": "Huffman Coding is a widely used data compression technique.",
        "wg": [
          {
            "t": "資料壓縮",
            "en": "data compression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，貪婪策略是如何被應用的？",
        "en": "In the process of constructing a Huffman Tree, how is the greedy strategy applied?",
        "wg": [
          {
            "t": "建構",
            "en": "construct",
            "ps": "V"
          },
          {
            "t": "應用",
            "en": "apply",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選取出現頻率最高的兩個字元進行合併。",
        "en": "(A) Merge the two characters with the highest frequency each time.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 每次選取出現頻率最低的兩個節點進行合併，形成一個新的父節點。",
        "en": "(B) Merge the two nodes with the lowest frequency each time to form a new parent node.",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "父節點",
            "en": "parent node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照字元的 ASCII 碼順序進行二元樹的建構。",
        "en": "(C) Construct the binary tree according to the ASCII code order of the characters.",
        "wg": []
      },
      {
        "t": "(D) 隨機選取兩個節點合併，直到只剩下一個根節點。",
        "en": "(D) Randomly select two nodes to merge until only one root node remains.",
        "wg": [
          {
            "t": "根節點",
            "en": "root node",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼編碼的貪婪策略在於總是將頻率最低的兩個節點合併，這樣可以確保高頻率的字元擁有較短的編碼長度，從而達到最佳壓縮效果。",
      "en": "The greedy strategy of Huffman Coding lies in always merging the two nodes with the lowest frequencies, ensuring that high-frequency characters have shorter code lengths, thereby achieving optimal compression.",
      "wg": [
        {
          "t": "編碼長度",
          "en": "code length",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "Hard",
    "keywords": "Coin Change, Counterexample, Canonical Coin Systems",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在找零問題（Coin Change Problem）中，我們希望用最少數量的硬幣湊出特定金額。",
        "en": "In the Coin Change Problem, we want to make up a specific amount using the minimum number of coins.",
        "wg": [
          {
            "t": "找零",
            "en": "change (money)",
            "ps": "N"
          },
          {
            "t": "湊出",
            "en": "make up / compose",
            "ps": "V"
          }
        ]
      },
      {
        "t": "對於硬幣面額組合 {1, 3, 4}，若目標金額為 6，使用貪婪演算法（每次取最大面額）會得到什麼結果？這是否為最佳解？",
        "en": "For the coin denomination set {1, 3, 4}, if the target amount is 6, what result will the Greedy Algorithm (taking the largest denomination each time) yield? Is this the optimal solution?",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          },
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪解為 4+1+1 (3枚)，這是最佳解。",
        "en": "(A) Greedy solution is 4+1+1 (3 coins), which is the optimal solution.",
        "wg": []
      },
      {
        "t": "(B) 貪婪解為 3+3 (2枚)，這是最佳解。",
        "en": "(B) Greedy solution is 3+3 (2 coins), which is the optimal solution.",
        "wg": []
      },
      {
        "t": "(C) 貪婪解為 4+1+1 (3枚)，但最佳解應為 3+3 (2枚)。",
        "en": "(C) Greedy solution is 4+1+1 (3 coins), but the optimal solution should be 3+3 (2 coins).",
        "wg": []
      },
      {
        "t": "(D) 貪婪解為 4+2 (2枚)，這是最佳解。",
        "en": "(D) Greedy solution is 4+2 (2 coins), which is the optimal solution.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "貪婪演算法會先選最大的 4，剩下 2，接著只能選兩個 1，總共 3 枚；但實際上選兩個 3 即可湊成 6 (2 枚)。這證明了貪婪演算法並不適用於所有硬幣組合。",
      "en": "The Greedy Algorithm picks the largest 4 first, leaving 2, then must pick two 1s, totaling 3 coins; however, picking two 3s makes 6 (2 coins). This proves that the Greedy Algorithm does not apply to all coin combinations.",
      "wg": [
        {
          "t": "適用於",
          "en": "apply to / suitable for",
          "ps": "V"
        },
        {
          "t": "組合",
          "en": "combination",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Interval Scheduling, Sorting, Activity Selection",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在經典的區間排程問題中，您有一組活動，每個活動都有開始時間和結束時間。",
        "en": "In the classic Interval Scheduling problem, you have a set of activities, each with a start time and an end time.",
        "wg": [
          {
            "t": "區間排程",
            "en": "Interval Scheduling",
            "ps": "NP"
          },
          {
            "t": "活動",
            "en": "activity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您的目標是安排盡可能多的活動，且這些活動在時間上不能重疊。",
        "en": "Your goal is to schedule as many activities as possible such that they do not overlap in time.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問應該採用哪種貪婪策略來排序這些活動，以確保獲得全域最佳解？",
        "en": "Which greedy strategy should be used to sort these activities to guarantee a globally optimal solution?",
        "wg": [
          {
            "t": "全域最佳解",
            "en": "globally optimal solution",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的開始時間，由早到晚排序。",
        "en": "(A) Sort by the start time of the activities, from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的持續時間（長度），由短到長排序。",
        "en": "(B) Sort by the duration (length) of the activities, from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照活動的結束時間，由早到晚排序。",
        "en": "(C) Sort by the end time of the activities, from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依照活動與其他活動重疊的數量，由少到多排序。",
        "en": "(D) Sort by the number of overlaps with other activities, from fewest to most.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選擇結束時間最早的活動，可以為後續的活動留出最多的剩餘時間，這是證明能產生最佳解的正確貪婪策略。",
      "en": "Choosing the activity that finishes earliest leaves the most remaining time for subsequent activities, which is the correct greedy strategy proven to yield the optimal solution.",
      "wg": [
        {
          "t": "剩餘時間",
          "en": "remaining time",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Knapsack Problem, Fractional, Greedy vs DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於背包問題（Knapsack Problem），我們通常區分為「0/1 背包問題」與「分數背包問題」。",
        "en": "Regarding the Knapsack Problem, we typically distinguish between the '0/1 Knapsack Problem' and the 'Fractional Knapsack Problem'.",
        "wg": [
          {
            "t": "分數背包問題",
            "en": "Fractional Knapsack Problem",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問以下哪種情境適合使用貪婪演算法（Greedy Algorithm）來求得最大價值？",
        "en": "In which of the following scenarios is the Greedy Algorithm suitable for finding the maximum value?",
        "wg": [
          {
            "t": "情境",
            "en": "scenario",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 物品是固定的金塊，不可分割，必須選擇拿或不拿。",
        "en": "(A) Items are solid gold bars, indivisible, and you must choose to take them or not.",
        "wg": [
          {
            "t": "不可分割",
            "en": "indivisible",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 物品是金沙或液體，可以任意分割取用部分。",
        "en": "(B) Items are gold dust or liquids, which can be arbitrarily divided and partially taken.",
        "wg": [
          {
            "t": "任意",
            "en": "arbitrarily",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 兩種情境都可以使用貪婪演算法獲得最佳解。",
        "en": "(C) Greedy algorithms can be used to obtain the optimal solution in both scenarios.",
        "wg": []
      },
      {
        "t": "(D) 兩種情境都必須使用動態規劃（Dynamic Programming）。",
        "en": "(D) Both scenarios must use Dynamic Programming.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "對於分數背包問題（物品可分割），我們可以貪婪地選擇「單位重量價值（CP值）」最高的物品直到背包含滿，這保證了最佳解；而 0/1 背包問題若用貪婪法可能會留下無法填滿的空隙，需用動態規劃。",
      "en": "For the Fractional Knapsack Problem (divisible items), we can greedily choose items with the highest 'value per unit weight' until the knapsack is full, guaranteeing an optimal solution; whereas for the 0/1 Knapsack Problem, a greedy approach might leave unfilled gaps, requiring Dynamic Programming.",
      "wg": [
        {
          "t": "單位重量價值",
          "en": "value per unit weight",
          "ps": "NP"
        },
        {
          "t": "空隙",
          "en": "gap",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "Jump Game, Array, Reachability",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [2, 3, 1, 1, 4]\nOutput: true\n\nInput: nums = [3, 2, 1, 0, 4]\nOutput: false",
    "question": [
      {
        "t": "在「跳躍遊戲」（Jump Game）問題中，給定一個非負整數陣列，每個元素代表在該位置可以跳躍的最大長度。",
        "en": "In the 'Jump Game' problem, you are given an array of non-negative integers, where each element represents the maximum length you can jump from that position.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "您最初位於陣列的第一個索引處，請判斷您是否能夠到達最後一個索引。",
        "en": "You are initially positioned at the first index of the array; determine if you are able to reach the last index.",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用貪婪演算法解決此問題，核心邏輯應為下列何者？",
        "en": "If using a greedy algorithm to solve this problem, which of the following should be the core logic?",
        "wg": [
          {
            "t": "核心邏輯",
            "en": "core logic",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次都必須跳躍該位置允許的最大步數。",
        "en": "(A) You must always jump the maximum number of steps allowed at that position.",
        "wg": []
      },
      {
        "t": "(B) 維護一個變數紀錄「目前能到達的最遠位置」，遍歷陣列時不斷更新此變數，若當前索引超過此變數則失敗。",
        "en": "(B) Maintain a variable recording the 'furthest reachable position', update it while iterating through the array, and fail if the current index exceeds this variable.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          },
          {
            "t": "最遠位置",
            "en": "furthest position",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 優先選擇跳躍到數值最小的位置，以保留大數值給後續使用。",
        "en": "(C) Prioritize jumping to the position with the smallest value to save larger values for later use.",
        "wg": []
      },
      {
        "t": "(D) 必須使用遞迴窮舉所有可能的跳躍路徑。",
        "en": "(D) Must use recursion to exhaustively enumerate all possible jump paths.",
        "wg": [
          {
            "t": "窮舉",
            "en": "exhaustively enumerate",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪策略在於每一步都計算「從當前位置能延伸到的最遠範圍」，而不需要真正決定每一步跳哪裡。只要這個最遠範圍能覆蓋到終點，且過程中沒有被卡住（當前索引 > 最遠範圍），即為可達。",
      "en": "The greedy strategy involves calculating the 'furthest range extendable from the current position' at each step, without needing to decide exactly where to jump. As long as this furthest range covers the end, and you don't get stuck (current index > furthest range), it is reachable.",
      "wg": [
        {
          "t": "延伸",
          "en": "extend",
          "ps": "V"
        },
        {
          "t": "覆蓋",
          "en": "cover",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Huffman Coding, Compression, Frequency",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼（Huffman Coding）是一種廣泛使用的資料壓縮貪婪演算法。",
        "en": "Huffman Coding is a widely used greedy algorithm for data compression.",
        "wg": [
          {
            "t": "資料壓縮",
            "en": "data compression",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "它透過建立一棵二元樹來產生前綴碼（Prefix Codes）。",
        "en": "It generates prefix codes by building a binary tree.",
        "wg": [
          {
            "t": "前綴碼",
            "en": "prefix codes",
            "ps": "NP"
          },
          {
            "t": "二元樹",
            "en": "binary tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在建構霍夫曼樹的過程中，貪婪選擇的依據是什麼？",
        "en": "What is the basis for the greedy choice during the construction of the Huffman tree?",
        "wg": [
          {
            "t": "建構",
            "en": "construction",
            "ps": "N"
          },
          {
            "t": "依據",
            "en": "basis",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選取兩個出現頻率最高的字元或節點進行合併。",
        "en": "(A) Always select the two characters or nodes with the highest frequencies to merge.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 每次隨機選取兩個節點進行合併。",
        "en": "(B) Randomly select two nodes to merge each time.",
        "wg": []
      },
      {
        "t": "(C) 每次選取兩個出現頻率最低的字元或節點進行合併。",
        "en": "(C) Always select the two characters or nodes with the lowest frequencies to merge.",
        "wg": []
      },
      {
        "t": "(D) 依照字元的 ASCII 碼順序進行合併。",
        "en": "(D) Merge according to the ASCII code order of the characters.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "霍夫曼編碼為了讓高頻率的字元擁有較短的編碼，採取「由下而上」的策略，每次貪婪地合併頻率最低的兩個節點，使其位於樹的較深層（編碼較長），進而最佳化整體的加權路徑長度。",
      "en": "To assign shorter codes to high-frequency characters, Huffman coding uses a 'bottom-up' strategy, greedily merging the two nodes with the lowest frequencies each time, placing them deeper in the tree (longer codes), thereby optimizing the overall weighted path length.",
      "wg": [
        {
          "t": "由下而上",
          "en": "bottom-up",
          "ps": "Adj"
        },
        {
          "t": "加權路徑長度",
          "en": "weighted path length",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Counter-example, Coin Change, Local Optimal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "貪婪演算法並不總是能找到全域最佳解。",
        "en": "Greedy algorithms do not always find the global optimal solution.",
        "wg": []
      },
      {
        "t": "考慮找零錢問題：假設硬幣面額有 {1, 3, 4}。",
        "en": "Consider the Coin Change problem: suppose the coin denominations are {1, 3, 4}.",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要湊出金額 6，使用標準的貪婪策略（每次盡可能拿最大的硬幣）會得到什麼結果？這是否為最佳解？",
        "en": "If you want to make change for the amount 6, what result will the standard greedy strategy (taking the largest possible coin each time) yield? Is this the optimal solution?",
        "wg": [
          {
            "t": "湊出",
            "en": "make change for",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪解為 4+1+1 (3枚)，這是最佳解。",
        "en": "(A) Greedy solution is 4+1+1 (3 coins), which is the optimal solution.",
        "wg": []
      },
      {
        "t": "(B) 貪婪解為 3+3 (2枚)，這是最佳解。",
        "en": "(B) Greedy solution is 3+3 (2 coins), which is the optimal solution.",
        "wg": []
      },
      {
        "t": "(C) 貪婪解為 4+1+1 (3枚)，但最佳解應為 3+3 (2枚)。",
        "en": "(C) Greedy solution is 4+1+1 (3 coins), but the optimal solution should be 3+3 (2 coins).",
        "wg": []
      },
      {
        "t": "(D) 貪婪解為 4+2 (2枚)，這是最佳解。",
        "en": "(D) Greedy solution is 4+2 (2 coins), which is the optimal solution.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "貪婪策略會先拿最大的 4，剩下 2，接著只能拿兩個 1，總共 3 枚硬幣；然而最佳解是直接拿兩個 3，只需 2 枚硬幣。這是一個貪婪演算法失效的經典反例。",
      "en": "The greedy strategy first takes the largest 4, leaving 2, then must take two 1s, totaling 3 coins; however, the optimal solution is to take two 3s, requiring only 2 coins. This is a classic counter-example where the greedy algorithm fails.",
      "wg": [
        {
          "t": "失效",
          "en": "fail",
          "ps": "V"
        },
        {
          "t": "反例",
          "en": "counter-example",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Interval Scheduling, Greedy Strategy, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設你有一間會議室，並且收到多個會議預約請求，每個請求都有特定的開始時間與結束時間。",
        "en": "Suppose you have a conference room and receive multiple meeting reservation requests, each with a specific start time and end time.",
        "wg": [
          {
            "t": "預約請求",
            "en": "reservation request",
            "ps": "N"
          },
          {
            "t": "特定的",
            "en": "specific",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "你的目標是接受盡可能多的會議，且會議之間的時間不能重疊。",
        "en": "Your goal is to accept as many meetings as possible without any time overlap between them.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V/N"
          }
        ]
      },
      {
        "t": "根據貪婪演算法（Greedy Algorithm），你應該依據什麼策略來排序這些會議請求，以達到最佳解？",
        "en": "According to the Greedy Algorithm, by what strategy should you sort these meeting requests to achieve the optimal solution?",
        "wg": [
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據會議的「開始時間」由早到晚排序。",
        "en": "(A) Sort by the meeting's 'start time' from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依據會議的「持續時間」由短到長排序。",
        "en": "(B) Sort by the meeting's 'duration' from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依據會議的「結束時間」由早到晚排序。",
        "en": "(C) Sort by the meeting's 'finish time' from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依據會議與其他會議的「重疊次數」由少到多排序。",
        "en": "(D) Sort by the number of 'overlaps' with other meetings from fewest to most.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是經典的區間排程問題（Interval Scheduling）。選擇「最早結束時間」的會議可以為後續的會議騰出最多的剩餘時間，從而最大化可安排的會議總數。",
      "en": "This is the classic Interval Scheduling problem. Choosing the meeting with the 'earliest finish time' frees up the most remaining time for subsequent meetings, thereby maximizing the total number of meetings that can be scheduled.",
      "wg": [
        {
          "t": "區間排程",
          "en": "Interval Scheduling",
          "ps": "N"
        },
        {
          "t": "騰出",
          "en": "free up",
          "ps": "Phrasal Verb"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Fractional Knapsack, 0/1 Knapsack, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於貪婪演算法在「背包問題」中的應用，下列敘述何者正確？",
        "en": "Regarding the application of Greedy Algorithms in 'Knapsack Problems', which of the following statements is true?",
        "wg": [
          {
            "t": "背包問題",
            "en": "Knapsack Problem",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請考慮「0/1 背包問題」（物品不可分割）與「分數背包問題」（物品可分割）。",
        "en": "Please consider the '0/1 Knapsack Problem' (items are indivisible) and the 'Fractional Knapsack Problem' (items are divisible).",
        "wg": [
          {
            "t": "不可分割",
            "en": "indivisible",
            "ps": "Adj"
          },
          {
            "t": "可分割",
            "en": "divisible",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪演算法可以保證在 0/1 背包問題中找到最佳解。",
        "en": "(A) Greedy algorithms guarantee finding the optimal solution in the 0/1 Knapsack Problem.",
        "wg": []
      },
      {
        "t": "(B) 貪婪演算法可以保證在分數背包問題中找到最佳解。",
        "en": "(B) Greedy algorithms guarantee finding the optimal solution in the Fractional Knapsack Problem.",
        "wg": []
      },
      {
        "t": "(C) 貪婪演算法在這兩種背包問題中皆無法保證最佳解。",
        "en": "(C) Greedy algorithms cannot guarantee the optimal solution in either of these Knapsack Problems.",
        "wg": []
      },
      {
        "t": "(D) 0/1 背包問題的時間複雜度比分數背包問題低。",
        "en": "(D) The time complexity of the 0/1 Knapsack Problem is lower than that of the Fractional Knapsack Problem.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "對於分數背包問題，我們可以依據「價值/重量比」進行貪婪選擇，這保證了最佳解；但在 0/1 背包問題中，貪婪策略可能會因為無法填滿背包而導致浪費空間，必須使用動態規劃（Dynamic Programming）。",
      "en": "For the Fractional Knapsack Problem, we can make greedy choices based on the 'value-to-weight ratio', which guarantees an optimal solution; however, in the 0/1 Knapsack Problem, a greedy strategy might waste space by failing to fill the knapsack, necessitating the use of Dynamic Programming.",
      "wg": [
        {
          "t": "價值/重量比",
          "en": "value-to-weight ratio",
          "ps": "N"
        },
        {
          "t": "動態規劃",
          "en": "Dynamic Programming",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Huffman Coding, Prefix Codes, Compression",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼（Huffman Coding）是一種利用貪婪策略建構最佳前綴碼（Prefix Code）的演算法。",
        "en": "Huffman Coding is an algorithm that uses a greedy strategy to construct optimal Prefix Codes.",
        "wg": [
          {
            "t": "前綴碼",
            "en": "Prefix Code",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，貪婪選擇的具體操作為何？",
        "en": "In the process of constructing a Huffman Tree, what is the specific operation of the greedy choice?",
        "wg": [
          {
            "t": "建構",
            "en": "construct",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選取頻率最高的兩個節點進行合併。",
        "en": "(A) Select the two nodes with the highest frequencies to merge each time.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 每次選取頻率最低的兩個節點進行合併，並將新節點放回集合中。",
        "en": "(B) Select the two nodes with the lowest frequencies to merge each time, and put the new node back into the set.",
        "wg": []
      },
      {
        "t": "(C) 將所有字元依頻率排序，直接賦予長度固定的編碼。",
        "en": "(C) Sort all characters by frequency and directly assign fixed-length codes.",
        "wg": [
          {
            "t": "固定",
            "en": "fixed",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 隨機選取兩個節點合併，直到只剩下一個根節點。",
        "en": "(D) Randomly select two nodes to merge until only one root node remains.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼演算法的核心貪婪策略是「由下而上」建構樹，每次取出頻率（權重）最小的兩個節點合併，這樣可以保證高頻率的字元擁有較短的編碼長度，從而最小化加權路徑長度。",
      "en": "The core greedy strategy of Huffman's algorithm is building the tree 'bottom-up' by merging the two nodes with the smallest frequencies (weights) each time. This ensures that high-frequency characters have shorter code lengths, thereby minimizing the weighted path length.",
      "wg": [
        {
          "t": "由下而上",
          "en": "bottom-up",
          "ps": "Adj"
        },
        {
          "t": "加權路徑長度",
          "en": "weighted path length",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Coin Change, Canonical Coin Systems, Counter-example",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Coins = {1, 3, 4}\nTarget = 6",
    "question": [
      {
        "t": "貪婪演算法在「找零錢問題」（Coin Change Problem）中並不總是能得到最少硬幣數量的解。",
        "en": "Greedy algorithms do not always yield the solution with the minimum number of coins in the 'Coin Change Problem'.",
        "wg": [
          {
            "t": "找零錢問題",
            "en": "Coin Change Problem",
            "ps": "N"
          }
        ]
      },
      {
        "t": "考慮硬幣面額集合 {1, 3, 4}，若目標金額為 6。",
        "en": "Consider a set of coin denominations {1, 3, 4}, and the target amount is 6.",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問使用貪婪策略（每次選取小於等於剩餘金額的最大面額）所得到的硬幣數量，與實際最佳解的硬幣數量差多少？",
        "en": "What is the difference in the number of coins between the result obtained using the greedy strategy (always picking the largest denomination less than or equal to the remaining amount) and the actual optimal solution?",
        "wg": [
          {
            "t": "剩餘金額",
            "en": "remaining amount",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0 (兩者結果相同)",
        "en": "(A) 0 (Both results are the same)",
        "wg": []
      },
      {
        "t": "(B) 1 (貪婪解比最佳解多 1 枚)",
        "en": "(B) 1 (Greedy solution has 1 more coin than optimal)",
        "wg": []
      },
      {
        "t": "(C) 2 (貪婪解比最佳解多 2 枚)",
        "en": "(C) 2 (Greedy solution has 2 more coins than optimal)",
        "wg": []
      },
      {
        "t": "(D) 貪婪策略無法湊出目標金額",
        "en": "(D) Greedy strategy cannot make up the target amount",
        "wg": [
          {
            "t": "湊出",
            "en": "make up / compose",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪策略會先選 4，剩下 2，接著選 1, 1，總共 3 枚硬幣 (4+1+1)。最佳解應為選兩枚 3，總共 2 枚硬幣 (3+3)。差值為 3 - 2 = 1。",
      "en": "The greedy strategy picks 4 first, leaving 2, then picks 1, 1, totaling 3 coins (4+1+1). The optimal solution is to pick two 3s, totaling 2 coins (3+3). The difference is 3 - 2 = 1.",
      "wg": [
        {
          "t": "差值",
          "en": "difference",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Minimum Spanning Tree, Kruskal's Algorithm, Disjoint Set",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Kruskal 演算法是用於尋找圖形最小生成樹（MST）的貪婪演算法。",
        "en": "Kruskal's algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a graph.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該演算法在每一步驟中選擇邊的邏輯為何？以及它如何避免形成迴圈（Cycle）？",
        "en": "What is the logic for selecting edges at each step of this algorithm? And how does it prevent the formation of cycles?",
        "wg": [
          {
            "t": "迴圈",
            "en": "cycle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 隨機選擇邊，並使用深度優先搜尋（DFS）偵測迴圈。",
        "en": "(A) Randomly select edges and use Depth First Search (DFS) to detect cycles.",
        "wg": []
      },
      {
        "t": "(B) 依權重由小到大選擇邊，若該邊連接的兩個頂點屬於不同集合則加入。",
        "en": "(B) Select edges by weight from smallest to largest; add the edge if the two vertices it connects belong to different sets.",
        "wg": [
          {
            "t": "頂點",
            "en": "vertex/vertices",
            "ps": "N"
          },
          {
            "t": "集合",
            "en": "set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 從任意頂點開始，每次選擇連接已訪問頂點中權重最小的邊。",
        "en": "(C) Start from an arbitrary vertex and repeatedly select the edge with the minimum weight connecting to already visited vertices.",
        "wg": [
          {
            "t": "已訪問",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 依權重由大到小選擇邊，若移除該邊不影響圖的連通性則移除。",
        "en": "(D) Select edges by weight from largest to smallest; remove the edge if removing it does not affect the graph's connectivity.",
        "wg": [
          {
            "t": "連通性",
            "en": "connectivity",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 描述的是 Kruskal 演算法的核心：先將所有邊排序，依序選取最小邊，並利用互斥集（Disjoint Set / Union-Find）資料結構來檢查是否形成迴圈（即兩個頂點是否已連通）。選項 (C) 描述的是 Prim 演算法。",
      "en": "Option (B) describes the core of Kruskal's algorithm: sort all edges, pick the smallest edge sequentially, and use the Disjoint Set (Union-Find) data structure to check for cycles (i.e., whether the two vertices are already connected). Option (C) describes Prim's algorithm.",
      "wg": [
        {
          "t": "互斥集",
          "en": "Disjoint Set",
          "ps": "N"
        },
        {
          "t": "核心",
          "en": "core",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Huffman Coding, Data Compression, Prefix Codes, Greedy Strategy",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼 (Huffman Coding) 是一種利用貪婪演算法來建構最佳前綴碼的壓縮技術。",
        "en": "Huffman Coding is a compression technique that uses a greedy algorithm to construct optimal prefix codes.",
        "wg": [
          {
            "t": "前綴碼",
            "en": "prefix code",
            "ps": "N"
          },
          {
            "t": "壓縮",
            "en": "compression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，貪婪策略是如何被應用的？",
        "en": "How is the greedy strategy applied during the construction of the Huffman tree?",
        "wg": [
          {
            "t": "建構",
            "en": "construction",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選擇出現頻率最高的兩個字元進行合併。",
        "en": "(A) Always select the two characters with the highest frequencies to merge.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 每次選擇出現頻率最低的兩個節點進行合併，並將其總和作為新節點的頻率。",
        "en": "(B) Always select the two nodes with the lowest frequencies to merge, using their sum as the frequency of the new node.",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將所有字元依照頻率由高到低排序，並依序分配二進位碼。",
        "en": "(C) Sort all characters from highest to lowest frequency and assign binary codes sequentially.",
        "wg": []
      },
      {
        "t": "(D) 隨機選擇兩個節點合併，直到只剩下一個根節點。",
        "en": "(D) Randomly select two nodes to merge until only one root node remains.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼編碼的貪婪選擇性質在於每次都選取當前頻率最小的兩個樹根節點合併，這樣能保證頻率高的字元擁有較短的編碼長度，進而達到最小的加權路徑長度 (WPL)。",
      "en": "The greedy choice property of Huffman Coding lies in always selecting the two root nodes with the smallest current frequencies to merge. This ensures that high-frequency characters have shorter code lengths, thereby achieving the minimum Weighted Path Length (WPL).",
      "wg": [
        {
          "t": "加權路徑長度",
          "en": "Weighted Path Length",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Fractional Knapsack, Greedy vs DP, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮一個背包問題，其中物品是可以被分割的 (例如：麵粉、液體)。",
        "en": "Consider a knapsack problem where items are divisible (e.g., flour, liquids).",
        "wg": [
          {
            "t": "可被分割的",
            "en": "divisible",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了在有限的重量限制下獲得最大的總價值，應該採用哪種貪婪策略來選擇物品？",
        "en": "To maximize the total value under a limited weight constraint, which greedy strategy should be used to select items?",
        "wg": [
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先選擇重量最輕的物品。",
        "en": "(A) Prioritize selecting the items with the lightest weight.",
        "wg": []
      },
      {
        "t": "(B) 優先選擇總價值最高的物品。",
        "en": "(B) Prioritize selecting the items with the highest total value.",
        "wg": []
      },
      {
        "t": "(C) 優先選擇單位重量價值 (價值/重量) 最高的物品。",
        "en": "(C) Prioritize selecting items with the highest value per unit weight (value/weight).",
        "wg": [
          {
            "t": "單位重量價值",
            "en": "value per unit weight",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 貪婪演算法不適用於此問題，必須使用動態規劃。",
        "en": "(D) Greedy algorithms are not applicable to this problem; dynamic programming must be used.",
        "wg": [
          {
            "t": "動態規劃",
            "en": "dynamic programming",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "對於分數背包問題 (Fractional Knapsack)，最佳策略是依據「性價比」(價值除以重量) 排序。優先拿取性價比最高的物品填滿背包，這樣能保證每一單位的重量都貢獻了最大的價值。如果是 0/1 背包問題 (不可分割)，則貪婪法失效，需用動態規劃。",
      "en": "For the Fractional Knapsack problem, the optimal strategy is to sort by 'value-to-weight ratio'. Prioritizing items with the highest ratio ensures that every unit of weight contributes the maximum possible value. If it were a 0/1 Knapsack problem (indivisible), the greedy approach would fail, and dynamic programming would be required.",
      "wg": [
        {
          "t": "性價比",
          "en": "price-performance ratio / value-to-weight ratio",
          "ps": "N"
        },
        {
          "t": "失效",
          "en": "fail",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Interval Scheduling, Activity Selection, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要安排一間會議室的使用時程，手上有許多活動申請，每個活動都有固定的開始與結束時間。",
        "en": "You need to schedule the usage of a conference room, with many activity requests on hand, each having a fixed start and end time.",
        "wg": [
          {
            "t": "時程",
            "en": "schedule",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若目標是安排「盡可能多」場不重疊的活動，請問應依據什麼標準對活動進行排序？",
        "en": "If the goal is to schedule as 'many' non-overlapping activities as possible, based on what criteria should the activities be sorted?",
        "wg": [
          {
            "t": "重疊",
            "en": "overlapping",
            "ps": "Adj"
          },
          {
            "t": "標準",
            "en": "criteria",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的開始時間，由早到晚排序。",
        "en": "(A) Sort by the start time of the activities, from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的持續時間，由短到長排序。",
        "en": "(B) Sort by the duration of the activities, from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照活動的結束時間，由早到晚排序。",
        "en": "(C) Sort by the end time of the activities, from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依照活動的結束時間，由晚到早排序。",
        "en": "(D) Sort by the end time of the activities, from latest to earliest.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是經典的活動選擇問題 (Activity Selection Problem)。貪婪策略是選擇「最早結束」的活動，因為這樣能為後續的活動騰出最多的剩餘時間，從而容納更多活動。依開始時間或持續時間排序都能找到反例證明其非最佳解。",
      "en": "This is the classic Activity Selection Problem. The greedy strategy is to select the activity that 'finishes earliest', as this leaves the maximum amount of remaining time for subsequent activities, thereby accommodating more activities. Sorting by start time or duration can be proven non-optimal with counter-examples.",
      "wg": [
        {
          "t": "騰出",
          "en": "free up / make room for",
          "ps": "V"
        },
        {
          "t": "反例",
          "en": "counter-example",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Dijkstra, Negative Edges, Graph Theory, Greedy Limitations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Dijkstra 演算法本質上是一種貪婪演算法，用於尋找圖中的最短路徑。",
        "en": "Dijkstra's algorithm is essentially a greedy algorithm used to find the shortest paths in a graph.",
        "wg": []
      },
      {
        "t": "當圖中存在「負權重邊」(Negative Weight Edges) 時，Dijkstra 演算法通常會發生什麼問題？",
        "en": "What problem usually occurs with Dijkstra's algorithm when 'Negative Weight Edges' exist in the graph?",
        "wg": [
          {
            "t": "負權重邊",
            "en": "negative weight edges",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 演算法會陷入無窮迴圈，無法終止。",
        "en": "(A) The algorithm will enter an infinite loop and cannot terminate.",
        "wg": [
          {
            "t": "無窮迴圈",
            "en": "infinite loop",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 演算法仍能正常運作並保證找到最短路徑。",
        "en": "(B) The algorithm will still work correctly and guarantee finding the shortest path.",
        "wg": []
      },
      {
        "t": "(C) 演算法可能會過早確定某個節點的最短距離，導致最終計算出的路徑並非最短。",
        "en": "(C) The algorithm might prematurely finalize the shortest distance for a node, causing the calculated path to not be the shortest.",
        "wg": [
          {
            "t": "過早",
            "en": "prematurely",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 演算法會自動將所有負權重轉換為正權重來處理。",
        "en": "(D) The algorithm will automatically convert all negative weights to positive weights for processing.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Dijkstra 的貪婪假設是：一旦一個節點被標記為「已訪問」(或從 Priority Queue 取出)，其最短路徑就已確定，不會再被更新。若存在負邊，後續的路徑可能會讓先前的距離變得更短，破壞了這個貪婪性質，導致結果錯誤。",
      "en": "Dijkstra's greedy assumption is that once a node is marked 'visited' (or extracted from the Priority Queue), its shortest path is finalized and will not be updated. If negative edges exist, a subsequent path might reduce a previously established distance, violating this greedy property and leading to incorrect results.",
      "wg": [
        {
          "t": "已訪問",
          "en": "visited",
          "ps": "Adj"
        },
        {
          "t": "破壞",
          "en": "violate / break",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Coin Change, Local Optimum, Global Optimum, Counter-example",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "貪婪演算法並不總是能找到全域最佳解 (Global Optimum)。",
        "en": "Greedy algorithms do not always find the global optimum.",
        "wg": [
          {
            "t": "全域最佳解",
            "en": "global optimum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "考慮找零錢問題，若硬幣面額為 {1, 3, 4}，目標金額為 6。",
        "en": "Consider the coin change problem with coin denominations {1, 3, 4} and a target amount of 6.",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問使用貪婪策略 (每次選最大的) 與實際最佳解的硬幣數量分別為何？",
        "en": "What are the number of coins used by the greedy strategy (always picking the largest) and the actual optimal solution, respectively?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪解：2 個 (4+1+1 錯誤)，最佳解：2 個 (3+3)。",
        "en": "(A) Greedy: 2 coins (4+1+1 error), Optimal: 2 coins (3+3).",
        "wg": []
      },
      {
        "t": "(B) 貪婪解：3 個 (4+1+1)，最佳解：2 個 (3+3)。",
        "en": "(B) Greedy: 3 coins (4+1+1), Optimal: 2 coins (3+3).",
        "wg": []
      },
      {
        "t": "(C) 貪婪解：3 個 (3+3)，最佳解：3 個 (4+1+1)。",
        "en": "(C) Greedy: 3 coins (3+3), Optimal: 3 coins (4+1+1).",
        "wg": []
      },
      {
        "t": "(D) 貪婪解與最佳解皆為 2 個。",
        "en": "(D) Both Greedy and Optimal solutions are 2 coins.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪演算法會先選最大的面額 4，剩下的 2 只能用兩個 1 補足，共需 3 個硬幣 (4, 1, 1)。然而，全域最佳解是直接選兩個 3，只需 2 個硬幣 (3, 3)。這證明了貪婪法在特定面額組合下會失敗。",
      "en": "The greedy algorithm first selects the largest denomination 4, leaving 2, which must be filled by two 1s, totaling 3 coins (4, 1, 1). However, the global optimum is to select two 3s, requiring only 2 coins (3, 3). This proves that the greedy approach fails with certain denomination combinations.",
      "wg": [
        {
          "t": "補足",
          "en": "make up / fill",
          "ps": "V"
        }
      ]
    }
  }
]