[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Greedy, Fractional Knapsack, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您是一個小偷，正在闖入一家香料店，您的背包只能承重 W 公斤。",
        "en": "Suppose you are a thief breaking into a spice shop, and your knapsack can only carry W kilograms.",
        "wg": [
          {
            "t": "香料",
            "en": "spice",
            "ps": "N"
          },
          {
            "t": "背包",
            "en": "knapsack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "店內有各種不同價值的香料粉末，您可以任意拿取部分的香料（可分割）。",
        "en": "There are various spices of different values in the shop, and you can take any fraction of the spices (divisible).",
        "wg": [
          {
            "t": "粉末",
            "en": "powder",
            "ps": "N"
          },
          {
            "t": "可分割",
            "en": "divisible",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問應該採取什麼貪婪策略來最大化背包內的總價值？",
        "en": "What greedy strategy should be adopted to maximize the total value in the knapsack?",
        "wg": [
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          },
          {
            "t": "最大化",
            "en": "maximize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先選擇總價值最高的香料。",
        "en": "(A) Prioritize picking the spice with the highest total value.",
        "wg": []
      },
      {
        "t": "(B) 優先選擇重量最輕的香料。",
        "en": "(B) Prioritize picking the spice with the lightest weight.",
        "wg": []
      },
      {
        "t": "(C) 優先選擇「單位重量價值」（價值/重量）最高的香料。",
        "en": "(C) Prioritize picking the spice with the highest 'value per unit weight' (value/weight).",
        "wg": [
          {
            "t": "單位重量",
            "en": "unit weight",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 隨機選擇直到背包裹滿為止。",
        "en": "(D) Randomly select until the knapsack is full.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在分數背包問題（Fractional Knapsack）中，物品可以被分割，因此最佳策略是每次都選擇當前剩餘物品中「單位價值」最高者，這能保證每一單位的重量都貢獻了最大的可能價值。",
      "en": "In the Fractional Knapsack problem, items can be divided, so the optimal strategy is to always choose the item with the highest 'value per unit' among the remaining ones, ensuring that every unit of weight contributes the maximum possible value.",
      "wg": [
        {
          "t": "分數背包問題",
          "en": "Fractional Knapsack Problem",
          "ps": "N"
        },
        {
          "t": "貢獻",
          "en": "contribute",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Greedy, Activity Selection, Scheduling",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「活動選擇問題」（Activity Selection Problem）中，我們有一組活動，每個活動都有開始時間與結束時間，且同一時間只能進行一個活動。",
        "en": "In the 'Activity Selection Problem', we have a set of activities, each with a start time and an end time, and only one activity can be performed at a time.",
        "wg": [
          {
            "t": "活動選擇問題",
            "en": "Activity Selection Problem",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了安排出數量最多的互不衝突活動，我們應該依據什麼標準對活動進行排序？",
        "en": "To schedule the maximum number of non-overlapping activities, based on what criteria should we sort the activities?",
        "wg": [
          {
            "t": "互不衝突",
            "en": "non-overlapping",
            "ps": "Adj"
          },
          {
            "t": "標準",
            "en": "criteria",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的「開始時間」由早到晚排序。",
        "en": "(A) Sort by the 'start time' of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的「結束時間」由早到晚排序。",
        "en": "(B) Sort by the 'end time' of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(C) 依照活動的「持續時間」由短到長排序。",
        "en": "(C) Sort by the 'duration' of the activities from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 依照活動的「結束時間」由晚到早排序。",
        "en": "(D) Sort by the 'end time' of the activities from latest to earliest.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "依照「結束時間」由早到晚排序可以讓我們儘早釋放資源給下一個活動，從而騰出更多時間容納後續的活動，這是確保全域最佳解的關鍵貪婪選擇。",
      "en": "Sorting by 'end time' from earliest to latest allows us to release resources for the next activity as early as possible, thereby freeing up more time to accommodate subsequent activities, which is the key greedy choice ensuring the global optimal solution.",
      "wg": [
        {
          "t": "釋放",
          "en": "release",
          "ps": "V"
        },
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        },
        {
          "t": "全域最佳解",
          "en": "global optimal solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Greedy, Huffman Coding, Data Compression",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼（Huffman Coding）是一種廣泛使用的資料壓縮演算法。",
        "en": "Huffman Coding is a widely used data compression algorithm.",
        "wg": [
          {
            "t": "資料壓縮",
            "en": "data compression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，演算法總是優先合併哪兩個節點？",
        "en": "During the construction of the Huffman tree, which two nodes does the algorithm always prioritize merging?",
        "wg": [
          {
            "t": "建構",
            "en": "construction",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 頻率（出現次數）最高的兩個節點。",
        "en": "(A) The two nodes with the highest frequency (occurrence count).",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 頻率最低的兩個節點。",
        "en": "(B) The two nodes with the lowest frequency.",
        "wg": []
      },
      {
        "t": "(C) 隨機選取的兩個節點。",
        "en": "(C) Two randomly selected nodes.",
        "wg": []
      },
      {
        "t": "(D) 依照字母順序排列的前兩個節點。",
        "en": "(D) The first two nodes arranged in alphabetical order.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼編碼採用貪婪策略，每次從優先佇列中取出頻率最低的兩個節點進行合併，這樣可以確保頻率低的字元位於樹的較深層（編碼較長），而頻率高的字元位於較淺層（編碼較短），進而達到最小化總編碼長度的目的。",
      "en": "Huffman coding uses a greedy strategy, extracting the two nodes with the lowest frequency from the priority queue each time to merge. This ensures that low-frequency characters are deeper in the tree (longer codes) and high-frequency characters are shallower (shorter codes), thereby minimizing the total encoding length.",
      "wg": [
        {
          "t": "優先佇列",
          "en": "priority queue",
          "ps": "N"
        },
        {
          "t": "淺層",
          "en": "shallow",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Greedy, Counter Example, Coin Change",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "貪婪演算法並不總是能找到全域最佳解。",
        "en": "Greedy algorithms do not always find the global optimal solution.",
        "wg": []
      },
      {
        "t": "考慮找零錢問題：假設硬幣面額為 {1, 3, 4}，目標金額為 6。",
        "en": "Consider the coin change problem: assume coin denominations are {1, 3, 4} and the target amount is 6.",
        "wg": [
          {
            "t": "找零錢問題",
            "en": "coin change problem",
            "ps": "N"
          },
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用標準的貪婪策略（每次儘量選最大的硬幣），會得到什麼結果？這與最佳解有何差異？",
        "en": "If a standard greedy strategy is used (always picking the largest possible coin), what is the result? How does it differ from the optimal solution?",
        "wg": [
          {
            "t": "差異",
            "en": "difference",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪解為 3 個硬幣 (4, 1, 1)，最佳解為 2 個硬幣 (3, 3)。",
        "en": "(A) Greedy solution is 3 coins (4, 1, 1); optimal solution is 2 coins (3, 3).",
        "wg": []
      },
      {
        "t": "(B) 貪婪解為 2 個硬幣 (3, 3)，最佳解也是 2 個硬幣。",
        "en": "(B) Greedy solution is 2 coins (3, 3); optimal solution is also 2 coins.",
        "wg": []
      },
      {
        "t": "(C) 貪婪解無法湊出金額 6。",
        "en": "(C) Greedy solution cannot make up the amount 6.",
        "wg": []
      },
      {
        "t": "(D) 貪婪解為 3 個硬幣 (3, 2, 1)，但面額中沒有 2。",
        "en": "(D) Greedy solution is 3 coins (3, 2, 1), but 2 is not in the denominations.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "貪婪演算法會先選擇小於等於 6 的最大面額 4，剩下 2，接著只能選兩個 1，總共 3 個硬幣；然而最佳解是直接選兩個 3。這證明了當硬幣面額不具備特定性質（如倍數關係）時，貪婪法可能失效。",
      "en": "The greedy algorithm first selects the largest denomination less than or equal to 6, which is 4, leaving 2, then it must select two 1s, totaling 3 coins; however, the optimal solution is to select two 3s directly. This proves that greedy methods may fail when coin denominations do not possess specific properties (like multiples).",
      "wg": [
        {
          "t": "失效",
          "en": "fail",
          "ps": "V"
        },
        {
          "t": "倍數關係",
          "en": "multiple relationship",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Greedy, Minimum Spanning Tree, Kruskal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Kruskal 演算法用於尋找加權圖的最小生成樹 (MST)。",
        "en": "Kruskal's algorithm is used to find the Minimum Spanning Tree (MST) of a weighted graph.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          },
          {
            "t": "加權圖",
            "en": "weighted graph",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該演算法的核心貪婪步驟為何？",
        "en": "What is the core greedy step of this algorithm?",
        "wg": []
      },
      {
        "t": "且在加入邊時必須檢查什麼條件以確保結構正確？",
        "en": "And what condition must be checked when adding an edge to ensure structural correctness?",
        "wg": [
          {
            "t": "結構正確",
            "en": "structural correctness",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 隨機選邊；檢查是否連通。",
        "en": "(A) Select edges randomly; check for connectivity.",
        "wg": [
          {
            "t": "連通",
            "en": "connectivity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 從權重最小的邊開始選；檢查是否形成環 (Cycle)。",
        "en": "(B) Start selecting from the edge with the minimum weight; check if it forms a cycle.",
        "wg": [
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 從權重最大的邊開始選；檢查是否形成環。",
        "en": "(C) Start selecting from the edge with the maximum weight; check if it forms a cycle.",
        "wg": []
      },
      {
        "t": "(D) 從任意頂點開始延伸；檢查是否重複拜訪頂點。",
        "en": "(D) Extend from any vertex; check if vertices are visited repeatedly.",
        "wg": [
          {
            "t": "延伸",
            "en": "extend",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Kruskal 演算法將所有邊依權重由小到大排序，依序嘗試加入圖中。若加入該邊會形成環（即連接的兩個頂點已在同一個連通分量中），則捨棄該邊；否則加入。這保證了總權重最小且無環。",
      "en": "Kruskal's algorithm sorts all edges by weight from smallest to largest and attempts to add them to the graph sequentially. If adding an edge forms a cycle (i.e., the two connected vertices are already in the same connected component), the edge is discarded; otherwise, it is added. This guarantees the minimum total weight and no cycles.",
      "wg": [
        {
          "t": "連通分量",
          "en": "connected component",
          "ps": "N"
        },
        {
          "t": "捨棄",
          "en": "discard",
          "ps": "V"
        }
      ]
    }
  }
]