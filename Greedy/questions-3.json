[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Interval Scheduling, Activity Selection, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您有一組活動，每個活動都有特定的開始時間和結束時間。",
        "en": "Suppose you have a set of activities, each with a specific start time and end time.",
        "wg": [
          {
            "t": "特定的",
            "en": "specific",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "您希望安排盡可能多的活動，且這些活動在時間上不能重疊。",
        "en": "You want to schedule as many activities as possible, and these activities cannot overlap in time.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問應該採取哪種貪婪策略來排序活動，才能保證獲得最佳解？",
        "en": "Which greedy strategy should be adopted to sort the activities to guarantee the optimal solution?",
        "wg": [
          {
            "t": "採取",
            "en": "adopt",
            "ps": "V"
          },
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          },
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的「開始時間」由早到晚排序。",
        "en": "(A) Sort by the \"start time\" of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的「持續時間」由短到長排序。",
        "en": "(B) Sort by the \"duration\" of the activities from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照活動的「結束時間」由早到晚排序。",
        "en": "(C) Sort by the \"finish time\" of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依照活動的「結束時間」由晚到早排序。",
        "en": "(D) Sort by the \"finish time\" of the activities from latest to earliest.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選擇最早結束的活動可以為後續的活動騰出最多的剩餘時間，這是區間排程問題 (Interval Scheduling) 的標準貪婪策略。依照開始時間或持續時間排序都可能導致選到一個佔用很長時間段的活動，從而排擠掉其他潛在的活動。",
      "en": "Choosing the activity that finishes earliest leaves the most remaining time for subsequent activities, which is the standard greedy strategy for the Interval Scheduling problem. Sorting by start time or duration may lead to selecting an activity that occupies a long period, thereby crowding out other potential activities.",
      "wg": [
        {
          "t": "騰出",
          "en": "leave / free up",
          "ps": "V"
        },
        {
          "t": "排擠",
          "en": "crowd out",
          "ps": "V"
        },
        {
          "t": "潛在的",
          "en": "potential",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Knapsack Problem, Fractional Knapsack, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於背包問題 (Knapsack Problem) 與貪婪演算法的適用性，下列敘述何者正確？",
        "en": "Regarding the Knapsack Problem and the applicability of greedy algorithms, which of the following statements is correct?",
        "wg": [
          {
            "t": "適用性",
            "en": "applicability",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請考慮物品是否可以被分割的情況。",
        "en": "Please consider the situation where items can be divided.",
        "wg": [
          {
            "t": "分割",
            "en": "divide",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0/1 背包問題 (0/1 Knapsack) 可以使用貪婪演算法求得最佳解。",
        "en": "(A) The 0/1 Knapsack problem can be solved optimally using a greedy algorithm.",
        "wg": []
      },
      {
        "t": "(B) 分數背包問題 (Fractional Knapsack) 必須使用動態規劃才能求得最佳解。",
        "en": "(B) The Fractional Knapsack problem requires dynamic programming to find the optimal solution.",
        "wg": []
      },
      {
        "t": "(C) 分數背包問題可以使用貪婪演算法，依據「價值/重量比」排序來求得最佳解。",
        "en": "(C) The Fractional Knapsack problem can be solved optimally using a greedy algorithm by sorting based on the \"value-to-weight ratio\".",
        "wg": [
          {
            "t": "比率",
            "en": "ratio",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 無論物品是否可分割，貪婪演算法都無法保證最佳解。",
        "en": "(D) Regardless of whether items are divisible, greedy algorithms cannot guarantee an optimal solution.",
        "wg": [
          {
            "t": "無論",
            "en": "regardless of",
            "ps": "Conj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當物品可以分割時 (分數背包)，我們可以貪婪地選擇「單位重量價值」最高的物品填滿背包，這保證了最佳解。然而，在 0/1 背包問題中，物品不可分割，貪婪策略可能會留下無法利用的空隙或錯過總價值更高的組合，因此需使用動態規劃。",
      "en": "When items are divisible (Fractional Knapsack), we can greedily choose items with the highest \"value per unit weight\" to fill the knapsack, guaranteeing an optimal solution. However, in the 0/1 Knapsack problem where items are indivisible, a greedy strategy might leave unusable gaps or miss combinations with higher total value, thus requiring dynamic programming.",
      "wg": [
        {
          "t": "不可分割",
          "en": "indivisible",
          "ps": "Adj"
        },
        {
          "t": "空隙",
          "en": "gap",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Huffman Coding, Data Compression, Prefix Codes",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼 (Huffman Coding) 是一種廣泛使用的資料壓縮演算法。",
        "en": "Huffman Coding is a widely used data compression algorithm.",
        "wg": [
          {
            "t": "廣泛",
            "en": "widely",
            "ps": "Adv"
          },
          {
            "t": "壓縮",
            "en": "compression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "它利用貪婪策略建構二元樹來產生前綴碼 (Prefix Code)。",
        "en": "It uses a greedy strategy to construct a binary tree to generate prefix codes.",
        "wg": [
          {
            "t": "建構",
            "en": "construct",
            "ps": "V"
          },
          {
            "t": "前綴碼",
            "en": "prefix code",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於其編碼長度與字元頻率的關係，下列何者正確？",
        "en": "Regarding the relationship between code length and character frequency, which of the following is correct?",
        "wg": [
          {
            "t": "頻率",
            "en": "frequency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 出現頻率越高的字元，其編碼長度越長。",
        "en": "(A) Characters with higher frequency have longer code lengths.",
        "wg": []
      },
      {
        "t": "(B) 出現頻率越高的字元，其編碼長度越短。",
        "en": "(B) Characters with higher frequency have shorter code lengths.",
        "wg": []
      },
      {
        "t": "(C) 所有字元的編碼長度皆相同。",
        "en": "(C) All characters have the same code length.",
        "wg": []
      },
      {
        "t": "(D) 編碼長度與字元頻率無關，取決於字元的 ASCII 順序。",
        "en": "(D) Code length is unrelated to character frequency and depends on the ASCII order of the characters.",
        "wg": [
          {
            "t": "取決於",
            "en": "depend on",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼演算法的貪婪策略是每次合併頻率最小的兩個節點，這使得頻率低的字元位於樹的較深層 (編碼較長)，而頻率高的字元位於較淺層 (編碼較短)，從而最小化總編碼長度。",
      "en": "The greedy strategy of Huffman's algorithm merges the two nodes with the lowest frequencies at each step. This places low-frequency characters deeper in the tree (longer codes) and high-frequency characters shallower in the tree (shorter codes), thereby minimizing the total encoded length.",
      "wg": [
        {
          "t": "合併",
          "en": "merge",
          "ps": "V"
        },
        {
          "t": "淺層",
          "en": "shallow layer",
          "ps": "N"
        },
        {
          "t": "最小化",
          "en": "minimize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Minimum Spanning Tree, Kruskal's Algorithm, Graph Theory",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在尋找圖形的最小生成樹 (MST) 時，Kruskal 演算法採取了貪婪策略。",
        "en": "When finding the Minimum Spanning Tree (MST) of a graph, Kruskal's algorithm adopts a greedy strategy.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問該演算法在每一回合選擇邊 (Edge) 的主要依據是什麼？",
        "en": "What is the main criterion for selecting an edge in each round of this algorithm?",
        "wg": [
          {
            "t": "依據",
            "en": "criterion",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 選擇連接已訪問頂點與未訪問頂點中權重最小的邊。",
        "en": "(A) Select the edge with the minimum weight connecting a visited vertex and an unvisited vertex.",
        "wg": [
          {
            "t": "頂點",
            "en": "vertex",
            "ps": "N"
          },
          {
            "t": "權重",
            "en": "weight",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 隨機選擇一條邊，只要它不構成迴圈。",
        "en": "(B) Randomly select an edge as long as it does not form a cycle.",
        "wg": [
          {
            "t": "迴圈",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 在所有尚未被選取的邊中，選擇權重最小且不會與已選邊形成迴圈的邊。",
        "en": "(C) Among all unselected edges, select the one with the minimum weight that does not form a cycle with the already selected edges.",
        "wg": []
      },
      {
        "t": "(D) 選擇權重最大的邊，以確保圖形的連通性。",
        "en": "(D) Select the edge with the maximum weight to ensure the connectivity of the graph.",
        "wg": [
          {
            "t": "連通性",
            "en": "connectivity",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Kruskal 演算法將所有邊依權重排序，並依序選取最小的邊，前提是該邊的兩個端點尚未連通 (即不形成迴圈)。選項 (A) 描述的是 Prim 演算法的邏輯。",
      "en": "Kruskal's algorithm sorts all edges by weight and sequentially selects the smallest edge, provided that the two endpoints of the edge are not yet connected (i.e., it does not form a cycle). Option (A) describes the logic of Prim's algorithm.",
      "wg": [
        {
          "t": "前提",
          "en": "premise / condition",
          "ps": "N"
        },
        {
          "t": "端點",
          "en": "endpoint",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Coin Change Problem, Local Optimum, Global Optimum",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "貪婪演算法在「找零錢問題」(Coin Change Problem) 中並不總是能找到最佳解 (使用最少硬幣數量)。",
        "en": "Greedy algorithms do not always find the optimal solution (using the minimum number of coins) in the \"Coin Change Problem\".",
        "wg": [
          {
            "t": "找零錢",
            "en": "make change",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設硬幣面額為 {1, 3, 4}，若要湊出金額 6，使用貪婪策略與最佳解的硬幣數量分別為何？",
        "en": "Assuming the coin denominations are {1, 3, 4}, if the target amount is 6, what are the number of coins used by the greedy strategy and the optimal solution, respectively?",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          },
          {
            "t": "湊出",
            "en": "make up / sum to",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪策略：2 個 (3+3)；最佳解：2 個 (3+3)。",
        "en": "(A) Greedy strategy: 2 (3+3); Optimal solution: 2 (3+3).",
        "wg": []
      },
      {
        "t": "(B) 貪婪策略：3 個 (4+1+1)；最佳解：2 個 (3+3)。",
        "en": "(B) Greedy strategy: 3 (4+1+1); Optimal solution: 2 (3+3).",
        "wg": []
      },
      {
        "t": "(C) 貪婪策略：2 個 (4+2)；最佳解：3 個 (1+1+1+1+1+1)。",
        "en": "(C) Greedy strategy: 2 (4+2); Optimal solution: 3 (1+1+1+1+1+1).",
        "wg": []
      },
      {
        "t": "(D) 貪婪策略：3 個 (4+1+1)；最佳解：3 個 (4+1+1)。",
        "en": "(D) Greedy strategy: 3 (4+1+1); Optimal solution: 3 (4+1+1).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪策略會優先選擇最大的面額，因此對 6 來說，會先選 4，剩下 2，接著只能選兩個 1，總共 3 個硬幣 (4+1+1)。但最佳解其實是兩個 3 (3+3)，只需 2 個硬幣。這證明了當面額非標準系統時，貪婪法可能失效。",
      "en": "The greedy strategy prioritizes the largest denomination, so for 6, it first picks 4, leaving 2, which then requires two 1s, totaling 3 coins (4+1+1). However, the optimal solution is actually two 3s (3+3), requiring only 2 coins. This proves that the greedy method can fail when denominations are not a standard system.",
      "wg": [
        {
          "t": "優先選擇",
          "en": "prioritize",
          "ps": "V"
        },
        {
          "t": "失效",
          "en": "fail / become invalid",
          "ps": "V"
        }
      ]
    }
  }
]