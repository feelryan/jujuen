[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Interval Scheduling, Activity Selection, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設你有一個會議室以及多個想要預約該會議室的活動，每個活動都有開始時間和結束時間。",
        "en": "Suppose you have a conference room and multiple activities that want to book it, each with a start time and an end time.",
        "wg": [
          {
            "t": "預約",
            "en": "book",
            "ps": "V"
          },
          {
            "t": "會議室",
            "en": "conference room",
            "ps": "N"
          }
        ]
      },
      {
        "t": "你的目標是安排盡可能多的活動，且活動之間不能重疊。",
        "en": "Your goal is to schedule as many activities as possible without them overlapping.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlapping",
            "ps": "V/Adj"
          }
        ]
      },
      {
        "t": "根據貪婪演算法（Greedy Algorithm）的策略，你應該依據什麼標準來對活動進行排序以獲得最佳解？",
        "en": "According to the Greedy Algorithm strategy, by what criterion should you sort the activities to obtain the optimal solution?",
        "wg": [
          {
            "t": "標準",
            "en": "criterion",
            "ps": "N"
          },
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依照活動的開始時間由早到晚排序。",
        "en": "(A) Sort by the start time of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(B) 依照活動的持續時間由短到長排序。",
        "en": "(B) Sort by the duration of the activities from shortest to longest.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依照活動的結束時間由早到晚排序。",
        "en": "(C) Sort by the end time of the activities from earliest to latest.",
        "wg": []
      },
      {
        "t": "(D) 依照活動與其他活動重疊的數量由少到多排序。",
        "en": "(D) Sort by the number of overlaps with other activities from least to most.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是經典的區間排程問題（Interval Scheduling）。選擇結束時間最早的活動可以騰出最多的剩餘時間給後續的活動，這是確保能選取最多活動的正確貪婪策略。",
      "en": "This is the classic Interval Scheduling problem. Choosing the activity with the earliest finish time frees up the most remaining time for subsequent activities, which is the correct greedy strategy to ensure the maximum number of activities are selected.",
      "wg": [
        {
          "t": "區間排程",
          "en": "Interval Scheduling",
          "ps": "N"
        },
        {
          "t": "騰出",
          "en": "free up",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Fractional Knapsack, Ratio, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「分數背包問題」（Fractional Knapsack Problem）中，物品是可以被分割的（例如金粉或穀物）。",
        "en": "In the 'Fractional Knapsack Problem', items can be divided (e.g., gold dust or grains).",
        "wg": [
          {
            "t": "分割",
            "en": "divided",
            "ps": "V"
          },
          {
            "t": "穀物",
            "en": "grains",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要最大化背包內的總價值，貪婪演算法應該優先選擇哪種物品？",
        "en": "To maximize the total value inside the knapsack, which items should the greedy algorithm prioritize?",
        "wg": [
          {
            "t": "最大化",
            "en": "maximize",
            "ps": "V"
          },
          {
            "t": "優先選擇",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總價值最高的物品。",
        "en": "(A) The items with the highest total value.",
        "wg": []
      },
      {
        "t": "(B) 重量最輕的物品。",
        "en": "(B) The items with the lightest weight.",
        "wg": []
      },
      {
        "t": "(C) 單位重量價值（價值/重量比）最高的物品。",
        "en": "(C) The items with the highest value per unit weight (value-to-weight ratio).",
        "wg": [
          {
            "t": "單位重量",
            "en": "unit weight",
            "ps": "N"
          },
          {
            "t": "比率",
            "en": "ratio",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 體積最小的物品。",
        "en": "(D) The items with the smallest volume.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在物品可分割的情況下，最佳策略是每次都拿取「CP值」最高（即單位重量價值最高）的物品填滿背包，直到該物品拿完或背包滿為止。",
      "en": "When items are divisible, the optimal strategy is to always take the item with the highest 'cost-performance ratio' (highest value per unit weight) to fill the knapsack until the item is exhausted or the knapsack is full.",
      "wg": [
        {
          "t": "可分割",
          "en": "divisible",
          "ps": "Adj"
        },
        {
          "t": "耗盡",
          "en": "exhausted",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "Huffman Coding, Data Compression, Tree Construction",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "霍夫曼編碼（Huffman Coding）是一種使用貪婪演算法來建構最佳前綴碼的資料壓縮技術。",
        "en": "Huffman Coding is a data compression technique that uses a greedy algorithm to construct optimal prefix codes.",
        "wg": [
          {
            "t": "前綴碼",
            "en": "prefix codes",
            "ps": "N"
          },
          {
            "t": "資料壓縮",
            "en": "data compression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在建構霍夫曼樹的過程中，貪婪選擇的具體步驟為何？",
        "en": "What is the specific step of the greedy choice during the construction of the Huffman tree?",
        "wg": [
          {
            "t": "建構",
            "en": "construction",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次選取出現頻率最高的兩個字元，將它們合併。",
        "en": "(A) Always select the two characters with the highest frequencies and merge them.",
        "wg": [
          {
            "t": "頻率",
            "en": "frequencies",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 每次選取出現頻率最低的兩個節點，將它們合併成一個新節點。",
        "en": "(B) Always select the two nodes with the lowest frequencies and merge them into a new node.",
        "wg": [
          {
            "t": "節點",
            "en": "nodes",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 隨機選取兩個節點進行合併，直到只剩下一個根節點。",
        "en": "(C) Randomly select two nodes to merge until only one root node remains.",
        "wg": []
      },
      {
        "t": "(D) 依照字元的 ASCII 順序進行合併。",
        "en": "(D) Merge according to the ASCII order of the characters.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "霍夫曼演算法的核心在於將出現頻率最低的字元放在樹的底部（編碼較長），頻率高的放在頂部（編碼較短）。因此，貪婪選擇是每次取出頻率最小的兩個節點進行合併。",
      "en": "The core of Huffman's algorithm is to place characters with the lowest frequency at the bottom of the tree (longer codes) and those with high frequency at the top (shorter codes). Therefore, the greedy choice is to merge the two nodes with the smallest frequencies at each step.",
      "wg": [
        {
          "t": "核心",
          "en": "core",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Minimum Spanning Tree, Kruskal, Cycle Detection",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Kruskal 演算法用於尋找圖的最小生成樹（MST），它屬於貪婪演算法的一種。",
        "en": "Kruskal's algorithm is used to find the Minimum Spanning Tree (MST) of a graph and is a type of greedy algorithm.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該演算法在每一步驟中選擇邊（Edge）的邏輯是什麼？",
        "en": "What is the logic for selecting edges at each step of this algorithm?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 選擇權重最小且不會與已選邊形成迴圈（Cycle）的邊。",
        "en": "(A) Select the edge with the minimum weight that does not form a cycle with the already selected edges.",
        "wg": [
          {
            "t": "權重",
            "en": "weight",
            "ps": "N"
          },
          {
            "t": "迴圈",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 從任意一個頂點開始，選擇連接該頂點且權重最小的邊。",
        "en": "(B) Start from an arbitrary vertex and select the edge with the minimum weight connected to that vertex.",
        "wg": [
          {
            "t": "頂點",
            "en": "vertex",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 選擇權重最大的邊，以確保圖的連通性。",
        "en": "(C) Select the edge with the maximum weight to ensure the connectivity of the graph.",
        "wg": [
          {
            "t": "連通性",
            "en": "connectivity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 隨機選擇邊，直到所有頂點都被連接。",
        "en": "(D) Randomly select edges until all vertices are connected.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "Kruskal 演算法將所有邊依權重排序，依序選取最小的邊，並利用「併查集」（Union-Find）等資料結構檢查是否形成迴圈。選項 (B) 描述的是 Prim 演算法的邏輯。",
      "en": "Kruskal's algorithm sorts all edges by weight and sequentially selects the smallest edge, using data structures like 'Union-Find' to check for cycles. Option (B) describes the logic of Prim's algorithm.",
      "wg": [
        {
          "t": "併查集",
          "en": "Union-Find",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "hard",
    "keywords": "Coin Change, Counter-example, Local Optimum",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "雖然貪婪演算法在許多情況下有效，但在「找零錢問題」（Coin Change Problem）中並不總是能保證得到最佳解。",
        "en": "Although greedy algorithms are effective in many cases, they do not always guarantee an optimal solution in the 'Coin Change Problem'.",
        "wg": [
          {
            "t": "找零錢問題",
            "en": "Coin Change Problem",
            "ps": "N"
          },
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "V"
          }
        ]
      },
      {
        "t": "考慮幣值系統為 {1, 3, 4}，若要湊出金額 6，使用貪婪策略（每次選取不大於剩餘金額的最大幣值）會得到什麼結果？",
        "en": "Consider a coin system {1, 3, 4}. If you need to make change for the amount 6, what result will the greedy strategy (always picking the largest coin not exceeding the remaining amount) yield?",
        "wg": [
          {
            "t": "幣值",
            "en": "denomination",
            "ps": "N"
          },
          {
            "t": "湊出",
            "en": "make change for",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2 枚硬幣 (3, 3)。",
        "en": "(A) 2 coins (3, 3).",
        "wg": []
      },
      {
        "t": "(B) 3 枚硬幣 (4, 1, 1)。",
        "en": "(B) 3 coins (4, 1, 1).",
        "wg": []
      },
      {
        "t": "(C) 貪婪演算法無法找出任何解。",
        "en": "(C) The greedy algorithm cannot find any solution.",
        "wg": []
      },
      {
        "t": "(D) 2 枚硬幣 (4, 2)。",
        "en": "(D) 2 coins (4, 2).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "貪婪策略會先選最大的 4，剩下 2，接著只能選 1 和 1，總共 3 枚硬幣。然而最佳解其實是兩枚 3 (3+3=6)。這證明了貪婪演算法的「局部最佳」不一定等於「全域最佳」。",
      "en": "The greedy strategy first picks the largest coin 4, leaving 2, then must pick 1 and 1, totaling 3 coins. However, the optimal solution is actually two 3s (3+3=6). This proves that the 'local optimum' of the greedy algorithm does not necessarily equal the 'global optimum'.",
      "wg": [
        {
          "t": "局部最佳",
          "en": "local optimum",
          "ps": "N"
        },
        {
          "t": "全域最佳",
          "en": "global optimum",
          "ps": "N"
        }
      ]
    }
  }
]