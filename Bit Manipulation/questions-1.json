[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Bitwise AND, Power of Two, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "boolean check(int n) {\n  return n > 0 && (n & (n - 1)) == 0;\n}",
    "question": [
      {
        "t": "請分析上述程式碼片段的功能。",
        "en": "Please analyze the functionality of the code snippet above.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "功能",
            "en": "functionality",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該函式利用位元運算來檢查整數 n 的特定屬性。",
        "en": "The function uses bitwise operations to check a specific property of the integer n.",
        "wg": [
          {
            "t": "位元運算",
            "en": "bitwise operations",
            "ps": "N"
          },
          {
            "t": "屬性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 檢查 n 是否為奇數。",
        "en": "(A) Checks if n is an odd number.",
        "wg": [
          {
            "t": "奇數",
            "en": "odd number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 檢查 n 是否為 2 的冪次 (Power of 2)。",
        "en": "(B) Checks if n is a power of 2.",
        "wg": [
          {
            "t": "冪次",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 檢查 n 是否為質數。",
        "en": "(C) Checks if n is a prime number.",
        "wg": [
          {
            "t": "質數",
            "en": "prime number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將 n 的最低位元設為 0。",
        "en": "(D) Sets the least significant bit of n to 0.",
        "wg": [
          {
            "t": "最低位元",
            "en": "least significant bit",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二進位表示中，2 的冪次僅有一個位元是 1 (例如 100, 1000)。減去 1 會將該位元變為 0 並將右側所有位元變為 1 (例如 011, 0111)。因此，兩者進行 AND 運算結果必為 0。",
      "en": "In binary representation, a power of 2 has exactly one bit set to 1 (e.g., 100, 1000). Subtracting 1 flips that bit to 0 and all bits to its right to 1 (e.g., 011, 0111). Thus, the AND operation between them results in 0.",
      "wg": [
        {
          "t": "二進位表示",
          "en": "binary representation",
          "ps": "N"
        },
        {
          "t": "翻轉",
          "en": "flip",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "XOR, Array, Time Complexity, Space Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個非空整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現兩次。",
        "en": "Given a non-empty array of integers, every element appears twice except for one.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "array of integers",
            "ps": "N"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要找出那個只出現一次的元素。",
        "en": "You need to find that single one.",
        "wg": []
      },
      {
        "t": "哪種方法可以在線性時間複雜度 O(n) 且不使用額外空間 O(1) 的情況下解決此問題？",
        "en": "Which approach solves this problem with linear time complexity O(n) and without using extra space O(1)?",
        "wg": [
          {
            "t": "線性時間複雜度",
            "en": "linear time complexity",
            "ps": "N"
          },
          {
            "t": "額外空間",
            "en": "extra space",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Map) 記錄出現次數。",
        "en": "(A) Use a Hash Map to record occurrence counts.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將陣列排序後，檢查相鄰元素。",
        "en": "(B) Sort the array and check adjacent elements.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 對陣列中所有元素進行 XOR (互斥或) 運算。",
        "en": "(C) Perform XOR operation on all elements in the array.",
        "wg": [
          {
            "t": "互斥或",
            "en": "XOR",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 計算所有元素的總和，減去重複元素的總和。",
        "en": "(D) Calculate the sum of all elements and subtract the sum of duplicate elements.",
        "wg": [
          {
            "t": "重複",
            "en": "duplicate",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "XOR 運算具有交換律與結合律，且 A ^ A = 0，A ^ 0 = A。因此，成對出現的數字 XOR 後會互相抵銷為 0，最後剩下的即為只出現一次的數字。",
      "en": "XOR operation is commutative and associative; also A ^ A = 0 and A ^ 0 = A. Therefore, numbers appearing in pairs will cancel each other out to 0 after XOR, leaving only the single number.",
      "wg": [
        {
          "t": "交換律",
          "en": "commutative",
          "ps": "Adj"
        },
        {
          "t": "結合律",
          "en": "associative",
          "ps": "Adj"
        },
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "easy",
    "keywords": "Bitwise OR, Bit Masking, Set Bit",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在嵌入式系統開發中，您經常需要操作暫存器的特定位元。",
        "en": "In embedded system development, you often need to manipulate specific bits of a register.",
        "wg": [
          {
            "t": "嵌入式系統",
            "en": "embedded system",
            "ps": "N"
          },
          {
            "t": "暫存器",
            "en": "register",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要將整數 x 的第 k 個位元 (從 0 開始計數) 設定為 1，且不影響其他位元，應使用下列哪個運算式？",
        "en": "To set the k-th bit (0-indexed) of integer x to 1 without affecting other bits, which expression should be used?",
        "wg": [
          {
            "t": "設定",
            "en": "set",
            "ps": "V"
          },
          {
            "t": "運算式",
            "en": "expression",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) x | (1 << k)",
        "en": "(A) x | (1 << k)",
        "wg": []
      },
      {
        "t": "(B) x & (1 << k)",
        "en": "(B) x & (1 << k)",
        "wg": []
      },
      {
        "t": "(C) x ^ (1 << k)",
        "en": "(C) x ^ (1 << k)",
        "wg": []
      },
      {
        "t": "(D) x & ~(1 << k)",
        "en": "(D) x & ~(1 << k)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "使用左移運算子 (<<) 產生一個只有第 k 位是 1 的遮罩。接著使用 OR (|) 運算，確保第 k 位被設為 1，而 0 | x = x 特性保證其他位元不變。",
      "en": "Use the left shift operator (<<) to create a mask with only the k-th bit set to 1. Then use the OR (|) operation to ensure the k-th bit becomes 1, while the property 0 | x = x ensures other bits remain unchanged.",
      "wg": [
        {
          "t": "遮罩",
          "en": "mask",
          "ps": "N"
        },
        {
          "t": "不變",
          "en": "unchanged",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Two's Complement, Lowbit, Binary Indexed Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二補數 (Two's Complement) 系統中，運算式 `x & (-x)` 常用於 Binary Indexed Tree (Fenwick Tree) 等演算法。",
        "en": "In the Two's Complement system, the expression `x & (-x)` is commonly used in algorithms like Binary Indexed Tree (Fenwick Tree).",
        "wg": [
          {
            "t": "二補數",
            "en": "Two's Complement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這個運算式的結果代表什麼？",
        "en": "What does the result of this expression represent?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) x 的絕對值。",
        "en": "(A) The absolute value of x.",
        "wg": [
          {
            "t": "絕對值",
            "en": "absolute value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將 x 的所有位元反轉。",
        "en": "(B) Flips all bits of x.",
        "wg": [
          {
            "t": "反轉",
            "en": "flip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 保留 x 最右邊的 1 (最低有效位)，並將其他位元歸零。",
        "en": "(C) Keeps the rightmost 1 (least significant bit) of x and clears other bits.",
        "wg": [
          {
            "t": "最低有效位",
            "en": "least significant bit",
            "ps": "N"
          },
          {
            "t": "歸零",
            "en": "clear",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 檢查 x 是否為負數。",
        "en": "(D) Checks if x is a negative number.",
        "wg": [
          {
            "t": "負數",
            "en": "negative number",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在二補數中，-x 等於 ~x + 1。這會將 x 最右邊的 1 左側的所有位元反轉，但保持最右邊的 1 及其右側的 0 不變。兩者進行 AND 運算後，僅保留最右邊的 1。",
      "en": "In Two's Complement, -x equals ~x + 1. This inverts all bits to the left of the rightmost 1 in x, but keeps the rightmost 1 and the 0s to its right unchanged. Performing AND on both results in only the rightmost 1 being kept.",
      "wg": [
        {
          "t": "反轉",
          "en": "invert",
          "ps": "V"
        },
        {
          "t": "保留",
          "en": "keep",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "XOR Swap, Variable Swapping, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void swap(int &a, int &b) {\n  if (a != b) {\n    a = a ^ b;\n    b = a ^ b;\n    a = a ^ b;\n  }\n}",
    "question": [
      {
        "t": "上述程式碼實作了一個經典的變數交換演算法。",
        "en": "The code above implements a classic variable swapping algorithm.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "變數交換",
            "en": "variable swapping",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於此方法的特性，下列敘述何者正確？",
        "en": "Regarding the characteristics of this method, which of the following statements is true?",
        "wg": [
          {
            "t": "特性",
            "en": "characteristic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它需要額外的記憶體空間來暫存變數。",
        "en": "(A) It requires extra memory space to store a temporary variable.",
        "wg": [
          {
            "t": "暫存",
            "en": "temporarily store",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 若 a 與 b 指向記憶體中同一個位址，此程式碼仍能正確運作。",
        "en": "(B) If a and b point to the same address in memory, this code still works correctly.",
        "wg": [
          {
            "t": "位址",
            "en": "address",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它利用 XOR 的可逆性，在不使用暫存變數的情況下交換數值。",
        "en": "(C) It utilizes the reversibility of XOR to swap values without using a temporary variable.",
        "wg": [
          {
            "t": "可逆性",
            "en": "reversibility",
            "ps": "N"
          },
          {
            "t": "暫存變數",
            "en": "temporary variable",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 此方法比使用暫存變數的交換方法在現代 CPU 上總是更快。",
        "en": "(D) This method is always faster than the temporary variable swap method on modern CPUs.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是 XOR Swap 演算法，不需要額外空間。但若 a 和 b 指向同一位址，第一步 `a = a ^ b` 會導致該位址的值變為 0，從而遺失資料 (這也是為何程式碼中常加上 `a != b` 或位址檢查)。現代編譯器通常能最佳化暫存變數交換，XOR Swap 未必較快。",
      "en": "This is the XOR Swap algorithm, requiring no extra space. However, if a and b point to the same address, the first step `a = a ^ b` results in 0 at that address, causing data loss (which is why `a != b` or address checks are often added). Modern compilers usually optimize temporary variable swaps well, so XOR Swap is not necessarily faster.",
      "wg": [
        {
          "t": "最佳化",
          "en": "optimize",
          "ps": "V"
        },
        {
          "t": "遺失",
          "en": "loss",
          "ps": "N"
        }
      ]
    }
  }
]