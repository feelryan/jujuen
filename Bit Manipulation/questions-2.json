[
  {
    "no": "6",
    "level": "medium",
    "keywords": "XOR, Swap, In-place, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void swap(int &a, int &b) {\n    if (&a == &b) return;\n    a = a ^ b;\n    b = a ^ b;\n    a = a ^ b;\n}",
    "question": [
      {
        "t": "請分析上述 C++ 程式碼片段。",
        "en": "Please analyze the C++ code snippet above.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這段程式碼的主要功能是什麼，以及為什麼需要檢查 `&a == &b`？",
        "en": "What is the primary function of this code, and why is the check `&a == &b` necessary?",
        "wg": [
          {
            "t": "主要功能",
            "en": "primary function",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 交換變數值；檢查是為了避免記憶體洩漏。",
        "en": "(A) Swaps variable values; the check is to avoid memory leaks.",
        "wg": [
          {
            "t": "記憶體洩漏",
            "en": "memory leaks",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 交換變數值；若 `a` 和 `b` 指向同一記憶體位址，XOR 操作會導致值變為 0。",
        "en": "(B) Swaps variable values; if `a` and `b` point to the same memory address, the XOR operations will result in the value becoming 0.",
        "wg": [
          {
            "t": "記憶體位址",
            "en": "memory address",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 計算兩數的總和；檢查是為了最佳化效能。",
        "en": "(C) Calculates the sum of two numbers; the check is for performance optimization.",
        "wg": []
      },
      {
        "t": "(D) 比較兩數是否相等；檢查是為了防止除以零錯誤。",
        "en": "(D) Compares if two numbers are equal; the check is to prevent division by zero errors.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是經典的 XOR 交換演算法。若 `a` 和 `b` 參考同一個記憶體位置（即別名），第一步 `a = a ^ b` 等同於 `a = a ^ a`，結果為 0，這會導致原始資料遺失，因此必須先檢查位址是否相同。",
      "en": "This is the classic XOR swap algorithm. If `a` and `b` refer to the same memory location (aliasing), the first step `a = a ^ b` becomes `a = a ^ a`, resulting in 0, which causes the loss of original data, so checking if addresses are the same is mandatory.",
      "wg": [
        {
          "t": "別名",
          "en": "aliasing",
          "ps": "N"
        },
        {
          "t": "原始資料",
          "en": "original data",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Bitwise AND, LSB, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "n = n & (n - 1);",
    "question": [
      {
        "t": "在二進位操作中，執行表達式 `n = n & (n - 1)` 會對整數 `n` 產生什麼效果？",
        "en": "In bitwise operations, what effect does executing the expression `n = n & (n - 1)` have on the integer `n`?",
        "wg": [
          {
            "t": "表達式",
            "en": "expression",
            "ps": "N"
          },
          {
            "t": "整數",
            "en": "integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 `n` 為正整數。",
        "en": "Assume `n` is a positive integer.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將 `n` 的最高有效位 (MSB) 設為 0。",
        "en": "(A) Sets the Most Significant Bit (MSB) of `n` to 0.",
        "wg": [
          {
            "t": "最高有效位",
            "en": "Most Significant Bit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將 `n` 的最低有效位 (LSB) 設為 0。",
        "en": "(B) Sets the Least Significant Bit (LSB) of `n` to 0.",
        "wg": [
          {
            "t": "最低有效位",
            "en": "Least Significant Bit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將 `n` 二進位表示中，最右邊為 1 的位元清除為 0。",
        "en": "(C) Clears the rightmost bit that is 1 in the binary representation of `n` to 0.",
        "wg": [
          {
            "t": "清除",
            "en": "clear",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 將 `n` 的所有位元反轉。",
        "en": "(D) Inverts all bits of `n`.",
        "wg": [
          {
            "t": "反轉",
            "en": "invert",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "操作 `n - 1` 會將最右邊的 1 變成 0，並將該位元右邊的所有 0 變成 1。將其與原始 `n` 進行 AND 運算，會保留最右邊 1 左側的所有位元，並清除最右邊的那個 1。",
      "en": "The operation `n - 1` flips the rightmost 1 to 0 and all 0s to its right to 1s. Performing an AND operation with the original `n` preserves all bits to the left of the rightmost 1 and clears that specific rightmost 1.",
      "wg": [
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Power of Two, Bitwise Check, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "boolean isPowerOfTwo(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}",
    "question": [
      {
        "t": "為什麼上述程式碼可以有效地判斷一個整數 `n` 是否為 2 的次方？",
        "en": "Why does the above code efficiently determine if an integer `n` is a power of two?",
        "wg": [
          {
            "t": "有效地",
            "en": "efficiently",
            "ps": "Adv"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2 的次方數在二進位中只有一個位元是 1，清除該位元後應為 0。",
        "en": "(A) Powers of two have only one bit set to 1 in binary; clearing that bit should result in 0.",
        "wg": [
          {
            "t": "位元",
            "en": "bit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 2 的次方數總是偶數，AND 運算可以檢查奇偶性。",
        "en": "(B) Powers of two are always even, and the AND operation checks for parity.",
        "wg": [
          {
            "t": "奇偶性",
            "en": "parity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) `n-1` 會產生負數，導致 AND 結果為 0。",
        "en": "(C) `n-1` produces a negative number, causing the AND result to be 0.",
        "wg": []
      },
      {
        "t": "(D) 這是編譯器的內建最佳化，與位元邏輯無關。",
        "en": "(D) This is a compiler built-in optimization and is unrelated to bitwise logic.",
        "wg": [
          {
            "t": "內建",
            "en": "built-in",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若 `n` 是 2 的次方（如 1, 2, 4, 8...），其二進位表示法中僅有一個位元為 1（例如 `1000`）。`n-1` 會將該位元變為 0 並將右側全變為 1（例如 `0111`）。兩者進行 AND 運算結果必為 0。",
      "en": "If `n` is a power of two (e.g., 1, 2, 4, 8...), its binary representation has exactly one bit set to 1 (e.g., `1000`). `n-1` turns that bit to 0 and all bits to the right to 1 (e.g., `0111`). The AND operation of the two must result in 0.",
      "wg": [
        {
          "t": "二進位表示法",
          "en": "binary representation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Two's Complement, Bitwise NOT, Signed Integers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int x = 10;\nint y = ~x;",
    "question": [
      {
        "t": "在一個使用二補數表示法的 32 位元有號整數系統中，變數 `y` 的十進位數值是多少？",
        "en": "In a 32-bit signed integer system using two's complement representation, what is the decimal value of variable `y`?",
        "wg": [
          {
            "t": "二補數",
            "en": "two's complement",
            "ps": "N"
          },
          {
            "t": "有號整數",
            "en": "signed integer",
            "ps": "N"
          },
          {
            "t": "十進位",
            "en": "decimal",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) -10",
        "en": "(A) -10",
        "wg": []
      },
      {
        "t": "(B) -11",
        "en": "(B) -11",
        "wg": []
      },
      {
        "t": "(C) 5",
        "en": "(C) 5",
        "wg": []
      },
      {
        "t": "(D) -9",
        "en": "(D) -9",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "位元反轉運算子 `~` 對數值 `x` 的作用遵循公式 `~x = -(x + 1)`。因此，`~10` 等於 `-(10 + 1)`，即 `-11`。這是二補數系統中定義負數的方式。",
      "en": "The bitwise NOT operator `~` acts on a value `x` following the formula `~x = -(x + 1)`. Therefore, `~10` equals `-(10 + 1)`, which is `-11`. This is how negative numbers are defined in the two's complement system.",
      "wg": [
        {
          "t": "位元反轉運算子",
          "en": "bitwise NOT operator",
          "ps": "N"
        },
        {
          "t": "遵循",
          "en": "follow",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "XOR, Associativity, Single Number",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int result = 0;\nfor (int num : nums) {\n    result ^= num;\n}",
    "question": [
      {
        "t": "給定一個整數陣列 `nums`，其中除了某個元素只出現一次外，其餘每個元素均出現兩次。",
        "en": "Given an integer array `nums` where every element appears twice except for one element which appears only once.",
        "wg": [
          {
            "t": "陣列",
            "en": "array",
            "ps": "N"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上述程式碼執行後，`result` 的值為何？",
        "en": "What is the value of `result` after the above code executes?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) 陣列中所有元素的總和。",
        "en": "(B) The sum of all elements in the array.",
        "wg": [
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 只出現一次的那個元素。",
        "en": "(C) The element that appears only once.",
        "wg": []
      },
      {
        "t": "(D) 陣列中最後一個元素。",
        "en": "(D) The last element in the array.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "利用 XOR 的特性：`A ^ A = 0` 且 `A ^ 0 = A`。由於 XOR 具有交換律與結合律，成對出現的數字會互相抵銷變成 0，最後只剩下那個單獨出現的數字。",
      "en": "Using the properties of XOR: `A ^ A = 0` and `A ^ 0 = A`. Since XOR is commutative and associative, numbers appearing in pairs will cancel each other out to 0, leaving only the single number.",
      "wg": [
        {
          "t": "交換律",
          "en": "commutative property",
          "ps": "N"
        },
        {
          "t": "結合律",
          "en": "associative property",
          "ps": "N"
        },
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        }
      ]
    }
  }
]