[
  {
    "no": "11",
    "level": "medium",
    "keywords": "XOR, Swap, In-place",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void swap(int &a, int &b) {\n    if (a != b) {\n        a = a ^ b;\n        b = a ^ b;\n        a = a ^ b;\n    }\n}",
    "question": [
      {
        "t": "在不使用額外暫存變數的情況下，上述程式碼利用 XOR 運算來交換兩個整數的值。",
        "en": "The code above uses XOR operations to swap the values of two integers without using an extra temporary variable.",
        "wg": [
          {
            "t": "暫存變數",
            "en": "temporary variable",
            "ps": "N"
          },
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問為什麼這種方法在某些嵌入式系統或低階優化中被視為有效，且相較於加減法交換有何優勢？",
        "en": "Why is this method considered effective in certain embedded systems or low-level optimizations, and what is its advantage over addition/subtraction swapping?",
        "wg": [
          {
            "t": "嵌入式系統",
            "en": "embedded systems",
            "ps": "N"
          },
          {
            "t": "低階優化",
            "en": "low-level optimizations",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) XOR 運算速度比記憶體存取慢，但可節省暫存器空間。",
        "en": "(A) XOR operations are slower than memory access but save register space.",
        "wg": []
      },
      {
        "t": "(B) XOR 交換法不會造成整數溢位 (Overflow)，而加減法交換可能會。",
        "en": "(B) The XOR swap method does not cause integer overflow, whereas addition/subtraction swapping might.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "integer overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) XOR 交換法可以同時處理浮點數與整數。",
        "en": "(C) The XOR swap method can handle both floating-point numbers and integers simultaneously.",
        "wg": []
      },
      {
        "t": "(D) 現代編譯器無法優化暫存變數，因此 XOR 法總是比較快。",
        "en": "(D) Modern compilers cannot optimize temporary variables, so the XOR method is always faster.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用加法交換 (a = a + b) 時，若 a + b 超過整數上限會發生溢位；XOR 是位元運算，不會有溢位問題。",
      "en": "Using addition swap (a = a + b) can cause overflow if a + b exceeds the integer limit; XOR is a bitwise operation and does not suffer from overflow issues.",
      "wg": [
        {
          "t": "上限",
          "en": "limit",
          "ps": "N"
        },
        {
          "t": "位元運算",
          "en": "bitwise operation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Power of 2, Bitwise AND, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isPowerOfTwo(int n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}",
    "question": [
      {
        "t": "判斷一個整數是否為 2 的冪 (Power of 2) 是常見的面試題。",
        "en": "Determining whether an integer is a power of 2 is a common interview question.",
        "wg": [
          {
            "t": "2 的冪",
            "en": "power of 2",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問運算式 `n & (n - 1)` 的核心幾何或位元意義是什麼？",
        "en": "What is the core geometric or bitwise meaning of the expression `n & (n - 1)`?",
        "wg": [
          {
            "t": "幾何",
            "en": "geometric",
            "ps": "Adj"
          },
          {
            "t": "核心意義",
            "en": "core meaning",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它會將 n 的二進位表示中，最低位元的 1 變成 0。",
        "en": "(A) It turns the lowest set bit (1) in the binary representation of n into 0.",
        "wg": [
          {
            "t": "最低位元",
            "en": "lowest bit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 它會將 n 的所有位元反轉。",
        "en": "(B) It inverts all bits of n.",
        "wg": []
      },
      {
        "t": "(C) 它會檢查 n 是否為奇數。",
        "en": "(C) It checks if n is an odd number.",
        "wg": []
      },
      {
        "t": "(D) 它會保留 n 的最高有效位元 (MSB) 並清除其餘位元。",
        "en": "(D) It keeps the Most Significant Bit (MSB) of n and clears the rest.",
        "wg": [
          {
            "t": "最高有效位元",
            "en": "Most Significant Bit",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若 n 是 2 的冪，其二進位僅有一個 1 (例如 1000)；n-1 則會將該位變 0 並將低位全變 1 (例如 0111)，兩者 AND 結果必為 0。",
      "en": "If n is a power of 2, its binary has only one '1' (e.g., 1000); n-1 turns that bit to 0 and all lower bits to 1 (e.g., 0111), so ANDing them results in 0.",
      "wg": [
        {
          "t": "二進位",
          "en": "binary",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "XOR, Array, Single Number",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int findSingle(int[] nums) {\n    int result = 0;\n    for (int i : nums) {\n        result ^= i;\n    }\n    return result;\n}",
    "question": [
      {
        "t": "給定一個非空整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現兩次。",
        "en": "Given a non-empty array of integers, every element appears twice except for one.",
        "wg": [
          {
            "t": "陣列",
            "en": "array",
            "ps": "N"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上述程式碼可以找出那個只出現一次的元素。",
        "en": "The code above can find that single one.",
        "wg": []
      },
      {
        "t": "這主要依賴於 XOR 運算的哪些數學性質？",
        "en": "Which mathematical properties of the XOR operation does this primarily rely on?",
        "wg": [
          {
            "t": "依賴",
            "en": "rely on",
            "ps": "V"
          },
          {
            "t": "性質",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 分配律與恆等律 (Distributive and Identity laws)。",
        "en": "(A) Distributive and Identity laws.",
        "wg": []
      },
      {
        "t": "(B) 交換律、結合律以及歸零律 (x ^ x = 0)。",
        "en": "(B) Commutative, Associative laws, and the Self-Inverse property (x ^ x = 0).",
        "wg": [
          {
            "t": "交換律",
            "en": "commutative law",
            "ps": "N"
          },
          {
            "t": "結合律",
            "en": "associative law",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 邏輯非 (NOT) 與 邏輯及 (AND) 的互補性。",
        "en": "(C) The complementarity of Logical NOT and Logical AND.",
        "wg": []
      },
      {
        "t": "(D) 二補數 (Two's Complement) 的表示法。",
        "en": "(D) Two's Complement representation.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "XOR 運算滿足交換律與結合律，因此運算順序不影響結果；且任意數與自己 XOR 為 0 (x ^ x = 0)，與 0 XOR 為自己 (x ^ 0 = x)，成對的數字會互相抵銷。",
      "en": "XOR satisfies commutative and associative laws, so order doesn't matter; any number XORed with itself is 0 (x ^ x = 0), and with 0 is itself (x ^ 0 = x), so paired numbers cancel out.",
      "wg": [
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Two's Complement, Lowbit, Isolation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "x & (-x)",
    "question": [
      {
        "t": "在二元索引樹 (Binary Indexed Tree / Fenwick Tree) 或位元操作技巧中，運算式 `x & (-x)` 經常被使用。",
        "en": "In Binary Indexed Trees (Fenwick Trees) or bit manipulation tricks, the expression `x & (-x)` is frequently used.",
        "wg": [
          {
            "t": "二元索引樹",
            "en": "Binary Indexed Tree",
            "ps": "N"
          },
          {
            "t": "經常",
            "en": "frequently",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "假設 x 為正整數，這個運算的結果代表什麼？",
        "en": "Assuming x is a positive integer, what does the result of this operation represent?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 取得 x 的二補數 (Two's Complement)。",
        "en": "(A) Get the Two's Complement of x.",
        "wg": []
      },
      {
        "t": "(B) 清除 x 最右邊的位元 1 (Turn off the rightmost 1-bit)。",
        "en": "(B) Clear the rightmost 1-bit of x.",
        "wg": [
          {
            "t": "清除",
            "en": "clear",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 隔離出 x 最右邊的位元 1 (Isolate the rightmost 1-bit)。",
        "en": "(C) Isolate the rightmost 1-bit of x.",
        "wg": [
          {
            "t": "隔離",
            "en": "isolate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 將 x 的所有位元設為 1。",
        "en": "(D) Set all bits of x to 1.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "電腦中使用二補數表示負數 (-x = ~x + 1)；當 x 與 -x 進行 AND 運算時，只有最低位的 1 會被保留，其餘位元皆為 0。",
      "en": "Computers use two's complement for negative numbers (-x = ~x + 1); when x is ANDed with -x, only the lowest set bit is preserved, and all other bits become 0.",
      "wg": [
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Hamming Weight, Bit Counting, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n & (n - 1);\n        count++;\n    }\n    return count;\n}",
    "question": [
      {
        "t": "這段程式碼實作了 Brian Kernighan 演算法來計算整數中位元為 1 的數量 (Hamming Weight)。",
        "en": "This code implements Brian Kernighan's algorithm to count the number of set bits (Hamming Weight) in an integer.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "數量",
            "en": "quantity/count",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於檢查每個位元的迴圈 (Loop through 32 bits)，此演算法的時間複雜度主要取決於什麼？",
        "en": "Compared to a loop that checks every bit (loop through 32 bits), what does the time complexity of this algorithm primarily depend on?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "取決於",
            "en": "depend on",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 整數的總位元數 (例如 32 或 64)。",
        "en": "(A) The total number of bits in the integer (e.g., 32 or 64).",
        "wg": []
      },
      {
        "t": "(B) 整數中位元為 1 的個數。",
        "en": "(B) The number of set bits (1s) in the integer.",
        "wg": [
          {
            "t": "個數",
            "en": "count",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 整數中位元為 0 的個數。",
        "en": "(C) The number of unset bits (0s) in the integer.",
        "wg": []
      },
      {
        "t": "(D) 該整數數值的大小 (Magnitude)。",
        "en": "(D) The magnitude of the integer value.",
        "wg": [
          {
            "t": "數值大小",
            "en": "magnitude",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為 `n = n & (n - 1)` 每次執行都會剛好消除一個最低位的 1，所以迴圈執行的次數等於位元為 1 的總數，而非總位元寬度。",
      "en": "Since `n = n & (n - 1)` eliminates exactly one lowest set bit in each iteration, the loop runs as many times as there are 1s, rather than the total bit width.",
      "wg": [
        {
          "t": "消除",
          "en": "eliminate",
          "ps": "V"
        },
        {
          "t": "迭代",
          "en": "iteration",
          "ps": "N"
        }
      ]
    }
  }
]