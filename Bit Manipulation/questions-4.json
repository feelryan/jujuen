[
  {
    "no": "16",
    "level": "medium",
    "keywords": "XOR, Array, Missing Number, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int missingNumber(int[] nums) {\n    int xor = 0, i = 0;\n    for (i = 0; i < nums.length; i++) {\n        xor = xor ^ i ^ nums[i];\n    }\n    return xor ^ i;\n}",
    "question": [
      {
        "t": "給定一個包含從 0 到 n 的 n 個不同數字的陣列，但其中缺少了一個數字。",
        "en": "Given an array containing n distinct numbers taken from 0 to n, but one number is missing.",
        "wg": [
          {
            "t": "不同",
            "en": "distinct",
            "ps": "Adj"
          },
          {
            "t": "缺少",
            "en": "missing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "上述程式碼使用了 XOR 運算來找出該缺失的數字。",
        "en": "The code above uses the XOR operation to find the missing number.",
        "wg": [
          {
            "t": "運算",
            "en": "operation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這個解法的主要原理是什麼？",
        "en": "What is the main principle behind this solution?",
        "wg": [
          {
            "t": "原理",
            "en": "principle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 利用 XOR 的交換律與結合律，相同的數字 XOR 後會歸零，剩下的即為缺失值。",
        "en": "(A) Utilizing the commutative and associative properties of XOR, identical numbers become zero after XOR, leaving the missing value.",
        "wg": [
          {
            "t": "交換律",
            "en": "commutative property",
            "ps": "N"
          },
          {
            "t": "結合律",
            "en": "associative property",
            "ps": "N"
          },
          {
            "t": "歸零",
            "en": "become zero",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 利用 XOR 運算來計算所有數字的總和，再減去陣列元素的總和。",
        "en": "(B) Using XOR operation to calculate the sum of all numbers, then subtracting the sum of array elements.",
        "wg": [
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 利用 AND 運算找出所有數字的共同位元。",
        "en": "(C) Using AND operation to find the common bits of all numbers.",
        "wg": []
      },
      {
        "t": "(D) 利用補數運算來反轉陣列索引。",
        "en": "(D) Using complement operation to reverse the array indices.",
        "wg": [
          {
            "t": "補數",
            "en": "complement",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "XOR 運算具有 `A ^ A = 0` 以及 `A ^ 0 = A` 的特性。將索引 `0..n` 與陣列中的數值全部進行 XOR，存在的數字會成對消除（變成 0），最終只會剩下那個沒有成對（即缺失）的數字。",
      "en": "The XOR operation has the properties `A ^ A = 0` and `A ^ 0 = A`. By XORing all indices `0..n` with all values in the array, existing numbers cancel each other out (becoming 0), leaving only the number that is not paired (the missing one).",
      "wg": [
        {
          "t": "消除",
          "en": "cancel out",
          "ps": "Phr"
        },
        {
          "t": "成對",
          "en": "paired",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "Power of 4, Bitwise Check, Mask",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isPowerOfFour(int n) {\n    return (n > 0) && ((n & (n - 1)) == 0) && ((n & 0x55555555) != 0);\n}",
    "question": [
      {
        "t": "我們想要判斷一個整數 n 是否為 4 的次方數。",
        "en": "We want to determine if an integer n is a power of 4.",
        "wg": [
          {
            "t": "次方數",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "程式碼中使用了三個條件判斷。",
        "en": "The code uses three conditions for the check.",
        "wg": []
      },
      {
        "t": "請問 `(n & 0x55555555) != 0` 這個條件的具體目的是什麼？",
        "en": "What is the specific purpose of the condition `(n & 0x55555555) != 0`?",
        "wg": [
          {
            "t": "具體",
            "en": "specific",
            "ps": "Adj"
          },
          {
            "t": "目的",
            "en": "purpose",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 確保 n 是正數。",
        "en": "(A) Ensure n is a positive number.",
        "wg": []
      },
      {
        "t": "(B) 確保 n 是 2 的次方數。",
        "en": "(B) Ensure n is a power of 2.",
        "wg": []
      },
      {
        "t": "(C) 排除掉那些是 2 的次方但不是 4 的次方的數（即 1 出現在奇數位置）。",
        "en": "(C) Exclude numbers that are powers of 2 but not powers of 4 (i.e., the 1 bit appears at an odd position).",
        "wg": [
          {
            "t": "排除",
            "en": "exclude",
            "ps": "V"
          },
          {
            "t": "奇數位置",
            "en": "odd position",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將 n 的所有位元反轉。",
        "en": "(D) Reverse all bits of n.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "4 的次方數在二進位表示中，唯一的 `1` 必定出現在偶數位置（如第 0, 2, 4 位）。`0x55555555` 的二進位是 `0101...`，用來保留偶數位的 `1`。如果 `n` 是 2 的次方但 `1` 在奇數位置（如 2, 8, 32），與該遮罩 AND 的結果會是 0。",
      "en": "In binary representation, a power of 4 must have its single `1` bit at an even position (e.g., bit 0, 2, 4). `0x55555555` is `0101...` in binary, which preserves bits at even positions. If `n` is a power of 2 but the `1` is at an odd position (e.g., 2, 8, 32), the result of ANDing with this mask will be 0.",
      "wg": [
        {
          "t": "二進位表示",
          "en": "binary representation",
          "ps": "N"
        },
        {
          "t": "偶數位置",
          "en": "even position",
          "ps": "N"
        },
        {
          "t": "遮罩",
          "en": "mask",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Bit Manipulation, Modulo, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int fastModulo(int n) {\n    return n & 7;\n}",
    "question": [
      {
        "t": "在高效能運算中，我們常希望用位元運算取代算術運算。",
        "en": "In high-performance computing, we often wish to replace arithmetic operations with bitwise operations.",
        "wg": [
          {
            "t": "高效能運算",
            "en": "high-performance computing",
            "ps": "N"
          },
          {
            "t": "取代",
            "en": "replace",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問上述程式碼 `n & 7` 等同於下列哪一個算術運算？",
        "en": "Which arithmetic operation is the code `n & 7` equivalent to?",
        "wg": [
          {
            "t": "等同於",
            "en": "equivalent to",
            "ps": "Phr"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) n % 7",
        "en": "(A) n % 7",
        "wg": []
      },
      {
        "t": "(B) n / 8",
        "en": "(B) n / 8",
        "wg": []
      },
      {
        "t": "(C) n % 8",
        "en": "(C) n % 8",
        "wg": []
      },
      {
        "t": "(D) n * 7",
        "en": "(D) n * 7",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "對於任何 2 的次方數 `k`，`n % k` 等同於 `n & (k - 1)`。因為 8 是 $2^3$，所以 `n % 8` 等同於 `n & 7`（二進位 0111），這會保留 n 的最後三位，即除以 8 的餘數。",
      "en": "For any power of 2 `k`, `n % k` is equivalent to `n & (k - 1)`. Since 8 is $2^3$, `n % 8` is equivalent to `n & 7` (binary 0111), which preserves the last three bits of n, representing the remainder when divided by 8.",
      "wg": [
        {
          "t": "餘數",
          "en": "remainder",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Bitwise Swap, Hex Mask, Odd Even Bits",
    "parentNo": null,
    "images": null,
    "codeSnippet": "uint32_t swapOddEvenBits(uint32_t x) {\n    return ((x & 0xAAAAAAAA) >> 1) | ((x & 0x55555555) << 1);\n}",
    "question": [
      {
        "t": "此函式的目的是交換 32 位元整數中，相鄰的奇數與偶數位置的位元。",
        "en": "The purpose of this function is to swap adjacent odd and even bits in a 32-bit integer.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          },
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "例如位元 1 與位元 0 交換，位元 3 與位元 2 交換。",
        "en": "For example, bit 1 is swapped with bit 0, and bit 3 is swapped with bit 2.",
        "wg": []
      },
      {
        "t": "關於這段程式碼的邏輯，下列敘述何者正確？",
        "en": "Regarding the logic of this code, which of the following statements is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `0xAAAAAAAA` 用於選取偶數位置的位元。",
        "en": "(A) `0xAAAAAAAA` is used to select bits at even positions.",
        "wg": [
          {
            "t": "選取",
            "en": "select",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) `0x55555555` 對應的二進位是 `1010...`。",
        "en": "(B) The binary representation of `0x55555555` is `1010...`.",
        "wg": []
      },
      {
        "t": "(C) `((x & 0xAAAAAAAA) >> 1)` 將奇數位的位元移至偶數位。",
        "en": "(C) `((x & 0xAAAAAAAA) >> 1)` moves bits from odd positions to even positions.",
        "wg": []
      },
      {
        "t": "(D) 此方法需要額外的暫存空間來儲存中間值。",
        "en": "(D) This method requires extra temporary space to store intermediate values.",
        "wg": [
          {
            "t": "暫存空間",
            "en": "temporary space",
            "ps": "N"
          },
          {
            "t": "中間值",
            "en": "intermediate value",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "`0xAAAAAAAA` (二進位 `1010...`) 遮罩選取奇數位置的位元，右移一位使其變為偶數位置；`0x55555555` (二進位 `0101...`) 選取偶數位置的位元，左移一位使其變為奇數位置。最後用 OR 結合兩者。",
      "en": "The mask `0xAAAAAAAA` (binary `1010...`) selects bits at odd positions, and shifting right by 1 moves them to even positions; `0x55555555` (binary `0101...`) selects bits at even positions, and shifting left by 1 moves them to odd positions. Finally, they are combined using OR.",
      "wg": [
        {
          "t": "結合",
          "en": "combine",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Average, Overflow, Bitwise Trick",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int getAverage(int x, int y) {\n    return (x & y) + ((x ^ y) >> 1);\n}",
    "question": [
      {
        "t": "計算兩個整數 x 與 y 的平均值時，直接使用 `(x + y) / 2` 可能會導致溢位。",
        "en": "When calculating the average of two integers x and y, using `(x + y) / 2` directly may cause an overflow.",
        "wg": [
          {
            "t": "平均值",
            "en": "average",
            "ps": "N"
          },
          {
            "t": "溢位",
            "en": "overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上述程式碼提供了一個安全的位元運算解法。",
        "en": "The code above provides a safe bitwise solution.",
        "wg": []
      },
      {
        "t": "請問 `(x & y)` 在此公式中代表什麼意義？",
        "en": "What is the significance of `(x & y)` in this formula?",
        "wg": [
          {
            "t": "意義",
            "en": "significance",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 代表 x 和 y 相加後的「不進位和」除以 2。",
        "en": "(A) Represents the \"sum without carry\" of x and y divided by 2.",
        "wg": [
          {
            "t": "不進位和",
            "en": "sum without carry",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 代表 x 和 y 相加過程中所產生的「進位」部分。",
        "en": "(B) Represents the \"carry\" part generated during the addition of x and y.",
        "wg": [
          {
            "t": "進位",
            "en": "carry",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 代表 x 和 y 的差值。",
        "en": "(C) Represents the difference between x and y.",
        "wg": [
          {
            "t": "差值",
            "en": "difference",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 代表 x 和 y 的最大公因數。",
        "en": "(D) Represents the greatest common divisor of x and y.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "加法可以分解為「不進位和」`(x ^ y)` 與「進位」`((x & y) << 1)`。平均值即為總和除以 2。進位部分除以 2 後變成 `(x & y)`，不進位和部分除以 2 變成 `(x ^ y) >> 1`。兩者相加即為平均值。",
      "en": "Addition can be decomposed into \"sum without carry\" `(x ^ y)` and \"carry\" `((x & y) << 1)`. The average is the sum divided by 2. The carry part divided by 2 becomes `(x & y)`, and the sum-without-carry part divided by 2 becomes `(x ^ y) >> 1`. Adding them together gives the average.",
      "wg": [
        {
          "t": "分解",
          "en": "decompose",
          "ps": "V"
        }
      ]
    }
  }
]