[
  {
    "no": "1",
    "level": "Easy",
    "keywords": "XOR, Bitwise Operation, Single Number",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int result = 0;\nint[] nums = {4, 1, 2, 1, 2};\nfor (int i : nums) {\n    result ^= i;\n}",
    "question": [
      {
        "t": "請分析上述程式碼片段，執行完畢後 `result` 的值為何？",
        "en": "Analyze the code snippet above. What is the value of `result` after execution?",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "執行",
            "en": "execution",
            "ps": "N"
          }
        ]
      },
      {
        "t": "此題目旨在測試您對 XOR (互斥或) 運算特性的理解。",
        "en": "This question aims to test your understanding of the properties of the XOR (exclusive OR) operation.",
        "wg": [
          {
            "t": "互斥或",
            "en": "exclusive OR",
            "ps": "N"
          },
          {
            "t": "特性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) 4",
        "en": "(B) 4",
        "wg": []
      },
      {
        "t": "(C) 6",
        "en": "(C) 6",
        "wg": []
      },
      {
        "t": "(D) 10",
        "en": "(D) 10",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "XOR 運算具有交換律與結合律，且 `x ^ x = 0` 以及 `x ^ 0 = x`。陣列中成對出現的數字 (1 和 2) 會互相抵銷變為 0，最後只剩下出現一次的數字 4。",
      "en": "The XOR operation is commutative and associative, with properties `x ^ x = 0` and `x ^ 0 = x`. The numbers appearing in pairs (1 and 2) in the array will cancel each other out to become 0, leaving only the number 4 which appears once.",
      "wg": [
        {
          "t": "交換律",
          "en": "commutative property",
          "ps": "N"
        },
        {
          "t": "結合律",
          "en": "associative property",
          "ps": "N"
        },
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "Medium",
    "keywords": "Power of Two, Bitwise AND, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "boolean isPowerOfTwo(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}",
    "question": [
      {
        "t": "上述函式的主要功能為何？",
        "en": "What is the primary function of the code above?",
        "wg": [
          {
            "t": "主要功能",
            "en": "primary function",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請考慮二進位表示法中 `n` 與 `n-1` 的關係。",
        "en": "Please consider the relationship between `n` and `n-1` in binary representation.",
        "wg": [
          {
            "t": "二進位表示法",
            "en": "binary representation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 判斷 n 是否為奇數。",
        "en": "(A) Determine if n is an odd number.",
        "wg": [
          {
            "t": "奇數",
            "en": "odd number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 判斷 n 是否為 2 的冪次方。",
        "en": "(B) Determine if n is a power of 2.",
        "wg": [
          {
            "t": "冪次方",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將 n 的最低位元設為 0。",
        "en": "(C) Set the lowest bit of n to 0.",
        "wg": [
          {
            "t": "最低位元",
            "en": "lowest bit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 計算 n 的二進位中 1 的個數。",
        "en": "(D) Count the number of 1s in the binary representation of n.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若 `n` 是 2 的冪次方，其二進位表示中只有一個位元是 1 (例如 1000)。`n-1` 會將該位元變為 0 並將右側所有位元變為 1 (例如 0111)。兩者進行 AND 運算結果必為 0。其他選項皆非此表達式的直接目的。",
      "en": "If `n` is a power of 2, its binary representation has exactly one bit set to 1 (e.g., 1000). `n-1` flips that bit to 0 and all bits to its right to 1 (e.g., 0111). The AND operation between them results in 0. Other options are not the direct purpose of this expression.",
      "wg": [
        {
          "t": "翻轉",
          "en": "flip",
          "ps": "V"
        },
        {
          "t": "表達式",
          "en": "expression",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "Medium",
    "keywords": "Two's Complement, Lowbit, LSB",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int x = 10; // Binary: 0000 1010\nint result = x & (-x);",
    "question": [
      {
        "t": "在二補數系統中，運算式 `x & (-x)` 的結果代表什麼意義？",
        "en": "In the Two's Complement system, what is the significance of the result of the expression `x & (-x)`?",
        "wg": [
          {
            "t": "二補數",
            "en": "Two's Complement",
            "ps": "N"
          },
          {
            "t": "運算式",
            "en": "expression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請根據提供的程式碼片段選出正確的 `result` 值及其幾何意義。",
        "en": "Please select the correct value of `result` and its geometric meaning based on the provided code snippet.",
        "wg": [
          {
            "t": "幾何意義",
            "en": "geometric meaning",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0，代表消除所有位元。",
        "en": "(A) 0, representing clearing all bits.",
        "wg": []
      },
      {
        "t": "(B) 2，代表取出最低位的 1 (Lowbit)。",
        "en": "(B) 2, representing extracting the lowest set bit (Lowbit).",
        "wg": [
          {
            "t": "取出",
            "en": "extract",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 8，代表取出最高位的 1。",
        "en": "(C) 8, representing extracting the highest set bit.",
        "wg": []
      },
      {
        "t": "(D) -10，代表取負值。",
        "en": "(D) -10, representing negation.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在二補數中，`-x` 等於 `~x + 1`。這會保留 `x` 最右邊的 1，並將其左邊的所有位元反轉。進行 AND 運算後，只有最右邊的 1 會被保留。10 (1010) 的 Lowbit 是 2 (0010)。",
      "en": "In Two's Complement, `-x` equals `~x + 1`. This preserves the rightmost 1 of `x` and inverts all bits to its left. After the AND operation, only the rightmost 1 remains. The Lowbit of 10 (1010) is 2 (0010).",
      "wg": [
        {
          "t": "反轉",
          "en": "invert",
          "ps": "V"
        },
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "Medium",
    "keywords": "Bitwise Shift, Arithmetic Shift, Logical Shift",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int a = -16;\nint result1 = a >> 2;\nint result2 = a >>> 2; // Assuming Java/JavaScript environment",
    "question": [
      {
        "t": "關於算術右移 (`>>`) 與邏輯右移 (`>>>`) 的區別，下列敘述何者正確？",
        "en": "Which of the following statements is correct regarding the difference between arithmetic right shift (`>>`) and logical right shift (`>>>`)?",
        "wg": [
          {
            "t": "算術右移",
            "en": "arithmetic right shift",
            "ps": "N"
          },
          {
            "t": "邏輯右移",
            "en": "logical right shift",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請思考符號位元 (Sign Bit) 在這兩種操作下的處理方式。",
        "en": "Please consider how the Sign Bit is handled in these two operations.",
        "wg": [
          {
            "t": "符號位元",
            "en": "Sign Bit",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 兩者皆會在左側補 0。",
        "en": "(A) Both fill the left side with 0s.",
        "wg": []
      },
      {
        "t": "(B) `>>` 會根據符號位元補值，而 `>>>` 恆補 0。",
        "en": "(B) `>>` fills based on the sign bit, while `>>>` always fills with 0.",
        "wg": [
          {
            "t": "恆",
            "en": "always",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) `>>` 恆補 0，而 `>>>` 會根據符號位元補值。",
        "en": "(C) `>>` always fills with 0, while `>>>` fills based on the sign bit.",
        "wg": []
      },
      {
        "t": "(D) 對於正數而言，兩者結果不同。",
        "en": "(D) For positive numbers, the results of the two are different.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "`>>` 是算術右移，為了保持數值的正負號，若原數為負，左側會補 1；`>>>` 是邏輯右移，不考慮符號，左側一律補 0。對於正數，兩者行為相同。",
      "en": "`>>` is the arithmetic right shift; to maintain the sign of the value, if the original number is negative, it fills the left with 1s. `>>>` is the logical right shift; it ignores the sign and always fills the left with 0s. For positive numbers, both behave the same.",
      "wg": [
        {
          "t": "保持",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "一律",
          "en": "in all cases",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "Medium",
    "keywords": "Bit Manipulation, Set Bit, Mask",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要將整數 `num` 的第 `i` 個位元 (從 0 開始計數) 設定為 1，且不影響其他位元，應使用下列哪一個運算式？",
        "en": "To set the `i`-th bit (0-indexed) of the integer `num` to 1 without affecting other bits, which of the following expressions should be used?",
        "wg": [
          {
            "t": "設定",
            "en": "set",
            "ps": "V"
          },
          {
            "t": "影響",
            "en": "affect",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `num & (1 << i)`",
        "en": "(A) `num & (1 << i)`",
        "wg": []
      },
      {
        "t": "(B) `num | (1 << i)`",
        "en": "(B) `num | (1 << i)`",
        "wg": []
      },
      {
        "t": "(C) `num ^ (1 << i)`",
        "en": "(C) `num ^ (1 << i)`",
        "wg": []
      },
      {
        "t": "(D) `num & ~(1 << i)`",
        "en": "(D) `num & ~(1 << i)`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "`1 << i` 會產生一個只有第 `i` 位是 1 的遮罩。使用 OR (`|`) 運算可以確保該位置變成 1，若原本就是 1 則保持不變，且其他位元不受影響。(A) 是檢查位元，(C) 是翻轉位元，(D) 是清除位元。",
      "en": "`1 << i` creates a mask with only the `i`-th bit set to 1. Using the OR (`|`) operation ensures that position becomes 1 (remaining 1 if it already was), without affecting other bits. (A) is for checking a bit, (C) is for toggling a bit, and (D) is for clearing a bit.",
      "wg": [
        {
          "t": "遮罩",
          "en": "mask",
          "ps": "N"
        },
        {
          "t": "清除",
          "en": "clear",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "easy",
    "keywords": "Power of Two, Bitwise AND, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isPowerOfTwo(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}",
    "question": [
      {
        "t": "請分析上述程式碼片段，",
        "en": "Please analyze the code snippet above,",
        "wg": []
      },
      {
        "t": "該函式利用位元運算來判斷整數 n 是否為 2 的次方。",
        "en": "which uses bitwise operations to determine if integer n is a power of two.",
        "wg": [
          {
            "t": "位元運算",
            "en": "bitwise operations",
            "ps": "N"
          },
          {
            "t": "2 的次方",
            "en": "power of two",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問表達式 `n & (n - 1)` 的主要數學或邏輯意義是什麼？",
        "en": "What is the primary mathematical or logical significance of the expression `n & (n - 1)`?",
        "wg": [
          {
            "t": "表達式",
            "en": "expression",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將 n 的二進位表示法中最左邊的 1 變為 0。",
        "en": "(A) Turns the leftmost '1' in the binary representation of n to '0'.",
        "wg": []
      },
      {
        "t": "(B) 將 n 的二進位表示法中最右邊的 1 變為 0。",
        "en": "(B) Turns the rightmost '1' in the binary representation of n to '0'.",
        "wg": [
          {
            "t": "最右邊",
            "en": "rightmost",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 將 n 的所有位元反轉。",
        "en": "(C) Inverts all bits of n.",
        "wg": [
          {
            "t": "反轉",
            "en": "invert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 檢查 n 是否為奇數。",
        "en": "(D) Checks if n is an odd number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若 n 為 2 的次方，其二進位表示法中僅有一個位元為 1。`n - 1` 會將該位元變為 0，並將其右側所有位元變為 1。因此 `n & (n - 1)` 會將 n 最低位的 1 清除。如果結果為 0，代表 n 原本只有一個 1，即為 2 的次方。",
      "en": "If n is a power of two, its binary representation has exactly one bit set to '1'. `n - 1` flips that bit to '0' and all bits to its right to '1'. Thus, `n & (n - 1)` clears the lowest set bit of n. If the result is 0, it implies n originally had only one '1', meaning it is a power of two.",
      "wg": [
        {
          "t": "二進位表示法",
          "en": "binary representation",
          "ps": "N"
        },
        {
          "t": "最低位",
          "en": "lowest bit / LSB",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Hamming Weight, Popcount, Algorithm Efficiency",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n & (n - 1);\n        count++;\n    }\n    return count;\n}",
    "question": [
      {
        "t": "在計算整數二進位中 '1' 的個數（漢明權重）時，",
        "en": "When counting the number of '1's in the binary representation of an integer (Hamming weight),",
        "wg": [
          {
            "t": "漢明權重",
            "en": "Hamming weight",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用上述 Brian Kernighan 演算法相較於單純逐位檢查 (Loop through 32 bits) 有什麼效能上的優勢？",
        "en": "what is the performance advantage of using Brian Kernighan's algorithm shown above compared to simply checking each bit (looping through 32 bits)?",
        "wg": [
          {
            "t": "逐位檢查",
            "en": "checking each bit",
            "ps": "V phrase"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它的時間複雜度總是 O(1)。",
        "en": "(A) Its time complexity is always O(1).",
        "wg": []
      },
      {
        "t": "(B) 迴圈執行的次數等於整數中 '1' 的個數，而非總位元數。",
        "en": "(B) The number of loop iterations equals the number of set bits ('1's) in the integer, rather than the total number of bits.",
        "wg": [
          {
            "t": "迴圈執行",
            "en": "loop iterations",
            "ps": "N"
          },
          {
            "t": "總位元數",
            "en": "total number of bits",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它不需要使用額外的記憶體空間。",
        "en": "(C) It does not require additional memory space.",
        "wg": []
      },
      {
        "t": "(D) 它可以處理負數，而逐位檢查則不行。",
        "en": "(D) It can handle negative numbers, whereas checking each bit cannot.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "此演算法利用 `n & (n - 1)` 每次消除最低位的一個 1。因此，迴圈只會執行 k 次（k 為 1 的總數），在稀疏位元（1 很少）的情況下，比遍歷所有 32 或 64 個位元更有效率。",
      "en": "This algorithm uses `n & (n - 1)` to remove the lowest set bit in each iteration. Therefore, the loop only runs k times (where k is the count of '1's), which is more efficient than iterating through all 32 or 64 bits, especially for sparse bits.",
      "wg": [
        {
          "t": "稀疏",
          "en": "sparse",
          "ps": "Adj"
        },
        {
          "t": "遍歷",
          "en": "iterate through",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "XOR, Single Number, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個非空整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現兩次。",
        "en": "Given a non-empty array of integers, every element appears twice except for one.",
        "wg": [
          {
            "t": "非空",
            "en": "non-empty",
            "ps": "Adj"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要在不使用額外記憶體（線性時間複雜度 O(n) 且 空間複雜度 O(1)）的情況下找出那個只出現一次的元素。",
        "en": "You need to find that single one without using extra memory (linear time complexity O(n) and space complexity O(1)).",
        "wg": [
          {
            "t": "線性時間複雜度",
            "en": "linear time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "應該使用哪種位元運算子最合適？",
        "en": "Which bitwise operator is most appropriate to use?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) AND (&)",
        "en": "(A) AND (&)",
        "wg": []
      },
      {
        "t": "(B) OR (|)",
        "en": "(B) OR (|)",
        "wg": []
      },
      {
        "t": "(C) XOR (^)",
        "en": "(C) XOR (^)",
        "wg": []
      },
      {
        "t": "(D) NOT (~)",
        "en": "(D) NOT (~)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "XOR 運算具有 `a ^ a = 0` 和 `a ^ 0 = a` 的特性。將陣列中所有數字進行 XOR 運算，成對出現的數字會互相抵銷變為 0，最終剩下的結果即為只出現一次的數字。",
      "en": "The XOR operation has the properties `a ^ a = 0` and `a ^ 0 = a`. XORing all numbers in the array causes the pairs to cancel each other out to 0, leaving only the number that appears once.",
      "wg": [
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        },
        {
          "t": "特性",
          "en": "property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Two's Complement, Lowbit, Binary Indexed Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int getLowbit(int x) {\n    return x & (-x);\n}",
    "question": [
      {
        "t": "在二補數系統中，表達式 `x & (-x)` 常用於 Binary Indexed Tree (Fenwick Tree) 等資料結構。",
        "en": "In the two's complement system, the expression `x & (-x)` is commonly used in data structures like Binary Indexed Tree (Fenwick Tree).",
        "wg": [
          {
            "t": "二補數",
            "en": "two's complement",
            "ps": "N"
          },
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若 x 的二進位值為 `0010 1100` (十進位 44)，請問 `x & (-x)` 的運算結果為何？",
        "en": "If the binary value of x is `0010 1100` (decimal 44), what is the result of `x & (-x)`?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `0000 0100` (十進位 4)",
        "en": "(A) `0000 0100` (decimal 4)",
        "wg": []
      },
      {
        "t": "(B) `0010 1000` (十進位 40)",
        "en": "(B) `0010 1000` (decimal 40)",
        "wg": []
      },
      {
        "t": "(C) `1101 0100` (十進位 -44)",
        "en": "(C) `1101 0100` (decimal -44)",
        "wg": []
      },
      {
        "t": "(D) `0000 1100` (十進位 12)",
        "en": "(D) `0000 1100` (decimal 12)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "`x & (-x)` 的作用是取出 x 最右邊的 1 (Lowbit)。-x 在二補數中等於 `~x + 1`。`0010 1100` 取反加一後變為 `1101 0100`。兩者進行 AND 運算：`0010 1100 & 1101 0100` 結果為 `0000 0100`。",
      "en": "`x & (-x)` isolates the rightmost '1' bit (Lowbit) of x. In two's complement, -x equals `~x + 1`. Inverting `0010 1100` and adding one gives `1101 0100`. Performing AND on both: `0010 1100 & 1101 0100` results in `0000 0100`.",
      "wg": [
        {
          "t": "取反",
          "en": "invert / negate",
          "ps": "V"
        },
        {
          "t": "取出",
          "en": "isolate / extract",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "easy",
    "keywords": "Bit Masking, Clear Bit, Shift Operations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若您想要將整數 `num` 的第 k 個位元（從 0 開始計數）設定為 0，且不影響其他位元。",
        "en": "If you want to set the k-th bit (0-indexed) of an integer `num` to 0 without affecting other bits.",
        "wg": [
          {
            "t": "設定為 0",
            "en": "set to 0 / clear",
            "ps": "V phrase"
          },
          {
            "t": "從 0 開始計數",
            "en": "0-indexed",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪一個操作是正確的？",
        "en": "Which of the following operations is correct?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `num | (1 << k)`",
        "en": "(A) `num | (1 << k)`",
        "wg": []
      },
      {
        "t": "(B) `num & ~(1 << k)`",
        "en": "(B) `num & ~(1 << k)`",
        "wg": []
      },
      {
        "t": "(C) `num ^ (1 << k)`",
        "en": "(C) `num ^ (1 << k)`",
        "wg": []
      },
      {
        "t": "(D) `num & (1 << k)`",
        "en": "(D) `num & (1 << k)`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "`1 << k` 會產生一個只有第 k 位是 1 的遮罩。取反 `~` 後，變成只有第 k 位是 0，其餘皆為 1。再與 `num` 進行 AND 運算，即可強制將第 k 位清除為 0，並保留其他位元不變。",
      "en": "`1 << k` creates a mask with only the k-th bit set to 1. Applying NOT `~` makes the k-th bit 0 and all others 1. Performing an AND operation with `num` forces the k-th bit to clear to 0 while preserving other bits.",
      "wg": [
        {
          "t": "遮罩",
          "en": "mask",
          "ps": "N"
        },
        {
          "t": "強制",
          "en": "force",
          "ps": "V"
        },
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "Medium",
    "keywords": "Bitwise AND, Algorithm, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n & (n - 1);\n        count++;\n    }\n    return count;\n}",
    "question": [
      {
        "t": "請分析上述程式碼片段。",
        "en": "Please analyze the code snippet above.",
        "wg": []
      },
      {
        "t": "此演算法用於計算整數中設定位元 (1) 的數量，",
        "en": "This algorithm is used to count the number of set bits (1s) in an integer,",
        "wg": [
          {
            "t": "設定位元",
            "en": "set bits",
            "ps": "N"
          },
          {
            "t": "整數",
            "en": "integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問其時間複雜度主要取決於什麼？",
        "en": "What does its time complexity primarily depend on?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "取決於",
            "en": "depend on",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是 O(32) 或 O(64)，取決於整數的總位元數。",
        "en": "(A) Always O(32) or O(64), depending on the total number of bits in the integer.",
        "wg": []
      },
      {
        "t": "(B) O(log n)，取決於數值的大小。",
        "en": "(B) O(log n), depending on the magnitude of the value.",
        "wg": [
          {
            "t": "數值",
            "en": "magnitude",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) O(k)，其中 k 是設定位元 (1) 的數量。",
        "en": "(C) O(k), where k is the number of set bits (1s).",
        "wg": []
      },
      {
        "t": "(D) O(1)，因為迴圈次數是固定的。",
        "en": "(D) O(1), because the number of loop iterations is fixed.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "運算式 `n = n & (n - 1)` 的作用是將整數 `n` 最右邊的一個 `1` 變成 `0`。因此，迴圈執行的次數等於該整數中 `1` 的總數 (k)，而非總位元數或數值大小。這比單純逐位檢查 (O(32)) 更有效率。",
      "en": "The expression `n = n & (n - 1)` turns off the rightmost `1` bit of the integer `n`. Therefore, the loop runs exactly as many times as there are `1`s (k) in the integer, not based on the total bit width or the value's magnitude. This is more efficient than checking every bit (O(32)).",
      "wg": [
        {
          "t": "最右邊",
          "en": "rightmost",
          "ps": "Adj"
        },
        {
          "t": "有效率",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "Easy",
    "keywords": "Two's Complement, Lowbit, Bitwise Operations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二進位操作中，我們經常需要取出一個整數 `x` 最右側的設定位元 (Rightmost Set Bit)，",
        "en": "In binary operations, we often need to isolate the rightmost set bit of an integer `x`,",
        "wg": [
          {
            "t": "取出",
            "en": "isolate",
            "ps": "V"
          },
          {
            "t": "最右側",
            "en": "rightmost",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "例如將 `0010 1100` 轉換為 `0000 0100`。",
        "en": "For example, converting `0010 1100` to `0000 0100`.",
        "wg": []
      },
      {
        "t": "請問下列哪個運算式可以達成此目的？",
        "en": "Which of the following expressions can achieve this?",
        "wg": [
          {
            "t": "運算式",
            "en": "expression",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) x & (x - 1)",
        "en": "(A) x & (x - 1)",
        "wg": []
      },
      {
        "t": "(B) x | (x + 1)",
        "en": "(B) x | (x + 1)",
        "wg": []
      },
      {
        "t": "(C) x & (-x)",
        "en": "(C) x & (-x)",
        "wg": []
      },
      {
        "t": "(D) x ^ (x >> 1)",
        "en": "(D) x ^ (x >> 1)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在二補數系統中，`-x` 等同於 `~x + 1`。這會反轉 `x` 的所有位元並加 1，導致最右側的 `1` 及其右邊的 `0` 保持不變，而該位元左側的所有位元都會被反轉。將其與原數 `x` 進行 AND 運算，僅會保留最右側的 `1`。",
      "en": "In the two's complement system, `-x` is equivalent to `~x + 1`. This inverts all bits of `x` and adds 1, causing the rightmost `1` and any `0`s to its right to remain unchanged, while all bits to the left are inverted. Performing an AND operation with the original `x` isolates only that rightmost `1`.",
      "wg": [
        {
          "t": "二補數",
          "en": "two's complement",
          "ps": "N"
        },
        {
          "t": "反轉",
          "en": "invert",
          "ps": "V"
        },
        {
          "t": "保留",
          "en": "retain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "Easy",
    "keywords": "XOR, Array, Missing Number",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個包含 `0` 到 `n` 的陣列，其中缺少了一個數字。",
        "en": "Given an array containing numbers from `0` to `n`, where one number is missing.",
        "wg": [
          {
            "t": "缺少",
            "en": "missing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "雖然可以使用數學求和公式 `n*(n+1)/2` 來找出缺失數，但在 `n` 非常大時可能會發生整數溢位。",
        "en": "Although the mathematical summation formula `n*(n+1)/2` can be used to find the missing number, integer overflow may occur when `n` is very large.",
        "wg": [
          {
            "t": "求和公式",
            "en": "summation formula",
            "ps": "N"
          },
          {
            "t": "整數溢位",
            "en": "integer overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問使用 XOR 運算解決此問題的主要優勢是什麼？",
        "en": "What is the main advantage of using the XOR operation to solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) XOR 運算的速度比加法快兩倍。",
        "en": "(A) XOR operation is twice as fast as addition.",
        "wg": []
      },
      {
        "t": "(B) XOR 運算不會產生進位，因此不會有溢位風險，且滿足 `A ^ A = 0` 的特性。",
        "en": "(B) XOR operation does not generate carries, so there is no risk of overflow, and it satisfies the property `A ^ A = 0`.",
        "wg": [
          {
            "t": "進位",
            "en": "carry",
            "ps": "N"
          },
          {
            "t": "風險",
            "en": "risk",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) XOR 可以自動排序陣列，方便查找。",
        "en": "(C) XOR can automatically sort the array for easier lookup.",
        "wg": []
      },
      {
        "t": "(D) XOR 運算可以同時找出兩個缺失的數字。",
        "en": "(D) XOR operation can find two missing numbers simultaneously.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "利用 `x ^ x = 0` 和 `x ^ 0 = x` 的特性，將陣列中所有數字與 `0` 到 `n` 的所有索引進行 XOR，重複出現的數字會互相抵銷，最終剩下的就是缺失的數字。此過程完全不需要擔心數值過大導致溢位。",
      "en": "Leveraging the properties `x ^ x = 0` and `x ^ 0 = x`, XORing all numbers in the array with all indices from `0` to `n` causes duplicate numbers to cancel each other out, leaving only the missing number. This process completely avoids the risk of overflow caused by large values.",
      "wg": [
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        },
        {
          "t": "特性",
          "en": "property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "Easy",
    "keywords": "Power of Two, Bitwise Check, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "boolean check(int n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}",
    "question": [
      {
        "t": "請檢視上述函式 `check`。",
        "en": "Please examine the function `check` above.",
        "wg": [
          {
            "t": "檢視",
            "en": "examine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "該函式的回傳值為 `true` 代表輸入整數 `n` 具備什麼特性？",
        "en": "If the function returns `true`, what property does the input integer `n` possess?",
        "wg": [
          {
            "t": "回傳值",
            "en": "return value",
            "ps": "N"
          },
          {
            "t": "具備",
            "en": "possess",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) n 是奇數。",
        "en": "(A) n is an odd number.",
        "wg": [
          {
            "t": "奇數",
            "en": "odd number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) n 是 2 的次方 (Power of 2)。",
        "en": "(B) n is a power of 2.",
        "wg": [
          {
            "t": "次方",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) n 是負數。",
        "en": "(C) n is a negative number.",
        "wg": []
      },
      {
        "t": "(D) n 的二進位表示中包含多個 1。",
        "en": "(D) The binary representation of n contains multiple 1s.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "2 的次方數在二進位中只有一個位元是 `1` (例如 1, 2, 4, 8 -> 001, 010, 100...)。`n & (n-1)` 會移除最低位的 `1`。如果移除後結果為 `0`，表示該數原本只有一個 `1`，即為 2 的次方。",
      "en": "Numbers that are powers of 2 have exactly one bit set to `1` in binary (e.g., 1, 2, 4, 8 -> 001, 010, 100...). `n & (n-1)` removes the lowest set bit. If the result is `0` after this operation, it implies the number originally had only one `1`, meaning it is a power of 2.",
      "wg": [
        {
          "t": "最低位",
          "en": "lowest bit",
          "ps": "N"
        },
        {
          "t": "原本",
          "en": "originally",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "Medium",
    "keywords": "Bit Mask, Bit Shift, Bit Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int swapBits(int x) {\n    return ((x & 0xAAAAAAAA) >>> 1) | ((x & 0x55555555) << 1);\n}",
    "question": [
      {
        "t": "上述程式碼使用了兩個十六進位遮罩：`0xAAAAAAAA` 和 `0x55555555`。",
        "en": "The code above uses two hexadecimal masks: `0xAAAAAAAA` and `0x55555555`.",
        "wg": [
          {
            "t": "遮罩",
            "en": "mask",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問此函式的主要功能是什麼？",
        "en": "What is the main function of this code?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 交換整數的高 16 位元與低 16 位元。",
        "en": "(A) Swap the high 16 bits and low 16 bits of the integer.",
        "wg": []
      },
      {
        "t": "(B) 反轉整數的所有位元 (Bit Reversal)。",
        "en": "(B) Reverse all bits of the integer (Bit Reversal).",
        "wg": []
      },
      {
        "t": "(C) 交換整數中相鄰的奇數與偶數位置的位元。",
        "en": "(C) Swap adjacent odd and even bits in the integer.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          },
          {
            "t": "偶數",
            "en": "even",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 將整數的所有位元設為 1。",
        "en": "(D) Set all bits of the integer to 1.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "`0xAA...` (1010...) 是用來選取偶數位置的位元，`0x55...` (0101...) 是用來選取奇數位置的位元。程式碼將偶數位元右移一位，奇數位元左移一位，然後使用 OR 結合，達成交換相鄰奇偶位元的效果。",
      "en": "`0xAA...` (1010...) is used to select bits at even positions, and `0x55...` (0101...) is used to select bits at odd positions. The code shifts even bits right by one and odd bits left by one, then combines them using OR, effectively swapping adjacent odd and even bits.",
      "wg": [
        {
          "t": "選取",
          "en": "select",
          "ps": "V"
        },
        {
          "t": "結合",
          "en": "combine",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "XOR, Array, Missing Number, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [3, 0, 1]\nOutput: 2\n\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8",
    "question": [
      {
        "t": "給定一個包含 0 到 n 的陣列，其中缺少了一個數字，",
        "en": "Given an array containing numbers from 0 to n, where one number is missing,",
        "wg": [
          {
            "t": "缺少",
            "en": "missing",
            "ps": "Adj"
          },
          {
            "t": "陣列",
            "en": "array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出一個時間複雜度為 O(n) 且空間複雜度為 O(1) 的最佳解法來找出該缺失數字。",
        "en": "Please select the optimal solution with O(n) time complexity and O(1) space complexity to find the missing number.",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將陣列排序後，線性掃描找出不連續的數字。",
        "en": "(A) Sort the array, then linearly scan to find the non-consecutive number.",
        "wg": [
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          },
          {
            "t": "線性掃描",
            "en": "linearly scan",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用雜湊集合 (HashSet) 儲存所有數字，再檢查 0 到 n 是否存在。",
        "en": "(B) Use a HashSet to store all numbers, then check if 0 to n exist.",
        "wg": [
          {
            "t": "雜湊集合",
            "en": "HashSet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將陣列中所有數字與 0 到 n 的所有索引值進行 XOR 運算。",
        "en": "(C) XOR all numbers in the array with all index values from 0 to n.",
        "wg": [
          {
            "t": "索引值",
            "en": "index values",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用雙重迴圈比對每個數字是否存在。",
        "en": "(D) Use a double loop to check if each number exists.",
        "wg": [
          {
            "t": "雙重迴圈",
            "en": "double loop",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "利用 XOR 的特性 `A ^ A = 0`，將陣列中的所有元素與完整序列 0 到 n 進行 XOR，重複出現的數字會抵銷，最終剩下的就是缺失的數字。此方法不需要額外空間且只需遍歷一次。",
      "en": "Using the XOR property `A ^ A = 0`, XORing all elements in the array with the complete sequence 0 to n will cancel out the duplicate numbers, leaving only the missing number. This method requires no extra space and only one pass.",
      "wg": [
        {
          "t": "抵銷",
          "en": "cancel out",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Bit Reversal, Low-level, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "uint32_t reverseBits(uint32_t n) {\n    uint32_t result = 0;\n    // ... implementation ...\n    return result;\n}",
    "question": [
      {
        "t": "您需要實作一個函式來顛倒 32 位元無號整數的二進位位元（例如：輸入 `00...011`，輸出 `110...00`）。",
        "en": "You need to implement a function to reverse the binary bits of a 32-bit unsigned integer (e.g., input `00...011`, output `110...00`).",
        "wg": [
          {
            "t": "顛倒",
            "en": "reverse",
            "ps": "V"
          },
          {
            "t": "無號整數",
            "en": "unsigned integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種邏輯是正確且常見的實作方式？",
        "en": "Which of the following logic is a correct and common implementation approach?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將整數轉換為字串，反轉字串後再轉回整數。",
        "en": "(A) Convert the integer to a string, reverse the string, and convert it back to an integer.",
        "wg": [
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 迴圈執行 32 次，每次取出輸入數的最低位元 (LSB)，加到結果變數並左移結果變數。",
        "en": "(B) Loop 32 times, extracting the Least Significant Bit (LSB) of the input each time, adding it to the result variable, and left-shifting the result.",
        "wg": [
          {
            "t": "最低位元",
            "en": "Least Significant Bit",
            "ps": "N"
          },
          {
            "t": "左移",
            "en": "left-shifting",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用 `n & (n-1)` 消除最低位的 1，直到數值為 0。",
        "en": "(C) Use `n & (n-1)` to remove the lowest set bit until the value becomes 0.",
        "wg": [
          {
            "t": "消除",
            "en": "remove",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 直接將數值乘以 -1。",
        "en": "(D) Multiply the value directly by -1.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "反轉位元的標準做法是遍歷所有 32 個位元，透過 `(n & 1)` 取得最低位，將其加到 `result`（通常先將 `result` 左移一位），然後將 `n` 右移一位。選項 (A) 效率極差且不適合低階操作。",
      "en": "The standard approach to reverse bits is to iterate through all 32 bits, get the LSB using `(n & 1)`, add it to `result` (usually by left-shifting `result` first), and then right-shift `n`. Option (A) is extremely inefficient and unsuitable for low-level operations.",
      "wg": [
        {
          "t": "標準做法",
          "en": "standard approach",
          "ps": "N"
        },
        {
          "t": "低階操作",
          "en": "low-level operations",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Bit Counting, Finite State Machine, Modulo Arithmetic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [2, 2, 3, 2]\nOutput: 3\n// Every element appears three times except for one.",
    "question": [
      {
        "t": "給定一個非空整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現三次。",
        "en": "Given a non-empty array of integers, every element appears three times except for one, which appears exactly once.",
        "wg": [
          {
            "t": "除了",
            "en": "except for",
            "ps": "Prep"
          },
          {
            "t": "出現",
            "en": "appear",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要找出那個只出現一次的元素，且不使用額外記憶體，下列哪個核心概念是正確的？",
        "en": "To find that single element without using extra memory, which of the following core concepts is correct?",
        "wg": [
          {
            "t": "核心概念",
            "en": "core concept",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將所有數字進行 XOR 運算。",
        "en": "(A) XOR all the numbers together.",
        "wg": []
      },
      {
        "t": "(B) 統計所有數字在每個位元位置（0-31）上 1 出現的次數，並對 3 取餘數。",
        "en": "(B) Count the occurrences of 1s at each bit position (0-31) for all numbers and take the modulo 3.",
        "wg": [
          {
            "t": "統計",
            "en": "count",
            "ps": "V"
          },
          {
            "t": "取餘數",
            "en": "take the modulo",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用快速排序法 (Quicksort) 排序後檢查相鄰元素。",
        "en": "(C) Sort using Quicksort and check adjacent elements.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 將所有數字相加，減去去重後數字和的 3 倍。",
        "en": "(D) Sum all numbers and subtract 3 times the sum of the unique numbers.",
        "wg": [
          {
            "t": "去重",
            "en": "deduplicated",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為其他數字都出現三次，所以在任何位元位置上，1 的總數如果是 3 的倍數，代表目標數字在該位元是 0；如果餘數是 1，代表目標數字在該位元是 1。選項 (A) 僅適用於出現兩次的情況。",
      "en": "Since other numbers appear three times, the total count of 1s at any bit position should be a multiple of 3 if the target number has a 0 at that bit; if the remainder is 1, the target number has a 1 there. Option (A) only works when duplicates appear twice.",
      "wg": [
        {
          "t": "倍數",
          "en": "multiple",
          "ps": "N"
        },
        {
          "t": "餘數",
          "en": "remainder",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Power of 4, Bit Mask, Logical AND",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isPowerOfFour(int n) {\n    return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;\n}",
    "question": [
      {
        "t": "在不使用迴圈或遞迴的情況下，判斷一個整數 n 是否為 4 的次方。",
        "en": "Determine if an integer n is a power of 4 without using loops or recursion.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          },
          {
            "t": "次方",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請分析程式碼片段中 `(n & 0x55555555) != 0` 的用途為何？",
        "en": "Please analyze the purpose of `(n & 0x55555555) != 0` in the code snippet.",
        "wg": [
          {
            "t": "用途",
            "en": "purpose",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 確保該數字是 2 的次方。",
        "en": "(A) Ensure the number is a power of 2.",
        "wg": []
      },
      {
        "t": "(B) 確保該數字是正數。",
        "en": "(B) Ensure the number is positive.",
        "wg": []
      },
      {
        "t": "(C) 確保唯一的 1 位元位於偶數索引位置（如第 0, 2, 4 位）。",
        "en": "(C) Ensure the single set bit is at an even index position (e.g., 0th, 2nd, 4th bit).",
        "wg": [
          {
            "t": "偶數",
            "en": "even",
            "ps": "Adj"
          },
          {
            "t": "索引位置",
            "en": "index position",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 確保該數字大於 `0x55555555`。",
        "en": "(D) Ensure the number is greater than `0x55555555`.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "4 的次方特性是：它是 2 的次方（只有一個位元是 1），且該位元必須位於偶數位置（$4^0=1, 4^1=100_2, 4^2=10000_2$）。遮罩 `0x55555555` 的二進位是 `...010101`，用來檢查 1 是否落在這些位置上。",
      "en": "The property of a power of 4 is: it is a power of 2 (only one bit is 1), and that bit must be at an even position ($4^0=1, 4^1=100_2, 4^2=10000_2$). The mask `0x55555555` (binary `...010101`) is used to check if the 1 falls in these positions.",
      "wg": [
        {
          "t": "遮罩",
          "en": "mask",
          "ps": "N"
        },
        {
          "t": "特性",
          "en": "property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Bitwise AND, Range, Common Prefix",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: left = 5, right = 7\nOutput: 4\n// 5 (101), 6 (110), 7 (111) -> 101 & 110 & 111 = 100 (4)",
    "question": [
      {
        "t": "給定兩個整數 `left` 和 `right`，代表區間 `[left, right]`。",
        "en": "Given two integers `left` and `right`, representing the range `[left, right]`.",
        "wg": [
          {
            "t": "區間",
            "en": "range",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要計算此區間內所有數字的「按位與」(Bitwise AND) 結果，最高效的思路是什麼？",
        "en": "To calculate the Bitwise AND result of all numbers in this range, what is the most efficient approach?",
        "wg": [
          {
            "t": "按位與",
            "en": "Bitwise AND",
            "ps": "N"
          },
          {
            "t": "最高效",
            "en": "most efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用迴圈從 `left` 到 `right` 逐一進行 AND 運算。",
        "en": "(A) Use a loop to perform AND operation from `left` to `right` one by one.",
        "wg": [
          {
            "t": "逐一",
            "en": "one by one",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 找出 `left` 和 `right` 二進位表示法的「公共前綴」(Common Prefix)，其餘補 0。",
        "en": "(B) Find the \"Common Prefix\" of the binary representations of `left` and `right`, and pad the rest with 0s.",
        "wg": [
          {
            "t": "公共前綴",
            "en": "Common Prefix",
            "ps": "N"
          },
          {
            "t": "補 0",
            "en": "pad with 0s",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 計算 `left & right` 即可。",
        "en": "(C) Simply calculate `left & right`.",
        "wg": []
      },
      {
        "t": "(D) 結果必定為 0，除非 `left == right`。",
        "en": "(D) The result is always 0, unless `left == right`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在連續數字範圍內，低位元會不斷變化（0 和 1 交替），導致 AND 運算後變為 0。只有 `left` 和 `right` 相同的高位元（公共前綴）會被保留下來。我們可以透過不斷右移兩數直到相等來找到前綴。",
      "en": "In a range of consecutive numbers, the lower bits change continuously (alternating between 0 and 1), resulting in 0 after AND operations. Only the identical high-order bits (common prefix) of `left` and `right` are preserved. We can find the prefix by right-shifting both numbers until they are equal.",
      "wg": [
        {
          "t": "連續數字",
          "en": "consecutive numbers",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "preserve",
          "ps": "V"
        }
      ]
    }
  }
]