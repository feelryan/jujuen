[
  {
    "no": "11",
    "level": "medium",
    "keywords": "N-Queens, Optimization, Space-Time Trade-off, Constraints",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決 N-Queens（N 皇后）問題時，傳統的做法是在放置每個皇后時，遍歷棋盤檢查是否衝突，這會導致檢查步驟的時間複雜度為 O(N)。",
        "en": "When solving the N-Queens problem, the traditional approach involves iterating through the board to check for conflicts when placing each queen, resulting in an O(N) time complexity for the check step.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterating",
            "ps": "V"
          },
          {
            "t": "衝突",
            "en": "conflicts",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了優化回溯演算法的效能，我們可以使用「空間換取時間」的策略。",
        "en": "To optimize the performance of the backtracking algorithm, we can use a 'space-time trade-off' strategy.",
        "wg": [
          {
            "t": "空間換取時間",
            "en": "space-time trade-off",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一種資料結構設計可以將檢查衝突的時間複雜度降低至 O(1)？",
        "en": "Which of the following data structure designs can reduce the time complexity of checking conflicts to O(1)?",
        "wg": [
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用三個布林陣列（或雜湊集）分別記錄「列」、「主對角線」與「副對角線」的佔用情況。",
        "en": "(A) Use three boolean arrays (or hash sets) to record the occupancy of 'columns', 'main diagonals', and 'anti-diagonals' respectively.",
        "wg": [
          {
            "t": "主對角線",
            "en": "main diagonals",
            "ps": "N"
          },
          {
            "t": "副對角線",
            "en": "anti-diagonals",
            "ps": "N"
          },
          {
            "t": "佔用情況",
            "en": "occupancy",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 在遞迴每一層時，對整個棋盤進行快速排序 (Quick Sort) 以確認位置。",
        "en": "(B) Perform Quick Sort on the entire board at each level of recursion to verify positions.",
        "wg": []
      },
      {
        "t": "(C) 使用二元搜尋樹 (BST) 來儲存已放置皇后的座標。",
        "en": "(C) Use a Binary Search Tree (BST) to store the coordinates of placed queens.",
        "wg": []
      },
      {
        "t": "(D) 僅使用一個整數變數來儲存所有皇后的位置總和。",
        "en": "(D) Use only a single integer variable to store the sum of all queens' positions.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "透過數學特性，同一主對角線上的元素滿足 `row - col` 為定值，副對角線滿足 `row + col` 為定值。使用陣列索引直接存取這些狀態，可將檢查時間降至 O(1)。",
      "en": "Based on mathematical properties, elements on the same main diagonal satisfy `row - col` = constant, and anti-diagonals satisfy `row + col` = constant. Accessing these states directly via array indices reduces the check time to O(1).",
      "wg": [
        {
          "t": "定值",
          "en": "constant value",
          "ps": "N"
        },
        {
          "t": "存取",
          "en": "access",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Permutations, Duplicates, Pruning, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 1, 2]\nTarget: Unique Permutations",
    "question": [
      {
        "t": "給定一個包含重複數字的序列（例如 `[1, 1, 2]`），您需要回傳所有不重複的全排列。",
        "en": "Given a sequence containing duplicate numbers (e.g., `[1, 1, 2]`), you need to return all unique permutations.",
        "wg": [
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "N"
          },
          {
            "t": "序列",
            "en": "sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了避免產生重複的結果並提高效率，通常會先對陣列進行排序。",
        "en": "To avoid generating duplicate results and improve efficiency, the array is usually sorted first.",
        "wg": [
          {
            "t": "排序",
            "en": "sorted",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問在回溯過程中，應該加入什麼樣的「剪枝」條件來跳過重複的元素？",
        "en": "What 'pruning' condition should be added during the backtracking process to skip duplicate elements?",
        "wg": [
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          },
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) if (i > 0 && nums[i] == nums[i-1]) continue;",
        "en": "(A) if (i > 0 && nums[i] == nums[i-1]) continue;",
        "wg": []
      },
      {
        "t": "(B) if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;",
        "en": "(B) if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;",
        "wg": []
      },
      {
        "t": "(C) if (nums[i] % 2 == 0) continue;",
        "en": "(C) if (nums[i] % 2 == 0) continue;",
        "wg": []
      },
      {
        "t": "(D) if (used[i] == true) break;",
        "en": "(D) if (used[i] == true) break;",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `nums[i] == nums[i-1]` 且 `!used[i-1]` 時，表示前一個相同的數字在當前層級尚未被使用（或是剛被回溯撤銷），這意味著我們正在嘗試以相同的數字作為當前位置的開頭，這會導致重複，因此需要剪枝。",
      "en": "When `nums[i] == nums[i-1]` and `!used[i-1]`, it indicates that the previous identical number has not been used in the current level (or was just backtracked). This means we are attempting to start the current position with the same number, which leads to duplicates, so pruning is required.",
      "wg": [
        {
          "t": "撤銷",
          "en": "undone/backtracked",
          "ps": "V"
        },
        {
          "t": "層級",
          "en": "level",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Time Complexity, Subsets, Permutations, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，分析回溯演算法的時間複雜度至關重要。",
        "en": "In interviews, analyzing the time complexity of backtracking algorithms is crucial.",
        "wg": [
          {
            "t": "至關重要",
            "en": "crucial",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "假設輸入陣列長度為 N 且元素不重複，請比較生成「所有子集 (Subsets)」與生成「所有排列 (Permutations)」的最壞情況時間複雜度。",
        "en": "Assuming the input array length is N with unique elements, compare the worst-case time complexity of generating 'all subsets' versus generating 'all permutations'.",
        "wg": [
          {
            "t": "子集",
            "en": "subsets",
            "ps": "N"
          },
          {
            "t": "最壞情況",
            "en": "worst-case",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 子集：O(N!)，排列：O(2^N)",
        "en": "(A) Subsets: O(N!), Permutations: O(2^N)",
        "wg": []
      },
      {
        "t": "(B) 子集：O(N*2^N)，排列：O(N*N!)",
        "en": "(B) Subsets: O(N*2^N), Permutations: O(N*N!)",
        "wg": []
      },
      {
        "t": "(C) 兩者皆為 O(2^N)",
        "en": "(C) Both are O(2^N)",
        "wg": []
      },
      {
        "t": "(D) 兩者皆為 O(N^N)",
        "en": "(D) Both are O(N^N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "子集問題的解空間大小為 2^N，每個解需 O(N) 時間複製，故為 O(N*2^N)；排列問題的解空間大小為 N!，故為 O(N*N!)。排列的增長速度遠快於子集。",
      "en": "The solution space size for subsets is 2^N, and copying each solution takes O(N), resulting in O(N*2^N); for permutations, the solution space size is N!, resulting in O(N*N!). Permutations grow much faster than subsets.",
      "wg": [
        {
          "t": "解空間",
          "en": "solution space",
          "ps": "N"
        },
        {
          "t": "增長速度",
          "en": "growth rate",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "State Restoration, Mutable Objects, Bug Finding",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(List<Integer> path, int[] nums) {\n    if (path.size() == nums.length) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    for (int num : nums) {\n        if (path.contains(num)) continue;\n        path.add(num);\n        backtrack(path, nums);\n        // Missing: path.remove(path.size() - 1);\n    }\n}",
    "question": [
      {
        "t": "觀察上方的 Java 程式碼片段，這是一個嘗試生成全排列的函式。",
        "en": "Observe the Java code snippet above; it is a function attempting to generate permutations.",
        "wg": []
      },
      {
        "t": "程式碼中缺少了遞迴返回後的「狀態重置」（Backtracking step/Undo）步驟。",
        "en": "The code is missing the 'state restoration' (Backtracking step/Undo) step after returning from recursion.",
        "wg": [
          {
            "t": "狀態重置",
            "en": "state restoration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這會導致什麼樣的執行結果？",
        "en": "What execution result will this lead to?",
        "wg": [
          {
            "t": "執行結果",
            "en": "execution result",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 程式會正常運作，因為 Java 的 List 是傳值 (Pass by Value)。",
        "en": "(A) The program will work correctly because Java Lists are Pass by Value.",
        "wg": [
          {
            "t": "傳值",
            "en": "Pass by Value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 結果列表 `res` 會是空的，因為沒有正確加入元素。",
        "en": "(B) The result list `res` will be empty because elements were not added correctly.",
        "wg": []
      },
      {
        "t": "(C) `path` 列表會不斷累積元素，導致後續的分支包含來自前一分支的錯誤資料，最終結果錯誤。",
        "en": "(C) The `path` list will continuously accumulate elements, causing subsequent branches to contain incorrect data from previous branches, leading to wrong results.",
        "wg": [
          {
            "t": "累積",
            "en": "accumulate",
            "ps": "V"
          },
          {
            "t": "分支",
            "en": "branches",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 會立即拋出 NullPointerException。",
        "en": "(D) It will immediately throw a NullPointerException.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為 `path` 是一個可變物件 (Mutable Object) 且在遞迴中被共享，若不執行 `remove` (Undo)，前一次遞迴加入的元素會保留在 List 中，汙染下一次的嘗試。",
      "en": "Since `path` is a mutable object and shared across recursion, if `remove` (Undo) is not executed, elements added in the previous recursion will remain in the List, polluting the next attempt.",
      "wg": [
        {
          "t": "可變物件",
          "en": "Mutable Object",
          "ps": "N"
        },
        {
          "t": "汙染",
          "en": "polluting",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "2D Grid, DFS, Word Search, Visited Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二維網格上進行「單字搜尋」(Word Search) 問題時，我們通常使用 DFS 搭配回溯法。",
        "en": "When solving the 'Word Search' problem on a 2D grid, we typically use DFS combined with backtracking.",
        "wg": [
          {
            "t": "二維網格",
            "en": "2D grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了防止走回頭路，我們會將當前路徑上的格子標記為「已訪問」。",
        "en": "To prevent retracing steps, we mark cells on the current path as 'visited'.",
        "wg": [
          {
            "t": "走回頭路",
            "en": "retracing steps",
            "ps": "V"
          },
          {
            "t": "已訪問",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為什麼在 DFS 遞迴返回之前，必須將該格子恢復為「未訪問」？",
        "en": "Why must the cell be restored to 'unvisited' before returning from the DFS recursion?",
        "wg": [
          {
            "t": "恢復",
            "en": "restored",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了節省記憶體空間。",
        "en": "(A) To save memory space.",
        "wg": []
      },
      {
        "t": "(B) 為了讓該格子能夠被其他可能的路徑再次使用。",
        "en": "(B) To allow the cell to be used again by other possible paths.",
        "wg": [
          {
            "t": "可能的路徑",
            "en": "possible paths",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是 Java 垃圾回收機制 (Garbage Collection) 的要求。",
        "en": "(C) This is a requirement of the Java Garbage Collection mechanism.",
        "wg": []
      },
      {
        "t": "(D) 如果不恢復，會導致 StackOverflowError。",
        "en": "(D) If not restored, it will cause a StackOverflowError.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當前路徑尋找失敗並不代表該格子不能是其他正確路徑的一部分。回溯時恢復狀態，是為了確保從其他方向進入該格子時，它仍是可用的。",
      "en": "Failure to find a solution on the current path does not mean the cell cannot be part of another correct path. Restoring the state during backtracking ensures that the cell remains available when approached from other directions.",
      "wg": [
        {
          "t": "方向",
          "en": "directions",
          "ps": "N"
        },
        {
          "t": "可用的",
          "en": "available",
          "ps": "Adj"
        }
      ]
    }
  }
]