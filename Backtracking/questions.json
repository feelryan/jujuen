[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Backtracking, DFS, Algorithm Concept",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "回溯法 (Backtracking) 主要採用哪種策略來遍歷問題的狀態空間樹？",
        "en": "Which strategy does Backtracking primarily use to traverse the state space tree of a problem?",
        "wg": [
          {
            "t": "狀態空間樹",
            "en": "state space tree",
            "ps": "N"
          },
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "它透過試探每一條可能的路徑，並在發現路徑不可行時返回。",
        "en": "It explores every possible path and returns when a path is found to be invalid.",
        "wg": [
          {
            "t": "試探",
            "en": "explore/probe",
            "ps": "V"
          },
          {
            "t": "不可行",
            "en": "invalid/infeasible",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 廣度優先搜尋 (BFS)",
        "en": "(A) Breadth-First Search (BFS)",
        "wg": []
      },
      {
        "t": "(B) 深度優先搜尋 (DFS)",
        "en": "(B) Depth-First Search (DFS)",
        "wg": []
      },
      {
        "t": "(C) 動態規劃 (Dynamic Programming)",
        "en": "(C) Dynamic Programming",
        "wg": []
      },
      {
        "t": "(D) 二分搜尋 (Binary Search)",
        "en": "(D) Binary Search",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "回溯法本質上是一種改進的深度優先搜尋 (DFS)。它會沿著一條路徑深入直到無法繼續或找到解答，然後回退 (Backtrack) 到上一個節點嘗試其他分支。",
      "en": "Backtracking is essentially a refined Depth-First Search (DFS). It goes deep along a path until it cannot proceed or finds a solution, then backtracks to the previous node to try other branches.",
      "wg": [
        {
          "t": "本質上",
          "en": "essentially",
          "ps": "Adv"
        },
        {
          "t": "分支",
          "en": "branch",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Backtracking, Pruning, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(int[] nums, List<Integer> path) {\n    if (path.size() == nums.length) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    for (int num : nums) {\n        // Check condition\n        if (path.contains(num)) continue;\n        \n        path.add(num);\n        backtrack(nums, path);\n        path.remove(path.size() - 1);\n    }\n}",
    "question": [
      {
        "t": "在回溯演算法中，`if (path.contains(num)) continue;` 這行程式碼體現了什麼概念？",
        "en": "In the backtracking algorithm, what concept does the line `if (path.contains(num)) continue;` demonstrate?",
        "wg": [
          {
            "t": "體現",
            "en": "demonstrate/embody",
            "ps": "V"
          }
        ]
      },
      {
        "t": "此操作避免了無效的遞迴呼叫。",
        "en": "This operation avoids invalid recursive calls.",
        "wg": [
          {
            "t": "無效的",
            "en": "invalid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 狀態重置 (State Reset)",
        "en": "(A) State Reset",
        "wg": []
      },
      {
        "t": "(B) 剪枝 (Pruning)",
        "en": "(B) Pruning",
        "wg": [
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 記憶化 (Memoization)",
        "en": "(C) Memoization",
        "wg": []
      },
      {
        "t": "(D) 貪婪選擇 (Greedy Choice)",
        "en": "(D) Greedy Choice",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個「剪枝」操作。當程式判斷當前路徑已經不符合條件（例如數字已重複使用）時，它會直接跳過該分支，不再繼續深入遞迴，從而縮小搜尋空間。",
      "en": "This is a 'Pruning' operation. When the program determines that the current path no longer meets the criteria (e.g., the number is already used), it skips that branch and stops recursing deeper, thereby reducing the search space.",
      "wg": [
        {
          "t": "縮小",
          "en": "reduce/narrow down",
          "ps": "V"
        },
        {
          "t": "搜尋空間",
          "en": "search space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Backtracking, Implementation, State Management",
    "parentNo": null,
    "images": null,
    "codeSnippet": "path.add(currentValue);\nbacktrack(options, path);\npath.remove(path.size() - 1); // ???",
    "question": [
      {
        "t": "在遞迴呼叫 `backtrack` 返回後，執行 `path.remove(path.size() - 1)` 的主要目的是什麼？",
        "en": "What is the primary purpose of executing `path.remove(path.size() - 1)` after the recursive call `backtrack` returns?",
        "wg": [
          {
            "t": "遞迴呼叫",
            "en": "recursive call",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這是回溯法實作樣板中至關重要的一步。",
        "en": "This is a crucial step in the backtracking implementation template.",
        "wg": [
          {
            "t": "實作樣板",
            "en": "implementation template",
            "ps": "N"
          },
          {
            "t": "至關重要",
            "en": "crucial",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了釋放記憶體空間。",
        "en": "(A) To free up memory space.",
        "wg": []
      },
      {
        "t": "(B) 為了將當前狀態加入結果集。",
        "en": "(B) To add the current state to the result set.",
        "wg": []
      },
      {
        "t": "(C) 為了將狀態恢復到進入該分支前的樣子，以便進行下一次嘗試。",
        "en": "(C) To restore the state to how it was before entering that branch, allowing for the next attempt.",
        "wg": [
          {
            "t": "恢復",
            "en": "restore",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 為了檢查邊界條件。",
        "en": "(D) To check boundary conditions.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這稱為「狀態重置」或「回溯」。因為 `path` 變數通常是共用的引用 (Reference)，在嘗試完一個分支後，必須移除剛加入的元素，才能在回到上一層時保持狀態乾淨，以正確探索下一個分支。",
      "en": "This is called 'State Reset' or 'Backtracking'. Since the `path` variable is usually a shared reference, after trying a branch, the newly added element must be removed to keep the state clean when returning to the previous level, ensuring the next branch is explored correctly.",
      "wg": [
        {
          "t": "共用的",
          "en": "shared",
          "ps": "Adj"
        },
        {
          "t": "引用",
          "en": "reference",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Backtracking, Time Complexity, Permutations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個包含 N 個不重複數字的陣列，使用回溯法產生所有「全排列 (Permutations)」的時間複雜度通常是多少？",
        "en": "Given an array of N unique numbers, what is the typical time complexity to generate all 'permutations' using backtracking?",
        "wg": [
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "N"
          },
          {
            "t": "不重複",
            "en": "unique",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請考慮解的總數以及生成每個解所需的成本。",
        "en": "Please consider the total number of solutions and the cost required to generate each solution.",
        "wg": [
          {
            "t": "成本",
            "en": "cost",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(2^N)",
        "en": "(B) O(2^N)",
        "wg": []
      },
      {
        "t": "(C) O(N!)",
        "en": "(C) O(N!)",
        "wg": []
      },
      {
        "t": "(D) O(N * N!)",
        "en": "(D) O(N * N!)",
        "wg": []
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "全排列的總數是 N! (N 階乘)。由於每個排列長度為 N，且通常需要 O(N) 的時間將當前路徑複製到結果集中，因此總時間複雜度約為 O(N * N!)。若只考慮節點訪問數，則為 O(N!)。",
      "en": "The total number of permutations is N! (N factorial). Since each permutation has length N, and it typically takes O(N) time to copy the current path to the result set, the total time complexity is approximately O(N * N!). If considering only node visits, it is O(N!).",
      "wg": [
        {
          "t": "階乘",
          "en": "factorial",
          "ps": "N"
        },
        {
          "t": "複製",
          "en": "copy",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Backtracking, Logic, Combination Sum",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(int[] candidates, int target, int start, List<Integer> path) {\n    // ... base cases ...\n    for (int i = start; i < candidates.length; i++) {\n        path.add(candidates[i]);\n        // Recursive call\n        backtrack(candidates, target - candidates[i], ???, path);\n        path.remove(path.size() - 1);\n    }\n}",
    "question": [
      {
        "t": "在解決「組合總和 (Combination Sum)」問題時，若題目允許同一個數字被「無限次重複使用」，遞迴呼叫時的第三個參數 (start index) 應填入什麼？",
        "en": "When solving the 'Combination Sum' problem, if the problem allows the same number to be used 'unlimited times', what should be passed as the third parameter (start index) in the recursive call?",
        "wg": [
          {
            "t": "組合總和",
            "en": "Combination Sum",
            "ps": "N"
          },
          {
            "t": "無限次",
            "en": "unlimited times",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "這決定了下一層遞迴可以選擇哪些候選數字。",
        "en": "This determines which candidate numbers can be selected in the next level of recursion.",
        "wg": [
          {
            "t": "候選",
            "en": "candidate",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) i",
        "en": "(A) i",
        "wg": []
      },
      {
        "t": "(B) i + 1",
        "en": "(B) i + 1",
        "wg": []
      },
      {
        "t": "(C) start",
        "en": "(C) start",
        "wg": []
      },
      {
        "t": "(D) start + 1",
        "en": "(D) start + 1",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "傳入 `i` 表示下一層遞迴仍然可以選擇當前這個數字 `candidates[i]`，從而實現「可重複使用」。若傳入 `i + 1`，則表示當前數字不能再被選用，適用於「不可重複」的組合問題。",
      "en": "Passing `i` means the next recursion level can still choose the current number `candidates[i]`, enabling 'reuse'. Passing `i + 1` would mean the current number cannot be picked again, which applies to combination problems without reuse.",
      "wg": [
        {
          "t": "適用於",
          "en": "applies to",
          "ps": "V"
        },
        {
          "t": "重複使用",
          "en": "reuse",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Backtracking, Permutations, Duplicates, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 1, 2]\nOutput: [[1,1,2], [1,2,1], [2,1,1]]",
    "question": [
      {
        "t": "在處理包含重複元素的「全排列」(Permutations II) 問題時，我們通常會先對陣列進行排序。",
        "en": "When dealing with the 'Permutations II' problem containing duplicate elements, we usually sort the array first.",
        "wg": [
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "Noun"
          },
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "Noun Phrase"
          }
        ]
      },
      {
        "t": "請問排序的主要目的是什麼，且在遞迴過程中如何利用它來避免產生重複的排列結果？",
        "en": "What is the main purpose of sorting, and how is it used during recursion to avoid generating duplicate permutations?",
        "wg": [
          {
            "t": "遞迴過程",
            "en": "recursion process",
            "ps": "Noun Phrase"
          },
          {
            "t": "避免",
            "en": "avoid",
            "ps": "Verb"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 排序是為了讓輸出結果美觀；去重是透過使用 HashSet 來儲存所有結果實現的。",
        "en": "(A) Sorting is for aesthetic output; deduplication is achieved by using a HashSet to store all results.",
        "wg": [
          {
            "t": "去重",
            "en": "deduplication",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "(B) 排序是為了將相同的元素聚在一起；若 `nums[i] == nums[i-1]` 且 `nums[i-1]` 尚未被使用，則跳過該元素以避免重複。",
        "en": "(B) Sorting groups identical elements together; if `nums[i] == nums[i-1]` and `nums[i-1]` has not been used, skip the element to avoid duplicates.",
        "wg": [
          {
            "t": "聚在一起",
            "en": "group together",
            "ps": "Verb Phrase"
          }
        ]
      },
      {
        "t": "(C) 排序是為了將相同的元素聚在一起；若 `nums[i] == nums[i-1]` 且 `nums[i-1]` 已經被使用，則跳過該元素。",
        "en": "(C) Sorting groups identical elements together; if `nums[i] == nums[i-1]` and `nums[i-1]` has already been used, skip the element.",
        "wg": []
      },
      {
        "t": "(D) 排序能降低時間複雜度至 O(N)，並自動消除重複項。",
        "en": "(D) Sorting reduces time complexity to O(N) and automatically eliminates duplicates.",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "Noun"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "排序後相同的數字會相鄰。當我們決定當前位置要放哪個數字時，如果 `nums[i]` 與前一個數字 `nums[i-1]` 相同，且 `nums[i-1]` 在當前層級還沒被使用（即 `!used[i-1]`，表示它是剛被回溯撤銷的），這意味著我們正在嘗試用相同的數字填入同一個位置，這會導致重複，因此應跳過。",
      "en": "Sorting makes identical numbers adjacent. When deciding which number to place at the current position, if `nums[i]` is the same as `nums[i-1]` and `nums[i-1]` is not used in the current level (i.e., `!used[i-1]`, meaning it was just backtracked), it implies we are trying to fill the same slot with the same number again, which causes duplicates, so it should be skipped.",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adjective"
        },
        {
          "t": "回溯撤銷",
          "en": "backtracked/undone",
          "ps": "Verb"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Backtracking, State Restoration, Word Search, Grid",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(int r, int c, int index) {\n    // ... base cases ...\n    visited[r][c] = true;\n    // explore neighbors\n    backtrack(r+1, c, index+1);\n    // ... other neighbors ...\n    \n    // MISSING CODE HERE\n}",
    "question": [
      {
        "t": "在二維網格(Grid)上進行「單字搜尋」(Word Search)時，我們使用回溯法尋找路徑。",
        "en": "When performing a 'Word Search' on a 2D grid, we use backtracking to find the path.",
        "wg": [
          {
            "t": "二維網格",
            "en": "2D grid",
            "ps": "Noun"
          },
          {
            "t": "單字搜尋",
            "en": "Word Search",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "如果在遞迴返回之前（即 MISSING CODE 處），忘記將 `visited[r][c]` 重設為 `false`，會發生什麼後果？",
        "en": "What happens if we forget to reset `visited[r][c]` to `false` before returning from recursion (at the MISSING CODE spot)?",
        "wg": [
          {
            "t": "重設",
            "en": "reset",
            "ps": "Verb"
          },
          {
            "t": "後果",
            "en": "consequence",
            "ps": "Noun"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 程式會陷入無窮迴圈，導致堆疊溢位。",
        "en": "(A) The program will enter an infinite loop, causing a stack overflow.",
        "wg": [
          {
            "t": "無窮迴圈",
            "en": "infinite loop",
            "ps": "Noun"
          },
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "(B) 該單元格將被永久標記為已訪問，導致其他可能的合法路徑無法使用該單元格，可能因此找不到正解。",
        "en": "(B) The cell will be permanently marked as visited, preventing other valid paths from using this cell, potentially failing to find the solution.",
        "wg": [
          {
            "t": "永久標記",
            "en": "permanently marked",
            "ps": "Verb Phrase"
          },
          {
            "t": "合法路徑",
            "en": "valid paths",
            "ps": "Noun Phrase"
          }
        ]
      },
      {
        "t": "(C) 不會有任何影響，因為每個遞迴堆疊都有自己的變數副本。",
        "en": "(C) There will be no effect because each recursion stack has its own copy of variables.",
        "wg": [
          {
            "t": "變數副本",
            "en": "copy of variables",
            "ps": "Noun Phrase"
          }
        ]
      },
      {
        "t": "(D) 演算法的時間複雜度會降低，因為搜尋空間變小了。",
        "en": "(D) The time complexity of the algorithm will decrease because the search space becomes smaller.",
        "wg": [
          {
            "t": "搜尋空間",
            "en": "search space",
            "ps": "Noun"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是回溯法的核心概念「狀態重置」。當前路徑走不通而返回時，必須將該格子的狀態還原，因為該格子可能是另一條從不同起點或不同分支過來的正確路徑的一部分。",
      "en": "This is the core concept of 'State Restoration' in backtracking. When the current path fails and returns, the state of the cell must be restored, because that cell might be part of another correct path originating from a different start or branch.",
      "wg": [
        {
          "t": "狀態重置",
          "en": "state restoration",
          "ps": "Noun"
        },
        {
          "t": "分支",
          "en": "branch",
          "ps": "Noun"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Backtracking, Pruning, Optimization, Combination Sum",
    "parentNo": null,
    "images": null,
    "codeSnippet": "candidates = [2, 3, 6, 7], target = 7\n// Sorted candidates helps pruning",
    "question": [
      {
        "t": "在解決「組合總和」(Combination Sum) 問題時，如果候選數字陣列已排序，我們可以進行「剪枝」(Pruning) 來優化效能。",
        "en": "When solving the 'Combination Sum' problem, if the candidate array is sorted, we can perform 'Pruning' to optimize performance.",
        "wg": [
          {
            "t": "組合總和",
            "en": "Combination Sum",
            "ps": "Noun"
          },
          {
            "t": "剪枝",
            "en": "Pruning",
            "ps": "Noun"
          },
          {
            "t": "優化效能",
            "en": "optimize performance",
            "ps": "Verb Phrase"
          }
        ]
      },
      {
        "t": "下列哪一段邏輯最能體現剪枝的操作？",
        "en": "Which of the following logic best demonstrates the pruning operation?",
        "wg": [
          {
            "t": "體現",
            "en": "demonstrate/embody",
            "ps": "Verb"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `if (currentSum == target) { result.add(path); return; }`",
        "en": "(A) `if (currentSum == target) { result.add(path); return; }`",
        "wg": []
      },
      {
        "t": "(B) `for (int i = start; i < candidates.length; i++) { ... }`",
        "en": "(B) `for (int i = start; i < candidates.length; i++) { ... }`",
        "wg": []
      },
      {
        "t": "(C) `if (currentSum + candidates[i] > target) break;`",
        "en": "(C) `if (currentSum + candidates[i] > target) break;`",
        "wg": []
      },
      {
        "t": "(D) `path.remove(path.size() - 1);`",
        "en": "(D) `path.remove(path.size() - 1);`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 是剪枝。因為陣列已排序，如果當前數字加上去已經超過目標值，那麼後面的數字更大，一定也會超過，因此可以直接 `break` 跳出迴圈，不再繼續搜尋該分支。",
      "en": "Option (C) is pruning. Since the array is sorted, if adding the current number exceeds the target, subsequent numbers (which are larger) will also exceed it. Thus, we can `break` the loop immediately and stop searching that branch.",
      "wg": [
        {
          "t": "超過",
          "en": "exceed",
          "ps": "Verb"
        },
        {
          "t": "跳出迴圈",
          "en": "break the loop",
          "ps": "Verb Phrase"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Backtracking, N-Queens, Space-Time Tradeoff",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在經典的 N-Queens 問題中，我們需要檢查放置皇后是否會受到攻擊（同行、同列、對角線）。",
        "en": "In the classic N-Queens problem, we need to check if placing a queen results in it being under attack (same row, column, or diagonals).",
        "wg": [
          {
            "t": "皇后",
            "en": "queen",
            "ps": "Noun"
          },
          {
            "t": "對角線",
            "en": "diagonal",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "為了將驗證位置合法性的時間複雜度從 O(N) 降低到 O(1)，通常會使用額外的空間來記錄。",
        "en": "To reduce the time complexity of validating a position from O(N) to O(1), extra space is usually used for recording.",
        "wg": [
          {
            "t": "驗證",
            "en": "validating",
            "ps": "Verb"
          },
          {
            "t": "合法性",
            "en": "validity",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "請問對於座標 `(row, col)`，其「主對角線」(Main Diagonal) 和「反對角線」(Anti-Diagonal) 的特徵值分別是什麼？",
        "en": "For coordinate `(row, col)`, what are the characteristic values for the 'Main Diagonal' and 'Anti-Diagonal' respectively?",
        "wg": [
          {
            "t": "特徵值",
            "en": "characteristic values",
            "ps": "Noun"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 主對角線：`row * col`；反對角線：`row / col`",
        "en": "(A) Main Diagonal: `row * col`; Anti-Diagonal: `row / col`",
        "wg": []
      },
      {
        "t": "(B) 主對角線：`row - col`；反對角線：`row + col`",
        "en": "(B) Main Diagonal: `row - col`; Anti-Diagonal: `row + col`",
        "wg": []
      },
      {
        "t": "(C) 主對角線：`row + col`；反對角線：`row - col`",
        "en": "(C) Main Diagonal: `row + col`; Anti-Diagonal: `row - col`",
        "wg": []
      },
      {
        "t": "(D) 主對角線：`row % col`；反對角線：`row | col`",
        "en": "(D) Main Diagonal: `row % col`; Anti-Diagonal: `row | col`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在矩陣中，同一條「主對角線」（左上至右下）上的元素，其 `row - col` 的值是恆定的；同一條「反對角線」（右上至左下）上的元素，其 `row + col` 的值是恆定的。利用這兩個特徵值作為 Hash Set 或 Array 的索引，可以快速判斷該對角線是否已被佔用。",
      "en": "In a matrix, elements on the same 'Main Diagonal' (top-left to bottom-right) have a constant `row - col` value; elements on the same 'Anti-Diagonal' (top-right to bottom-left) have a constant `row + col` value. Using these two characteristic values as indices for a Hash Set or Array allows for quick checking if the diagonal is occupied.",
      "wg": [
        {
          "t": "恆定的",
          "en": "constant",
          "ps": "Adjective"
        },
        {
          "t": "佔用",
          "en": "occupied",
          "ps": "Adjective"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Backtracking, Time Complexity, Subsets",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "分析回溯演算法的時間複雜度時，我們通常關注狀態空間樹(State Space Tree)的大小。",
        "en": "When analyzing the time complexity of backtracking algorithms, we usually focus on the size of the State Space Tree.",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "Noun"
          },
          {
            "t": "狀態空間樹",
            "en": "State Space Tree",
            "ps": "Noun"
          }
        ]
      },
      {
        "t": "請問「子集」(Subsets) 問題（找出一個集合的所有子集）的時間複雜度通常表示為多少？假設集合大小為 N。",
        "en": "What is the typical time complexity for the 'Subsets' problem (finding all subsets of a set)? Assume the set size is N.",
        "wg": [
          {
            "t": "子集",
            "en": "subsets",
            "ps": "Noun"
          },
          {
            "t": "集合",
            "en": "set",
            "ps": "Noun"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N!)",
        "en": "(A) O(N!)",
        "wg": []
      },
      {
        "t": "(B) O(N^2)",
        "en": "(B) O(N^2)",
        "wg": []
      },
      {
        "t": "(C) O(N * 2^N)",
        "en": "(C) O(N * 2^N)",
        "wg": []
      },
      {
        "t": "(D) O(log N)",
        "en": "(D) O(log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "每個元素都有「選」或「不選」兩種選擇，因此總共有 2^N 個子集。而構造每個子集（複製到結果列表）平均需要 O(N) 的時間，因此總時間複雜度為 O(N * 2^N)。",
      "en": "Each element has two choices: 'select' or 'not select', resulting in a total of 2^N subsets. Constructing each subset (copying to the result list) takes O(N) time on average, so the total time complexity is O(N * 2^N).",
      "wg": [
        {
          "t": "構造",
          "en": "construct",
          "ps": "Verb"
        },
        {
          "t": "平均",
          "en": "on average",
          "ps": "Adverb"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Backtracking, Pruning, Optimization, N-Queens",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決 N-Queens（N 皇后）問題時，我們通常會在放置皇后之前檢查該位置是否安全。",
        "en": "When solving the N-Queens problem, we typically check if a position is safe before placing a queen.",
        "wg": [
          {
            "t": "N 皇后",
            "en": "N-Queens",
            "ps": "N"
          },
          {
            "t": "放置",
            "en": "placing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這種在遞迴深入之前先判斷條件不符則放棄該路徑的技術稱為什麼？",
        "en": "What is the technique called where we abandon a path if conditions are not met before recursing deeper?",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursing",
            "ps": "V"
          },
          {
            "t": "放棄",
            "en": "abandon",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 記憶化 (Memoization)",
        "en": "(A) Memoization",
        "wg": []
      },
      {
        "t": "(B) 剪枝 (Pruning)",
        "en": "(B) Pruning",
        "wg": [
          {
            "t": "剪枝",
            "en": "Pruning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 貪婪法 (Greedy Approach)",
        "en": "(C) Greedy Approach",
        "wg": []
      },
      {
        "t": "(D) 動態規劃 (Dynamic Programming)",
        "en": "(D) Dynamic Programming",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "剪枝 (Pruning) 是回溯法中用來減少搜尋空間的關鍵技術，透過提早排除不可能產生解的路徑來提升效率；記憶化通常用於動態規劃。",
      "en": "Pruning is a key technique in backtracking used to reduce the search space by eliminating paths that cannot lead to a solution early on; Memoization is typically used in Dynamic Programming.",
      "wg": [
        {
          "t": "搜尋空間",
          "en": "search space",
          "ps": "N"
        },
        {
          "t": "排除",
          "en": "eliminating",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "hard",
    "keywords": "Backtracking, Permutations, Duplicates, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [1, 1, 2]\nTarget: Unique Permutations",
    "question": [
      {
        "t": "當輸入陣列包含重複元素（例如 `[1, 1, 2]`）且要求產生「不重複」的全排列時，",
        "en": "When the input array contains duplicate elements (e.g., `[1, 1, 2]`) and unique permutations are required,",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "N"
          },
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種策略是最常見且有效的去重方法？",
        "en": "Which of the following strategies is the most common and effective method for deduplication?",
        "wg": [
          {
            "t": "去重",
            "en": "deduplication",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 `Set` 資料結構來儲存所有產生的排列結果，最後再轉回 List。",
        "en": "(A) Use a `Set` data structure to store all generated permutations, then convert back to a List.",
        "wg": []
      },
      {
        "t": "(B) 先對陣列進行排序，並在回溯過程中略過與前一個元素相同且前一個元素未被使用的情況。",
        "en": "(B) Sort the array first, and during backtracking, skip the element if it is the same as the previous one and the previous one was not used.",
        "wg": [
          {
            "t": "略過",
            "en": "skip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 隨機打亂陣列順序，直到產生所有不同的排列。",
        "en": "(C) Randomly shuffle the array order until all distinct permutations are generated.",
        "wg": []
      },
      {
        "t": "(D) 僅在遞迴深度達到陣列長度時檢查該排列是否已存在於結果中。",
        "en": "(D) Check if the permutation already exists in the result only when the recursion depth reaches the array length.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 是標準的剪枝做法，透過排序讓重複元素相鄰，並利用 `if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue` 來避免在同一層級重複選取相同的數字，這比生成後再用 Set 去重 (A) 更節省時間與空間。",
      "en": "Option (B) is the standard pruning approach. By sorting to make duplicates adjacent and using `if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue`, we avoid selecting the same number repeatedly at the same level. This saves more time and space than deduplicating with a Set after generation (A).",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        },
        {
          "t": "同一層級",
          "en": "same level",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Backtracking, State Restoration, Mutable",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(List<Integer> path) {\n    if (goal reached) { res.add(new ArrayList<>(path)); return; }\n    for (int i = 0; i < nums.length; i++) {\n        path.add(nums[i]);\n        backtrack(path);\n        path.remove(path.size() - 1); // ???\n    }\n}",
    "question": [
      {
        "t": "在上述的回溯演算法虛擬碼中，為什麼在遞迴呼叫 `backtrack(path)` 之後，必須執行 `path.remove(path.size() - 1)`？",
        "en": "In the backtracking pseudocode above, why must `path.remove(path.size() - 1)` be executed after the recursive call `backtrack(path)`?",
        "wg": [
          {
            "t": "虛擬碼",
            "en": "pseudocode",
            "ps": "N"
          },
          {
            "t": "執行",
            "en": "executed",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了釋放記憶體空間以避免堆疊溢位。",
        "en": "(A) To free up memory space to avoid stack overflow.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 為了將狀態重置（撤銷選擇），以便在迴圈的下一次迭代中探索其他可能性。",
        "en": "(B) To reset the state (undo the choice) so that other possibilities can be explored in the next iteration of the loop.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          },
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是 Java 語法的強制要求，否則編譯不會通過。",
        "en": "(C) This is a mandatory requirement of Java syntax, otherwise it will not compile.",
        "wg": []
      },
      {
        "t": "(D) 為了確保結果列表是按升序排列的。",
        "en": "(D) To ensure the result list is sorted in ascending order.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "回溯法的核心在於「嘗試」與「撤銷」。因為 `path` 是一個可變物件 (Mutable Object)，在深入遞迴後回到當前層級時，必須將剛剛加入的元素移除，才能保證嘗試下一個分支時 `path` 的狀態是正確的。",
      "en": "The core of backtracking is 'try' and 'undo'. Since `path` is a mutable object, after returning from a deeper recursion level, the element just added must be removed to ensure the `path` state is correct when attempting the next branch.",
      "wg": [
        {
          "t": "可變物件",
          "en": "mutable object",
          "ps": "N"
        },
        {
          "t": "分支",
          "en": "branch",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Time Complexity, Subsets, Backtracking",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若使用回溯法來產生一個包含 N 個相異元素集合的所有子集（Power Set），",
        "en": "If backtracking is used to generate all subsets (Power Set) of a set containing N distinct elements,",
        "wg": [
          {
            "t": "相異",
            "en": "distinct",
            "ps": "Adj"
          },
          {
            "t": "子集",
            "en": "subsets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "其時間複雜度通常是多少？",
        "en": "what is the typical time complexity?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(N!)",
        "en": "(B) O(N!)",
        "wg": []
      },
      {
        "t": "(C) O(N * 2^N)",
        "en": "(C) O(N * 2^N)",
        "wg": []
      },
      {
        "t": "(D) O(log N)",
        "en": "(D) O(log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "一個包含 N 個元素的集合有 2^N 個子集。對於每個子集，我們通常需要 O(N) 的時間來建構或複製到結果列表中（視平均子集長度而定，最壞情況為 N），因此總時間複雜度為 O(N * 2^N)。",
      "en": "A set with N elements has 2^N subsets. For each subset, it typically takes O(N) time to construct or copy it to the result list (depending on average subset length, worst case N), so the total time complexity is O(N * 2^N).",
      "wg": [
        {
          "t": "建構",
          "en": "construct",
          "ps": "V"
        },
        {
          "t": "最壞情況",
          "en": "worst case",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Backtracking, 2D Grid, Word Search, Visited Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二維網格（Grid）上進行「單字搜尋 (Word Search)」問題時，我們使用回溯法尋找路徑。",
        "en": "When solving the 'Word Search' problem on a 2D Grid using backtracking to find a path.",
        "wg": [
          {
            "t": "二維網格",
            "en": "2D Grid",
            "ps": "N"
          },
          {
            "t": "單字搜尋",
            "en": "Word Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼在進入遞迴前需要將當前格子標記為「已訪問」，並在遞迴返回後將其標記回「未訪問」？",
        "en": "Why is it necessary to mark the current cell as 'visited' before entering recursion and mark it back to 'unvisited' after returning?",
        "wg": [
          {
            "t": "標記",
            "en": "mark",
            "ps": "V"
          },
          {
            "t": "已訪問",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了防止在同一條路徑中重複使用同一個格子，同時允許其他路徑再次使用該格子。",
        "en": "(A) To prevent reusing the same cell within the same path, while allowing other paths to use that cell again.",
        "wg": [
          {
            "t": "重複使用",
            "en": "reusing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 這是為了計算最短路徑長度。",
        "en": "(B) This is to calculate the shortest path length.",
        "wg": []
      },
      {
        "t": "(C) 這樣做可以將時間複雜度降至 O(1)。",
        "en": "(C) Doing so reduces the time complexity to O(1).",
        "wg": []
      },
      {
        "t": "(D) 這是為了避免修改原始輸入陣列。",
        "en": "(D) This is to avoid modifying the original input array.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "標記為「已訪問」是為了避免在當前的遞迴路徑中形成迴圈（走回頭路）；而在回溯時「取消標記」則是為了讓該格子在其他可能的路徑嘗試中能夠再次被使用。",
      "en": "Marking as 'visited' prevents cycles (going back) in the current recursive path; 'unmarking' during backtracking allows the cell to be used again in other potential path attempts.",
      "wg": [
        {
          "t": "迴圈",
          "en": "cycles",
          "ps": "N"
        },
        {
          "t": "取消標記",
          "en": "unmarking",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Backtracking, 2D Grid, State Restoration, Word Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def backtrack(row, col, index):\n    temp = board[row][col]\n    board[row][col] = '#'\n    # ... recursive calls ...\n    board[row][col] = temp  # <--- Key Step",
    "question": [
      {
        "t": "在解決「字詞搜尋」(Word Search) 問題時，我們需要在二維網格中尋找是否存在特定字串。",
        "en": "When solving the 'Word Search' problem, we need to find if a specific string exists in a 2D grid.",
        "wg": [
          {
            "t": "二維網格",
            "en": "2D grid",
            "ps": "N"
          },
          {
            "t": "字串",
            "en": "string",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在遞迴探索某個格子後，為什麼必須將該格子的值還原（如程式碼片段中的 Key Step 所示）？",
        "en": "After recursively exploring a cell, why is it necessary to restore the cell's value (as shown in the Key Step of the code snippet)?",
        "wg": [
          {
            "t": "還原",
            "en": "restore",
            "ps": "V"
          },
          {
            "t": "遞迴探索",
            "en": "recursively explore",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免在同一次深度優先搜尋 (DFS) 路徑中重複訪問該格子。",
        "en": "(A) To avoid revisiting the cell within the same Depth-First Search (DFS) path.",
        "wg": []
      },
      {
        "t": "(B) 為了讓該格子能夠在其他可能的搜尋路徑中再次被使用。",
        "en": "(B) To allow the cell to be used again in other possible search paths.",
        "wg": [
          {
            "t": "搜尋路徑",
            "en": "search paths",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 為了節省記憶體空間，避免堆疊溢位。",
        "en": "(C) To save memory space and prevent stack overflow.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 這是多餘的步驟，因為遞迴結束後變數會自動銷毀。",
        "en": "(D) This is a redundant step because variables are automatically destroyed after recursion ends.",
        "wg": [
          {
            "t": "多餘的",
            "en": "redundant",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是回溯法的核心機制。當目前的搜尋路徑失敗並返回時，我們必須將狀態「重置」(Backtrack)，這樣當我們從不同的方向或起點再次經過此格子時，它才是可用的原始狀態。",
      "en": "This is the core mechanism of backtracking. When the current search path fails and returns, we must 'reset' (backtrack) the state so that the cell is in its original available state when approached from a different direction or starting point.",
      "wg": [
        {
          "t": "核心機制",
          "en": "core mechanism",
          "ps": "N"
        },
        {
          "t": "重置",
          "en": "reset",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "hard",
    "keywords": "Backtracking, N-Queens, Optimization, Space Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在優化 N-Queens 問題的回溯演算法時，我們通常使用三個集合 (Set) 或布林陣列來快速檢查皇后的放置位置是否合法。",
        "en": "When optimizing the backtracking algorithm for the N-Queens problem, we typically use three Sets or boolean arrays to quickly check if a queen's placement is valid.",
        "wg": [
          {
            "t": "優化",
            "en": "optimizing",
            "ps": "V"
          },
          {
            "t": "合法",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "除了檢查「列」(Column) 之外，對於位置 `(row, col)`，我們該如何最有效地標記並檢查兩條對角線的衝突？",
        "en": "Besides checking the 'Column', how do we most effectively mark and check for conflicts on the two diagonals for a position `(row, col)`?",
        "wg": [
          {
            "t": "對角線",
            "en": "diagonals",
            "ps": "N"
          },
          {
            "t": "衝突",
            "en": "conflicts",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 `row + col` 標記主對角線，`row - col` 標記反對角線。",
        "en": "(A) Use `row + col` to mark the main diagonal and `row - col` for the anti-diagonal.",
        "wg": [
          {
            "t": "主對角線",
            "en": "main diagonal",
            "ps": "N"
          },
          {
            "t": "反對角線",
            "en": "anti-diagonal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 每次放置新皇后時，遍歷棋盤上所有已放置的皇后計算斜率。",
        "en": "(B) Iterate through all placed queens on the board to calculate slopes every time a new queen is placed.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          },
          {
            "t": "斜率",
            "en": "slope",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用 `row * col` 標記主對角線，`row / col` 標記反對角線。",
        "en": "(C) Use `row * col` to mark the main diagonal and `row / col` for the anti-diagonal.",
        "wg": []
      },
      {
        "t": "(D) 使用 `row` 標記主對角線，`col` 標記反對角線。",
        "en": "(D) Use `row` to mark the main diagonal and `col` for the anti-diagonal.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在同一條「左上至右下」的對角線上，`row - col` 的值是恆定的；在同一條「右上至左下」的對角線上，`row + col` 的值是恆定的。利用這兩個數學性質可以在 O(1) 時間內完成檢查。",
      "en": "On the same 'top-left to bottom-right' diagonal, the value of `row - col` is constant; on the same 'top-right to bottom-left' diagonal, the value of `row + col` is constant. Using these mathematical properties allows for checking in O(1) time.",
      "wg": [
        {
          "t": "恆定的",
          "en": "constant",
          "ps": "Adj"
        },
        {
          "t": "性質",
          "en": "property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Backtracking, Sudoku, Logic, Implementation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作「數獨求解器」(Sudoku Solver) 的回溯演算法時，我們需要驗證將數字 `num` 填入 `board[row][col]` 是否合法。",
        "en": "When implementing a backtracking algorithm for a 'Sudoku Solver', we need to validate if placing a number `num` into `board[row][col]` is valid.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "除了檢查該行與該列之外，還需要檢查所在的 3x3 子方格。下列哪個公式能正確計算出 `(row, col)` 所在 3x3 子方格左上角的座標？",
        "en": "Besides checking the row and column, we must check the 3x3 sub-box it belongs to. Which of the following formulas correctly calculates the top-left coordinate of the 3x3 sub-box for `(row, col)`?",
        "wg": [
          {
            "t": "子方格",
            "en": "sub-box",
            "ps": "N"
          },
          {
            "t": "座標",
            "en": "coordinate",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `startRow = (row % 3) * 3`, `startCol = (col % 3) * 3`",
        "en": "(A) `startRow = (row % 3) * 3`, `startCol = (col % 3) * 3`",
        "wg": []
      },
      {
        "t": "(B) `startRow = (row / 3) * 3`, `startCol = (col / 3) * 3`",
        "en": "(B) `startRow = (row / 3) * 3`, `startCol = (col / 3) * 3`",
        "wg": []
      },
      {
        "t": "(C) `startRow = row - 3`, `startCol = col - 3`",
        "en": "(C) `startRow = row - 3`, `startCol = col - 3`",
        "wg": []
      },
      {
        "t": "(D) `startRow = row`, `startCol = col`",
        "en": "(D) `startRow = row`, `startCol = col`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "數獨的索引是 0-8。整數除法 `row / 3` 會得到 0, 1 或 2，代表是第幾個區塊帶。再乘以 3 即可還原回該區塊帶的起始索引 (0, 3, 或 6)。",
      "en": "Sudoku indices are 0-8. Integer division `row / 3` results in 0, 1, or 2, representing which block band it is in. Multiplying by 3 restores it to the starting index of that block band (0, 3, or 6).",
      "wg": [
        {
          "t": "整數除法",
          "en": "integer division",
          "ps": "N"
        },
        {
          "t": "索引",
          "en": "index",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Backtracking, Pruning, Sorting, Partition Problem",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「將陣列分割為 K 個總和相等的子集」這類問題時，通常會先對輸入陣列進行排序以優化回溯效率。",
        "en": "When solving problems like 'Partition to K Equal Sum Subsets', the input array is usually sorted first to optimize backtracking efficiency.",
        "wg": [
          {
            "t": "分割",
            "en": "partition",
            "ps": "V"
          },
          {
            "t": "子集",
            "en": "subsets",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問採用「降序排序」(Descending Order) 的主要優勢為何？",
        "en": "What is the main advantage of using 'Descending Order' sorting?",
        "wg": [
          {
            "t": "降序排序",
            "en": "descending order",
            "ps": "N"
          },
          {
            "t": "優勢",
            "en": "advantage",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 較大的數字較容易導致總和超過目標值，從而能更早觸發剪枝 (Pruning)。",
        "en": "(A) Larger numbers are more likely to cause the sum to exceed the target, thereby triggering pruning earlier.",
        "wg": [
          {
            "t": "觸發",
            "en": "trigger",
            "ps": "V"
          },
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 降序排序可以減少遞迴的深度。",
        "en": "(B) Descending order can reduce the depth of recursion.",
        "wg": []
      },
      {
        "t": "(C) 較小的數字比較難處理，應該放在最後。",
        "en": "(C) Smaller numbers are harder to handle and should be placed last.",
        "wg": []
      },
      {
        "t": "(D) 排序只是為了美觀，對時間複雜度沒有影響。",
        "en": "(D) Sorting is just for aesthetics and has no effect on time complexity.",
        "wg": [
          {
            "t": "美觀",
            "en": "aesthetics",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是一種「快速失敗」(Fail Fast) 的策略。先嘗試放入大數字，如果無法滿足條件（例如超過目標和），演算法可以立即回溯，避免浪費時間在許多小數字的無效組合上。",
      "en": "This is a 'Fail Fast' strategy. By trying to place large numbers first, if the condition cannot be met (e.g., exceeding the target sum), the algorithm can backtrack immediately, avoiding wasted time on many invalid combinations of small numbers.",
      "wg": [
        {
          "t": "快速失敗",
          "en": "fail fast",
          "ps": "N"
        },
        {
          "t": "無效組合",
          "en": "invalid combinations",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Backtracking, Time Complexity, Permutations, Factorial",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "分析回溯演算法的時間複雜度時，我們通常關注狀態空間樹 (State-Space Tree) 的大小。",
        "en": "When analyzing the time complexity of backtracking algorithms, we usually focus on the size of the State-Space Tree.",
        "wg": [
          {
            "t": "狀態空間樹",
            "en": "state-space tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問產生一個長度為 N 的陣列之「全排列」(All Permutations) 的時間複雜度通常是多少？",
        "en": "What is the typical time complexity for generating 'All Permutations' of an array of length N?",
        "wg": [
          {
            "t": "全排列",
            "en": "all permutations",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(2^N)",
        "en": "(A) O(2^N)",
        "wg": []
      },
      {
        "t": "(B) O(N^2)",
        "en": "(B) O(N^2)",
        "wg": []
      },
      {
        "t": "(C) O(N!)",
        "en": "(C) O(N!)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "全排列的數量是 N 階乘 (N!)。第一層有 N 個選擇，第二層有 N-1 個選擇，依此類推。O(2^N) 通常是「子集」(Subset) 問題的複雜度。",
      "en": "The number of permutations is N factorial (N!). The first level has N choices, the second has N-1 choices, and so on. O(2^N) is typically the complexity for 'Subset' problems.",
      "wg": [
        {
          "t": "階乘",
          "en": "factorial",
          "ps": "N"
        },
        {
          "t": "依此類推",
          "en": "and so on",
          "ps": "Phra"
        }
      ]
    }
  }
]