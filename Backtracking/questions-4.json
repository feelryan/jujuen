[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Backtracking, Grid Search, State Restoration, Word Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(board, r, c, word, index) {\n    // ... base cases ...\n    char temp = board[r][c];\n    board[r][c] = '#'; // Mark as visited\n    \n    // Recursive calls for neighbors\n    // ...\n\n    board[r][c] = temp; // Restore state\n}",
    "question": [
      {
        "t": "在解決「文字搜尋」(Word Search) 等二維網格路徑問題時，我們通常會在遞迴返回之前將當前格子的狀態還原（如程式碼中的 `board[r][c] = temp`）。",
        "en": "When solving 2D grid path problems like 'Word Search', we usually restore the state of the current cell before returning from recursion (as shown in the code `board[r][c] = temp`).",
        "wg": [
          {
            "t": "二維網格",
            "en": "2D grid",
            "ps": "N"
          },
          {
            "t": "還原",
            "en": "restore",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問這個步驟的主要目的是什麼？",
        "en": "What is the primary purpose of this step?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了節省記憶體空間，避免堆疊溢位。",
        "en": "(A) To save memory space and avoid stack overflow.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 為了確保同一個格子可以在當前路徑中被重複訪問。",
        "en": "(B) To ensure the same cell can be visited repeatedly within the current path.",
        "wg": []
      },
      {
        "t": "(C) 為了讓該格子能夠被其他潛在的路徑（源自不同的起點或分支）再次使用。",
        "en": "(C) To allow the cell to be used again by other potential paths (originating from different starting points or branches).",
        "wg": [
          {
            "t": "潛在的",
            "en": "potential",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 這是編譯器的要求，否則會拋出語法錯誤。",
        "en": "(D) This is a compiler requirement; otherwise, a syntax error will be thrown.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "回溯法的核心在於「嘗試與撤銷」。將格子標記為已訪問是為了防止在「當前」路徑走回頭路；而當遞迴返回（Backtrack）時，表示當前路徑的嘗試結束，必須將狀態還原，這樣該格子才能在其他可能的路徑探索中被視為可用。",
      "en": "The core of backtracking is 'try and undo'. Marking a cell as visited prevents looping back in the 'current' path; however, when the recursion returns (Backtrack), it means the attempt for the current path is finished. The state must be restored so that the cell is considered available for other potential path explorations.",
      "wg": [
        {
          "t": "撤銷",
          "en": "undo",
          "ps": "V"
        },
        {
          "t": "走回頭路",
          "en": "loop back / retrace",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "Backtracking, Pruning, Duplicates, Subsets II",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Arrays.sort(nums);\nbacktrack(list, new ArrayList<>(), nums, 0);\n\nvoid backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        // ??? MISSING CODE ???\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}",
    "question": [
      {
        "t": "在處理含有重複數字的陣列並尋找所有子集（Subsets II）時，為了避免產生重複的子集（例如 `[1, 2]` 出現兩次），我們通常先對陣列排序。",
        "en": "When processing an array with duplicate numbers to find all subsets (Subsets II), we usually sort the array first to avoid generating duplicate subsets (e.g., `[1, 2]` appearing twice).",
        "wg": [
          {
            "t": "子集",
            "en": "subset",
            "ps": "N"
          },
          {
            "t": "重複的",
            "en": "duplicate",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問在程式碼註解 `MISSING CODE` 處，應填入什麼邏輯來進行剪枝？",
        "en": "What logic should be filled in at the `MISSING CODE` comment to perform pruning?",
        "wg": [
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `if(i > 0 && nums[i] == nums[i-1]) continue;`",
        "en": "(A) `if(i > 0 && nums[i] == nums[i-1]) continue;`",
        "wg": []
      },
      {
        "t": "(B) `if(i > start && nums[i] == nums[i-1]) continue;`",
        "en": "(B) `if(i > start && nums[i] == nums[i-1]) continue;`",
        "wg": []
      },
      {
        "t": "(C) `if(nums[i] == nums[i+1]) continue;`",
        "en": "(C) `if(nums[i] == nums[i+1]) continue;`",
        "wg": []
      },
      {
        "t": "(D) `if(tempList.contains(nums[i])) continue;`",
        "en": "(D) `if(tempList.contains(nums[i])) continue;`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "正確的剪枝邏輯是 `if(i > start && nums[i] == nums[i-1]) continue;`。這表示在「同一層」遞迴中，如果當前數字與前一個數字相同，且前一個數字尚未被選用（隱含在 `i > start` 中，表示 `i` 不是這一層的第一個選擇），則跳過該數字以避免重複組合。選項 (A) 會錯誤地排除掉所有重複數字，導致無法選取如 `[1, 1]` 的合法子集。",
      "en": "The correct pruning logic is `if(i > start && nums[i] == nums[i-1]) continue;`. This means that within the 'same level' of recursion, if the current number is the same as the previous one, and the previous one was not chosen (implied by `i > start`, meaning `i` is not the first choice of this level), we skip it to avoid duplicate combinations. Option (A) would incorrectly exclude all duplicates, preventing valid subsets like `[1, 1]`.",
      "wg": [
        {
          "t": "同一層",
          "en": "same level",
          "ps": "N"
        },
        {
          "t": "隱含",
          "en": "implied",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Backtracking, Time Complexity, Permutations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "使用回溯法產生長度為 N 的陣列之「全排列」(Permutations) 時，其最壞情況的時間複雜度通常屬於哪個等級？",
        "en": "When using backtracking to generate 'Permutations' of an array of length N, what is the typical worst-case time complexity class?",
        "wg": [
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "N"
          },
          {
            "t": "最壞情況",
            "en": "worst-case",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(2^N)",
        "en": "(B) O(2^N)",
        "wg": []
      },
      {
        "t": "(C) O(N!)",
        "en": "(C) O(N!)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "全排列問題的解空間大小為 N 的階乘（N!）。回溯法需要訪問每一個排列結果，因此時間複雜度由葉節點的數量主導，即 O(N!)。相較之下，O(2^N) 通常是「子集」(Subsets) 問題的複雜度。",
      "en": "The solution space size for the permutations problem is N factorial (N!). Backtracking needs to visit every permutation result, so the time complexity is dominated by the number of leaf nodes, which is O(N!). In comparison, O(2^N) is typically the complexity for 'Subsets' problems.",
      "wg": [
        {
          "t": "解空間",
          "en": "solution space",
          "ps": "N"
        },
        {
          "t": "階乘",
          "en": "factorial",
          "ps": "N"
        },
        {
          "t": "主導",
          "en": "dominated",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Backtracking, N-Queens, Optimization, Bitmask",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在優化 N-Queens (N 皇后) 問題的回溯演算法時，我們常使用三個集合(Sets)或布林陣列來以 O(1) 時間檢查放置位置的合法性。",
        "en": "When optimizing the backtracking algorithm for the N-Queens problem, we often use three sets or boolean arrays to check the validity of a placement in O(1) time.",
        "wg": [
          {
            "t": "合法性",
            "en": "validity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "除了紀錄被佔用的「列」(Column) 之外，另外兩個集合通常用來記錄什麼資訊？",
        "en": "Besides recording the occupied 'Columns', what information do the other two sets typically record?",
        "wg": [
          {
            "t": "被佔用的",
            "en": "occupied",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 棋盤的行 (Rows) 與 剩餘皇后的數量。",
        "en": "(A) The rows of the board and the number of remaining queens.",
        "wg": []
      },
      {
        "t": "(B) 正對角線 (Diagonals) 與 反對角線 (Anti-diagonals)。",
        "en": "(B) Main diagonals and anti-diagonals.",
        "wg": [
          {
            "t": "對角線",
            "en": "diagonal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 棋盤的奇數格與偶數格。",
        "en": "(C) Odd and even cells of the board.",
        "wg": []
      },
      {
        "t": "(D) 已經放置皇后的座標 (X, Y)。",
        "en": "(D) The coordinates (X, Y) of queens already placed.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 N-Queens 問題中，同一條正對角線上的格子滿足 `row - col` 為定值，同一條反對角線上的格子滿足 `row + col` 為定值。利用這兩個特性，我們可以用集合來快速判斷某個位置是否會與已放置的皇后在對角線上衝突，而不需要遍歷棋盤。",
      "en": "In the N-Queens problem, cells on the same main diagonal satisfy `row - col` = constant, and cells on the same anti-diagonal satisfy `row + col` = constant. Using these two properties, we can use sets to quickly determine if a position conflicts diagonally with already placed queens without iterating through the board.",
      "wg": [
        {
          "t": "定值",
          "en": "constant value",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "iterate / traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "hard",
    "keywords": "Backtracking, Iterative, Stack, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "大多數回溯演算法都以遞迴 (Recursion) 方式實作。",
        "en": "Most backtracking algorithms are implemented using recursion.",
        "wg": []
      },
      {
        "t": "若因系統限制需要將其改寫為「迭代」(Iterative) 版本以避免遞迴過深，最適合用來模擬遞迴行為的資料結構是什麼？",
        "en": "If system constraints require rewriting it into an 'Iterative' version to avoid deep recursion, which data structure is most suitable for simulating the recursion behavior?",
        "wg": [
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          },
          {
            "t": "模擬",
            "en": "simulate",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 佇列 (Queue)",
        "en": "(A) Queue",
        "wg": []
      },
      {
        "t": "(B) 堆疊 (Stack)",
        "en": "(B) Stack",
        "wg": []
      },
      {
        "t": "(C) 優先佇列 (Priority Queue)",
        "en": "(C) Priority Queue",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遞迴的本質是利用系統的呼叫堆疊 (Call Stack) 來保存每一層的狀態（如參數、局部變數）。要將遞迴轉為迭代，必須顯式地使用「堆疊」(Stack) 資料結構來模擬這種後進先出 (LIFO) 的行為，保存當前的搜尋路徑與狀態。",
      "en": "The essence of recursion is using the system's call stack to save the state of each level (e.g., parameters, local variables). To convert recursion to iteration, one must explicitly use a 'Stack' data structure to simulate this Last-In-First-Out (LIFO) behavior, preserving the current search path and state.",
      "wg": [
        {
          "t": "顯式地",
          "en": "explicitly",
          "ps": "Adv"
        },
        {
          "t": "後進先出",
          "en": "Last-In-First-Out (LIFO)",
          "ps": "N"
        }
      ]
    }
  }
]