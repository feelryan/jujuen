[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Backtracking, DFS, Recursion, Concept",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於回溯法 (Backtracking) 的核心概念，下列敘述何者最為精確？",
        "en": "Which of the following statements most accurately describes the core concept of Backtracking?",
        "wg": [
          {
            "t": "核心概念",
            "en": "core concept",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          },
          {
            "t": "精確",
            "en": "accurate",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請考慮其搜尋策略與狀態處理方式。",
        "en": "Please consider its search strategy and state handling mechanism.",
        "wg": [
          {
            "t": "搜尋策略",
            "en": "search strategy",
            "ps": "N"
          },
          {
            "t": "狀態處理",
            "en": "state handling",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它是一種廣度優先搜尋 (BFS)，保證能找到最短路徑。",
        "en": "(A) It is a Breadth-First Search (BFS) that guarantees finding the shortest path.",
        "wg": []
      },
      {
        "t": "(B) 它是一種貪婪演算法 (Greedy)，每一步都選擇當前最佳解。",
        "en": "(B) It is a Greedy algorithm that chooses the local optimum at each step.",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy algorithm",
            "ps": "N"
          },
          {
            "t": "當前最佳解",
            "en": "local optimum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它是一種深度優先搜尋 (DFS)，透過遞迴探索並在無法滿足條件時撤銷上一步的選擇。",
        "en": "(C) It is a Depth-First Search (DFS) that explores recursively and undoes the previous choice when conditions are not met.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          },
          {
            "t": "撤銷",
            "en": "undo",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 它主要用於解決排序問題，時間複雜度為 O(N log N)。",
        "en": "(D) It is mainly used to solve sorting problems with a time complexity of O(N log N).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "回溯法本質上是在狀態空間樹 (State Space Tree) 上進行深度優先搜尋 (DFS)。當發現當前路徑無法導向有效解時，會「回溯」並撤銷 (Undo) 最近一次的選擇，嘗試其他分支。",
      "en": "Backtracking is essentially a Depth-First Search (DFS) on a State Space Tree. When the current path cannot lead to a valid solution, it 'backtracks' by undoing the most recent choice to try other branches.",
      "wg": [
        {
          "t": "狀態空間樹",
          "en": "State Space Tree",
          "ps": "N"
        },
        {
          "t": "分支",
          "en": "branch",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Permutations, Time Complexity, Factorial",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若使用回溯法產生 N 個相異數字的所有「全排列」(Permutations)，",
        "en": "If using backtracking to generate all 'permutations' of N distinct numbers,",
        "wg": [
          {
            "t": "相異",
            "en": "distinct",
            "ps": "Adj"
          },
          {
            "t": "全排列",
            "en": "permutation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "其最差情況下的時間複雜度通常為何？",
        "en": "what is the typical time complexity in the worst case?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst case",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(2^N)",
        "en": "(B) O(2^N)",
        "wg": []
      },
      {
        "t": "(C) O(N!)",
        "en": "(C) O(N!)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "全排列問題需要產生所有可能的排列組合。對於 N 個元素，第一個位置有 N 種選擇，第二個有 N-1 種，依此類推，總共有 N! (N 的階乘) 種解，因此複雜度為 O(N!)。",
      "en": "The permutation problem requires generating all possible arrangements. For N elements, there are N choices for the first position, N-1 for the second, and so on, totaling N! (N factorial) solutions, so the complexity is O(N!).",
      "wg": [
        {
          "t": "階乘",
          "en": "factorial",
          "ps": "N"
        },
        {
          "t": "依此類推",
          "en": "and so on",
          "ps": "Idm"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Pruning, Optimization, Constraints",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在回溯演算法中，「剪枝」(Pruning) 的主要目的為何？",
        "en": "What is the primary purpose of 'Pruning' in backtracking algorithms?",
        "wg": [
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          },
          {
            "t": "主要目的",
            "en": "primary purpose",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出最能描述其對演算法效能影響的選項。",
        "en": "Please select the option that best describes its impact on algorithm performance.",
        "wg": [
          {
            "t": "效能",
            "en": "performance",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 增加遞迴深度以確保找到所有解。",
        "en": "(A) Increase recursion depth to ensure all solutions are found.",
        "wg": [
          {
            "t": "遞迴深度",
            "en": "recursion depth",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 提早排除不可能產生有效解的路徑，減少不必要的計算。",
        "en": "(B) Eliminate paths that cannot yield valid solutions early to reduce unnecessary computations.",
        "wg": [
          {
            "t": "排除",
            "en": "eliminate",
            "ps": "V"
          },
          {
            "t": "有效解",
            "en": "valid solution",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將遞迴結構轉換為迭代結構以節省記憶體。",
        "en": "(C) Convert the recursive structure to an iterative structure to save memory.",
        "wg": [
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 自動修正錯誤的程式邏輯。",
        "en": "(D) Automatically correct erroneous program logic.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "剪枝是回溯法優化的關鍵。透過檢查限制條件 (Constraints)，若發現當前路徑已不可能滿足條件，則立即停止該分支的深層探索，從而大幅縮減搜尋空間。",
      "en": "Pruning is key to optimizing backtracking. By checking constraints, if the current path is found to be impossible to satisfy conditions, deep exploration of that branch is stopped immediately, significantly reducing the search space.",
      "wg": [
        {
          "t": "限制條件",
          "en": "constraints",
          "ps": "N"
        },
        {
          "t": "搜尋空間",
          "en": "search space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Code Structure, State Restoration, Implementation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def backtrack(path, choices):\n    if goal_reached():\n        res.append(path[:])\n        return\n\n    for choice in choices:\n        if is_valid(choice):\n            path.append(choice)  # Make choice\n            backtrack(path, choices)\n            ___________________  # <--- Missing Line",
    "question": [
      {
        "t": "觀察上方的 Python 虛擬碼，這是回溯法的標準模板。",
        "en": "Observe the Python pseudo-code above; this is a standard template for backtracking.",
        "wg": [
          {
            "t": "虛擬碼",
            "en": "pseudo-code",
            "ps": "N"
          },
          {
            "t": "模板",
            "en": "template",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在遞迴呼叫 `backtrack` 結束後，底線處應該填入什麼程式碼以完成「狀態重置」？",
        "en": "After the recursive call to `backtrack` returns, what code should be filled in the blank to complete 'state restoration'?",
        "wg": [
          {
            "t": "狀態重置",
            "en": "state restoration",
            "ps": "N"
          },
          {
            "t": "底線",
            "en": "blank/underline",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) path.pop()",
        "en": "(A) path.pop()",
        "wg": []
      },
      {
        "t": "(B) return",
        "en": "(B) return",
        "wg": []
      },
      {
        "t": "(C) path.append(choice)",
        "en": "(C) path.append(choice)",
        "wg": []
      },
      {
        "t": "(D) continue",
        "en": "(D) continue",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是回溯法的核心步驟：撤銷選擇 (Undo)。在遞迴返回後，必須將剛剛加入 `path` 的元素移除，將狀態恢復到進入該分支前的樣子，以便在迴圈中嘗試下一個可能的選擇。",
      "en": "This is the core step of backtracking: Undo. After the recursion returns, the element just added to `path` must be removed to restore the state to how it was before entering that branch, allowing the loop to try the next possible choice.",
      "wg": [
        {
          "t": "撤銷選擇",
          "en": "undo choice",
          "ps": "N"
        },
        {
          "t": "恢復",
          "en": "restore",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Combinations, Permutations, Logic, Duplicates",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在使用回溯法尋找陣列 `[1, 2, 3]` 的所有「子集」(Subsets/Combinations) 時，",
        "en": "When using backtracking to find all 'subsets' (combinations) of the array `[1, 2, 3]`,",
        "wg": [
          {
            "t": "子集",
            "en": "subset",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了避免產生重複的組合（例如視 `[1, 2]` 與 `[2, 1]` 為相同），遞迴函式通常需要傳遞一個 `start_index` 參數。",
        "en": "to avoid generating duplicate combinations (e.g., treating `[1, 2]` and `[2, 1]` as the same), the recursive function usually needs to pass a `start_index` parameter.",
        "wg": [
          {
            "t": "重複",
            "en": "duplicate",
            "ps": "Adj"
          },
          {
            "t": "參數",
            "en": "parameter",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這個參數的主要作用為何？",
        "en": "What is the primary function of this parameter?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 限制下一層遞迴只能選擇當前索引之後的元素，確保選取順序。",
        "en": "(A) Restrict the next recursion level to only choose elements after the current index, ensuring selection order.",
        "wg": [
          {
            "t": "選取順序",
            "en": "selection order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 記錄目前路徑的長度，用於判斷是否結束。",
        "en": "(B) Record the length of the current path to determine if it should terminate.",
        "wg": []
      },
      {
        "t": "(C) 用來計算目前已經產生了多少個解。",
        "en": "(C) Used to count how many solutions have been generated so far.",
        "wg": []
      },
      {
        "t": "(D) 強制每次都從陣列的第一個元素開始重新掃描。",
        "en": "(D) Force a rescan from the first element of the array every time.",
        "wg": [
          {
            "t": "重新掃描",
            "en": "rescan",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在求組合（子集）問題中，順序不影響結果（即集合概念）。透過 `start_index` 確保每次遞迴只考慮當前元素之後的數字，可以強迫選出的元素索引是遞增的，從而避免如 `[2, 1]` 這種回頭選取的情況。",
      "en": "In combination (subset) problems, order does not matter (set concept). Using `start_index` ensures that each recursion only considers numbers after the current element, forcing the selected element indices to be increasing, thus avoiding backward selection like `[2, 1]`.",
      "wg": [
        {
          "t": "遞增",
          "en": "increasing",
          "ps": "Adj"
        },
        {
          "t": "回頭選取",
          "en": "backward selection",
          "ps": "N"
        }
      ]
    }
  }
]