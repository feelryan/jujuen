[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Backtracking, Permutations, Duplicates, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;",
    "question": [
      {
        "t": "在處理包含重複數字的陣列（例如 `[1, 1, 2]`）的全排列問題時，我們通常會先將陣列排序。",
        "en": "When dealing with the permutations of an array containing duplicates (e.g., `[1, 1, 2]`), we usually sort the array first.",
        "wg": [
          {
            "t": "全排列",
            "en": "permutations",
            "ps": "N"
          },
          {
            "t": "重複",
            "en": "duplicates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在回溯過程中，使用上述程式碼片段的主要目的是什麼？",
        "en": "What is the primary purpose of using the code snippet above during the backtracking process?",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "主要目的",
            "en": "primary purpose",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 確保產生的排列長度等於原始陣列長度。",
        "en": "(A) Ensure the length of generated permutations equals the original array length.",
        "wg": []
      },
      {
        "t": "(B) 避免產生重複的排列結果（去重）。",
        "en": "(B) Avoid generating duplicate permutation results (deduplication).",
        "wg": [
          {
            "t": "去重",
            "en": "deduplication",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 確保排列是按照升序產生的。",
        "en": "(C) Ensure the permutations are generated in ascending order.",
        "wg": []
      },
      {
        "t": "(D) 最佳化記憶體使用量。",
        "en": "(D) Optimize memory usage.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `nums[i] == nums[i-1]` 且 `!used[i-1]` 時，表示前一個相同的數字在當前層級尚未被使用（或已被回溯撤銷），若此時選取 `nums[i]` 將會造成重複的排列分支，因此需跳過以達到去重效果。",
      "en": "When `nums[i] == nums[i-1]` and `!used[i-1]`, it indicates that the previous identical number has not been used in the current level (or has been backtracked). Selecting `nums[i]` at this point would cause a duplicate permutation branch, so it must be skipped to achieve deduplication.",
      "wg": [
        {
          "t": "層級",
          "en": "level",
          "ps": "N"
        },
        {
          "t": "撤銷",
          "en": "reverted",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Backtracking, Combination Sum, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void backtrack(int[] candidates, int target, int start_index, List<Integer> path) {\n    ...\n    for (int i = start_index; i < candidates.length; i++) {\n        path.add(candidates[i]);\n        // Option A: backtrack(..., i, ...);\n        // Option B: backtrack(..., i + 1, ...);\n        path.remove(path.size() - 1);\n    }\n}",
    "question": [
      {
        "t": "在「組合總和」(Combination Sum) 問題中，如果題目允許陣列中的同一個數字被無限制重複選取。",
        "en": "In the 'Combination Sum' problem, if the problem allows the same number in the array to be selected unlimited times.",
        "wg": [
          {
            "t": "無限制",
            "en": "unlimited",
            "ps": "Adj"
          },
          {
            "t": "選取",
            "en": "selected",
            "ps": "V"
          }
        ]
      },
      {
        "t": "您應該在遞迴呼叫時選擇哪種索引傳遞方式？",
        "en": "Which index passing method should you choose in the recursive call?",
        "wg": [
          {
            "t": "遞迴呼叫",
            "en": "recursive call",
            "ps": "N"
          },
          {
            "t": "傳遞",
            "en": "passing",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 傳入 `i`，表示下一層遞迴仍可考慮當前元素。",
        "en": "(A) Pass `i`, indicating the next recursion level can still consider the current element.",
        "wg": []
      },
      {
        "t": "(B) 傳入 `i + 1`，表示下一層遞迴必須從下一個元素開始。",
        "en": "(B) Pass `i + 1`, indicating the next recursion level must start from the next element.",
        "wg": []
      },
      {
        "t": "(C) 傳入 `start_index`，表示每次都從頭開始搜尋。",
        "en": "(C) Pass `start_index`, indicating searching from the beginning every time.",
        "wg": []
      },
      {
        "t": "(D) 傳入 `i - 1`，表示回頭重新考慮前一個元素。",
        "en": "(D) Pass `i - 1`, indicating looking back to reconsider the previous element.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若允許重複選取同一個元素，遞迴時不應移動索引至下一個位置，而是保持在當前索引 `i`，讓下一層遞迴有機會再次選取該數字。",
      "en": "If selecting the same element repeatedly is allowed, the recursion should not move the index to the next position but stay at the current index `i`, giving the next recursion level a chance to select that number again.",
      "wg": [
        {
          "t": "索引",
          "en": "index",
          "ps": "N"
        },
        {
          "t": "保持",
          "en": "stay/remain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "Time Complexity, Backtracking, Permutations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "對於一個長度為 N 的不重複數字陣列，使用回溯法產生所有全排列 (Permutations)。",
        "en": "For an array of N distinct numbers, using backtracking to generate all permutations.",
        "wg": [
          {
            "t": "不重複",
            "en": "distinct",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "其時間複雜度最接近下列何者？",
        "en": "Which of the following is closest to its time complexity?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(2^N)",
        "en": "(B) O(2^N)",
        "wg": []
      },
      {
        "t": "(C) O(N!)",
        "en": "(C) O(N!)",
        "wg": []
      },
      {
        "t": "(D) O(log N)",
        "en": "(D) O(log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "全排列的總數為 N! (N 階乘)，回溯法必須拜訪每一個排列結果，因此時間複雜度主要由 N! 決定（嚴格來說通常是 O(N * N!)，因為複製路徑需要 O(N)）。",
      "en": "The total number of permutations is N! (N factorial). Backtracking must visit every permutation result, so the time complexity is dominated by N! (strictly speaking, it is often O(N * N!) because copying the path takes O(N)).",
      "wg": [
        {
          "t": "階乘",
          "en": "factorial",
          "ps": "N"
        },
        {
          "t": "拜訪",
          "en": "visit",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "easy",
    "keywords": "Backtracking, State Restoration, Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": "path.add(nums[i]);\nbacktrack(...);\npath.remove(path.size() - 1); // <--- This line",
    "question": [
      {
        "t": "在回溯演算法的樣板中，遞迴呼叫後的 `path.remove(path.size() - 1)` 操作稱為什麼？",
        "en": "In the backtracking algorithm template, what is the operation `path.remove(path.size() - 1)` after the recursive call called?",
        "wg": [
          {
            "t": "樣板",
            "en": "template",
            "ps": "N"
          },
          {
            "t": "操作",
            "en": "operation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼這個步驟是必要的？",
        "en": "Why is this step necessary?",
        "wg": [
          {
            "t": "必要的",
            "en": "necessary",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 狀態重置 (State Reset)；為了清除當前選擇，讓父節點可以探索其他分支。",
        "en": "(A) State Reset; to clear the current selection so the parent node can explore other branches.",
        "wg": [
          {
            "t": "狀態重置",
            "en": "state reset",
            "ps": "N"
          },
          {
            "t": "探索",
            "en": "explore",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 記憶化 (Memoization)；為了儲存計算結果以供未來使用。",
        "en": "(B) Memoization; to store calculation results for future use.",
        "wg": []
      },
      {
        "t": "(C) 終止條件 (Base Case)；為了防止無窮遞迴。",
        "en": "(C) Base Case; to prevent infinite recursion.",
        "wg": []
      },
      {
        "t": "(D) 貪婪選擇 (Greedy Choice)；為了確保每次都選擇最佳解。",
        "en": "(D) Greedy Choice; to ensure the best solution is chosen every time.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是回溯法的核心機制，稱為「撤銷」或「狀態重置」。在遞迴返回後，必須將路徑恢復到進入該節點前的狀態，才能正確地嘗試下一個可能的選項。",
      "en": "This is the core mechanism of backtracking, known as 'undo' or 'state reset'. After the recursion returns, the path must be restored to the state it was in before entering that node to correctly attempt the next possible option.",
      "wg": [
        {
          "t": "核心機制",
          "en": "core mechanism",
          "ps": "N"
        },
        {
          "t": "恢復",
          "en": "restore",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Backtracking, Pruning, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (currentSum > target) return;",
    "question": [
      {
        "t": "在解決「子集總和」問題時，若我們在遞迴函數開頭加入 `if (currentSum > target) return;`。",
        "en": "When solving the 'Subset Sum' problem, if we add `if (currentSum > target) return;` at the beginning of the recursive function.",
        "wg": [
          {
            "t": "子集總和",
            "en": "subset sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這種技巧在演算法術語中稱為什麼？",
        "en": "What is this technique called in algorithmic terminology?",
        "wg": [
          {
            "t": "技巧",
            "en": "technique",
            "ps": "N"
          },
          {
            "t": "術語",
            "en": "terminology",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 動態規劃 (Dynamic Programming)",
        "en": "(A) Dynamic Programming",
        "wg": []
      },
      {
        "t": "(B) 剪枝 (Pruning)",
        "en": "(B) Pruning",
        "wg": [
          {
            "t": "剪枝",
            "en": "pruning",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 分治法 (Divide and Conquer)",
        "en": "(C) Divide and Conquer",
        "wg": []
      },
      {
        "t": "(D) 廣度優先搜尋 (BFS)",
        "en": "(D) Breadth-First Search (BFS)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "剪枝 (Pruning) 是指在搜索過程中，提前判斷當前路徑不可能產生滿足條件的解，從而放棄該路徑的後續搜索，以減少不必要的計算量。",
      "en": "Pruning refers to determining early in the search process that the current path cannot yield a solution satisfying the conditions, thereby abandoning further search along that path to reduce unnecessary computation.",
      "wg": [
        {
          "t": "放棄",
          "en": "abandoning",
          "ps": "V"
        },
        {
          "t": "計算量",
          "en": "computation",
          "ps": "N"
        }
      ]
    }
  }
]