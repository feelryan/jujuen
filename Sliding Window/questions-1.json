[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Sliding Window, Fixed Window, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1, 3, 2, 6, -1, 4, 1, 8, 2], k = 5",
    "question": [
      {
        "t": "給定一個整數陣列與一個整數 k，我們想要找出長度為 k 的連續子陣列的最大總和。",
        "en": "Given an integer array and an integer k, we want to find the maximum sum of a contiguous subarray of length k.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "contiguous subarray",
            "ps": "N"
          },
          {
            "t": "整數",
            "en": "integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用滑動視窗 (Sliding Window) 技巧，當視窗向右移動一步時，應該如何更新當前的總和以達到最佳效率？",
        "en": "If using the Sliding Window technique, how should the current sum be updated to achieve optimal efficiency when the window moves one step to the right?",
        "wg": [
          {
            "t": "最佳效率",
            "en": "optimal efficiency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 重新計算視窗內所有 k 個元素的總和。",
        "en": "(A) Recalculate the sum of all k elements within the window.",
        "wg": []
      },
      {
        "t": "(B) 減去剛離開視窗的最左側元素，並加上剛進入視窗的最右側元素。",
        "en": "(B) Subtract the leftmost element that just left the window and add the rightmost element that just entered the window.",
        "wg": [
          {
            "t": "離開",
            "en": "left / exit",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 比較新舊視窗的中位數，並根據差異調整總和。",
        "en": "(C) Compare the medians of the old and new windows and adjust the sum based on the difference.",
        "wg": [
          {
            "t": "中位數",
            "en": "median",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 只有當新元素大於舊元素時才更新總和。",
        "en": "(D) Update the sum only if the new element is greater than the old element.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "滑動視窗的核心優勢在於避免重複計算。透過「減去移出項、加上移入項」，我們可以在 O(1) 時間內更新視窗狀態，而不是 O(k)。",
      "en": "The core advantage of the Sliding Window is avoiding redundant calculations. By 'subtracting the outgoing element and adding the incoming element', we can update the window state in O(1) time instead of O(k).",
      "wg": [
        {
          "t": "重複計算",
          "en": "redundant calculation",
          "ps": "N"
        },
        {
          "t": "移出項",
          "en": "outgoing element",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Sliding Window, Dynamic Window, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int left = 0, right = 0;\nwhile (right < n) {\n    // add nums[right] to window\n    while (condition_met) {\n        // remove nums[left]\n        left++;\n    }\n    right++;\n}",
    "question": [
      {
        "t": "在解決「長度最小的子陣列」這類動態滑動視窗問題時，我們通常使用雙指標 (Left, Right)。",
        "en": "When solving dynamic sliding window problems like 'Minimum Size Subarray', we typically use two pointers (Left, Right).",
        "wg": [
          {
            "t": "雙指標",
            "en": "two pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請參考上方的程式碼結構，判斷此演算法的時間複雜度為何？",
        "en": "Please refer to the code snippet above and determine the time complexity of this algorithm.",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)，因為有一個 while 迴圈嵌套在另一個 while 迴圈內。",
        "en": "(A) O(N^2), because there is a while loop nested inside another while loop.",
        "wg": [
          {
            "t": "嵌套",
            "en": "nested",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) O(N log N)，因為視窗大小是動態變化的。",
        "en": "(B) O(N log N), because the window size changes dynamically.",
        "wg": []
      },
      {
        "t": "(C) O(N)，因為每個元素最多被 Right 指標訪問一次，並被 Left 指標移除一次。",
        "en": "(C) O(N), because each element is visited at most once by the Right pointer and removed at most once by the Left pointer.",
        "wg": [
          {
            "t": "訪問",
            "en": "visit",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) O(1)，因為這是在原地 (In-place) 操作。",
        "en": "(D) O(1), because this is an in-place operation.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雖然有雙層迴圈，但 Left 和 Right 指標都只會單向移動（不回頭）。每個元素最多進出視窗各一次，總操作次數約為 2N，因此為線性時間 O(N)。",
      "en": "Although there are nested loops, both Left and Right pointers only move unidirectionally (no backtracking). Each element enters and leaves the window at most once, resulting in roughly 2N operations, which is linear time O(N).",
      "wg": [
        {
          "t": "單向移動",
          "en": "move unidirectionally",
          "ps": "V"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Sliding Window, String, Hash Set",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "題目要求找出字串中「不含重複字元的最長子字串長度」。",
        "en": "The problem asks to find the 'length of the longest substring without repeating characters' in a string.",
        "wg": [
          {
            "t": "重複字元",
            "en": "repeating characters",
            "ps": "N"
          },
          {
            "t": "子字串",
            "en": "substring",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在使用滑動視窗解題時，當 Right 指標遇到一個已經存在於視窗內的字元時，下一步該怎麼做？",
        "en": "When solving with a sliding window, what is the next step when the Right pointer encounters a character that already exists within the window?",
        "wg": [
          {
            "t": "遇到",
            "en": "encounter",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 停止程式並回傳目前的長度。",
        "en": "(A) Stop the program and return the current length.",
        "wg": []
      },
      {
        "t": "(B) 移動 Left 指標收縮視窗，直到重複的字元被移出視窗為止。",
        "en": "(B) Move the Left pointer to shrink the window until the duplicate character is removed from the window.",
        "wg": [
          {
            "t": "收縮",
            "en": "shrink",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 將 Right 指標重置到 Left 指標的下一個位置重新開始。",
        "en": "(C) Reset the Right pointer to the position next to the Left pointer and restart.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 忽略該重複字元，繼續移動 Right 指標。",
        "en": "(D) Ignore the duplicate character and continue moving the Right pointer.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了維持視窗內「無重複字元」的條件，當遇到重複時，必須移動 Left 指標來排除舊的重複項，才能讓新的字元合法進入視窗。",
      "en": "To maintain the condition of 'no repeating characters' inside the window, when a duplicate is encountered, the Left pointer must be moved to exclude the old duplicate so that the new character can validly enter the window.",
      "wg": [
        {
          "t": "排除",
          "en": "exclude",
          "ps": "V"
        },
        {
          "t": "合法",
          "en": "validly",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Sliding Window, Concept, Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "滑動視窗 (Sliding Window) 演算法最適合應用於下列哪一種資料結構或情境？",
        "en": "Which of the following data structures or scenarios is the Sliding Window algorithm most suitable for?",
        "wg": [
          {
            "t": "應用於",
            "en": "apply to",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鏈結串列 (Linked List) 中的隨機存取問題。",
        "en": "(A) Random access problems in a Linked List.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 二元樹 (Binary Tree) 的層序遍歷。",
        "en": "(B) Level-order traversal of a Binary Tree.",
        "wg": [
          {
            "t": "層序遍歷",
            "en": "level-order traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 陣列 (Array) 或字串 (String) 中的連續區間問題。",
        "en": "(C) Contiguous interval problems in an Array or String.",
        "wg": [
          {
            "t": "連續區間",
            "en": "contiguous interval",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 雜湊表 (Hash Map) 的鍵值碰撞處理。",
        "en": "(D) Handling key collisions in a Hash Map.",
        "wg": [
          {
            "t": "碰撞",
            "en": "collision",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "滑動視窗依賴於資料的「連續性」與「順序性」，透過指標移動來維護區間狀態，因此最適合處理陣列或字串中的連續子序列問題。",
      "en": "Sliding Window relies on the 'continuity' and 'ordering' of data, maintaining interval states by moving pointers, making it most suitable for contiguous subsequence problems in arrays or strings.",
      "wg": [
        {
          "t": "連續性",
          "en": "continuity",
          "ps": "N"
        },
        {
          "t": "順序性",
          "en": "ordering",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Sliding Window, Optimization, Negative Numbers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, -10, 2, 3, -5, 7]",
    "question": [
      {
        "t": "關於滑動視窗的適用限制，若陣列中包含「負數」，下列哪種問題通常**無法**直接使用標準的滑動視窗（雙指標收縮）來解決？",
        "en": "Regarding the limitations of Sliding Window, if the array contains 'negative numbers', which of the following problems usually **cannot** be directly solved using the standard sliding window (two-pointer shrinking)?",
        "wg": [
          {
            "t": "適用限制",
            "en": "applicability limitation",
            "ps": "N"
          },
          {
            "t": "收縮",
            "en": "shrink",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 找出長度固定為 k 的子陣列最大總和。",
        "en": "(A) Find the maximum sum of a subarray of fixed length k.",
        "wg": []
      },
      {
        "t": "(B) 找出總和「大於等於」某個目標值 S 的最小長度子陣列。",
        "en": "(B) Find the minimal length subarray with a sum 'greater than or equal to' a target value S.",
        "wg": []
      },
      {
        "t": "(C) 找出字串中包含所有目標字元的最小視窗。",
        "en": "(C) Find the minimum window in a string that contains all target characters.",
        "wg": []
      },
      {
        "t": "(D) 計算視窗內不同整數的個數。",
        "en": "(D) Count the number of distinct integers within the window.",
        "wg": [
          {
            "t": "不同",
            "en": "distinct",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當陣列含有負數時，擴大視窗（Right++）不一定會增加總和，縮小視窗（Left++）也不一定會減少總和，這破壞了滑動視窗所需的單調性，導致無法正確判斷何時該收縮。",
      "en": "When the array contains negative numbers, expanding the window (Right++) does not necessarily increase the sum, and shrinking it (Left++) does not necessarily decrease the sum. This breaks the monotonicity required for Sliding Window, making it impossible to correctly determine when to shrink.",
      "wg": [
        {
          "t": "單調性",
          "en": "monotonicity",
          "ps": "N"
        },
        {
          "t": "破壞",
          "en": "break / violate",
          "ps": "V"
        }
      ]
    }
  }
]