[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Minimum Size Subarray Sum, Variable Window, Shrinking",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (currentSum >= target) {\n    minLen = min(minLen, right - left + 1);\n    currentSum -= nums[left];\n    left++;\n}",
    "question": [
      {
        "t": "在解決「長度最小的子陣列總和」(Minimum Size Subarray Sum) 問題時，我們使用變動大小的滑動視窗。",
        "en": "When solving the 'Minimum Size Subarray Sum' problem, we use a variable-size sliding window.",
        "wg": [
          {
            "t": "變動大小",
            "en": "variable-size",
            "ps": "Adj"
          },
          {
            "t": "子陣列",
            "en": "subarray",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在什麼條件下，我們需要移動左指標 (left pointer) 來縮小視窗？",
        "en": "Under what condition do we need to move the left pointer to shrink the window?",
        "wg": [
          {
            "t": "縮小",
            "en": "shrink",
            "ps": "V"
          },
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當視窗內的總和小於目標值 (target) 時。",
        "en": "(A) When the sum within the window is less than the target.",
        "wg": []
      },
      {
        "t": "(B) 當視窗內的總和等於 0 時。",
        "en": "(B) When the sum within the window equals 0.",
        "wg": []
      },
      {
        "t": "(C) 當視窗內的總和大於或等於目標值 (target) 時。",
        "en": "(C) When the sum within the window is greater than or equal to the target.",
        "wg": []
      },
      {
        "t": "(D) 左指標永遠不移動，只移動右指標。",
        "en": "(D) The left pointer never moves; only the right pointer moves.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在這個問題中，我們的目標是找到滿足條件 (總和 >= target) 的最小長度。一旦當前視窗的總和滿足條件，我們就嘗試透過移動左指標來縮小視窗，以檢查是否有更短的子陣列也能滿足條件。",
      "en": "In this problem, our goal is to find the minimal length that satisfies the condition (sum >= target). Once the current window's sum satisfies the condition, we attempt to shrink the window by moving the left pointer to check if a shorter subarray also meets the requirement.",
      "wg": [
        {
          "t": "滿足條件",
          "en": "satisfy the condition",
          "ps": "VP"
        },
        {
          "t": "最小長度",
          "en": "minimal length",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Time Complexity, Linear Time, Amortized Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "對於一個標準的滑動視窗演算法，若左指標 (left) 和右指標 (right) 都只會從陣列的開頭移動到結尾且不回頭。",
        "en": "For a standard sliding window algorithm, if both the left and right pointers only move from the start to the end of the array without moving backward.",
        "wg": [
          {
            "t": "回頭",
            "en": "move backward",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "該演算法的時間複雜度通常是多少？",
        "en": "What is the typical time complexity of this algorithm?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N^2)",
        "en": "(A) O(N^2)",
        "wg": []
      },
      {
        "t": "(B) O(N log N)",
        "en": "(B) O(N log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(1)",
        "en": "(D) O(1)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在滑動視窗中，每個元素最多被右指標加入視窗一次，且最多被左指標移除視窗一次。因此，總操作次數與陣列長度 N 成正比，為線性時間 O(N)。",
      "en": "In a sliding window, each element is added to the window at most once by the right pointer and removed at most once by the left pointer. Therefore, the total number of operations is proportional to the array length N, resulting in linear time O(N).",
      "wg": [
        {
          "t": "成正比",
          "en": "proportional to",
          "ps": "Adj"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Longest Substring, Hash Set, Duplicates",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「無重複字元的最長子字串」(Longest Substring Without Repeating Characters) 問題時，我們需要快速檢查新進入視窗的字元是否已經存在。",
        "en": "When solving the 'Longest Substring Without Repeating Characters' problem, we need to quickly check if a character entering the window already exists.",
        "wg": [
          {
            "t": "無重複",
            "en": "without repeating",
            "ps": "Adj"
          },
          {
            "t": "子字串",
            "en": "substring",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種資料結構最適合用來儲存視窗內的字元以達到最佳效率？",
        "en": "Which of the following data structures is most suitable for storing characters within the window to achieve optimal efficiency?",
        "wg": [
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "N"
          },
          {
            "t": "最佳效率",
            "en": "optimal efficiency",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)",
        "en": "(A) Stack",
        "wg": []
      },
      {
        "t": "(B) 雜湊集合 (Hash Set) 或布林陣列 (Boolean Array)",
        "en": "(B) Hash Set or Boolean Array",
        "wg": [
          {
            "t": "雜湊集合",
            "en": "Hash Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 優先佇列 (Priority Queue)",
        "en": "(C) Priority Queue",
        "wg": []
      },
      {
        "t": "(D) 鏈結串列 (Linked List)",
        "en": "(D) Linked List",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們需要 O(1) 的時間複雜度來檢查字元是否存在於當前視窗中。雜湊集合 (Hash Set) 或固定大小的陣列 (若字元集有限，如 ASCII) 提供了最快的查找速度。",
      "en": "We need O(1) time complexity to check if a character exists in the current window. A Hash Set or a fixed-size array (if the character set is limited, like ASCII) provides the fastest lookup speed.",
      "wg": [
        {
          "t": "查找速度",
          "en": "lookup speed",
          "ps": "N"
        },
        {
          "t": "字元集",
          "en": "character set",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Subarray vs Subsequence, Concept Clarification",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "滑動視窗技術主要依賴於資料的「連續性」。",
        "en": "Sliding window technique primarily relies on the 'contiguousness' of data.",
        "wg": [
          {
            "t": "連續性",
            "en": "contiguousness",
            "ps": "N"
          }
        ]
      },
      {
        "t": "因此，下列哪一種問題類型通常**不適合**直接使用標準的滑動視窗來解決？",
        "en": "Therefore, which of the following problem types is generally **NOT suitable** for being solved directly using a standard sliding window?",
        "wg": [
          {
            "t": "不適合",
            "en": "not suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 尋找總和最大的連續子陣列 (Maximum Sum Subarray)。",
        "en": "(A) Finding the Maximum Sum Subarray.",
        "wg": []
      },
      {
        "t": "(B) 尋找最長的無重複字元子字串 (Longest Substring Without Repeating Characters)。",
        "en": "(B) Finding the Longest Substring Without Repeating Characters.",
        "wg": []
      },
      {
        "t": "(C) 尋找最長遞增子序列 (Longest Increasing Subsequence)。",
        "en": "(C) Finding the Longest Increasing Subsequence.",
        "wg": [
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 尋找包含所有目標字元的最小視窗 (Minimum Window Substring)。",
        "en": "(D) Finding the Minimum Window Substring containing all target characters.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "「子序列」(Subsequence) 不需要元素是連續的，可以跳過中間的元素。滑動視窗本質上是在維護一個「連續」的區間，因此無法直接處理非連續的子序列問題 (通常使用動態規劃解决)。",
      "en": "A 'Subsequence' does not require elements to be contiguous and can skip intermediate elements. Sliding window inherently maintains a 'contiguous' range, so it cannot directly handle non-contiguous subsequence problems (usually solved using Dynamic Programming).",
      "wg": [
        {
          "t": "本質上",
          "en": "inherently",
          "ps": "Adv"
        },
        {
          "t": "動態規劃",
          "en": "Dynamic Programming",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "hard",
    "keywords": "Max Consecutive Ones III, Flipping, At Most K",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int left = 0, right;\nfor (right = 0; right < nums.length; right++) {\n    if (nums[right] == 0) zeroCount++;\n    while (zeroCount > K) {\n        if (nums[left] == 0) zeroCount--;\n        left++;\n    }\n    maxLen = max(maxLen, right - left + 1);\n}",
    "question": [
      {
        "t": "考慮一個問題：給定一個二進位陣列，你可以將最多 K 個 0 翻轉成 1，求最長的連續 1 子陣列長度。",
        "en": "Consider a problem: Given a binary array, you can flip at most K 0s to 1s. Find the length of the longest contiguous subarray of 1s.",
        "wg": [
          {
            "t": "二進位陣列",
            "en": "binary array",
            "ps": "N"
          },
          {
            "t": "翻轉",
            "en": "flip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這可以轉化為滑動視窗問題。請問這個視窗需要滿足什麼條件才算合法？",
        "en": "This can be transformed into a sliding window problem. What condition must the window satisfy to be considered valid?",
        "wg": [
          {
            "t": "轉化",
            "en": "transform",
            "ps": "V"
          },
          {
            "t": "合法",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 視窗內的 1 的數量不超過 K。",
        "en": "(A) The count of 1s inside the window does not exceed K.",
        "wg": []
      },
      {
        "t": "(B) 視窗內的 0 的數量不超過 K。",
        "en": "(B) The count of 0s inside the window does not exceed K.",
        "wg": []
      },
      {
        "t": "(C) 視窗的長度不超過 K。",
        "en": "(C) The length of the window does not exceed K.",
        "wg": []
      },
      {
        "t": "(D) 視窗內的總和必須等於 K。",
        "en": "(D) The sum inside the window must equal K.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "題目允許翻轉最多 K 個 0，這意味著我們尋找的最長子陣列中，原本是 0 的個數不能超過 K 個。只要視窗內的 0 小於等於 K，我們就可以把它們全部視為 1。",
      "en": "The problem allows flipping at most K 0s, which means in the longest subarray we look for, the number of original 0s cannot exceed K. As long as the 0s in the window are less than or equal to K, we can treat them all as 1s.",
      "wg": [
        {
          "t": "意味著",
          "en": "implies",
          "ps": "V"
        },
        {
          "t": "視為",
          "en": "treat as",
          "ps": "V"
        }
      ]
    }
  }
]