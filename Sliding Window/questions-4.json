[
  {
    "no": "16",
    "level": "hard",
    "keywords": "Sliding Window Maximum, Monotonic Queue, Deque, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在處理一個需要即時分析數據流的系統，目標是找出每個長度為 k 的滑動視窗中的最大值。",
        "en": "You are working on a system that analyzes data streams in real-time, aiming to find the maximum value in every sliding window of length k.",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          },
          {
            "t": "數據流",
            "en": "data stream",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用暴力法，時間複雜度為 O(N*k)。為了將時間複雜度優化至 O(N)，應該搭配哪種資料結構來維護視窗內的候選元素？",
        "en": "Using a brute-force approach results in O(N*k) time complexity. To optimize this to O(N), which data structure should be used to maintain candidate elements within the window?",
        "wg": [
          {
            "t": "暴力法",
            "en": "brute-force",
            "ps": "N"
          },
          {
            "t": "候選元素",
            "en": "candidate elements",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 最小堆積 (Min Heap)",
        "en": "(A) Min Heap",
        "wg": []
      },
      {
        "t": "(B) 單調遞減雙端隊列 (Monotonic Decreasing Deque)",
        "en": "(B) Monotonic Decreasing Deque",
        "wg": [
          {
            "t": "單調遞減",
            "en": "monotonic decreasing",
            "ps": "Adj"
          },
          {
            "t": "雙端隊列",
            "en": "deque",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 雜湊表 (Hash Map)",
        "en": "(C) Hash Map",
        "wg": []
      },
      {
        "t": "(D) 二元搜尋樹 (Binary Search Tree)",
        "en": "(D) Binary Search Tree",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用單調遞減雙端隊列 (Deque) 可以存儲視窗內可能成為最大值的元素索引。當新元素進入時，移除隊列尾部所有小於新元素的索引（因為它們不可能是最大值了），並移除隊列頭部超出視窗範圍的索引，確保隊首始終是當前視窗的最大值。",
      "en": "Using a Monotonic Decreasing Deque allows storing indices of potential maximum values in the window. When a new element enters, remove all indices from the tail that correspond to values smaller than the new element (as they cannot be the maximum), and remove indices from the head that are out of the window scope, ensuring the head always holds the maximum of the current window.",
      "wg": [
        {
          "t": "索引",
          "en": "indices",
          "ps": "N"
        },
        {
          "t": "超出範圍",
          "en": "out of scope",
          "ps": "Phrase"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "String, Anagrams, Fixed Window, Frequency Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"cbaebabacd\", p = \"abc\"",
    "question": [
      {
        "t": "給定一個字串 s 和一個目標字串 p，您需要找出 s 中所有是 p 的「易位構詞」(Anagrams) 的子字串起始索引。",
        "en": "Given a string s and a target string p, you need to find all start indices of substrings in s that are 'Anagrams' of p.",
        "wg": [
          {
            "t": "易位構詞",
            "en": "anagrams",
            "ps": "N"
          },
          {
            "t": "起始索引",
            "en": "start indices",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在此情境下，最適合的滑動視窗策略是什麼？",
        "en": "In this scenario, what is the most suitable sliding window strategy?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用可變大小視窗，當遇到不在 p 中的字元時重置視窗。",
        "en": "(A) Use a variable-size window, resetting the window when a character not in p is encountered.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用固定大小視窗（長度為 p 的長度），並維護兩個頻率陣列（或雜湊表）來比較字元計數。",
        "en": "(B) Use a fixed-size window (length equal to p's length) and maintain two frequency arrays (or hash maps) to compare character counts.",
        "wg": [
          {
            "t": "頻率陣列",
            "en": "frequency arrays",
            "ps": "N"
          },
          {
            "t": "字元計數",
            "en": "character counts",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 對 s 的每個子字串進行排序，並與排序後的 p 進行比較。",
        "en": "(C) Sort every substring of s and compare it with the sorted p.",
        "wg": []
      },
      {
        "t": "(D) 使用雙指針，左指針固定，右指針移動直到找到匹配。",
        "en": "(D) Use two pointers, keeping the left pointer fixed and moving the right pointer until a match is found.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為易位構詞的長度必須與 p 相同，所以應使用固定大小視窗。透過比較視窗內字元的頻率分佈與 p 的頻率分佈是否一致，可以在 O(N) 時間內解決問題，而無需對每個子字串排序 (O(N * K log K))。",
      "en": "Since anagrams must have the same length as p, a fixed-size window should be used. By comparing the frequency distribution of characters in the window with that of p, the problem can be solved in O(N) time, avoiding sorting every substring (O(N * K log K)).",
      "wg": [
        {
          "t": "頻率分佈",
          "en": "frequency distribution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Variable Window, Hash Map, Longest Substring, Distinct Characters",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「含有至多 K 個不同字元的最長子字串」問題時，我們通常使用雜湊表 (Hash Map) 搭配滑動視窗。",
        "en": "When solving the 'Longest Substring with At Most K Distinct Characters' problem, we typically use a Hash Map combined with a sliding window.",
        "wg": [
          {
            "t": "至多",
            "en": "at most",
            "ps": "Adv"
          },
          {
            "t": "不同字元",
            "en": "distinct characters",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當視窗內的「不同字元數量」超過 K 時，應該如何操作左指針 (Left Pointer)？",
        "en": "When the number of 'distinct characters' in the window exceeds K, how should the Left Pointer be manipulated?",
        "wg": [
          {
            "t": "超過",
            "en": "exceeds",
            "ps": "V"
          },
          {
            "t": "操作",
            "en": "manipulate",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將左指針直接移動到右指針的位置，重新開始。",
        "en": "(A) Move the left pointer directly to the right pointer's position and restart.",
        "wg": []
      },
      {
        "t": "(B) 將左指針向右移動，並減少雜湊表中對應字元的計數，直到不同字元數量回到 K。",
        "en": "(B) Move the left pointer to the right and decrement the count of the corresponding character in the hash map until the number of distinct characters returns to K.",
        "wg": [
          {
            "t": "減少",
            "en": "decrement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 保持左指針不動，繼續移動右指針尋找下一個可能的字元。",
        "en": "(C) Keep the left pointer stationary and continue moving the right pointer to find the next possible character.",
        "wg": [
          {
            "t": "不動",
            "en": "stationary",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 立即回傳當前的視窗長度作為最大值。",
        "en": "(D) Immediately return the current window length as the maximum.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是可變視窗的典型收縮策略。當條件不滿足（不同字元 > K）時，必須收縮左邊界，並同時更新雜湊表中的計數。若某字元計數歸零，則將其從表中移除，直到不同字元數 <= K 為止。",
      "en": "This is the typical shrinking strategy for a variable window. When the condition is violated (distinct characters > K), the left boundary must be shrunk, and the counts in the hash map updated simultaneously. If a character's count drops to zero, it is removed from the map until the distinct count is <= K.",
      "wg": [
        {
          "t": "收縮",
          "en": "shrink",
          "ps": "V"
        },
        {
          "t": "違反",
          "en": "violated",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Minimum Window Substring, Optimization, Logic Flow",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「最小覆蓋子字串」(Minimum Window Substring) 問題（找出包含目標字串 t 所有字元的最小 s 子字串），下列哪一個描述了正確的演算法流程？",
        "en": "Regarding the 'Minimum Window Substring' problem (finding the smallest substring of s containing all characters of target string t), which of the following describes the correct algorithmic flow?",
        "wg": [
          {
            "t": "最小覆蓋子字串",
            "en": "Minimum Window Substring",
            "ps": "N"
          },
          {
            "t": "演算法流程",
            "en": "algorithmic flow",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 固定視窗大小為 t 的長度，逐步向右掃描，若不符合則擴大視窗。",
        "en": "(A) Fix the window size to the length of t, scan rightwards, and expand the window if it doesn't match.",
        "wg": []
      },
      {
        "t": "(B) 擴張右指針直到視窗包含 t 的所有字元，然後嘗試收縮左指針以找到局部最小值，重複此過程。",
        "en": "(B) Expand the right pointer until the window contains all characters of t, then try to shrink the left pointer to find the local minimum, repeating this process.",
        "wg": [
          {
            "t": "擴張",
            "en": "expand",
            "ps": "V"
          },
          {
            "t": "局部最小值",
            "en": "local minimum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 先找出 s 中所有 t 的字元位置，然後使用動態規劃計算最小距離。",
        "en": "(C) First find all positions of t's characters in s, then use dynamic programming to calculate the minimum distance.",
        "wg": []
      },
      {
        "t": "(D) 使用兩個不重疊的視窗分別從頭和尾開始搜尋。",
        "en": "(D) Use two non-overlapping windows searching from the start and end respectively.",
        "wg": [
          {
            "t": "不重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "此問題的核心在於「先滿足條件，再優化長度」。我們移動右指針直到視窗「有效」（包含所有 t 的字元），接著移動左指針來移除不必要的字元，直到視窗不再有效，藉此找到最小長度。",
      "en": "The core of this problem is 'satisfy the condition first, then optimize the length'. We move the right pointer until the window is 'valid' (contains all characters of t), then move the left pointer to remove unnecessary characters until the window is no longer valid, thereby finding the minimum length.",
      "wg": [
        {
          "t": "滿足條件",
          "en": "satisfy the condition",
          "ps": "Phrase"
        },
        {
          "t": "有效",
          "en": "valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Concept Clarification, Subarray vs Subsequence, Pattern Recognition",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "辨識何時「不適合」使用滑動視窗至關重要。",
        "en": "Identifying when it is 'not suitable' to use a sliding window is crucial.",
        "wg": [
          {
            "t": "辨識",
            "en": "identifying",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一個問題場景**無法**直接使用標準的滑動視窗技巧解決？",
        "en": "Which of the following problem scenarios **cannot** be directly solved using standard sliding window techniques?",
        "wg": [
          {
            "t": "場景",
            "en": "scenarios",
            "ps": "N"
          },
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 找出陣列中總和 >= target 的長度最小連續子陣列。",
        "en": "(A) Find the minimal length contiguous subarray with sum >= target.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "contiguous subarray",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 找出字串中不含重複字元的最長子字串。",
        "en": "(B) Find the longest substring without repeating characters.",
        "wg": []
      },
      {
        "t": "(C) 找出陣列中最長的遞增子序列 (Longest Increasing Subsequence)。",
        "en": "(C) Find the Longest Increasing Subsequence (LIS) in an array.",
        "wg": [
          {
            "t": "遞增子序列",
            "en": "increasing subsequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 給定一個由 0 和 1 組成的陣列，找出翻轉 K 個 0 變為 1 後的最長連續 1 的長度。",
        "en": "(D) Given an array of 0s and 1s, find the max length of consecutive 1s after flipping at most K 0s to 1s.",
        "wg": [
          {
            "t": "翻轉",
            "en": "flipping",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "滑動視窗專門處理「連續」的子陣列或子字串問題。選項 (C) 是「子序列」(Subsequence)，元素在原陣列中不需要連續，這類問題通常需要使用動態規劃 (Dynamic Programming) 或貪婪演算法搭配二分搜尋來解決。",
      "en": "Sliding Window is specifically for 'contiguous' subarrays or substrings. Option (C) refers to a 'Subsequence', where elements do not need to be adjacent in the original array. Such problems are typically solved using Dynamic Programming or Greedy algorithms with Binary Search.",
      "wg": [
        {
          "t": "連續",
          "en": "contiguous",
          "ps": "Adj"
        },
        {
          "t": "子序列",
          "en": "subsequence",
          "ps": "N"
        }
      ]
    }
  }
]