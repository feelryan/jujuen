[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Sliding Window, Variable Size, Hash Map, Longest Substring",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int lengthOfLongestSubstringKDistinct(string s, int k) {\n    unordered_map<char, int> map;\n    int left = 0, maxLen = 0;\n    for (int right = 0; right < s.length(); right++) {\n        map[s[right]]++;\n        while (/* CONDITION */) {\n            map[s[left]]--;\n            if (map[s[left]] == 0) map.erase(s[left]);\n            left++;\n        }\n        maxLen = max(maxLen, right - left + 1);\n    }\n    return maxLen;\n}",
    "question": [
      {
        "t": "在解決「至多包含 K 個不同字元的各字串中最長的一個」問題時，我們使用變動大小的滑動視窗。",
        "en": "When solving the 'Longest Substring with At Most K Distinct Characters' problem, we use a variable-size sliding window.",
        "wg": [
          {
            "t": "至多",
            "en": "at most",
            "ps": "Prep"
          },
          {
            "t": "不同字元",
            "en": "distinct characters",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請參考提供的程式碼片段，`while` 迴圈中的 `CONDITION` 應該是什麼，以確保視窗縮小的時機正確？",
        "en": "Referring to the provided code snippet, what should the `CONDITION` in the `while` loop be to ensure the window shrinks at the correct time?",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "NP"
          },
          {
            "t": "縮小",
            "en": "shrink",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `map.size() < k`",
        "en": "(A) `map.size() < k`",
        "wg": []
      },
      {
        "t": "(B) `map.size() > k`",
        "en": "(B) `map.size() > k`",
        "wg": []
      },
      {
        "t": "(C) `right - left + 1 > k`",
        "en": "(C) `right - left + 1 > k`",
        "wg": []
      },
      {
        "t": "(D) `map[s[right]] > 1`",
        "en": "(D) `map[s[right]] > 1`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當雜湊表 (Map) 的大小超過 K 時，表示視窗內的不同字元數量已超過限制，此時必須移動左指標縮小視窗，直到不同字元數量回到 K 或以下。",
      "en": "When the size of the Hash Map exceeds K, it indicates that the number of distinct characters in the window has surpassed the limit. At this point, the left pointer must be moved to shrink the window until the count of distinct characters returns to K or less.",
      "wg": [
        {
          "t": "雜湊表",
          "en": "Hash Map",
          "ps": "N"
        },
        {
          "t": "超過",
          "en": "surpass",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Sliding Window, Fixed Size, Permutation, Anagram",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個字串 s1 和 s2，判斷 s2 是否包含 s1 的排列 (Permutation)。",
        "en": "Given two strings s1 and s2, determine if s2 contains a permutation of s1.",
        "wg": [
          {
            "t": "排列",
            "en": "permutation",
            "ps": "N"
          },
          {
            "t": "包含",
            "en": "contains",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若使用滑動視窗法，視窗的大小應該如何設定，且視窗移動時主要比對什麼？",
        "en": "If using the sliding window approach, how should the window size be set, and what is primarily compared when the window moves?",
        "wg": [
          {
            "t": "比對",
            "en": "compare",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 視窗大小固定為 `s1.length()`，比對視窗內字元的頻率陣列是否與 s1 相同。",
        "en": "(A) The window size is fixed at `s1.length()`, comparing whether the frequency array of characters in the window matches that of s1.",
        "wg": [
          {
            "t": "頻率陣列",
            "en": "frequency array",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 視窗大小變動，直到視窗內包含所有 s1 的字元。",
        "en": "(B) The window size is variable until the window contains all characters of s1.",
        "wg": []
      },
      {
        "t": "(C) 視窗大小固定為 `s2.length()`，直接比對子字串是否相等。",
        "en": "(C) The window size is fixed at `s2.length()`, directly comparing if the substrings are equal.",
        "wg": []
      },
      {
        "t": "(D) 視窗大小從 1 開始遞增，比對字元的順序是否一致。",
        "en": "(D) The window size increments from 1, comparing if the order of characters is consistent.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "尋找排列 (Permutation) 等同於尋找長度相同且字元計數相同的子字串，因此視窗大小應固定為 s1 的長度，並透過頻率陣列或雜湊表來驗證內容是否一致。",
      "en": "Finding a permutation is equivalent to finding a substring of the same length with the same character counts. Therefore, the window size should be fixed to the length of s1, and a frequency array or hash map is used to verify if the content matches.",
      "wg": [
        {
          "t": "等同於",
          "en": "equivalent to",
          "ps": "Phr"
        },
        {
          "t": "驗證",
          "en": "verify",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Sliding Window, Monotonic Queue, Deque, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「滑動視窗最大值 (Sliding Window Maximum)」問題中，我們需要在一個大小為 k 的移動視窗中找出每個位置的最大值。",
        "en": "In the 'Sliding Window Maximum' problem, we need to find the maximum value at each position within a moving window of size k.",
        "wg": [
          {
            "t": "最大值",
            "en": "maximum value",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為了將時間複雜度優化至 O(N)，最適合搭配滑動視窗使用的資料結構是什麼？",
        "en": "To optimize the time complexity to O(N), which data structure is most suitable to use with the sliding window?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先佇列 (Priority Queue / Max Heap)",
        "en": "(A) Priority Queue / Max Heap",
        "wg": []
      },
      {
        "t": "(B) 單調雙端佇列 (Monotonic Deque)",
        "en": "(B) Monotonic Deque",
        "wg": [
          {
            "t": "單調",
            "en": "monotonic",
            "ps": "Adj"
          },
          {
            "t": "雙端佇列",
            "en": "deque",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 二元搜尋樹 (Binary Search Tree)",
        "en": "(C) Binary Search Tree",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用單調遞減的 Deque 可以存儲可能成為最大值的候選索引。當新元素進入時，移除比它小的元素；當最大值索引滑出視窗範圍時，從頭部移除。每個元素最多進出 Deque 一次，故為 O(N)。Heap 的操作是 O(log k)，總體會是 O(N log k)。",
      "en": "Using a monotonically decreasing Deque allows storing candidate indices that could be the maximum. When a new element enters, smaller elements are removed; when the maximum index slides out of the window, it is removed from the front. Each element enters and exits the Deque at most once, resulting in O(N). Heap operations are O(log k), making the total O(N log k).",
      "wg": [
        {
          "t": "候選",
          "en": "candidate",
          "ps": "N"
        },
        {
          "t": "索引",
          "en": "index",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Sliding Window, Minimum Window Substring, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「最小覆蓋子字串 (Minimum Window Substring)」問題（找出包含字串 T 所有字元的最小 S 子字串），下列哪一個描述了正確的演算法流程？",
        "en": "Regarding the 'Minimum Window Substring' problem (finding the smallest substring in S that contains all characters of T), which of the following describes the correct algorithm flow?",
        "wg": [
          {
            "t": "覆蓋",
            "en": "covering",
            "ps": "V"
          },
          {
            "t": "演算法流程",
            "en": "algorithm flow",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 擴展 `right` 直到視窗有效，然後移動 `left` 縮小視窗並更新最小長度，直到視窗不再有效，重複此過程。",
        "en": "(A) Expand `right` until the window is valid, then move `left` to shrink the window and update the minimum length until the window is no longer valid, repeating this process.",
        "wg": [
          {
            "t": "有效",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 同時移動 `left` 和 `right` 保持固定視窗大小，直到找到符合條件的子字串。",
        "en": "(B) Move both `left` and `right` simultaneously to maintain a fixed window size until a substring meeting the condition is found.",
        "wg": []
      },
      {
        "t": "(C) 先計算 S 和 T 的最長公共子序列 (LCS)，再推導最小視窗。",
        "en": "(C) First calculate the Longest Common Subsequence (LCS) of S and T, then derive the minimum window.",
        "wg": []
      },
      {
        "t": "(D) 擴展 `right` 直到視窗有效，然後重置 `left` 到 `right` 的位置重新開始。",
        "en": "(D) Expand `right` until the window is valid, then reset `left` to the position of `right` to restart.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是標準的滑動視窗策略：先擴展尋找可行解，再收縮尋找最佳解 (最短長度)。一旦收縮導致視窗無效 (缺字元)，則再次擴展 `right`。",
      "en": "This is the standard sliding window strategy: first expand to find a feasible solution, then shrink to find the optimal solution (minimum length). Once shrinking makes the window invalid (missing characters), expand `right` again.",
      "wg": [
        {
          "t": "可行解",
          "en": "feasible solution",
          "ps": "NP"
        },
        {
          "t": "最佳解",
          "en": "optimal solution",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Sliding Window, Subarray Counting, Math",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在計算「乘積小於 K 的子陣列數量 (Subarray Product Less Than K)」這類問題時，我們維護一個滿足條件的視窗 `[left, right]`。",
        "en": "When counting 'Subarray Product Less Than K', we maintain a window `[left, right]` that satisfies the condition.",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當 `right` 向右擴展且視窗內容有效時，以 `right` 為結尾的新增合法子陣列數量該如何計算？",
        "en": "When `right` expands to the right and the window content is valid, how should the number of newly added valid subarrays ending at `right` be calculated?",
        "wg": [
          {
            "t": "結尾",
            "en": "ending at",
            "ps": "Phr"
          },
          {
            "t": "合法",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `right - left + 1`",
        "en": "(A) `right - left + 1`",
        "wg": []
      },
      {
        "t": "(B) `(right - left + 1) * (right - left) / 2`",
        "en": "(B) `(right - left + 1) * (right - left) / 2`",
        "wg": []
      },
      {
        "t": "(C) `1` (只計算最長的那一個)",
        "en": "(C) `1` (Only count the longest one)",
        "wg": []
      },
      {
        "t": "(D) `right - left`",
        "en": "(D) `right - left`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "對於一個有效的視窗 `[left, right]`，所有以 `right` 為結尾且起點在 `left` 到 `right` 之間的子陣列都是合法的。這些子陣列的數量正好是視窗的長度，即 `right - left + 1`。",
      "en": "For a valid window `[left, right]`, all subarrays ending at `right` with a start point between `left` and `right` are valid. The count of these subarrays corresponds exactly to the length of the window, which is `right - left + 1`.",
      "wg": [
        {
          "t": "起點",
          "en": "start point",
          "ps": "N"
        },
        {
          "t": "正好是",
          "en": "corresponds exactly to",
          "ps": "Phr"
        }
      ]
    }
  }
]