[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Fixed Size Window, Time Complexity, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個整數陣列與一個整數 k，目標是找出長度為 k 的連續子陣列的最大總和。",
        "en": "Given an array of integers and an integer k, the goal is to find the maximum sum of a contiguous subarray of length k.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "contiguous subarray",
            "ps": "N"
          },
          {
            "t": "最大總和",
            "en": "maximum sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於暴力解法，為什麼使用滑動視窗 (Sliding Window) 演算法能顯著提升效能？",
        "en": "Compared to the brute force approach, why does using the Sliding Window algorithm significantly improve performance?",
        "wg": [
          {
            "t": "暴力解法",
            "en": "brute force approach",
            "ps": "N"
          },
          {
            "t": "顯著提升",
            "en": "significantly improve",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它將時間複雜度從 O(N*k) 降低到 O(N)，因為它重複利用了前一個視窗的總和。",
        "en": "(A) It reduces the time complexity from O(N*k) to O(N) because it reuses the sum of the previous window.",
        "wg": [
          {
            "t": "重複利用",
            "en": "reuses",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 它會先對陣列進行排序，使得尋找最大元素變得更快。",
        "en": "(B) It sorts the array first, making it faster to find the largest elements.",
        "wg": [
          {
            "t": "排序",
            "en": "sorts",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 它使用遞迴方式將問題分解為更小的子問題。",
        "en": "(C) It uses recursion to break the problem down into smaller sub-problems.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 它不需要遍歷整個陣列即可找到答案。",
        "en": "(D) It does not need to traverse the entire array to find the answer.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "滑動視窗的核心優勢在於避免重複計算。當視窗向右移動一格時，只需減去移出的元素並加上新進入的元素，這是一個 O(1) 的操作，使得整體複雜度為 O(N)。暴力解法對每個起點都重新計算 k 個元素的和，導致 O(N*k)。",
      "en": "The core advantage of the Sliding Window is avoiding redundant calculations. When the window moves one step to the right, it only needs to subtract the outgoing element and add the incoming element, which is an O(1) operation, making the overall complexity O(N). The brute force approach recalculates the sum of k elements for every starting point, resulting in O(N*k).",
      "wg": [
        {
          "t": "重複計算",
          "en": "redundant calculations",
          "ps": "N"
        },
        {
          "t": "移出",
          "en": "outgoing",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Variable Size Window, Two Pointers, Subarray Sum",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int minSubArrayLen(int target, int[] nums) {\n    int left = 0, sum = 0, minLen = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        sum += nums[right];\n        while (sum >= target) {\n            minLen = Math.min(minLen, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n    return minLen == Integer.MAX_VALUE ? 0 : minLen;\n}",
    "question": [
      {
        "t": "請參考上述程式碼片段，這是解決「長度最小的子陣列」問題的典型動態滑動視窗解法。",
        "en": "Please refer to the code snippet above, which is a typical dynamic sliding window solution for the \"Minimum Size Subarray Sum\" problem.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "典型",
            "en": "typical",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "關於 `while (sum >= target)` 迴圈的作用，下列敘述何者正確？",
        "en": "Regarding the function of the `while (sum >= target)` loop, which of the following statements is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 用於擴展視窗的右邊界，直到總和滿足條件。",
        "en": "(A) It is used to expand the right boundary of the window until the sum meets the condition.",
        "wg": [
          {
            "t": "擴展",
            "en": "expand",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 用於重置視窗，當總和過大時將 `left` 和 `right` 都歸零。",
        "en": "(B) It is used to reset the window, setting both `left` and `right` to zero when the sum is too large.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 用於收縮視窗的左邊界，嘗試在滿足條件的前提下找到更短的長度。",
        "en": "(C) It is used to shrink the left boundary of the window, attempting to find a shorter length while still satisfying the condition.",
        "wg": [
          {
            "t": "收縮",
            "en": "shrink",
            "ps": "V"
          },
          {
            "t": "前提",
            "en": "premise/condition",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 用於檢查陣列中是否有負數，以避免無窮迴圈。",
        "en": "(D) It is used to check if there are negative numbers in the array to avoid infinite loops.",
        "wg": [
          {
            "t": "無窮迴圈",
            "en": "infinite loops",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "外部的 `for` 迴圈負責移動 `right` 指標來擴展視窗（增加總和）。當總和滿足條件 (`sum >= target`) 時，內部的 `while` 迴圈負責移動 `left` 指標來收縮視窗，目的是在保持條件成立的情況下，試圖找到最小的視窗長度。",
      "en": "The outer `for` loop is responsible for moving the `right` pointer to expand the window (increasing the sum). When the sum meets the condition (`sum >= target`), the inner `while` loop is responsible for moving the `left` pointer to shrink the window, with the goal of finding the minimum window length while the condition still holds.",
      "wg": [
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        },
        {
          "t": "成立",
          "en": "holds/valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "String, Hash Map, Longest Substring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「無重複字元的最長子字串」問題時，我們通常使用滑動視窗搭配雜湊表 (HashMap) 來記錄字元索引。",
        "en": "When solving the \"Longest Substring Without Repeating Characters\" problem, we typically use a sliding window combined with a HashMap to store character indices.",
        "wg": [
          {
            "t": "無重複字元",
            "en": "without repeating characters",
            "ps": "Adj"
          },
          {
            "t": "雜湊表",
            "en": "HashMap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當右指標 `right` 遇到一個已經存在於視窗內的字元時，左指標 `left` 應該如何移動？",
        "en": "When the right pointer `right` encounters a character that already exists within the window, how should the left pointer `left` move?",
        "wg": [
          {
            "t": "遇到",
            "en": "encounters",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `left` 保持不動，直接更新該字元在 HashMap 中的索引。",
        "en": "(A) Keep `left` unchanged and directly update the index of that character in the HashMap.",
        "wg": []
      },
      {
        "t": "(B) `left` 移動到 `right` 的位置，重新開始新的視窗。",
        "en": "(B) Move `left` to the position of `right` and start a new window.",
        "wg": []
      },
      {
        "t": "(C) `left` 移動到該重複字元上一次出現位置的下一個索引（需確保不往回移動）。",
        "en": "(C) Move `left` to the next index after the previous occurrence of the repeating character (ensuring it does not move backward).",
        "wg": [
          {
            "t": "上一次出現",
            "en": "previous occurrence",
            "ps": "N"
          },
          {
            "t": "往回移動",
            "en": "move backward",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) `left` 僅向右移動一步。",
        "en": "(D) Move `left` to the right by just one step.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "為了排除重複字元並保持視窗內字元的唯一性，左指標必須跳過重複字元的上一次出現位置。例如字串 \"abca\"，當遇到第二個 'a' 時，`left` 應從索引 0 移動到 1 (即第一個 'a' 的下一位)。同時需取 `max` 以防止 `left` 往回跳（例如處理 \"abba\" 的情況）。",
      "en": "To eliminate the duplicate character and maintain uniqueness within the window, the left pointer must skip past the previous occurrence of the repeating character. For example, in string \"abca\", when encountering the second 'a', `left` should move from index 0 to 1 (the position after the first 'a'). Also, `max` is needed to prevent `left` from jumping backward (e.g., handling the \"abba\" case).",
      "wg": [
        {
          "t": "唯一性",
          "en": "uniqueness",
          "ps": "N"
        },
        {
          "t": "排除",
          "en": "eliminate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Amortized Analysis, Time Complexity, Nested Loops",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "許多滑動視窗的實作包含一個外層 `for` 迴圈和一個內層 `while` 迴圈。",
        "en": "Many sliding window implementations contain an outer `for` loop and an inner `while` loop.",
        "wg": [
          {
            "t": "實作",
            "en": "implementations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "儘管有兩層迴圈，為什麼其時間複雜度通常被分析為 O(N) 而非 O(N^2)？",
        "en": "Despite having two loops, why is its time complexity usually analyzed as O(N) instead of O(N^2)?",
        "wg": [
          {
            "t": "儘管",
            "en": "despite",
            "ps": "Conj"
          },
          {
            "t": "分析為",
            "en": "analyzed as",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為內層 `while` 迴圈只在極少數情況下執行。",
        "en": "(A) Because the inner `while` loop executes only in very rare cases.",
        "wg": [
          {
            "t": "極少數",
            "en": "very rare",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 因為每個元素最多只會被 `right` 指標加入視窗一次，且被 `left` 指標移出視窗一次。",
        "en": "(B) Because each element is added to the window at most once by the `right` pointer and removed at most once by the `left` pointer.",
        "wg": [
          {
            "t": "加入",
            "en": "added",
            "ps": "V"
          },
          {
            "t": "移出",
            "en": "removed",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 因為現代編譯器會自動優化這種巢狀迴圈結構。",
        "en": "(C) Because modern compilers automatically optimize this nested loop structure.",
        "wg": [
          {
            "t": "編譯器",
            "en": "compilers",
            "ps": "N"
          },
          {
            "t": "巢狀",
            "en": "nested",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 只有當 N 很小的時候，複雜度才是 O(N)。",
        "en": "(D) The complexity is O(N) only when N is very small.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這屬於均攤分析 (Amortized Analysis) 的概念。雖然內層有迴圈，但 `left` 指標在整個演算法過程中只會單向移動（從左到右），不會重置。因此，每個元素最多被訪問兩次（一次進視窗，一次出視窗），總操作次數為 2N，即 O(N)。",
      "en": "This falls under the concept of Amortized Analysis. Although there is an inner loop, the `left` pointer only moves unidirectionally (left to right) throughout the entire algorithm and never resets. Therefore, each element is visited at most twice (once entering the window, once leaving), resulting in 2N total operations, which is O(N).",
      "wg": [
        {
          "t": "均攤分析",
          "en": "Amortized Analysis",
          "ps": "N"
        },
        {
          "t": "單向",
          "en": "unidirectionally",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Concept Distinction, Subsequence vs Substring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "下列哪一個演算法問題**不適合**使用滑動視窗 (Sliding Window) 技術來解決？",
        "en": "Which of the following algorithmic problems is **NOT** suitable for solving with the Sliding Window technique?",
        "wg": [
          {
            "t": "不適合",
            "en": "not suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 尋找字串中包含所有目標字元的最小子字串 (Minimum Window Substring)。",
        "en": "(A) Finding the minimum substring containing all target characters in a string (Minimum Window Substring).",
        "wg": []
      },
      {
        "t": "(B) 尋找陣列中乘積小於 K 的連續子陣列數量。",
        "en": "(B) Finding the number of contiguous subarrays with a product less than K.",
        "wg": [
          {
            "t": "乘積",
            "en": "product",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 尋找兩個字串的最長公共子序列 (Longest Common Subsequence)。",
        "en": "(C) Finding the Longest Common Subsequence of two strings.",
        "wg": [
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          },
          {
            "t": "公共",
            "en": "common",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 尋找字串中所有異位詞 (Anagrams) 的起始索引。",
        "en": "(D) Finding the starting indices of all anagrams in a string.",
        "wg": [
          {
            "t": "異位詞",
            "en": "anagrams",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "滑動視窗專門用於處理「連續」的子陣列或子字串問題。選項 (C) 涉及「子序列 (Subsequence)」，子序列中的元素不需要連續，這類問題通常需要使用動態規劃 (Dynamic Programming) 來解決，而非滑動視窗。",
      "en": "Sliding Window is specifically designed for \"contiguous\" subarray or substring problems. Option (C) involves a \"Subsequence\", where elements do not need to be contiguous. Such problems are typically solved using Dynamic Programming, not Sliding Window.",
      "wg": [
        {
          "t": "連續",
          "en": "contiguous",
          "ps": "Adj"
        },
        {
          "t": "動態規劃",
          "en": "Dynamic Programming",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Variable Size Window, Hash Map, Optimization, String",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (map.containsKey(currentChar)) {\n    left = Math.max(left, map.get(currentChar) + 1);\n}",
    "question": [
      {
        "t": "在解決「無重複字元的最長子字串」問題時，我們通常使用雜湊表 (Hash Map) 來記錄字元索引。",
        "en": "When solving the 'Longest Substring Without Repeating Characters' problem, we typically use a Hash Map to store character indices.",
        "wg": [
          {
            "t": "無重複字元",
            "en": "without repeating characters",
            "ps": "Phrase"
          },
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "indices",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當右指標 (right) 遇到一個已經存在於雜湊表中的字元時，為什麼更新左指標 (left) 時需要使用 `Math.max(left, map.get(currentChar) + 1)` 而不僅僅是 `map.get(currentChar) + 1`？",
        "en": "When the right pointer encounters a character that already exists in the Hash Map, why do we need to use `Math.max(left, map.get(currentChar) + 1)` to update the left pointer, instead of just `map.get(currentChar) + 1`?",
        "wg": [
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了確保視窗長度始終為偶數。",
        "en": "(A) To ensure the window length is always even.",
        "wg": []
      },
      {
        "t": "(B) 為了防止左指標向後移動，因為重複的字元可能出現在當前視窗的左邊界之外。",
        "en": "(B) To prevent the left pointer from moving backward, as the duplicate character might appear outside the left boundary of the current window.",
        "wg": [
          {
            "t": "向後移動",
            "en": "moving backward",
            "ps": "V"
          },
          {
            "t": "邊界",
            "en": "boundary",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 為了讓演算法的時間複雜度降低至 O(log N)。",
        "en": "(C) To reduce the time complexity of the algorithm to O(log N).",
        "wg": []
      },
      {
        "t": "(D) 這是為了處理字串中包含特殊符號的情況。",
        "en": "(D) This is to handle cases where the string contains special symbols.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "如果重複的字元上次出現的位置在當前 `left` 指標的左側（即已經被排除在視窗外），直接使用 `map.get(currentChar) + 1` 會導致 `left` 指標「倒退」，這違反了滑動視窗單向移動的規則並會導致錯誤的結果。",
      "en": "If the previous occurrence of the duplicate character is to the left of the current `left` pointer (meaning it has already been excluded from the window), using `map.get(currentChar) + 1` directly would cause the `left` pointer to move 'backward', violating the unidirectional movement rule of the sliding window and leading to incorrect results.",
      "wg": [
        {
          "t": "排除",
          "en": "excluded",
          "ps": "V"
        },
        {
          "t": "倒退",
          "en": "move backward",
          "ps": "V"
        },
        {
          "t": "單向移動",
          "en": "unidirectional movement",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Fixed Size Window, Efficiency, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您要計算一個長度為 N 的陣列中，所有長度為 K 的連續子陣列的總和。",
        "en": "Suppose you want to calculate the sum of all contiguous subarrays of length K in an array of length N.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "contiguous subarrays",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於對每個子陣列重新計算總和，使用滑動視窗技術的主要優勢是什麼？",
        "en": "Compared to recalculating the sum for each subarray, what is the main advantage of using the sliding window technique?",
        "wg": [
          {
            "t": "重新計算",
            "en": "recalculating",
            "ps": "V"
          },
          {
            "t": "優勢",
            "en": "advantage",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以將空間複雜度降低到 O(1)。",
        "en": "(A) It can reduce the space complexity to O(1).",
        "wg": []
      },
      {
        "t": "(B) 它利用重複利用前一個視窗的計算結果，將時間複雜度從 O(N*K) 優化為 O(N)。",
        "en": "(B) It optimizes time complexity from O(N*K) to O(N) by reusing the calculation result of the previous window.",
        "wg": [
          {
            "t": "重複利用",
            "en": "reusing",
            "ps": "V"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 它可以自動處理陣列中的負數。",
        "en": "(C) It can automatically handle negative numbers in the array.",
        "wg": []
      },
      {
        "t": "(D) 它不需要遍歷整個陣列。",
        "en": "(D) It does not need to traverse the entire array.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "固定大小的滑動視窗透過減去離開視窗的元素並加上進入視窗的元素，能在 O(1) 時間內更新狀態，避免了對每個視窗內的 K 個元素進行重複加總。",
      "en": "A fixed-size sliding window updates the state in O(1) time by subtracting the element leaving the window and adding the element entering it, avoiding repetitive summation of the K elements within each window.",
      "wg": [
        {
          "t": "重複加總",
          "en": "repetitive summation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Time Complexity, Amortized Analysis, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在典型的變動大小滑動視窗演算法中（例如：尋找總和大於 S 的最小子陣列），雖然程式碼中有兩個巢狀迴圈（外層 `right` 增加，內層 `left` 增加），為什麼時間複雜度仍被認為是 O(N)？",
        "en": "In a typical variable-size sliding window algorithm (e.g., finding the smallest subarray with a sum greater than S), although there are two nested loops (outer loop increments `right`, inner loop increments `left`), why is the time complexity still considered O(N)?",
        "wg": [
          {
            "t": "變動大小",
            "en": "variable-size",
            "ps": "Adj"
          },
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為內層迴圈只會執行常數次。",
        "en": "(A) Because the inner loop only executes a constant number of times.",
        "wg": []
      },
      {
        "t": "(B) 因為現代編譯器會自動優化巢狀迴圈。",
        "en": "(B) Because modern compilers automatically optimize nested loops.",
        "wg": []
      },
      {
        "t": "(C) 因為 `left` 和 `right` 指標都只會向前移動，每個元素最多被 `right` 訪問一次且被 `left` 訪問一次，總操作次數約為 2N。",
        "en": "(C) Because both `left` and `right` pointers only move forward; each element is visited at most once by `right` and once by `left`, resulting in approximately 2N total operations.",
        "wg": [
          {
            "t": "向前移動",
            "en": "move forward",
            "ps": "V"
          },
          {
            "t": "總操作次數",
            "en": "total operations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 這是一個常見的誤解，實際上時間複雜度是 O(N^2)。",
        "en": "(D) This is a common misconception; the time complexity is actually O(N^2).",
        "wg": [
          {
            "t": "誤解",
            "en": "misconception",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是一種均攤分析的概念。雖然是在巢狀迴圈中，但 `left` 指標從不回頭，因此整個過程中 `left` 最多移動 N 次，`right` 也最多移動 N 次，總體線性。",
      "en": "This is a concept of amortized analysis. Even though it's inside a nested loop, the `left` pointer never moves backward. Therefore, throughout the entire process, `left` moves at most N times and `right` moves at most N times, making it linear overall.",
      "wg": [
        {
          "t": "均攤分析",
          "en": "amortized analysis",
          "ps": "N"
        },
        {
          "t": "線性",
          "en": "linear",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Minimum Window Substring, Logic, Shrinking Condition",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「最小覆蓋子字串」(Minimum Window Substring) 問題時，我們維護一個視窗並嘗試包含目標字串 T 的所有字元。",
        "en": "When solving the 'Minimum Window Substring' problem, we maintain a window and try to include all characters of the target string T.",
        "wg": [
          {
            "t": "最小覆蓋子字串",
            "en": "Minimum Window Substring",
            "ps": "N"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當目前的視窗已經滿足條件（包含 T 中所有字元）時，下一步的操作策略應該是什麼？",
        "en": "When the current window satisfies the condition (contains all characters of T), what should be the strategy for the next operation?",
        "wg": [
          {
            "t": "滿足條件",
            "en": "satisfies the condition",
            "ps": "V"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 繼續移動 `right` 指標以尋找更多匹配字元。",
        "en": "(A) Continue moving the `right` pointer to find more matching characters.",
        "wg": []
      },
      {
        "t": "(B) 嘗試移動 `left` 指標縮小視窗，直到視窗不再滿足條件，並在過程中更新最小長度。",
        "en": "(B) Try moving the `left` pointer to shrink the window until it no longer satisfies the condition, updating the minimum length in the process.",
        "wg": [
          {
            "t": "縮小",
            "en": "shrink",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 立即返回當前視窗作為結果。",
        "en": "(C) Immediately return the current window as the result.",
        "wg": []
      },
      {
        "t": "(D) 重置 `left` 指標到 `right` 的位置重新開始。",
        "en": "(D) Reset the `left` pointer to the position of `right` and start over.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "一旦視窗滿足條件（可行解），我們的目標轉變為尋找「最小」長度。因此必須嘗試收縮左邊界來排除不必要的字元，直到視窗剛好不再滿足條件為止，然後再繼續擴展右邊界。",
      "en": "Once the window satisfies the condition (a feasible solution), our goal shifts to finding the 'minimum' length. Therefore, we must try to shrink the left boundary to remove unnecessary characters until the window just barely fails to satisfy the condition, and then resume expanding the right boundary.",
      "wg": [
        {
          "t": "可行解",
          "en": "feasible solution",
          "ps": "N"
        },
        {
          "t": "收縮",
          "en": "shrink",
          "ps": "V"
        },
        {
          "t": "擴展",
          "en": "expand",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "hard",
    "keywords": "Sliding Window Maximum, Deque, Monotonic Queue",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要在一個整數陣列中找出每個長度為 K 的滑動視窗中的最大值（Sliding Window Maximum）。",
        "en": "If you want to find the maximum value in every sliding window of length K within an integer array (Sliding Window Maximum).",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用「單調佇列」(Monotonic Queue/Deque) 可以在 O(N) 時間內解決此問題。請問該佇列應該維持什麼性質？",
        "en": "Using a 'Monotonic Queue/Deque' can solve this problem in O(N) time. What property should this queue maintain?",
        "wg": [
          {
            "t": "單調佇列",
            "en": "Monotonic Queue",
            "ps": "N"
          },
          {
            "t": "性質",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遞增順序：隊首始終是視窗內的最小值。",
        "en": "(A) Increasing order: The front of the queue is always the minimum value in the window.",
        "wg": [
          {
            "t": "遞增",
            "en": "increasing",
            "ps": "Adj"
          },
          {
            "t": "隊首",
            "en": "front of the queue",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 遞減順序：隊首始終是視窗內的最大值。",
        "en": "(B) Decreasing order: The front of the queue is always the maximum value in the window.",
        "wg": [
          {
            "t": "遞減",
            "en": "decreasing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 儲存視窗內所有元素的索引，不需特定順序。",
        "en": "(C) Store indices of all elements in the window, without any specific order.",
        "wg": []
      },
      {
        "t": "(D) 僅儲存比當前進入視窗元素還大的數值。",
        "en": "(D) Only store values that are larger than the element currently entering the window.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了在 O(1) 時間取得當前視窗最大值，我們維護一個遞減的雙端佇列 (Deque)。當新元素進入時，移除所有比它小的尾端元素（因為它們不可能再成為最大值），並移除隊首已滑出視窗的元素。隊首即為當前最大值。",
      "en": "To access the current window's maximum in O(1) time, we maintain a decreasing Deque. When a new element enters, we remove all smaller elements from the tail (as they can no longer be the maximum) and remove elements from the front that have slid out of the window. The front is then the current maximum.",
      "wg": [
        {
          "t": "雙端佇列",
          "en": "Deque",
          "ps": "N"
        },
        {
          "t": "尾端",
          "en": "tail",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Sliding Window, Variable Size, HashTable, Longest Substring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「包含最多 K 個相異字元的最長子字串」問題時，我們通常使用變動大小的滑動視窗搭配雜湊表 (Hash Map)。",
        "en": "When solving the 'Longest Substring with At Most K Distinct Characters' problem, we typically use a variable-size sliding window combined with a Hash Map.",
        "wg": [
          {
            "t": "相異字元",
            "en": "distinct characters",
            "ps": "NP"
          },
          {
            "t": "變動大小",
            "en": "variable-size",
            "ps": "Adj"
          },
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當視窗內的相異字元數量超過 K 時，應該採取什麼動作？",
        "en": "What action should be taken when the number of distinct characters in the window exceeds K?",
        "wg": [
          {
            "t": "超過",
            "en": "exceeds",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 立即重置視窗，將左指標 (Left) 移動到右指標 (Right) 的位置。",
        "en": "(A) Immediately reset the window by moving the left pointer to the position of the right pointer.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 移動左指標縮小視窗，並更新雜湊表中的計數，直到相異字元數量回復到 K 為止。",
        "en": "(B) Move the left pointer to shrink the window and update counts in the Hash Map until the number of distinct characters returns to K.",
        "wg": [
          {
            "t": "縮小",
            "en": "shrink",
            "ps": "V"
          },
          {
            "t": "回復",
            "en": "returns",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 停止右指標的移動，並直接回傳當前的最大長度。",
        "en": "(C) Stop moving the right pointer and immediately return the current maximum length.",
        "wg": []
      },
      {
        "t": "(D) 擴大視窗大小，直到包含第 K+1 個相異字元。",
        "en": "(D) Expand the window size until it includes the (K+1)th distinct character.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當視窗內的相異字元數超過 K 時，視窗處於無效狀態。必須透過移動左指標 (Left) 來縮小視窗並移除字元，直到視窗內的相異字元數再次小於或等於 K，才能繼續擴展右指標。",
      "en": "When the number of distinct characters exceeds K, the window is in an invalid state. You must shrink the window by moving the left pointer and removing characters until the count of distinct characters is less than or equal to K again, before continuing to expand the right pointer.",
      "wg": [
        {
          "t": "無效狀態",
          "en": "invalid state",
          "ps": "NP"
        },
        {
          "t": "擴展",
          "en": "expand",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Sliding Window, Fixed Size, Anagram, Permutation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s1 = \"ab\", s2 = \"eidbaooo\"",
    "question": [
      {
        "t": "給定兩個字串 s1 和 s2，判斷 s2 是否包含 s1 的排列 (Permutation)。",
        "en": "Given two strings s1 and s2, determine if s2 contains a permutation of s1.",
        "wg": [
          {
            "t": "排列",
            "en": "permutation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這是一個典型的固定大小滑動視窗問題。",
        "en": "This is a typical fixed-size sliding window problem.",
        "wg": [
          {
            "t": "固定大小",
            "en": "fixed-size",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "在此演算法中，視窗的大小應該設定為多少？",
        "en": "In this algorithm, what should the window size be set to?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) s2 的長度 (len(s2))。",
        "en": "(A) The length of s2 (len(s2)).",
        "wg": []
      },
      {
        "t": "(B) s1 的長度 (len(s1))。",
        "en": "(B) The length of s1 (len(s1)).",
        "wg": []
      },
      {
        "t": "(C) 視窗大小是變動的，初始為 0。",
        "en": "(C) The window size is variable, initially 0.",
        "wg": []
      },
      {
        "t": "(D) 26 (對應英文字母的數量)。",
        "en": "(D) 26 (corresponding to the number of English letters).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "尋找 s1 的排列意味著我們要在 s2 中尋找一個長度與 s1 相同，且字元計數完全一致的子字串。因此，滑動視窗的大小應固定為 s1 的長度。",
      "en": "Finding a permutation of s1 means looking for a substring in s2 that has the same length as s1 and identical character counts. Therefore, the sliding window size should be fixed to the length of s1.",
      "wg": [
        {
          "t": "字元計數",
          "en": "character counts",
          "ps": "NP"
        },
        {
          "t": "一致",
          "en": "identical",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Sliding Window, Minimum Window Substring, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「最小覆蓋子字串」(Minimum Window Substring) 問題中，我們需要找到字串 S 中包含字串 T 所有字元的最小子字串。",
        "en": "In the 'Minimum Window Substring' problem, we need to find the smallest substring in string S that contains all characters of string T.",
        "wg": [
          {
            "t": "最小覆蓋子字串",
            "en": "Minimum Window Substring",
            "ps": "NP"
          },
          {
            "t": "包含",
            "en": "contains",
            "ps": "V"
          }
        ]
      },
      {
        "t": "關於此演算法的「縮小視窗」階段，下列敘述何者正確？",
        "en": "Regarding the 'shrinking window' phase of this algorithm, which of the following statements is true?",
        "wg": [
          {
            "t": "縮小視窗",
            "en": "shrinking window",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只有當右指標 (Right) 到達 S 的末端時，才開始移動左指標 (Left)。",
        "en": "(A) Start moving the left pointer only when the right pointer reaches the end of S.",
        "wg": []
      },
      {
        "t": "(B) 只要當前視窗滿足條件 (包含 T 所有字元)，就嘗試移動左指標以縮小範圍，並更新最小長度。",
        "en": "(B) As long as the current window satisfies the condition (contains all characters of T), try moving the left pointer to shrink the range and update the minimum length.",
        "wg": [
          {
            "t": "滿足條件",
            "en": "satisfies the condition",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(C) 左指標與右指標必須同時移動，以保持視窗大小不變。",
        "en": "(C) The left and right pointers must move simultaneously to keep the window size constant.",
        "wg": [
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 如果遇到不在 T 中的字元，直接將左指標跳到右指標的位置。",
        "en": "(D) If a character not in T is encountered, jump the left pointer directly to the right pointer's position.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "此問題的邏輯是：先擴展右指標直到視窗「合法」(包含 T)，然後在保持合法的狀態下，盡可能移動左指標來縮小視窗以找到最小值。一旦縮小導致視窗「不合法」，則停止縮小並繼續擴展右指標。",
      "en": "The logic is: expand the right pointer until the window is 'valid' (contains T), then, while keeping it valid, move the left pointer as much as possible to shrink the window and find the minimum. Once shrinking makes the window 'invalid', stop shrinking and resume expanding the right pointer.",
      "wg": [
        {
          "t": "合法",
          "en": "valid",
          "ps": "Adj"
        },
        {
          "t": "最小值",
          "en": "minimum value",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Sliding Window, Time Complexity, Amortized Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "分析滑動視窗演算法的時間複雜度時，即使程式碼中有兩個巢狀迴圈 (例如 `while` 迴圈在 `for` 迴圈內)，其複雜度通常仍為 O(N)。",
        "en": "When analyzing the time complexity of the sliding window algorithm, even if there are two nested loops in the code (e.g., a `while` loop inside a `for` loop), the complexity is usually still O(N).",
        "wg": [
          {
            "t": "巢狀迴圈",
            "en": "nested loops",
            "ps": "N"
          },
          {
            "t": "複雜度",
            "en": "complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這是什麼原因造成的？",
        "en": "What is the reason for this?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為內層的 `while` 迴圈只會執行常數次。",
        "en": "(A) Because the inner `while` loop only executes a constant number of times.",
        "wg": []
      },
      {
        "t": "(B) 因為每個元素最多只會被右指標加入視窗一次，且被左指標移除視窗一次。",
        "en": "(B) Because each element is added to the window by the right pointer at most once and removed by the left pointer at most once.",
        "wg": [
          {
            "t": "移除",
            "en": "removed",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 因為現代編譯器會自動優化巢狀迴圈。",
        "en": "(C) Because modern compilers automatically optimize nested loops.",
        "wg": [
          {
            "t": "編譯器",
            "en": "compilers",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 實際上是 O(N^2)，只是在平均情況下接近 O(N)。",
        "en": "(D) It is actually O(N^2), but close to O(N) in the average case.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雖然結構上是巢狀迴圈，但透過分攤分析 (Amortized Analysis) 可知，左指標 (Left) 和右指標 (Right) 都只會單向移動，不會回頭。因此，陣列中的每個元素最多被處理兩次 (進一次，出一次)，總操作次數與 N 成正比。",
      "en": "Although structurally nested, Amortized Analysis shows that both the left and right pointers only move unidirectionally and do not turn back. Therefore, each element in the array is processed at most twice (added once, removed once), making the total operations proportional to N.",
      "wg": [
        {
          "t": "分攤分析",
          "en": "Amortized Analysis",
          "ps": "NP"
        },
        {
          "t": "單向移動",
          "en": "move unidirectionally",
          "ps": "VP"
        },
        {
          "t": "成正比",
          "en": "proportional",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Sliding Window, Two Pointers, Concept Comparison",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "滑動視窗 (Sliding Window) 與一般雙指標 (Two Pointers) 技術非常相似，但應用場景有所不同。",
        "en": "Sliding Window and general Two Pointers techniques are very similar, but their application scenarios differ.",
        "wg": [
          {
            "t": "應用場景",
            "en": "application scenarios",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "下列哪種情況最明確暗示應該使用「滑動視窗」而非一般的雙指標 (如左右夾擠)？",
        "en": "Which of the following situations most clearly implies that 'Sliding Window' should be used instead of general Two Pointers (like converging from both ends)?",
        "wg": [
          {
            "t": "暗示",
            "en": "implies",
            "ps": "V"
          },
          {
            "t": "左右夾擠",
            "en": "converging from both ends",
            "ps": "VP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 題目要求在已排序的陣列中尋找兩個數之和等於目標值。",
        "en": "(A) The problem asks to find two numbers in a sorted array that sum up to a target value.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 題目涉及計算陣列中「連續」子陣列或子字串的某種統計量 (如總和、最大長度)。",
        "en": "(B) The problem involves calculating a statistic (e.g., sum, max length) of a 'contiguous' subarray or substring.",
        "wg": [
          {
            "t": "連續",
            "en": "contiguous",
            "ps": "Adj"
          },
          {
            "t": "統計量",
            "en": "statistic",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 題目需要移除陣列中的重複元素並回傳新長度。",
        "en": "(C) The problem requires removing duplicate elements from an array and returning the new length.",
        "wg": []
      },
      {
        "t": "(D) 題目要求反轉字串中的母音字母。",
        "en": "(D) The problem asks to reverse the vowels in a string.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "滑動視窗的核心特性在於維護一個「連續」的區間。選項 (A) 和 (D) 通常使用左右指標夾擠 (對撞指標)，選項 (C) 使用快慢指標。唯有選項 (B) 強調「連續」子陣列，這是滑動視窗最典型的應用場景。",
      "en": "The core characteristic of Sliding Window is maintaining a 'contiguous' range. Options (A) and (D) typically use converging pointers (left/right pointers moving towards each other), and option (C) uses fast/slow pointers. Only option (B) emphasizes 'contiguous' subarrays, which is the most typical scenario for Sliding Window.",
      "wg": [
        {
          "t": "維護",
          "en": "maintaining",
          "ps": "V"
        },
        {
          "t": "區間",
          "en": "range",
          "ps": "N"
        },
        {
          "t": "對撞指標",
          "en": "converging pointers",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Sliding Window, Monotonic Queue, Deque, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]",
    "question": [
      {
        "t": "您需要解決「滑動視窗最大值」(Sliding Window Maximum) 的問題，即找出每個長度為 k 的視窗中的最大值。",
        "en": "You need to solve the 'Sliding Window Maximum' problem, which involves finding the maximum value in every window of length k.",
        "wg": [
          {
            "t": "滑動視窗",
            "en": "sliding window",
            "ps": "N"
          },
          {
            "t": "最大值",
            "en": "maximum value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了達到 O(n) 的線性時間複雜度，應該使用哪種輔助資料結構來儲存視窗內的元素索引？",
        "en": "To achieve O(n) linear time complexity, which auxiliary data structure should be used to store the indices of elements within the window?",
        "wg": [
          {
            "t": "線性時間複雜度",
            "en": "linear time complexity",
            "ps": "N"
          },
          {
            "t": "輔助",
            "en": "auxiliary",
            "ps": "Adj"
          },
          {
            "t": "索引",
            "en": "indices",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 最大堆積 (Max Heap) / 優先佇列 (Priority Queue)",
        "en": "(A) Max Heap / Priority Queue",
        "wg": []
      },
      {
        "t": "(B) 單調遞減雙端佇列 (Monotonic Decreasing Deque)",
        "en": "(B) Monotonic Decreasing Deque",
        "wg": [
          {
            "t": "單調遞減",
            "en": "monotonic decreasing",
            "ps": "Adj"
          },
          {
            "t": "雙端佇列",
            "en": "deque",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 二元搜尋樹 (Binary Search Tree)",
        "en": "(C) Binary Search Tree",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用單調遞減 Deque 可以確保佇列頭部始終是當前視窗的最大值索引，且每個元素最多進出佇列一次，達成 O(n)。使用 Heap 的複雜度為 O(n log k)，而 BST 亦為 O(n log k)。",
      "en": "Using a monotonic decreasing Deque ensures the head of the queue is always the index of the maximum value in the current window, and each element enters and exits the queue at most once, achieving O(n). Using a Heap results in O(n log k), and a BST is also O(n log k).",
      "wg": [
        {
          "t": "佇列頭部",
          "en": "head of the queue",
          "ps": "N"
        },
        {
          "t": "進出",
          "en": "enter and exit",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Sliding Window, Negative Numbers, Prefix Sum, Limitations",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, -5, 20, -3, 5], target = 10",
    "question": [
      {
        "t": "當陣列中包含「負數」時，為什麼標準的變動滑動視窗 (Variable Sliding Window) 策略無法直接用於尋找「總和 >= target 的最短子陣列」？",
        "en": "When the array contains 'negative numbers', why can't the standard Variable Sliding Window strategy be directly used to find the 'shortest subarray with sum >= target'?",
        "wg": [
          {
            "t": "負數",
            "en": "negative numbers",
            "ps": "N"
          },
          {
            "t": "子陣列",
            "en": "subarray",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為負數會導致陣列索引越界。",
        "en": "(A) Because negative numbers cause array index out of bounds.",
        "wg": []
      },
      {
        "t": "(B) 因為破壞了視窗擴張與總和增加之間的單調性關係。",
        "en": "(B) Because it breaks the monotonicity relationship between window expansion and sum increase.",
        "wg": [
          {
            "t": "單調性",
            "en": "monotonicity",
            "ps": "N"
          },
          {
            "t": "擴張",
            "en": "expansion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 因為滑動視窗只能處理排序後的陣列。",
        "en": "(C) Because Sliding Window can only handle sorted arrays.",
        "wg": []
      },
      {
        "t": "(D) 因為計算負數的總和需要使用浮點數運算。",
        "en": "(D) Because calculating the sum of negative numbers requires floating-point arithmetic.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "標準滑動視窗依賴於「擴張右邊界會增加總和，縮減左邊界會減少總和」的單調性。若有負數，擴張視窗可能導致總和變小，導致無法確定何時該縮減視窗，因此需改用前綴和 (Prefix Sum) 搭配 Deque 解決。",
      "en": "Standard Sliding Window relies on the monotonicity that 'expanding the right boundary increases the sum, and shrinking the left boundary decreases the sum'. With negative numbers, expanding the window might decrease the sum, making it impossible to determine when to shrink, so Prefix Sum with Deque is needed instead.",
      "wg": [
        {
          "t": "依賴",
          "en": "rely on",
          "ps": "V"
        },
        {
          "t": "縮減",
          "en": "shrink",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Fixed Window, Anagrams, Hash Map, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「字串排列」(Permutation in String) 或「尋找所有異位詞」(Find All Anagrams) 問題時，通常使用固定大小的滑動視窗。",
        "en": "When solving 'Permutation in String' or 'Find All Anagrams' problems, a fixed-size sliding window is typically used.",
        "wg": [
          {
            "t": "異位詞",
            "en": "anagrams",
            "ps": "N"
          },
          {
            "t": "固定大小",
            "en": "fixed-size",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若字串僅包含小寫英文字母，為了比較視窗內的字元計數與目標字串是否相同，最高效的實作方式為何？",
        "en": "If the string contains only lowercase English letters, what is the most efficient implementation to compare if the character counts in the window match the target string?",
        "wg": [
          {
            "t": "小寫",
            "en": "lowercase",
            "ps": "Adj"
          },
          {
            "t": "計數",
            "en": "count",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對視窗內的子字串進行排序 (Sorting) 後比較。",
        "en": "(A) Sort the substring within the window and then compare.",
        "wg": []
      },
      {
        "t": "(B) 使用兩個長度為 26 的整數陣列進行比較。",
        "en": "(B) Use two integer arrays of length 26 for comparison.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer arrays",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 每次移動視窗都重新建立一個 HashMap。",
        "en": "(C) Recreate a HashMap every time the window moves.",
        "wg": []
      },
      {
        "t": "(D) 使用遞迴生成所有排列組合。",
        "en": "(D) Use recursion to generate all permutations.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "排序的時間複雜度為 O(k log k)，而使用長度 26 的陣列比較僅需 O(1) (常數時間 26)。陣列比 HashMap 更輕量且無雜湊碰撞開銷，是處理固定字元集計數的最佳選擇。",
      "en": "Sorting has a time complexity of O(k log k), whereas comparing arrays of length 26 takes O(1) (constant time 26). Arrays are more lightweight than HashMaps and have no hash collision overhead, making them the best choice for counting fixed character sets.",
      "wg": [
        {
          "t": "雜湊碰撞",
          "en": "hash collision",
          "ps": "N"
        },
        {
          "t": "開銷",
          "en": "overhead",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Sliding Window, Subarrays, Exactly K, Problem Transformation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int subarraysWithKDistinct(int[] nums, int k)",
    "question": [
      {
        "t": "某些題目要求找出「恰好包含 K 個不同整數的子陣列數量」。",
        "en": "Some problems ask to find the 'number of subarrays with exactly K distinct integers'.",
        "wg": [
          {
            "t": "恰好",
            "en": "exactly",
            "ps": "Adv"
          },
          {
            "t": "不同整數",
            "en": "distinct integers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "直接使用滑動視窗處理「恰好 K 個」通常很困難。請問常見的轉換解法技巧是什麼？",
        "en": "Directly using a sliding window to handle 'exactly K' is often difficult. What is the common transformation technique used to solve this?",
        "wg": [
          {
            "t": "轉換",
            "en": "transformation",
            "ps": "N"
          },
          {
            "t": "技巧",
            "en": "technique",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 轉換為「最多 K 個」減去「最多 K-1 個」。",
        "en": "(A) Transform into 'at most K' minus 'at most K-1'.",
        "wg": [
          {
            "t": "最多",
            "en": "at most",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 轉換為「至少 K 個」加上「至少 K+1 個」。",
        "en": "(B) Transform into 'at least K' plus 'at least K+1'.",
        "wg": []
      },
      {
        "t": "(C) 使用動態規劃 (Dynamic Programming) 建立二維表格。",
        "en": "(C) Use Dynamic Programming to build a 2D table.",
        "wg": []
      },
      {
        "t": "(D) 將陣列反轉後求「最長重複子字串」。",
        "en": "(D) Reverse the array and find the 'longest repeating substring'.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "求「最多 K 個」可以使用標準滑動視窗 (雙指標) 在 O(n) 解決。因為「恰好 K 個」=「最多 K 個」-「最多 K-1 個」，這種轉換能將困難的精確條件轉化為兩個容易解決的寬鬆條件問題。",
      "en": "Finding 'at most K' can be solved in O(n) using standard sliding window (two pointers). Since 'exactly K' = 'at most K' - 'at most K-1', this transformation converts a difficult exact condition into two easier loose condition problems.",
      "wg": [
        {
          "t": "精確條件",
          "en": "exact condition",
          "ps": "N"
        },
        {
          "t": "寬鬆條件",
          "en": "loose condition",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Sliding Window, Time Complexity, Nested Loops, Amortized Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int left = 0, ans = 0, curr = 0;\nfor (int right = 0; right < n; right++) {\n    curr += nums[right];\n    while (curr > target) {\n        curr -= nums[left];\n        left++;\n    }\n    ans = Math.max(ans, right - left + 1);\n}",
    "question": [
      {
        "t": "請分析上述程式碼的時間複雜度。",
        "en": "Please analyze the time complexity of the code snippet above.",
        "wg": [
          {
            "t": "分析",
            "en": "analyze",
            "ps": "V"
          }
        ]
      },
      {
        "t": "雖然程式碼中有 `for` 迴圈和 `while` 迴圈的巢狀結構，但其總體複雜度為何？",
        "en": "Although there is a nested structure of a `for` loop and a `while` loop, what is the overall complexity?",
        "wg": [
          {
            "t": "巢狀結構",
            "en": "nested structure",
            "ps": "N"
          },
          {
            "t": "總體",
            "en": "overall",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(n^2)，因為最壞情況下 while 迴圈會執行 n 次。",
        "en": "(A) O(n^2), because in the worst case the while loop runs n times.",
        "wg": []
      },
      {
        "t": "(B) O(n)，因為 `left` 和 `right` 指標各自最多只會移動 n 次。",
        "en": "(B) O(n), because the `left` and `right` pointers each move at most n times.",
        "wg": [
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) O(n log n)，因為視窗大小是動態變化的。",
        "en": "(C) O(n log n), because the window size changes dynamically.",
        "wg": []
      },
      {
        "t": "(D) O(1)，因為這是在原地 (In-place) 操作。",
        "en": "(D) O(1), because it is an in-place operation.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是典型的攤銷分析 (Amortized Analysis)。儘管有巢狀迴圈，但 `right` 指標從 0 走到 n，`left` 指標也只能從 0 走到 n (不會回頭)。每個元素最多被訪問兩次 (加入視窗一次，移出視窗一次)，故總時間為 O(n)。",
      "en": "This is typical Amortized Analysis. Despite the nested loops, the `right` pointer goes from 0 to n, and the `left` pointer also only goes from 0 to n (never moves back). Each element is visited at most twice (added to window once, removed once), so the total time is O(n).",
      "wg": [
        {
          "t": "攤銷分析",
          "en": "amortized analysis",
          "ps": "N"
        },
        {
          "t": "回頭",
          "en": "move back",
          "ps": "V"
        }
      ]
    }
  }
]