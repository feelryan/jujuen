[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Data Structure, Memory, Array vs Linked List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在記憶體配置方面，鏈結串列 (Linked List) 與陣列 (Array) 的主要區別是什麼？",
        "en": "In terms of memory allocation, what is the main difference between a Linked List and an Array?",
        "wg": [
          {
            "t": "記憶體配置",
            "en": "memory allocation",
            "ps": "NP"
          },
          {
            "t": "區別",
            "en": "difference",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出描述最準確的選項。",
        "en": "Please select the most accurate statement.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鏈結串列需要連續的記憶體空間，而陣列則不需要。",
        "en": "(A) Linked Lists require contiguous memory space, whereas Arrays do not.",
        "wg": [
          {
            "t": "連續的",
            "en": "contiguous",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 陣列的大小是動態的，而鏈結串列的大小是固定的。",
        "en": "(B) The size of an Array is dynamic, whereas the size of a Linked List is fixed.",
        "wg": [
          {
            "t": "動態的",
            "en": "dynamic",
            "ps": "Adj"
          },
          {
            "t": "固定的",
            "en": "fixed",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 鏈結串列中的每個節點都需要額外的記憶體來儲存指標 (Pointer)。",
        "en": "(C) Each node in a Linked List requires extra memory to store a pointer.",
        "wg": [
          {
            "t": "額外的",
            "en": "extra",
            "ps": "Adj"
          },
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 兩者都支援 O(1) 時間複雜度的隨機存取。",
        "en": "(D) Both support random access with O(1) time complexity.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "鏈結串列的節點分散在記憶體中（非連續），且每個節點除了儲存資料外，還必須儲存指向下一個節點的參照（指標），這產生了額外的記憶體開銷。",
      "en": "Nodes in a Linked List are scattered in memory (non-contiguous), and each node must store a reference (pointer) to the next node in addition to the data, creating memory overhead.",
      "wg": [
        {
          "t": "分散",
          "en": "scattered",
          "ps": "Adj"
        },
        {
          "t": "開銷",
          "en": "overhead",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Time Complexity, Search, Access",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個單向鏈結串列 (Singly Linked List)，若要存取第 k 個元素（假設 k 合法），其時間複雜度為何？",
        "en": "Given a Singly Linked List, what is the time complexity to access the k-th element (assuming k is valid)?",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "Singly Linked List",
            "ps": "NP"
          },
          {
            "t": "存取",
            "en": "access",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(k)",
        "en": "(B) O(k)",
        "wg": []
      },
      {
        "t": "(C) O(log n)",
        "en": "(C) O(log n)",
        "wg": []
      },
      {
        "t": "(D) O(n log n)",
        "en": "(D) O(n log n)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "鏈結串列不支援隨機存取。必須從頭節點 (Head) 開始，順著指標逐一走訪直到到達第 k 個節點，因此時間複雜度與 k 成正比，即 O(k)（最差情況為 O(n)）。",
      "en": "Linked Lists do not support random access. You must start from the Head node and traverse the pointers one by one until reaching the k-th node, so the time complexity is proportional to k, which is O(k) (O(n) in the worst case).",
      "wg": [
        {
          "t": "走訪",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "成正比",
          "en": "proportional",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Algorithm, Two Pointers, Cycle Detection",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，您被要求檢測一個鏈結串列是否包含「環」(Cycle)。",
        "en": "In an interview, you are asked to detect if a linked list contains a 'cycle'.",
        "wg": [
          {
            "t": "檢測",
            "en": "detect",
            "ps": "V"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了滿足 O(1) 的空間複雜度限制，您應該使用哪種演算法或技巧？",
        "en": "To meet the O(1) space complexity constraint, which algorithm or technique should you use?",
        "wg": [
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Set) 儲存已訪問過的節點。",
        "en": "(A) Use a Hash Set to store visited nodes.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Set",
            "ps": "N"
          },
          {
            "t": "已訪問過的",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) Floyd 的判圈演算法 (快慢指標法)。",
        "en": "(B) Floyd's Cycle-Finding Algorithm (Fast and Slow Pointers).",
        "wg": [
          {
            "t": "判圈演算法",
            "en": "Cycle-Finding Algorithm",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 遞迴走訪每個節點。",
        "en": "(C) Recursively traverse each node.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 將每個節點的值修改為特定標記。",
        "en": "(D) Modify the value of each node to a specific marker.",
        "wg": [
          {
            "t": "修改",
            "en": "modify",
            "ps": "V"
          },
          {
            "t": "標記",
            "en": "marker",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "快慢指標法只需要兩個指標變數，因此空間複雜度為 O(1)。若有環，快指標最終會追上慢指標；若無環，快指標會抵達終點。選項 (A) 需要 O(n) 空間。",
      "en": "The Fast and Slow Pointers method only requires two pointer variables, so the space complexity is O(1). If there is a cycle, the fast pointer will eventually catch up to the slow pointer; otherwise, it will reach the end. Option (A) requires O(n) space.",
      "wg": [
        {
          "t": "追上",
          "en": "catch up to",
          "ps": "VP"
        },
        {
          "t": "終點",
          "en": "end",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Code Logic, Reverse, Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (curr != null) {\n    nextTemp = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = nextTemp;\n}",
    "question": [
      {
        "t": "請分析上方的程式碼片段。",
        "en": "Please analyze the code snippet above.",
        "wg": [
          {
            "t": "片段",
            "en": "snippet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這段程式碼在單向鏈結串列的操作中，實現了什麼功能？",
        "en": "What function does this code implement in the operation of a singly linked list?",
        "wg": [
          {
            "t": "實現",
            "en": "implement",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 刪除目前節點 (Delete current node)。",
        "en": "(A) Delete current node.",
        "wg": []
      },
      {
        "t": "(B) 反轉鏈結串列 (Reverse Linked List)。",
        "en": "(B) Reverse Linked List.",
        "wg": [
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 尋找鏈結串列的中間節點 (Find middle node)。",
        "en": "(C) Find middle node.",
        "wg": []
      },
      {
        "t": "(D) 檢測是否有環 (Detect cycle)。",
        "en": "(D) Detect cycle.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這段程式碼透過暫存下一個節點 (`nextTemp`)，將當前節點的指標指向前一個節點 (`curr.next = prev`)，然後推進指標，這是標準的迭代反轉邏輯。",
      "en": "This code temporarily stores the next node (`nextTemp`), points the current node's pointer to the previous node (`curr.next = prev`), and then advances the pointers, which is the standard iterative reversal logic.",
      "wg": [
        {
          "t": "暫存",
          "en": "temporarily store",
          "ps": "VP"
        },
        {
          "t": "推進",
          "en": "advance",
          "ps": "V"
        },
        {
          "t": "迭代",
          "en": "iterative",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Doubly Linked List, Deletion, Efficiency",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "相較於單向鏈結串列 (Singly Linked List)，雙向鏈結串列 (Doubly Linked List) 在以下哪種操作上具有顯著的效率優勢？",
        "en": "Compared to a Singly Linked List, in which of the following operations does a Doubly Linked List have a significant efficiency advantage?",
        "wg": [
          {
            "t": "顯著的",
            "en": "significant",
            "ps": "Adj"
          },
          {
            "t": "優勢",
            "en": "advantage",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設我們已經取得了要操作的該節點之參照 (Reference)。",
        "en": "Assume we have already obtained the reference to the node to be operated on.",
        "wg": [
          {
            "t": "參照",
            "en": "reference",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 搜尋特定值的節點。",
        "en": "(A) Searching for a node with a specific value.",
        "wg": []
      },
      {
        "t": "(B) 刪除該節點。",
        "en": "(B) Deleting that node.",
        "wg": [
          {
            "t": "刪除",
            "en": "delete",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 計算串列的總長度。",
        "en": "(C) Calculating the total length of the list.",
        "wg": []
      },
      {
        "t": "(D) 對串列進行排序。",
        "en": "(D) Sorting the list.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在雙向鏈結串列中，因為每個節點都知道其「前驅節點」(prev)，所以刪除給定節點只需要 O(1) 時間。而在單向鏈結串列中，即使有該節點的參照，仍需 O(n) 時間從頭遍歷以找到前一個節點來調整指標。",
      "en": "In a Doubly Linked List, since each node knows its 'predecessor' (prev), deleting a given node takes only O(1) time. In a Singly Linked List, even with the node's reference, it takes O(n) time to traverse from the head to find the previous node to adjust the pointers.",
      "wg": [
        {
          "t": "前驅節點",
          "en": "predecessor",
          "ps": "N"
        },
        {
          "t": "調整",
          "en": "adjust",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Linked List, Cycle Detection, Two Pointers, Floyd's Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在不修改鏈結串列結構且僅使用 O(1) 額外空間的情況下，",
        "en": "Without modifying the linked list structure and using only O(1) extra space,",
        "wg": [
          {
            "t": "修改",
            "en": "modifying",
            "ps": "V"
          },
          {
            "t": "額外空間",
            "en": "extra space",
            "ps": "N"
          }
        ]
      },
      {
        "t": "哪種方法最適合用來檢測鏈結串列中是否存在環 (Cycle)？",
        "en": "which method is most suitable for detecting if a cycle exists in a linked list?",
        "wg": [
          {
            "t": "檢測",
            "en": "detecting",
            "ps": "V"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Set) 儲存走訪過的節點。",
        "en": "(A) Use a Hash Set to store visited nodes.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Set",
            "ps": "N"
          },
          {
            "t": "走訪",
            "en": "visited",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用快慢指標 (Fast and Slow Pointers)，快指標每次移動兩步，慢指標移動一步。",
        "en": "(B) Use Fast and Slow Pointers, where the fast pointer moves two steps and the slow pointer moves one step at a time.",
        "wg": [
          {
            "t": "快慢指標",
            "en": "Fast and Slow Pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 遞迴走訪每個節點並標記已訪問。",
        "en": "(C) Recursively traverse each node and mark it as visited.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 反轉整個鏈結串列，看是否能回到原點。",
        "en": "(D) Reverse the entire linked list to see if it returns to the origin.",
        "wg": [
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 是 Floyd 判圈演算法，若有環存在，快慢指標最終會相遇，且空間複雜度為 O(1)。選項 (A) 需要 O(n) 空間；選項 (C) 的遞迴堆疊也需要 O(n) 空間；選項 (D) 會破壞結構且不保證能檢測環。",
      "en": "Option (B) is Floyd's Cycle-Finding Algorithm; if a cycle exists, the fast and slow pointers will eventually meet, with a space complexity of O(1). Option (A) requires O(n) space; Option (C) requires O(n) space for the recursion stack; Option (D) modifies the structure and does not guarantee cycle detection.",
      "wg": [
        {
          "t": "相遇",
          "en": "meet",
          "ps": "V"
        },
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Linked List, Intersection, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個單向鏈結串列 headA 和 headB，它們在某個節點相交並匯合成一個串列。",
        "en": "Given two singly linked lists headA and headB, they intersect at a certain node and merge into a single list.",
        "wg": [
          {
            "t": "相交",
            "en": "intersect",
            "ps": "V"
          },
          {
            "t": "匯合",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要找到該相交節點，且不使用額外的儲存空間，最佳的指針操作策略為何？",
        "en": "To find the intersection node without using extra storage space, what is the optimal pointer manipulation strategy?",
        "wg": [
          {
            "t": "指針",
            "en": "pointer",
            "ps": "N"
          },
          {
            "t": "操作策略",
            "en": "manipulation strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將兩個串列分別排序後再比較。",
        "en": "(A) Sort both lists separately and then compare them.",
        "wg": []
      },
      {
        "t": "(B) 雙重迴圈暴力法，比較每一個節點是否相同。",
        "en": "(B) Nested loop brute-force method, comparing whether every node is the same.",
        "wg": [
          {
            "t": "暴力法",
            "en": "brute-force",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 兩個指標分別走訪 A 和 B，當到達尾端時，切換到另一個串列的頭部繼續走訪。",
        "en": "(C) Two pointers traverse A and B respectively; when reaching the end, switch to the head of the other list and continue traversing.",
        "wg": [
          {
            "t": "尾端",
            "en": "end",
            "ps": "N"
          },
          {
            "t": "切換",
            "en": "switch",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 反轉其中一個串列，然後從頭開始比較。",
        "en": "(D) Reverse one of the lists, then compare from the beginning.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 能夠消除長度差。若兩串列長度分別為 a 和 b，透過切換指針，兩個指針都會走過 a + b 的距離，最終會在相交點相遇（或同時為 null）。這是一種 O(n) 時間且 O(1) 空間的優雅解法。",
      "en": "Option (C) eliminates the length difference. If the lists have lengths a and b, by switching pointers, both pointers will travel a distance of a + b, eventually meeting at the intersection node (or both becoming null). This is an elegant solution with O(n) time and O(1) space.",
      "wg": [
        {
          "t": "消除",
          "en": "eliminate",
          "ps": "V"
        },
        {
          "t": "優雅",
          "en": "elegant",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Linked List, N-th Node, Two Pointers, One Pass",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要在「一次遍歷」中刪除鏈結串列的倒數第 N 個節點，",
        "en": "To remove the N-th node from the end of a linked list in a 'one pass' traversal,",
        "wg": [
          {
            "t": "一次遍歷",
            "en": "one pass traversal",
            "ps": "N"
          },
          {
            "t": "倒數",
            "en": "from the end",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "應該如何設定兩個指標（first 與 second）的移動邏輯？",
        "en": "how should the movement logic of two pointers (first and second) be configured?",
        "wg": [
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 兩個指標同時從頭出發，速度相同，直到遇到 NULL。",
        "en": "(A) Both pointers start from the head at the same speed until NULL is reached.",
        "wg": []
      },
      {
        "t": "(B) 讓 first 指標先移動 N+1 步，然後 first 與 second 同速移動直到 first 到達尾端。",
        "en": "(B) Let the first pointer move N+1 steps ahead, then move both first and second at the same speed until first reaches the end.",
        "wg": [
          {
            "t": "同速",
            "en": "same speed",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 先計算鏈結串列總長度，再重新遍歷一次刪除節點。",
        "en": "(C) First calculate the total length of the linked list, then traverse again to remove the node.",
        "wg": [
          {
            "t": "總長度",
            "en": "total length",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用遞迴到達尾端後，回溯時計數 N 次。",
        "en": "(D) Use recursion to reach the end, then count N times during backtracking.",
        "wg": [
          {
            "t": "回溯",
            "en": "backtracking",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 是標準的雙指標解法。讓快指標先走 N+1 步（或 N 步視實作而定），當快指標到達尾端時，慢指標恰好會停在「倒數第 N 個節點的前一個節點」，方便執行刪除操作。選項 (C) 需要兩次遍歷，不符合題目要求。",
      "en": "Option (B) is the standard two-pointer solution. By letting the fast pointer move N+1 steps ahead (or N steps depending on implementation), when the fast pointer reaches the end, the slow pointer will stop exactly at the 'node before the N-th node from the end', facilitating the deletion. Option (C) requires two traversals, which does not meet the requirement.",
      "wg": [
        {
          "t": "恰好",
          "en": "exactly",
          "ps": "Adv"
        },
        {
          "t": "實作",
          "en": "implementation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "easy",
    "keywords": "Linked List, Dummy Node, Sentinel, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode dummy = new ListNode(0);\ndummy.next = head;",
    "question": [
      {
        "t": "在處理鏈結串列問題（如合併排序串列或刪除節點）時，",
        "en": "When dealing with linked list problems (such as merging sorted lists or deleting nodes),",
        "wg": [
          {
            "t": "合併",
            "en": "merging",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用「啞節點」(Dummy Node / Sentinel Node) 的主要好處是什麼？",
        "en": "what is the main benefit of using a 'Dummy Node' (or Sentinel Node)?",
        "wg": [
          {
            "t": "啞節點",
            "en": "Dummy Node",
            "ps": "N"
          },
          {
            "t": "好處",
            "en": "benefit",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以減少記憶體的使用量。",
        "en": "(A) It reduces memory usage.",
        "wg": []
      },
      {
        "t": "(B) 它能自動將鏈結串列排序。",
        "en": "(B) It automatically sorts the linked list.",
        "wg": []
      },
      {
        "t": "(C) 它簡化了邊界情況的處理，特別是當頭節點 (Head) 可能改變或被刪除時。",
        "en": "(C) It simplifies the handling of edge cases, especially when the head node might change or be deleted.",
        "wg": [
          {
            "t": "邊界情況",
            "en": "edge cases",
            "ps": "N"
          },
          {
            "t": "頭節點",
            "en": "head node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 它可以加快節點的存取速度至 O(1)。",
        "en": "(D) It speeds up node access to O(1).",
        "wg": [
          {
            "t": "存取速度",
            "en": "access speed",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "啞節點作為一個虛擬的頭部，確保回傳結果時總是有一個非空的參照點 (dummy.next)。這避免了需要針對「頭部為空」或「頭部被刪除」等情況撰寫額外的 if-else 邏輯，從而簡化程式碼。",
      "en": "The dummy node acts as a virtual head, ensuring there is always a non-null reference point (dummy.next) when returning the result. This avoids the need to write extra if-else logic for cases like 'empty head' or 'head being deleted', thereby simplifying the code.",
      "wg": [
        {
          "t": "虛擬",
          "en": "virtual",
          "ps": "Adj"
        },
        {
          "t": "參照點",
          "en": "reference point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Linked List, Palindrome, Reverse, Middle Node",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要判斷一個單向鏈結串列是否為「迴文」(Palindrome)，",
        "en": "To determine if a singly linked list is a 'Palindrome',",
        "wg": [
          {
            "t": "迴文",
            "en": "Palindrome",
            "ps": "N"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "且限制時間複雜度為 O(n)、空間複雜度為 O(1)，下列哪個步驟組合是正確的？",
        "en": "with constraints of O(n) time complexity and O(1) space complexity, which combination of steps is correct?",
        "wg": [
          {
            "t": "限制",
            "en": "constraints",
            "ps": "N"
          },
          {
            "t": "步驟組合",
            "en": "combination of steps",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將鏈結串列所有值複製到陣列中，再使用雙指標檢查。",
        "en": "(A) Copy all values of the linked list into an array, then use two pointers to check.",
        "wg": [
          {
            "t": "複製",
            "en": "copy",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用堆疊 (Stack) 儲存前半段節點，再與後半段比較。",
        "en": "(B) Use a Stack to store the first half of the nodes, then compare with the second half.",
        "wg": [
          {
            "t": "堆疊",
            "en": "Stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 找到中點，反轉後半段鏈結串列，比較前後兩半段，最後（可選）將後半段還原。",
        "en": "(C) Find the middle point, reverse the second half of the linked list, compare the two halves, and finally (optionally) restore the second half.",
        "wg": [
          {
            "t": "中點",
            "en": "middle point",
            "ps": "N"
          },
          {
            "t": "還原",
            "en": "restore",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 遞迴走訪到尾端，利用遞迴堆疊的特性反向比較。",
        "en": "(D) Recursively traverse to the end and use the recursion stack property to compare backwards.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 是唯一符合 O(1) 空間複雜度的解法。選項 (A) 和 (B) 都需要 O(n) 的額外空間來儲存陣列或堆疊；選項 (D) 的遞迴深度也是 O(n) 的空間消耗。",
      "en": "Option (C) is the only solution that satisfies the O(1) space complexity constraint. Options (A) and (B) both require O(n) extra space to store the array or stack; Option (D) also consumes O(n) space due to recursion depth.",
      "wg": [
        {
          "t": "符合",
          "en": "satisfies",
          "ps": "V"
        },
        {
          "t": "消耗",
          "en": "consumes",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Cycle Detection, Floyd's Algorithm, Two Pointers, Space Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，面試官要求您檢測一個單向鏈結串列（Singly Linked List）中是否存在環（Cycle）。",
        "en": "In an interview, the interviewer asks you to detect if a cycle exists in a Singly Linked List.",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "Singly Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "限制條件是您必須使用 O(1) 的額外空間複雜度。",
        "en": "The constraint is that you must use O(1) extra space complexity.",
        "wg": [
          {
            "t": "額外空間複雜度",
            "en": "extra space complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種演算法或資料結構最適合解決此問題？",
        "en": "Which of the following algorithms or data structures is most suitable for solving this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表（Hash Set）來儲存訪問過的節點。",
        "en": "(A) Use a Hash Set to store visited nodes.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Set",
            "ps": "N"
          },
          {
            "t": "訪問過的",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 修改節點的值，標記為已訪問（例如將值改為特殊字元）。",
        "en": "(B) Modify the node values to mark them as visited (e.g., changing the value to a special character).",
        "wg": [
          {
            "t": "標記",
            "en": "mark",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用 Floyd 的判圈演算法（快慢指標法）。",
        "en": "(C) Use Floyd's Cycle-Finding Algorithm (Fast and Slow Pointers).",
        "wg": [
          {
            "t": "判圈演算法",
            "en": "Cycle-Finding Algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遞迴遍歷鏈結串列並計算深度。",
        "en": "(D) Recursively traverse the linked list and calculate the depth.",
        "wg": [
          {
            "t": "遞迴遍歷",
            "en": "recursively traverse",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Floyd 的判圈演算法使用兩個指標（快指標和慢指標），不需要額外的記憶體空間來儲存節點歷史，符合 O(1) 空間複雜度的要求；雜湊表需要 O(N) 空間。",
      "en": "Floyd's Cycle-Finding Algorithm uses two pointers (fast and slow) and does not require extra memory to store node history, meeting the O(1) space complexity requirement; a Hash Set requires O(N) space.",
      "wg": [
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        },
        {
          "t": "記憶體空間",
          "en": "memory space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Intersection, Two Pointers, Alignment",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個單向鏈結串列 headA 和 headB，它們可能在某個節點相交並合併成一個串列。",
        "en": "Given two singly linked lists headA and headB, they may intersect at a certain node and merge into one list.",
        "wg": [
          {
            "t": "相交",
            "en": "intersect",
            "ps": "V"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若兩個串列長度不同，為了找到相交點，下列哪種雙指標策略最為高效且常見？",
        "en": "If the two lists have different lengths, which of the following two-pointer strategies is the most efficient and common for finding the intersection point?",
        "wg": [
          {
            "t": "雙指標策略",
            "en": "two-pointer strategy",
            "ps": "N"
          },
          {
            "t": "高效",
            "en": "efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將兩個串列的所有節點值放入兩個陣列中，從尾部開始比較。",
        "en": "(A) Put all node values of both lists into two arrays and compare from the tail.",
        "wg": [
          {
            "t": "尾部",
            "en": "tail",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 指標 A 遍歷完 headA 後跳轉到 headB 頭部，指標 B 遍歷完 headB 後跳轉到 headA 頭部，直到相遇。",
        "en": "(B) Pointer A traverses headA then jumps to the head of headB; Pointer B traverses headB then jumps to the head of headA, until they meet.",
        "wg": [
          {
            "t": "跳轉",
            "en": "jump/switch",
            "ps": "V"
          },
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 對兩個串列進行排序，然後逐一比較節點。",
        "en": "(C) Sort both lists and then compare nodes one by one.",
        "wg": []
      },
      {
        "t": "(D) 每次移動指標前，先計算兩個串列的總和。",
        "en": "(D) Calculate the sum of both lists before moving the pointers each time.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這種方法消除了長度差異的影響。若兩串列長度分別為 L1 和 L2，兩個指標都會走過 L1 + L2 的距離，最終在相交點（或結尾 null）同時相遇。",
      "en": "This method eliminates the effect of length differences. If the lists have lengths L1 and L2, both pointers will traverse a distance of L1 + L2, eventually meeting at the intersection point (or null at the end) simultaneously.",
      "wg": [
        {
          "t": "消除",
          "en": "eliminate",
          "ps": "V"
        },
        {
          "t": "長度差異",
          "en": "length difference",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Reverse Linked List, Iterative, Pointer Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Node nextTemp = curr.next;\ncurr.next = prev;\nprev = curr;\ncurr = nextTemp;",
    "question": [
      {
        "t": "在迭代反轉單向鏈結串列（Reverse Linked List）的過程中，我們通常使用 `prev`、`curr` 和 `nextTemp` 三個變數。",
        "en": "In the process of iteratively reversing a Singly Linked List, we typically use three variables: `prev`, `curr`, and `nextTemp`.",
        "wg": [
          {
            "t": "迭代反轉",
            "en": "iteratively reversing",
            "ps": "V"
          },
          {
            "t": "變數",
            "en": "variable",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請參考提供的程式碼片段，為什麼第一行 `Node nextTemp = curr.next;` 是絕對必要的？",
        "en": "Referring to the provided code snippet, why is the first line `Node nextTemp = curr.next;` absolutely necessary?",
        "wg": [
          {
            "t": "絕對必要",
            "en": "absolutely necessary",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為我們需要檢查 `curr` 是否為 null。",
        "en": "(A) Because we need to check if `curr` is null.",
        "wg": []
      },
      {
        "t": "(B) 因為執行 `curr.next = prev` 後，原本指向下一個節點的連結會斷開，若不先暫存，將無法繼續遍歷。",
        "en": "(B) Because after executing `curr.next = prev`, the link to the next node is broken; if not saved beforehand, traversal cannot continue.",
        "wg": [
          {
            "t": "斷開",
            "en": "broken/severed",
            "ps": "V"
          },
          {
            "t": "暫存",
            "en": "save temporarily",
            "ps": "V"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是為了釋放記憶體空間。",
        "en": "(C) This is to free up memory space.",
        "wg": [
          {
            "t": "釋放",
            "en": "free up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 這是為了確保 `prev` 指標不會指向 null。",
        "en": "(D) This is to ensure the `prev` pointer does not point to null.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "反轉操作的核心是改變 `curr.next` 的指向。一旦執行該行，原本通往後續節點的路徑就會遺失，因此必須先用 `nextTemp` 保存起來。",
      "en": "The core of the reversal operation is changing the direction of `curr.next`. Once that line is executed, the path to the subsequent nodes is lost, so it must be saved using `nextTemp` first.",
      "wg": [
        {
          "t": "後續節點",
          "en": "subsequent nodes",
          "ps": "N"
        },
        {
          "t": "遺失",
          "en": "lost",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Doubly Linked List, Deletion, Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在雙向鏈結串列（Doubly Linked List）中，若要刪除一個既非頭節點也非尾節點的中間節點 `target`。",
        "en": "In a Doubly Linked List, if you want to delete an intermediate node `target` that is neither the head nor the tail.",
        "wg": [
          {
            "t": "雙向鏈結串列",
            "en": "Doubly Linked List",
            "ps": "N"
          },
          {
            "t": "頭節點",
            "en": "head node",
            "ps": "N"
          },
          {
            "t": "尾節點",
            "en": "tail node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一組操作正確地更新了相鄰節點的指標？",
        "en": "Which of the following sets of operations correctly updates the pointers of the adjacent nodes?",
        "wg": [
          {
            "t": "相鄰節點",
            "en": "adjacent nodes",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `target.prev.next = target.next;`",
        "en": "(A) `target.prev.next = target.next;`",
        "wg": []
      },
      {
        "t": "(B) `target.next.prev = target.prev;`",
        "en": "(B) `target.next.prev = target.prev;`",
        "wg": []
      },
      {
        "t": "(C) `target.prev.next = target.next;` 且 `target.next.prev = target.prev;`",
        "en": "(C) `target.prev.next = target.next;` AND `target.next.prev = target.prev;`",
        "wg": []
      },
      {
        "t": "(D) `target.prev = null;` 且 `target.next = null;`",
        "en": "(D) `target.prev = null;` AND `target.next = null;`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雙向鏈結串列需要同時維護前向和後向的連結。選項 (C) 正確地將 `target` 前一個節點的 `next` 指向 `target` 的後一個節點，並將 `target` 後一個節點的 `prev` 指向 `target` 的前一個節點。",
      "en": "A Doubly Linked List requires maintaining both forward and backward links simultaneously. Option (C) correctly points the `next` of the node before `target` to the node after `target`, and points the `prev` of the node after `target` to the node before `target`.",
      "wg": [
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "前向",
          "en": "forward",
          "ps": "Adj"
        },
        {
          "t": "後向",
          "en": "backward",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Fast and Slow Pointers, Middle Node, One Pass",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要找到一個單向鏈結串列的「中間節點」（若有兩個中間節點，則取第二個）。",
        "en": "You need to find the 'middle node' of a Singly Linked List (if there are two middle nodes, return the second one).",
        "wg": [
          {
            "t": "中間節點",
            "en": "middle node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了僅遍歷串列一次（One Pass）就完成此任務，應如何設置快慢指標的移動步數？",
        "en": "To accomplish this task by traversing the list only once (One Pass), how should the step sizes of the fast and slow pointers be set?",
        "wg": [
          {
            "t": "僅遍歷串列一次",
            "en": "traversing the list only once",
            "ps": "Phrase"
          },
          {
            "t": "步數",
            "en": "step sizes",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 快指標每次走 1 步，慢指標每次走 1 步。",
        "en": "(A) Fast pointer moves 1 step at a time; Slow pointer moves 1 step at a time.",
        "wg": []
      },
      {
        "t": "(B) 快指標每次走 2 步，慢指標每次走 1 步。",
        "en": "(B) Fast pointer moves 2 steps at a time; Slow pointer moves 1 step at a time.",
        "wg": []
      },
      {
        "t": "(C) 快指標每次走 3 步，慢指標每次走 1 步。",
        "en": "(C) Fast pointer moves 3 steps at a time; Slow pointer moves 1 step at a time.",
        "wg": []
      },
      {
        "t": "(D) 快指標先走 n/2 步，慢指標再開始走。",
        "en": "(D) Fast pointer moves n/2 steps first, then Slow pointer starts moving.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當快指標移動速度是慢指標的兩倍時，快指標到達終點時，慢指標剛好位於串列的中點。這是尋找中位數的標準解法。",
      "en": "When the fast pointer moves at twice the speed of the slow pointer, the slow pointer will be exactly at the midpoint of the list when the fast pointer reaches the end. This is the standard solution for finding the median.",
      "wg": [
        {
          "t": "中點",
          "en": "midpoint",
          "ps": "N"
        },
        {
          "t": "標準解法",
          "en": "standard solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Cycle Detection, Floyd's Algorithm, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您已經使用 Floyd 的龜兔賽跑演算法 (快慢指標) 偵測到單向鏈結串列中存在環 (Cycle)。",
        "en": "Assume you have already detected a cycle in a singly linked list using Floyd's Cycle-Finding Algorithm (Fast and Slow Pointers).",
        "wg": [
          {
            "t": "龜兔賽跑演算法",
            "en": "Tortoise and Hare Algorithm",
            "ps": "N"
          },
          {
            "t": "單向鏈結串列",
            "en": "singly linked list",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "現在您需要找出環的「起始節點」(Entry Node)。",
        "en": "Now you need to find the 'entry node' of the cycle.",
        "wg": [
          {
            "t": "起始節點",
            "en": "entry node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當快指標與慢指標首次相遇後，接下來該採取什麼步驟？",
        "en": "What steps should be taken next after the fast and slow pointers meet for the first time?",
        "wg": [
          {
            "t": "首次",
            "en": "for the first time",
            "ps": "Adv"
          },
          {
            "t": "相遇",
            "en": "meet",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將慢指標重置回頭節點 (Head)，快指標保持在相遇點，兩者皆以每次一步的速度移動，直到再次相遇。",
        "en": "(A) Reset the slow pointer to the head, keep the fast pointer at the meeting point, and move both one step at a time until they meet again.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將快指標重置回頭節點 (Head)，慢指標保持在相遇點，快指標每次走兩步，慢指標每次走一步。",
        "en": "(B) Reset the fast pointer to the head, keep the slow pointer at the meeting point, move the fast pointer two steps at a time and the slow pointer one step.",
        "wg": []
      },
      {
        "t": "(C) 計算環的長度，然後從頭節點重新開始遍歷。",
        "en": "(C) Calculate the length of the cycle, then restart traversal from the head.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 直接回傳目前的相遇點，因為它就是環的起始點。",
        "en": "(D) Directly return the current meeting point, as it is the start of the cycle.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "根據 Floyd 演算法的數學證明，當快慢指標相遇時，將其中一個指標移回起點，另一個留在相遇點，兩者同時以每次一步的速度前進，它們必定會在環的起始點相遇。",
      "en": "According to the mathematical proof of Floyd's algorithm, when the pointers meet, moving one pointer back to the start and keeping the other at the meeting point, then advancing both one step at a time, guarantees they will meet at the cycle's entry node.",
      "wg": [
        {
          "t": "數學證明",
          "en": "mathematical proof",
          "ps": "N"
        },
        {
          "t": "必定",
          "en": "guarantee",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Intersection, Memory Management, O(1) Space",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListA: a1 -> a2 -> c1 -> c2\nListB: b1 -> c1 -> c2",
    "question": [
      {
        "t": "給定兩個單向鏈結串列，它們在某個節點相交並合併成一個串列 (如 Y 字型)。",
        "en": "Given two singly linked lists that intersect at a certain node and merge into a single list (Y-shape).",
        "wg": [
          {
            "t": "相交",
            "en": "intersect",
            "ps": "V"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要求時間複雜度為 O(N + M) 且空間複雜度為 O(1)，下列哪種方法最適合找出相交的起始節點？",
        "en": "If the requirement is O(N + M) time complexity and O(1) space complexity, which of the following methods is best suited to find the starting node of the intersection?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "適合",
            "en": "suited",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Set) 儲存第一個串列的所有節點，然後檢查第二個串列的節點是否存在於表中。",
        "en": "(A) Use a Hash Set to store all nodes of the first list, then check if nodes of the second list exist in the set.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 分別計算兩個串列的長度，讓較長的串列指標先走長度差的步數，然後兩個指標同步移動直到指向相同節點。",
        "en": "(B) Calculate the lengths of both lists separately, advance the pointer of the longer list by the length difference, then move both pointers synchronously until they point to the same node.",
        "wg": [
          {
            "t": "長度差",
            "en": "length difference",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 將其中一個串列反轉，然後從尾端開始比較。",
        "en": "(C) Reverse one of the lists and start comparing from the tail.",
        "wg": [
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 對兩個串列的每個節點進行暴力法兩兩比較。",
        "en": "(D) Perform a brute-force pairwise comparison for every node of the two lists.",
        "wg": [
          {
            "t": "暴力法",
            "en": "brute-force",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 需要 O(N) 的額外空間；選項 (B) 利用長度差對齊起點，僅需 O(1) 空間且只需遍歷兩次，符合題目要求；選項 (C) 會破壞鏈結結構；選項 (D) 時間複雜度為 O(N*M)，效率太差。",
      "en": "Option (A) requires O(N) extra space; Option (B) uses the length difference to align starting points, requiring only O(1) space and two traversals, meeting the requirements; Option (C) destroys the link structure; Option (D) has a time complexity of O(N*M), which is too inefficient.",
      "wg": [
        {
          "t": "對齊",
          "en": "align",
          "ps": "V"
        },
        {
          "t": "破壞",
          "en": "destroy",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "LRU Cache, System Design, Doubly Linked List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 LRU (Least Recently Used) 快取機制時，通常會結合雜湊表 (Hash Map) 與雙向鏈結串列 (Doubly Linked List)。",
        "en": "When implementing an LRU (Least Recently Used) cache mechanism, a Hash Map is usually combined with a Doubly Linked List.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "快取機制",
            "en": "cache mechanism",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在此架構中，使用雙向鏈結串列的主要原因是什麼？",
        "en": "What is the primary reason for using a Doubly Linked List in this architecture?",
        "wg": [
          {
            "t": "架構",
            "en": "architecture",
            "ps": "N"
          },
          {
            "t": "主要原因",
            "en": "primary reason",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了能夠在 O(1) 時間內隨機存取任意索引的資料。",
        "en": "(A) To enable random access to data at any index in O(1) time.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 為了節省記憶體空間，因為雙向鏈結串列比陣列更緊湊。",
        "en": "(B) To save memory space, as doubly linked lists are more compact than arrays.",
        "wg": [
          {
            "t": "緊湊",
            "en": "compact",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 為了能在 O(1) 時間內將節點移動到頭部 (表示最近使用) 或移除尾部節點 (表示最久未使用)。",
        "en": "(C) To allow moving a node to the head (indicating recently used) or removing the tail node (indicating least recently used) in O(1) time.",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "最久未使用",
            "en": "least recently used",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 為了避免雜湊碰撞 (Hash Collision) 的問題。",
        "en": "(D) To avoid the problem of Hash Collisions.",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "Hash Collision",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "LRU 的核心操作是更新資料的新舊程度 (移動到前面) 和淘汰舊資料 (從後面移除)。雙向鏈結串列只要知道節點位置 (由 Hash Map 提供)，即可在 O(1) 完成斷開與重新連接的操作。",
      "en": "The core operations of LRU are updating the recency of data (moving to front) and evicting old data (removing from back). A Doubly Linked List can complete disconnect and reconnect operations in O(1) as long as the node location is known (provided by the Hash Map).",
      "wg": [
        {
          "t": "淘汰",
          "en": "evict",
          "ps": "V"
        },
        {
          "t": "斷開",
          "en": "disconnect",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Palindrome, Algorithm, Recursion vs Iteration",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要檢查一個單向鏈結串列是否為「迴文」(Palindrome)，例如 `1 -> 2 -> 2 -> 1`。",
        "en": "To check if a singly linked list is a 'palindrome', e.g., `1 -> 2 -> 2 -> 1`.",
        "wg": [
          {
            "t": "迴文",
            "en": "palindrome",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若限制空間複雜度為 O(1) (不包含遞迴堆疊)，下列哪個步驟是必要的？",
        "en": "If the space complexity is restricted to O(1) (excluding recursion stack), which of the following steps is necessary?",
        "wg": [
          {
            "t": "限制",
            "en": "restricted",
            "ps": "V"
          },
          {
            "t": "必要的",
            "en": "necessary",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將整個鏈結串列複製到一個陣列中，然後使用雙指標檢查。",
        "en": "(A) Copy the entire linked list into an array, then use two pointers to check.",
        "wg": [
          {
            "t": "複製",
            "en": "copy",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用堆疊 (Stack) 儲存前半段的節點值。",
        "en": "(B) Use a Stack to store the node values of the first half.",
        "wg": []
      },
      {
        "t": "(C) 找到鏈結串列的中點，並將後半段串列反轉，再與前半段進行比較。",
        "en": "(C) Find the middle of the linked list, reverse the second half of the list, and then compare it with the first half.",
        "wg": [
          {
            "t": "中點",
            "en": "middle",
            "ps": "N"
          },
          {
            "t": "後半段",
            "en": "second half",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 對鏈結串列進行氣泡排序 (Bubble Sort) 後再比較。",
        "en": "(D) Perform Bubble Sort on the linked list and then compare.",
        "wg": [
          {
            "t": "氣泡排序",
            "en": "Bubble Sort",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (A) 和 (B) 都需要 O(N) 的額外空間來儲存節點資料。選項 (C) 透過在原串列上進行反轉 (In-place reversal)，可以達到 O(1) 空間複雜度，是標準的最佳解法。",
      "en": "Options (A) and (B) both require O(N) extra space to store node data. Option (C) achieves O(1) space complexity by performing an in-place reversal on the original list, which is the standard optimal solution.",
      "wg": [
        {
          "t": "額外空間",
          "en": "extra space",
          "ps": "N"
        },
        {
          "t": "最佳解法",
          "en": "optimal solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "hard",
    "keywords": "Merge Sort, Priority Queue, Divide and Conquer",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [List1, List2, ..., ListK]\nTotal nodes: N",
    "question": [
      {
        "t": "您需要合併 K 個已排序的鏈結串列 (Merge K Sorted Lists) 成為一個排序好的串列。",
        "en": "You need to merge K sorted linked lists into a single sorted list.",
        "wg": [
          {
            "t": "已排序的",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若 N 為所有節點的總數，下列哪種方法可以提供最佳的時間複雜度 O(N log K)？",
        "en": "If N is the total number of nodes, which of the following methods provides the best time complexity of O(N log K)?",
        "wg": [
          {
            "t": "總數",
            "en": "total number",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依序將第 1 個與第 2 個合併，結果再與第 3 個合併，以此類推。",
        "en": "(A) Sequentially merge the 1st and 2nd, then merge the result with the 3rd, and so on.",
        "wg": [
          {
            "t": "依序",
            "en": "sequentially",
            "ps": "Adv"
          },
          {
            "t": "以此類推",
            "en": "and so on",
            "ps": "Phrase"
          }
        ]
      },
      {
        "t": "(B) 將所有鏈結串列的節點放入一個陣列中，進行快速排序 (Quick Sort)，再重建串列。",
        "en": "(B) Put all nodes from the linked lists into an array, perform Quick Sort, and then reconstruct the list.",
        "wg": [
          {
            "t": "重建",
            "en": "reconstruct",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用最小堆積 (Min-Heap) 或優先佇列 (Priority Queue) 來維護目前 K 個串列的頭部節點。",
        "en": "(C) Use a Min-Heap or Priority Queue to maintain the head nodes of the current K lists.",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "優先佇列",
            "en": "Priority Queue",
            "ps": "N"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 比較所有 K 個串列的頭部，找出最小值，重複此步驟直到結束 (不使用額外資料結構)。",
        "en": "(D) Compare the heads of all K lists to find the minimum, repeat this step until finished (without using extra data structures).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "使用 Min-Heap 每次取出最小值需 O(log K)，總共做 N 次，故為 O(N log K)。選項 (A) 和 (D) 的時間複雜度接近 O(N * K)，效率較差；選項 (B) 為 O(N log N)，當 K << N 時比 (C) 慢。",
      "en": "Using a Min-Heap takes O(log K) to extract the minimum each time, performed N times, resulting in O(N log K). Options (A) and (D) have time complexities close to O(N * K), which is less efficient; Option (B) is O(N log N), which is slower than (C) when K << N.",
      "wg": [
        {
          "t": "取出",
          "en": "extract",
          "ps": "V"
        },
        {
          "t": "效率較差",
          "en": "less efficient",
          "ps": "Adj"
        }
      ]
    }
  }
]