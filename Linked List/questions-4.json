[
  {
    "no": "16",
    "level": "hard",
    "keywords": "Cache Locality, Performance, Memory Layout, Array vs LinkedList",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在現代電腦架構中，遍歷一個儲存了 100 萬個整數的陣列 (Array)，通常比遍歷同樣大小的鏈結串列 (Linked List) 快得多。",
        "en": "In modern computer architecture, iterating over an Array storing 1 million integers is typically much faster than iterating over a Linked List of the same size.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterating",
            "ps": "V"
          },
          {
            "t": "電腦架構",
            "en": "computer architecture",
            "ps": "N"
          }
        ]
      },
      {
        "t": "造成這種效能差異的主要原因是什麼？",
        "en": "What is the primary reason for this performance difference?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鏈結串列的 Big O 時間複雜度在遍歷上較高。",
        "en": "(A) The Big O time complexity for traversal is higher in Linked Lists.",
        "wg": []
      },
      {
        "t": "(B) 陣列具有較好的空間局部性 (Spatial Locality)，能有效利用 CPU 快取 (Cache)。",
        "en": "(B) Arrays have better Spatial Locality, effectively utilizing the CPU Cache.",
        "wg": [
          {
            "t": "空間局部性",
            "en": "Spatial Locality",
            "ps": "N"
          },
          {
            "t": "快取",
            "en": "Cache",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 鏈結串列需要額外的記憶體來儲存指標，導致記憶體溢位 (Overflow)。",
        "en": "(C) Linked Lists require extra memory for pointers, causing memory overflow.",
        "wg": [
          {
            "t": "記憶體溢位",
            "en": "memory overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 陣列是在堆疊 (Stack) 上分配，而鏈結串列是在堆積 (Heap) 上分配。",
        "en": "(D) Arrays are allocated on the Stack, while Linked Lists are allocated on the Heap.",
        "wg": [
          {
            "t": "堆疊",
            "en": "Stack",
            "ps": "N"
          },
          {
            "t": "堆積",
            "en": "Heap",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "陣列佔用連續的記憶體空間，這使得 CPU 預取機制能將後續資料預先載入快取線 (Cache Line) 中，極大化了空間局部性效益；反之，鏈結串列的節點在記憶體中是分散的，容易導致頻繁的快取未命中 (Cache Miss)。",
      "en": "Arrays occupy contiguous memory space, allowing CPU prefetching mechanisms to load subsequent data into Cache Lines, maximizing spatial locality; conversely, Linked List nodes are scattered in memory, leading to frequent Cache Misses.",
      "wg": [
        {
          "t": "連續的",
          "en": "contiguous",
          "ps": "Adj"
        },
        {
          "t": "預取",
          "en": "prefetching",
          "ps": "V"
        },
        {
          "t": "快取未命中",
          "en": "Cache Miss",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Cycle Detection, Floyd's Algorithm, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "使用 Floyd 判圈演算法 (快慢指標) 偵測到鏈結串列中有環 (Cycle) 後，",
        "en": "After detecting a cycle in a linked list using Floyd's Cycle-Finding Algorithm (Fast and Slow Pointers),",
        "wg": [
          {
            "t": "判圈演算法",
            "en": "Cycle-Finding Algorithm",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要找出環的「進入點」節點，接下來應該採取什麼步驟？",
        "en": "what steps should be taken next to find the 'entry point' node of the cycle?",
        "wg": [
          {
            "t": "進入點",
            "en": "entry point",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將慢指標移回頭部 (Head)，快指標保持在相遇點，兩者皆以每次一步的速度移動直到再次相遇。",
        "en": "(A) Move the slow pointer back to the Head, keep the fast pointer at the meeting point, and move both one step at a time until they meet again.",
        "wg": []
      },
      {
        "t": "(B) 將快指標移回頭部 (Head)，慢指標保持在相遇點，快指標每次兩步，慢指標每次一步移動。",
        "en": "(B) Move the fast pointer back to the Head, keep the slow pointer at the meeting point, move the fast pointer two steps and the slow pointer one step at a time.",
        "wg": []
      },
      {
        "t": "(C) 計算環的長度，然後從頭部重新開始遍歷直到達到該長度。",
        "en": "(C) Calculate the length of the cycle, then restart traversal from the Head until that length is reached.",
        "wg": []
      },
      {
        "t": "(D) 直接回傳目前的相遇點，因為相遇點即為進入點。",
        "en": "(D) Return the current meeting point directly, as the meeting point is the entry point.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "根據數學證明，從頭部到環起點的距離，等於從相遇點繼續走到環起點的距離。因此，將其中一個指標重置回頭部，並讓兩者以相同速度 (每次一步) 前進，它們必會在環的進入點相遇。",
      "en": "According to mathematical proof, the distance from the head to the cycle start equals the distance from the meeting point to the cycle start. Therefore, resetting one pointer to the head and moving both at the same speed (one step at a time) ensures they meet at the cycle's entry point.",
      "wg": [
        {
          "t": "重置",
          "en": "resetting",
          "ps": "V"
        },
        {
          "t": "證明",
          "en": "proof",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Intersection, Two Pointers, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListA: a1 -> a2 -> c1 -> c2\nListB: b1 -> b2 -> b3 -> c1 -> c2",
    "question": [
      {
        "t": "給定兩個單向鏈結串列 ListA 與 ListB，它們在節點 c1 交會並形成 Y 字型結構。",
        "en": "Given two singly linked lists, ListA and ListB, which intersect at node c1 forming a Y-shape structure.",
        "wg": [
          {
            "t": "交會",
            "en": "intersect",
            "ps": "V"
          },
          {
            "t": "Y 字型",
            "en": "Y-shape",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若要在 O(N) 時間複雜度且 O(1) 空間複雜度下找到交會點 c1，最佳策略為何？",
        "en": "What is the optimal strategy to find the intersection node c1 with O(N) time complexity and O(1) space complexity?",
        "wg": [
          {
            "t": "最佳策略",
            "en": "optimal strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Table) 儲存 ListA 的所有節點，然後檢查 ListB 的節點是否存在於表中。",
        "en": "(A) Use a Hash Table to store all nodes of ListA, then check if nodes of ListB exist in the table.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Table",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 計算兩個串列的長度差，讓較長的串列先走「長度差」步，然後兩者同步前進直到指標相同。",
        "en": "(B) Calculate the length difference between the two lists, advance the pointer of the longer list by the 'length difference', then move both synchronously until pointers match.",
        "wg": [
          {
            "t": "長度差",
            "en": "length difference",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 反轉兩個鏈結串列，然後從頭開始比較，直到發現分歧點。",
        "en": "(C) Reverse both linked lists, then compare from the start until a divergence is found.",
        "wg": [
          {
            "t": "分歧點",
            "en": "divergence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將 ListA 的尾端接到 ListB 的頭部，形成一個環，再找環的起點。",
        "en": "(D) Connect the tail of ListA to the head of ListB to form a cycle, then find the start of the cycle.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 僅需遍歷兩次 (一次算長度，一次找交點)，符合 O(N) 時間與 O(1) 空間。選項 (A) 需要 O(N) 空間；選項 (C) 會破壞原始結構且需要額外空間或複雜操作；選項 (D) 雖然可行但修改了結構，通常面試要求不修改原始資料。",
      "en": "Option (B) requires only two traversals (one to count lengths, one to find intersection), meeting O(N) time and O(1) space. Option (A) requires O(N) space; Option (C) modifies the structure and is complex; Option (D) is viable but modifies the original data, which is often forbidden in interviews.",
      "wg": [
        {
          "t": "破壞",
          "en": "modifies/destroys",
          "ps": "V"
        },
        {
          "t": "原始資料",
          "en": "original data",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Skip List, Data Structures, Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「跳躍串列」(Skip List) 的特性描述，下列何者正確？",
        "en": "Which of the following statements about 'Skip List' characteristics is correct?",
        "wg": [
          {
            "t": "跳躍串列",
            "en": "Skip List",
            "ps": "N"
          },
          {
            "t": "特性",
            "en": "characteristics",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這是一種常用於 Redis 等資料庫系統中的進階鏈結串列結構。",
        "en": "This is an advanced linked list structure commonly used in database systems like Redis.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它是一種確定性 (Deterministic) 的資料結構，保證每次插入後的結構都相同。",
        "en": "(A) It is a Deterministic data structure, guaranteeing the same structure after every insertion.",
        "wg": [
          {
            "t": "確定性",
            "en": "Deterministic",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 它的搜尋、插入與刪除的平均時間複雜度皆為 O(log N)，透過多層索引來加速。",
        "en": "(B) Its average time complexity for search, insertion, and deletion is O(log N), achieved through multi-level indexing.",
        "wg": [
          {
            "t": "平均時間複雜度",
            "en": "average time complexity",
            "ps": "N"
          },
          {
            "t": "多層索引",
            "en": "multi-level indexing",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它比平衡二元搜尋樹 (如 AVL Tree) 更難實作，且需要頻繁的旋轉操作。",
        "en": "(C) It is harder to implement than balanced binary search trees (like AVL Trees) and requires frequent rotation operations.",
        "wg": [
          {
            "t": "旋轉操作",
            "en": "rotation operations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 它完全不需要額外的記憶體空間，因為它重複利用了現有的節點指標。",
        "en": "(D) It requires absolutely no extra memory space because it reuses existing node pointers.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "跳躍串列是一種「機率性」資料結構，透過建立多層鏈結來跳過部分節點，達到類似二分搜尋的效果。其平均複雜度為 O(log N)。它比平衡樹容易實作 (不需旋轉)，但需要額外空間儲存多層指標。",
      "en": "A Skip List is a 'probabilistic' data structure that builds multiple layers of links to skip over nodes, achieving an effect similar to binary search. Its average complexity is O(log N). It is easier to implement than balanced trees (no rotations needed) but requires extra space for multi-level pointers.",
      "wg": [
        {
          "t": "機率性",
          "en": "probabilistic",
          "ps": "Adj"
        },
        {
          "t": "二分搜尋",
          "en": "binary search",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Dummy Node, Sentinel Node, Implementation Patterns",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode dummy = new ListNode(0);\ndummy.next = head;",
    "question": [
      {
        "t": "在處理鏈結串列問題 (如合併兩個串列或刪除特定節點) 時，經常會建立一個「啞節點」(Dummy Node / Sentinel Node) 指向頭部。",
        "en": "When solving linked list problems (such as merging two lists or deleting specific nodes), a 'Dummy Node' (or Sentinel Node) pointing to the head is often created.",
        "wg": [
          {
            "t": "啞節點",
            "en": "Dummy Node",
            "ps": "N"
          },
          {
            "t": "哨兵節點",
            "en": "Sentinel Node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用這個技巧的主要好處是什麼？",
        "en": "What is the primary benefit of using this technique?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以減少記憶體的使用量。",
        "en": "(A) It reduces memory usage.",
        "wg": []
      },
      {
        "t": "(B) 它可以將時間複雜度從 O(N) 降低到 O(1)。",
        "en": "(B) It reduces the time complexity from O(N) to O(1).",
        "wg": []
      },
      {
        "t": "(C) 它簡化了邊界情況的處理，特別是當頭部節點 (Head) 可能改變或被刪除時。",
        "en": "(C) It simplifies the handling of edge cases, especially when the head node might change or be deleted.",
        "wg": [
          {
            "t": "邊界情況",
            "en": "edge cases",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 它可以防止鏈結串列產生環 (Cycle)。",
        "en": "(D) It prevents the linked list from creating a cycle.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "啞節點作為一個固定的前驅節點，使得第一個節點的操作與其他節點一致，消除了需要單獨判斷 `if (head == null)` 或處理頭部被刪除後更新 `head` 變數的複雜邏輯。",
      "en": "The Dummy Node acts as a fixed predecessor, making operations on the first node consistent with others. It eliminates the need for complex logic to check `if (head == null)` or to update the `head` variable if the head node is deleted.",
      "wg": [
        {
          "t": "前驅節點",
          "en": "predecessor node",
          "ps": "N"
        },
        {
          "t": "一致",
          "en": "consistent",
          "ps": "Adj"
        }
      ]
    }
  }
]