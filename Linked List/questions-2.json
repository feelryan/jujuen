[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Cycle Detection, Floyd's Cycle-Finding Algorithm, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個單向鏈結串列 (Singly Linked List)，您需要檢測其中是否存在環 (Cycle)。",
        "en": "Given a Singly Linked List, you need to detect if a cycle exists within it.",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "Singly Linked List",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了滿足 O(1) 的空間複雜度要求，下列哪種方法最為合適？",
        "en": "To satisfy the requirement of O(1) space complexity, which of the following methods is most suitable?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Set) 儲存已訪問過的節點。",
        "en": "(A) Use a Hash Set to store visited nodes.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 修改節點結構，增加一個 'visited' 布林標記。",
        "en": "(B) Modify the node structure to add a 'visited' boolean flag.",
        "wg": []
      },
      {
        "t": "(C) 使用快慢指標 (Floyd's Cycle-Finding Algorithm)。",
        "en": "(C) Use fast and slow pointers (Floyd's Cycle-Finding Algorithm).",
        "wg": [
          {
            "t": "快慢指標",
            "en": "fast and slow pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遞迴遍歷串列並設定計時器。",
        "en": "(D) Recursively traverse the list and set a timer.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "使用快慢指標 (龜兔賽跑演算法) 可以在不使用額外記憶體空間 (O(1)) 的情況下檢測環；雜湊表需要 O(N) 空間，而修改節點結構通常是不被允許或不切實際的。",
      "en": "Using fast and slow pointers (Tortoise and Hare algorithm) allows cycle detection without using extra memory space (O(1)); a Hash Set requires O(N) space, and modifying the node structure is usually not allowed or practical.",
      "wg": [
        {
          "t": "額外記憶體",
          "en": "extra memory",
          "ps": "N"
        },
        {
          "t": "不切實際",
          "en": "impractical",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Middle Node, Two Pointers, Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要在不知道鏈結串列長度的情況下，僅透過一次遍歷 (One Pass) 找到鏈結串列的中間節點。",
        "en": "You need to find the middle node of a linked list in only one pass without knowing the length of the list.",
        "wg": [
          {
            "t": "一次遍歷",
            "en": "one pass",
            "ps": "N"
          },
          {
            "t": "中間節點",
            "en": "middle node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問應該採取什麼策略？",
        "en": "What strategy should be adopted?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先遍歷一次計算長度，再遍歷第二次到長度的一半。",
        "en": "(A) Traverse once to count the length, then traverse a second time to half the length.",
        "wg": []
      },
      {
        "t": "(B) 使用兩個指標，快指標每次移動兩步，慢指標每次移動一步。",
        "en": "(B) Use two pointers; the fast pointer moves two steps at a time, and the slow pointer moves one step at a time.",
        "wg": [
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將所有節點複製到陣列中，然後存取中間索引。",
        "en": "(C) Copy all nodes into an array and then access the middle index.",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 每次刪除頭尾節點，直到剩下最後一個節點。",
        "en": "(D) Delete head and tail nodes repeatedly until only the last node remains.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當快指標到達終點時，慢指標剛好會位於串列的中間，這符合一次遍歷的要求；選項 (A) 需要兩次遍歷 (或 1.5 次)，選項 (C) 增加了 O(N) 的空間複雜度。",
      "en": "When the fast pointer reaches the end, the slow pointer will be exactly at the middle of the list, which meets the one-pass requirement; option (A) requires two passes (or 1.5), and option (C) adds O(N) space complexity.",
      "wg": [
        {
          "t": "終點",
          "en": "end/termination point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Reverse Linked List, Iterative, Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (curr != null) {\n  nextTemp = curr.next;\n  curr.next = prev;\n  prev = curr;\n  curr = nextTemp;\n}",
    "question": [
      {
        "t": "在反轉單向鏈結串列的迭代實作中，上述程式碼片段扮演了關鍵角色。",
        "en": "In the iterative implementation of reversing a singly linked list, the above code snippet plays a key role.",
        "wg": [
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          },
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問 `nextTemp = curr.next` 這行程式碼的主要目的是什麼？",
        "en": "What is the primary purpose of the line `nextTemp = curr.next`?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將當前節點指向前一個節點。",
        "en": "(A) Point the current node to the previous node.",
        "wg": []
      },
      {
        "t": "(B) 暫存下一個節點的參考，以免在切斷連結後遺失後續串列。",
        "en": "(B) Temporarily store the reference to the next node to avoid losing the rest of the list after breaking the link.",
        "wg": [
          {
            "t": "暫存",
            "en": "temporarily store",
            "ps": "V"
          },
          {
            "t": "遺失",
            "en": "losing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 更新 `prev` 指標以推進迭代。",
        "en": "(C) Update the `prev` pointer to advance the iteration.",
        "wg": [
          {
            "t": "推進",
            "en": "advance",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 檢查串列是否已經結束。",
        "en": "(D) Check if the list has ended.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "一旦執行 `curr.next = prev` (反轉指標方向)，原本指向下一個節點的連結就會斷開。如果沒有先用 `nextTemp` 保存起來，將無法繼續遍歷剩下的節點。",
      "en": "Once `curr.next = prev` (reversing the pointer direction) is executed, the link to the next node is broken. If it is not saved in `nextTemp` first, it will be impossible to continue traversing the remaining nodes.",
      "wg": [
        {
          "t": "斷開",
          "en": "broken/severed",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "traversing",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Dummy Node, Sentinel Node, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理鏈結串列問題（如合併兩個排序串列或刪除特定節點）時，經常會建立一個「虛擬頭節點」(Dummy Head / Sentinel Node)。",
        "en": "When dealing with linked list problems (such as merging two sorted lists or deleting specific nodes), a 'Dummy Head' (or Sentinel Node) is often created.",
        "wg": [
          {
            "t": "虛擬頭節點",
            "en": "Dummy Head",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merging",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用虛擬頭節點的主要好處是什麼？",
        "en": "What is the main benefit of using a dummy head node?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 減少記憶體的使用量。",
        "en": "(A) Reduce memory usage.",
        "wg": []
      },
      {
        "t": "(B) 簡化邊界情況的處理，例如當頭節點可能被改變或刪除時。",
        "en": "(B) Simplify the handling of edge cases, such as when the head node might be changed or deleted.",
        "wg": [
          {
            "t": "邊界情況",
            "en": "edge cases",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 加快存取串列尾端的速度。",
        "en": "(C) Speed up access to the tail of the list.",
        "wg": []
      },
      {
        "t": "(D) 防止鏈結串列產生環。",
        "en": "(D) Prevent the linked list from creating cycles.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "虛擬頭節點確保回傳的結果總是有一個非空的參考點，這消除了針對「頭節點為空」或「頭節點被刪除」等情況撰寫額外 `if/else` 判斷的需要。",
      "en": "A dummy head node ensures that the returned result always has a non-null reference point, eliminating the need to write extra `if/else` checks for cases where the 'head is null' or the 'head is deleted'.",
      "wg": [
        {
          "t": "消除",
          "en": "eliminating",
          "ps": "V"
        },
        {
          "t": "判斷",
          "en": "checks/judgments",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Doubly Linked List, Deletion, Pointer Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在雙向鏈結串列 (Doubly Linked List) 中刪除一個非頭尾的中間節點 `curr`。",
        "en": "Deleting a middle node `curr` (neither head nor tail) in a Doubly Linked List.",
        "wg": [
          {
            "t": "雙向鏈結串列",
            "en": "Doubly Linked List",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一組指標操作是正確且完整的？",
        "en": "Which of the following sets of pointer operations is correct and complete?",
        "wg": [
          {
            "t": "完整的",
            "en": "complete",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `curr.prev.next = curr.next;`",
        "en": "(A) `curr.prev.next = curr.next;`",
        "wg": []
      },
      {
        "t": "(B) `curr.next.prev = curr.prev;`",
        "en": "(B) `curr.next.prev = curr.prev;`",
        "wg": []
      },
      {
        "t": "(C) `curr.prev.next = curr.next; curr.next.prev = curr.prev;`",
        "en": "(C) `curr.prev.next = curr.next; curr.next.prev = curr.prev;`",
        "wg": []
      },
      {
        "t": "(D) `curr.prev = null; curr.next = null;`",
        "en": "(D) `curr.prev = null; curr.next = null;`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雙向鏈結串列的刪除需要同時更新「前一個節點的 next 指標」與「後一個節點的 prev 指標」，才能完全將該節點從串列中移除並維持雙向連結。",
      "en": "Deletion in a doubly linked list requires updating both 'the next pointer of the previous node' and 'the prev pointer of the next node' to completely remove the node from the list and maintain the bidirectional links.",
      "wg": [
        {
          "t": "維持",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "雙向連結",
          "en": "bidirectional links",
          "ps": "N"
        }
      ]
    }
  }
]