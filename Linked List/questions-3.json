[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Cycle Detection, Two Pointers, Floyd's Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，您被要求檢測一個單向鏈結串列 (Singly Linked List) 是否包含循環 (Cycle)。",
        "en": "In an interview, you are asked to detect if a singly linked list contains a cycle.",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "singly linked list",
            "ps": "NP"
          },
          {
            "t": "循環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您決定使用 Floyd 的判圈演算法 (龜兔賽跑演算法)。",
        "en": "You decide to use Floyd's Cycle-Finding Algorithm (Tortoise and Hare algorithm).",
        "wg": [
          {
            "t": "判圈演算法",
            "en": "Cycle-Finding Algorithm",
            "ps": "NP"
          },
          {
            "t": "龜兔賽跑",
            "en": "Tortoise and Hare",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "關於此演算法的空間複雜度與指標移動方式，下列敘述何者正確？",
        "en": "Which of the following statements regarding the space complexity and pointer movement of this algorithm is correct?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "NP"
          },
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 空間複雜度為 O(n)，慢指標每次移動 1 步，快指標每次移動 2 步。",
        "en": "(A) Space complexity is O(n); the slow pointer moves 1 step and the fast pointer moves 2 steps at a time.",
        "wg": []
      },
      {
        "t": "(B) 空間複雜度為 O(1)，慢指標每次移動 1 步，快指標每次移動 2 步。",
        "en": "(B) Space complexity is O(1); the slow pointer moves 1 step and the fast pointer moves 2 steps at a time.",
        "wg": []
      },
      {
        "t": "(C) 空間複雜度為 O(1)，兩個指標都以相同的速度移動，但從不同的起點出發。",
        "en": "(C) Space complexity is O(1); both pointers move at the same speed but start from different positions.",
        "wg": []
      },
      {
        "t": "(D) 空間複雜度為 O(n)，需要使用雜湊表 (Hash Table) 來記錄訪問過的節點。",
        "en": "(D) Space complexity is O(n); it requires a Hash Table to record visited nodes.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Table",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Floyd 判圈演算法利用兩個指標 (快慢指標) 在鏈結串列中移動，不需要額外的儲存空間來記錄節點，因此空間複雜度為 O(1)。如果串列中有環，移動較快的指標最終會追上移動較慢的指標。",
      "en": "Floyd's Cycle-Finding Algorithm uses two pointers (fast and slow) to traverse the linked list without needing extra storage for nodes, so the space complexity is O(1). If there is a cycle, the faster pointer will eventually catch up to the slower pointer.",
      "wg": [
        {
          "t": "追上",
          "en": "catch up to",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Reverse, Iterative, Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode prev = null;\nListNode curr = head;\nwhile (curr != null) {\n    ListNode nextTemp = curr.next;\n    // Missing Line\n    prev = curr;\n    curr = nextTemp;\n}\nreturn prev;",
    "question": [
      {
        "t": "請檢視上方的程式碼片段，這是用來反轉單向鏈結串列的迭代解法。",
        "en": "Please examine the code snippet above, which is an iterative solution to reverse a singly linked list.",
        "wg": [
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          },
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了正確地將當前節點的指標指向前一個節點，`// Missing Line` 處應該填入什麼程式碼？",
        "en": "To correctly point the current node's pointer to the previous node, what code should be inserted at `// Missing Line`?",
        "wg": [
          {
            "t": "當前節點",
            "en": "current node",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `curr.next = prev;`",
        "en": "(A) `curr.next = prev;`",
        "wg": []
      },
      {
        "t": "(B) `prev.next = curr;`",
        "en": "(B) `prev.next = curr;`",
        "wg": []
      },
      {
        "t": "(C) `curr.next = nextTemp;`",
        "en": "(C) `curr.next = nextTemp;`",
        "wg": []
      },
      {
        "t": "(D) `nextTemp.next = prev;`",
        "en": "(D) `nextTemp.next = prev;`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在反轉過程中，我們必須切斷當前節點 (`curr`) 與原本下一個節點的連結，並將其 `next` 指標指向前一個節點 (`prev`)。變數 `nextTemp` 已經暫存了原本的下一個節點，確保鏈結不會斷裂。",
      "en": "During the reversal process, we must break the link between the current node (`curr`) and the original next node, and point its `next` pointer to the previous node (`prev`). The variable `nextTemp` has already temporarily stored the original next node to ensure the link is not lost.",
      "wg": [
        {
          "t": "切斷",
          "en": "break",
          "ps": "V"
        },
        {
          "t": "暫存",
          "en": "temporarily store",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "N-th Node, Two Pointers, One Pass",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要找出單向鏈結串列中「倒數第 k 個」節點。",
        "en": "You need to find the \"k-th node from the end\" of a singly linked list.",
        "wg": [
          {
            "t": "倒數",
            "en": "from the end",
            "ps": "Adv"
          },
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了只遍歷串列一次 (One Pass) 就完成此任務，最佳的策略是什麼？",
        "en": "What is the best strategy to accomplish this task by traversing the list only once (One Pass)?",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先遍歷一次計算總長度 L，再遍歷第二次移動到 L-k 的位置。",
        "en": "(A) Traverse once to calculate the total length L, then traverse a second time to move to the L-k position.",
        "wg": []
      },
      {
        "t": "(B) 使用兩個指標，讓快指標先移動 k 步，然後兩個指標同時移動直到快指標到達終點。",
        "en": "(B) Use two pointers; let the fast pointer move k steps first, then move both pointers simultaneously until the fast pointer reaches the end.",
        "wg": [
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 反轉整個鏈結串列，然後從頭移動 k 步。",
        "en": "(C) Reverse the entire linked list, then move k steps from the head.",
        "wg": []
      },
      {
        "t": "(D) 將所有節點存入陣列中，直接存取索引為 length - k 的元素。",
        "en": "(D) Store all nodes in an array and directly access the element at index length - k.",
        "wg": [
          {
            "t": "存取",
            "en": "access",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用雙指標法可以達成一次遍歷。當快指標先走 k 步後，快慢指標之間保持 k 的距離。當快指標到達尾端 (null) 時，慢指標剛好會停在倒數第 k 個節點上。選項 (A) 需要兩次遍歷，選項 (D) 增加了 O(n) 的空間複雜度。",
      "en": "Using the two-pointer method achieves a one-pass solution. After the fast pointer moves k steps, a distance of k is maintained between the fast and slow pointers. When the fast pointer reaches the end (null), the slow pointer will be exactly at the k-th node from the end. Option (A) requires two traversals, and Option (D) increases space complexity to O(n).",
      "wg": [
        {
          "t": "距離",
          "en": "distance",
          "ps": "N"
        },
        {
          "t": "尾端",
          "en": "end/tail",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Merge, Sorted List, Dummy Node",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "合併兩個已排序的單向鏈結串列時，通常會建議使用一個「虛擬節點」(Dummy Node / Sentinel Node)。",
        "en": "When merging two sorted singly linked lists, it is often recommended to use a \"Dummy Node\" (or Sentinel Node).",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          },
          {
            "t": "虛擬節點",
            "en": "Dummy Node",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "使用虛擬節點的主要好處是什麼？",
        "en": "What is the primary benefit of using a dummy node?",
        "wg": [
          {
            "t": "主要好處",
            "en": "primary benefit",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以自動排序輸入的資料，降低時間複雜度。",
        "en": "(A) It automatically sorts the input data, reducing time complexity.",
        "wg": []
      },
      {
        "t": "(B) 它可以簡化處理新串列「頭部」的邊界情況，避免需要額外判斷頭節點是否為空。",
        "en": "(B) It simplifies handling the \"head\" edge cases of the new list, avoiding the need for extra checks on whether the head node is null.",
        "wg": [
          {
            "t": "邊界情況",
            "en": "edge cases",
            "ps": "NP"
          },
          {
            "t": "判斷",
            "en": "check/determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 它可以將單向鏈結串列轉換為雙向鏈結串列。",
        "en": "(C) It converts a singly linked list into a doubly linked list.",
        "wg": []
      },
      {
        "t": "(D) 它可以減少記憶體的使用量。",
        "en": "(D) It reduces memory usage.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在合併過程中，我們需要一個指標來構建新的串列。如果沒有虛擬節點，我們必須寫額外的 `if-else` 邏輯來初始化結果串列的第一個節點 (Head)。使用虛擬節點可以讓我們統一處理所有節點的連接邏輯，最後只需回傳 `dummy.next`。",
      "en": "During the merge process, we need a pointer to build the new list. Without a dummy node, we would have to write extra `if-else` logic to initialize the first node (Head) of the result list. Using a dummy node allows us to unify the connection logic for all nodes and simply return `dummy.next` at the end.",
      "wg": [
        {
          "t": "構建",
          "en": "build/construct",
          "ps": "V"
        },
        {
          "t": "統一",
          "en": "unify/standardize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Doubly Linked List, Deletion, Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在雙向鏈結串列 (Doubly Linked List) 中，若要刪除一個非頭尾的特定節點 `curr`。",
        "en": "In a Doubly Linked List, if you want to delete a specific node `curr` that is neither the head nor the tail.",
        "wg": [
          {
            "t": "雙向鏈結串列",
            "en": "Doubly Linked List",
            "ps": "NP"
          },
          {
            "t": "特定",
            "en": "specific",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪一組操作是正確且完整的？",
        "en": "Which of the following sets of operations is correct and complete?",
        "wg": [
          {
            "t": "完整",
            "en": "complete",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `curr.prev.next = curr.next;`",
        "en": "(A) `curr.prev.next = curr.next;`",
        "wg": []
      },
      {
        "t": "(B) `curr.next.prev = curr.prev;`",
        "en": "(B) `curr.next.prev = curr.prev;`",
        "wg": []
      },
      {
        "t": "(C) `curr.prev.next = curr.next;` 且 `curr.next.prev = curr.prev;`",
        "en": "(C) `curr.prev.next = curr.next;` and `curr.next.prev = curr.prev;`",
        "wg": []
      },
      {
        "t": "(D) `curr.next = curr.prev;` 且 `curr.prev = curr.next;`",
        "en": "(D) `curr.next = curr.prev;` and `curr.prev = curr.next;`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雙向鏈結串列的刪除操作需要同時更新兩個方向的指標：將「前一個節點的 next」指向「下一個節點」，並將「下一個節點的 prev」指向「前一個節點」，這樣才能完全將 `curr` 從鏈結中移除。",
      "en": "Deleting a node in a doubly linked list requires updating pointers in both directions: pointing the \"next of the previous node\" to the \"next node\", and pointing the \"prev of the next node\" to the \"previous node\". This completely removes `curr` from the chain.",
      "wg": [
        {
          "t": "移除",
          "en": "remove",
          "ps": "V"
        },
        {
          "t": "方向",
          "en": "direction",
          "ps": "N"
        }
      ]
    }
  }
]