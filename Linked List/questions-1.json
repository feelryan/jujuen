[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Time Complexity, Array, Linked List, Insertion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統，需要頻繁地在資料結構的「開頭」插入或刪除元素。",
        "en": "You are designing a system that requires frequent insertion or deletion of elements at the 'beginning' of a data structure.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "插入",
            "en": "insertion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若不考慮記憶體空間的額外開銷，下列哪種資料結構在執行此操作時通常最具效率？",
        "en": "Disregarding memory overhead, which of the following data structures is generally most efficient for this operation?",
        "wg": [
          {
            "t": "額外開銷",
            "en": "overhead",
            "ps": "N"
          },
          {
            "t": "最具效率",
            "en": "most efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 動態陣列 (Dynamic Array)",
        "en": "(A) Dynamic Array",
        "wg": []
      },
      {
        "t": "(B) 單向鏈結串列 (Singly Linked List)",
        "en": "(B) Singly Linked List",
        "wg": []
      },
      {
        "t": "(C) 雜湊表 (Hash Table)",
        "en": "(C) Hash Table",
        "wg": []
      },
      {
        "t": "(D) 堆積 (Heap)",
        "en": "(D) Heap",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在鏈結串列的頭部插入節點僅需更新指標，時間複雜度為 O(1)。相比之下，陣列在頭部插入元素需要將所有現有元素向後搬移，時間複雜度為 O(N)。",
      "en": "Inserting a node at the head of a linked list only requires updating pointers, with a time complexity of O(1). In contrast, inserting at the beginning of an array requires shifting all existing elements, resulting in O(N) complexity.",
      "wg": [
        {
          "t": "搬移",
          "en": "shifting",
          "ps": "V"
        },
        {
          "t": "時間複雜度",
          "en": "time complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Cycle Detection, Two Pointers, Floyd's Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，您被要求檢測一個單向鏈結串列是否包含「環」(Cycle)。",
        "en": "In an interview, you are asked to detect if a singly linked list contains a 'cycle'.",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "singly linked list",
            "ps": "N"
          },
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了滿足 O(1) 的空間複雜度限制，您應該採用哪種演算法或策略？",
        "en": "To satisfy the constraint of O(1) space complexity, which algorithm or strategy should you adopt?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊集合 (HashSet) 儲存走過的節點。",
        "en": "(A) Use a HashSet to store visited nodes.",
        "wg": [
          {
            "t": "走過的",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 修改節點結構，增加一個「已訪問」的布林標記。",
        "en": "(B) Modify the node structure to add a 'visited' boolean flag.",
        "wg": [
          {
            "t": "修改",
            "en": "modify",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用快慢指標 (Floyd's Cycle-Finding Algorithm)。",
        "en": "(C) Use Fast and Slow Pointers (Floyd's Cycle-Finding Algorithm).",
        "wg": [
          {
            "t": "快慢指標",
            "en": "Fast and Slow Pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 遞迴走訪並設定最大深度限制。",
        "en": "(D) Recursively traverse and set a maximum depth limit.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "快慢指標法僅使用兩個指標變數，因此空間複雜度為 O(1)。若使用 HashSet，空間複雜度會隨著節點數量增加而變成 O(N)；修改節點結構則破壞了原始資料定義且不總是可行。",
      "en": "The Fast and Slow Pointers method uses only two pointer variables, so the space complexity is O(1). Using a HashSet results in O(N) space complexity as it grows with the number of nodes; modifying the node structure violates the original data definition and is not always feasible.",
      "wg": [
        {
          "t": "變數",
          "en": "variable",
          "ps": "N"
        },
        {
          "t": "可行",
          "en": "feasible",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Doubly Linked List, Singly Linked List, Trade-off",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "相較於單向鏈結串列，雙向鏈結串列 (Doubly Linked List) 的主要優勢為何？",
        "en": "Compared to a Singly Linked List, what is the main advantage of a Doubly Linked List?",
        "wg": [
          {
            "t": "雙向鏈結串列",
            "en": "Doubly Linked List",
            "ps": "N"
          },
          {
            "t": "優勢",
            "en": "advantage",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出最能體現其結構特性的敘述。",
        "en": "Please select the statement that best embodies its structural characteristics.",
        "wg": [
          {
            "t": "體現",
            "en": "embodies",
            "ps": "V"
          },
          {
            "t": "特性",
            "en": "characteristics",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它使用的記憶體空間較少。",
        "en": "(A) It uses less memory space.",
        "wg": []
      },
      {
        "t": "(B) 它可以直接以 O(1) 時間存取第 k 個元素。",
        "en": "(B) It can access the k-th element directly in O(1) time.",
        "wg": [
          {
            "t": "存取",
            "en": "access",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 給定一個節點指標，可以在 O(1) 時間內刪除該節點（無需從頭走訪）。",
        "en": "(C) Given a pointer to a node, that node can be deleted in O(1) time (without traversing from the head).",
        "wg": [
          {
            "t": "走訪",
            "en": "traversing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 它可以避免產生循環參照的問題。",
        "en": "(D) It avoids the problem of circular references.",
        "wg": [
          {
            "t": "循環參照",
            "en": "circular references",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雙向鏈結串列的節點持有前驅節點 (prev) 的指標，因此若已知某節點，可以直接存取其前一個節點來執行刪除操作。單向鏈結串列則必須從頭走訪以找到前一個節點，耗時 O(N)。",
      "en": "Nodes in a Doubly Linked List hold a pointer to the predecessor (prev), so if a node is known, its predecessor can be directly accessed to perform deletion. A Singly Linked List requires traversing from the head to find the previous node, taking O(N) time.",
      "wg": [
        {
          "t": "前驅節點",
          "en": "predecessor",
          "ps": "N"
        },
        {
          "t": "耗時",
          "en": "taking (time)",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Random Access, Performance, Array vs List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "如果您的應用程式主要操作是透過索引值 (Index) 來讀取資料（例如二元搜尋），",
        "en": "If your application's primary operation is reading data via index values (e.g., binary search),",
        "wg": [
          {
            "t": "索引值",
            "en": "index values",
            "ps": "N"
          },
          {
            "t": "二元搜尋",
            "en": "binary search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼使用鏈結串列 (Linked List) 通常是一個糟糕的選擇？",
        "en": "Why is using a Linked List usually a poor choice?",
        "wg": [
          {
            "t": "糟糕的",
            "en": "poor",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 鏈結串列不支援動態大小調整。",
        "en": "(A) Linked Lists do not support dynamic resizing.",
        "wg": []
      },
      {
        "t": "(B) 鏈結串列缺乏隨機存取 (Random Access) 能力，讀取第 k 個元素需 O(k) 時間。",
        "en": "(B) Linked Lists lack Random Access capability; reading the k-th element takes O(k) time.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "Random Access",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 鏈結串列插入元素的速度比陣列慢。",
        "en": "(C) Linked Lists are slower at inserting elements than arrays.",
        "wg": []
      },
      {
        "t": "(D) 鏈結串列無法儲存整數以外的資料型態。",
        "en": "(D) Linked Lists cannot store data types other than integers.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "陣列支援 O(1) 的隨機存取，適合索引讀取。鏈結串列必須從頭開始依序走訪指標 (Sequential Access) 才能到達指定位置，這使得二元搜尋等演算法效率極低。",
      "en": "Arrays support O(1) random access, making them suitable for index-based reading. Linked Lists must traverse pointers sequentially from the start (Sequential Access) to reach a specific position, making algorithms like binary search extremely inefficient.",
      "wg": [
        {
          "t": "依序",
          "en": "sequentially",
          "ps": "Adv"
        },
        {
          "t": "極低",
          "en": "extremely inefficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Dummy Node, Sentinel, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "ListNode dummy = new ListNode(0);\ndummy.next = head;\n// ... operations ...\nreturn dummy.next;",
    "question": [
      {
        "t": "在解決鏈結串列問題時，常會使用「虛擬頭節點」(Dummy Node / Sentinel Node) 技巧（如上方程式碼所示）。",
        "en": "When solving Linked List problems, the 'Dummy Node' (or Sentinel Node) technique is often used (as shown in the code snippet above).",
        "wg": [
          {
            "t": "虛擬頭節點",
            "en": "Dummy Node",
            "ps": "N"
          },
          {
            "t": "技巧",
            "en": "technique",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這個技巧的主要目的是什麼？",
        "en": "What is the primary purpose of this technique?",
        "wg": [
          {
            "t": "主要目的",
            "en": "primary purpose",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了節省記憶體空間。",
        "en": "(A) To save memory space.",
        "wg": []
      },
      {
        "t": "(B) 為了加快走訪速度。",
        "en": "(B) To speed up traversal.",
        "wg": []
      },
      {
        "t": "(C) 為了簡化處理頭部節點 (Head) 可能變動的邊界情況。",
        "en": "(C) To simplify handling edge cases where the head node might change.",
        "wg": [
          {
            "t": "邊界情況",
            "en": "edge cases",
            "ps": "N"
          },
          {
            "t": "變動",
            "en": "change",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 為了防止鏈結串列產生環。",
        "en": "(D) To prevent the linked list from creating a cycle.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當操作可能導致新的頭節點產生（例如刪除第一個節點或插入新節點到最前面）時，使用 Dummy Node 可以讓所有節點（包含頭節點）的處理邏輯一致，避免針對頭部撰寫額外的 `if-else` 判斷。",
      "en": "When operations might result in a new head node (e.g., deleting the first node or inserting a new node at the front), using a Dummy Node allows for consistent handling logic for all nodes (including the head), avoiding extra `if-else` checks specifically for the head.",
      "wg": [
        {
          "t": "一致",
          "en": "consistent",
          "ps": "Adj"
        },
        {
          "t": "判斷",
          "en": "checks",
          "ps": "N"
        }
      ]
    }
  }
]