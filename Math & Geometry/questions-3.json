[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Matrix, Linear Algebra, In-place Algorithm, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
    "question": [
      {
        "t": "給定一個 N × N 的二維矩陣代表一張影像，您需要將影像順時針旋轉 90 度。",
        "en": "Given an N × N 2D matrix representing an image, you need to rotate the image by 90 degrees (clockwise).",
        "wg": [
          {
            "t": "二維矩陣",
            "en": "2D matrix",
            "ps": "N"
          },
          {
            "t": "順時針",
            "en": "clockwise",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "為了節省記憶體空間，您必須「原地」修改輸入的二維矩陣。",
        "en": "To save memory space, you have to modify the input 2D matrix 'in-place'.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj/Adv"
          }
        ]
      },
      {
        "t": "下列哪一種操作組合可以正確且最有效率地達成此目標？",
        "en": "Which of the following combinations of operations can achieve this goal correctly and most efficiently?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將矩陣進行轉置 (Transpose)，然後反轉每一列 (Reverse each row)。",
        "en": "(A) Transpose the matrix first, then reverse each row.",
        "wg": [
          {
            "t": "轉置",
            "en": "transpose",
            "ps": "V/N"
          },
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 先反轉每一列，然後將矩陣進行轉置。",
        "en": "(B) Reverse each row first, then transpose the matrix.",
        "wg": []
      },
      {
        "t": "(C) 先將矩陣進行轉置，然後反轉每一行 (Reverse each column)。",
        "en": "(C) Transpose the matrix first, then reverse each column.",
        "wg": []
      },
      {
        "t": "(D) 建立一個新的 N × N 矩陣，填入旋轉後的數值，再複製回原矩陣。",
        "en": "(D) Create a new N × N matrix, fill in the rotated values, and copy them back to the original matrix.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "順時針旋轉 90 度的數學變換等同於先沿主對角線轉置矩陣 (matrix[i][j] 與 matrix[j][i] 交換)，再將每一列的元素順序反轉。選項 (D) 雖然正確但使用了額外的 O(N^2) 空間，不符合「原地」要求。",
      "en": "The mathematical transformation for a 90-degree clockwise rotation is equivalent to first transposing the matrix along the main diagonal (swapping matrix[i][j] with matrix[j][i]) and then reversing the order of elements in each row. Option (D) is correct but uses extra O(N^2) space, which does not meet the 'in-place' requirement.",
      "wg": [
        {
          "t": "主對角線",
          "en": "main diagonal",
          "ps": "N"
        },
        {
          "t": "變換",
          "en": "transformation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "easy",
    "keywords": "Math, GCD, Euclidean Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a",
    "question": [
      {
        "t": "在處理數論問題時，我們常使用歐幾里得演算法 (Euclidean Algorithm) 來計算兩個正整數 a 和 b 的最大公因數 (GCD)。",
        "en": "When dealing with number theory problems, we often use the Euclidean Algorithm to calculate the Greatest Common Divisor (GCD) of two positive integers a and b.",
        "wg": [
          {
            "t": "數論",
            "en": "number theory",
            "ps": "N"
          },
          {
            "t": "歐幾里得演算法",
            "en": "Euclidean Algorithm",
            "ps": "N"
          },
          {
            "t": "最大公因數",
            "en": "Greatest Common Divisor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問此演算法的時間複雜度為何？",
        "en": "What is the time complexity of this algorithm?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(a + b)",
        "en": "(A) O(a + b)",
        "wg": []
      },
      {
        "t": "(B) O(min(a, b))",
        "en": "(B) O(min(a, b))",
        "wg": []
      },
      {
        "t": "(C) O(log(min(a, b)))",
        "en": "(C) O(log(min(a, b)))",
        "wg": []
      },
      {
        "t": "(D) O(1)",
        "en": "(D) O(1)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "歐幾里得演算法利用餘數運算，每次迭代後數值至少會減少一半（類似費氏數列的增長逆過程）。因此，其時間複雜度與較小數值的位數成正比，即對數級別 O(log(min(a, b)))。",
      "en": "The Euclidean algorithm uses modulo operations, and the value decreases by at least half after every two iterations (similar to the reverse process of Fibonacci sequence growth). Therefore, its time complexity is proportional to the number of digits of the smaller number, which is logarithmic O(log(min(a, b))).",
      "wg": [
        {
          "t": "迭代",
          "en": "iteration",
          "ps": "N"
        },
        {
          "t": "對數級別",
          "en": "logarithmic scale",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Geometry, Slope, Precision, Division by Zero",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在撰寫一個函式來判斷二維平面上的三個點 (x1, y1), (x2, y2), (x3, y3) 是否位於同一條直線上。",
        "en": "You are writing a function to determine if three points (x1, y1), (x2, y2), (x3, y3) on a 2D plane lie on the same straight line.",
        "wg": [
          {
            "t": "二維平面",
            "en": "2D plane",
            "ps": "N"
          },
          {
            "t": "直線",
            "en": "straight line",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了避免浮點數運算的精確度問題以及除以零的錯誤，下列哪種實作邏輯最為穩健？",
        "en": "To avoid floating-point precision issues and division-by-zero errors, which of the following implementation logic is the most robust?",
        "wg": [
          {
            "t": "浮點數",
            "en": "floating-point",
            "ps": "N"
          },
          {
            "t": "精確度",
            "en": "precision",
            "ps": "N"
          },
          {
            "t": "穩健",
            "en": "robust",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計算斜率 m1 = (y2-y1)/(x2-x1) 和 m2 = (y3-y2)/(x3-x2)，並檢查 m1 == m2。",
        "en": "(A) Calculate slopes m1 = (y2-y1)/(x2-x1) and m2 = (y3-y2)/(x3-x2), and check if m1 == m2.",
        "wg": [
          {
            "t": "斜率",
            "en": "slope",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用交叉相乘法檢查 (y2-y1) * (x3-x2) 是否等於 (y3-y2) * (x2-x1)。",
        "en": "(B) Use cross-multiplication to check if (y2-y1) * (x3-x2) equals (y3-y2) * (x2-x1).",
        "wg": [
          {
            "t": "交叉相乘",
            "en": "cross-multiplication",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用 Math.atan2 計算角度，並比較角度是否相等。",
        "en": "(C) Use Math.atan2 to calculate angles and compare if the angles are equal.",
        "wg": []
      },
      {
        "t": "(D) 計算三點構成的三角形面積，若面積非常小（小於某個 epsilon）則視為共線。",
        "en": "(D) Calculate the area of the triangle formed by the three points; if the area is very small (less than some epsilon), consider them collinear.",
        "wg": [
          {
            "t": "共線",
            "en": "collinear",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 在垂直線時會遇到除以零的問題，且浮點數比較存在誤差。選項 (B) 將斜率公式轉換為乘法形式，完全使用整數運算（假設輸入為整數），避免了除法異常與精度丟失，是最精確且安全的方法。",
      "en": "Option (A) encounters division-by-zero issues with vertical lines and suffers from floating-point inaccuracies. Option (B) transforms the slope formula into multiplication, using purely integer arithmetic (assuming integer inputs), thereby avoiding division exceptions and precision loss, making it the most precise and safe method.",
      "wg": [
        {
          "t": "誤差",
          "en": "error/inaccuracy",
          "ps": "N"
        },
        {
          "t": "異常",
          "en": "exception",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Math, Primes, Sieve of Eratosthenes, Algorithm Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要計算小於非負整數 n 的所有質數數量。",
        "en": "You need to count the number of prime numbers strictly less than a non-negative integer n.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          },
          {
            "t": "質數",
            "en": "prime number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 n 非常大時（例如 n = 5,000,000），直接對每個數字進行質數測試會太慢。",
        "en": "When n is very large (e.g., n = 5,000,000), testing each number for primality individually is too slow.",
        "wg": []
      },
      {
        "t": "下列哪種演算法最適合解決此問題？",
        "en": "Which of the following algorithms is most suitable for solving this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 埃拉托斯特尼篩法 (Sieve of Eratosthenes)。",
        "en": "(A) Sieve of Eratosthenes.",
        "wg": [
          {
            "t": "篩法",
            "en": "sieve",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 對每個數字使用試除法 (Trial Division) 至 sqrt(k)。",
        "en": "(B) Use Trial Division up to sqrt(k) for each number.",
        "wg": [
          {
            "t": "試除法",
            "en": "Trial Division",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 費馬小定理 (Fermat's Little Theorem) 質數測試。",
        "en": "(C) Fermat's Little Theorem primality test.",
        "wg": []
      },
      {
        "t": "(D) 深度優先搜尋 (DFS) 生成所有組合。",
        "en": "(D) Depth-First Search (DFS) to generate all combinations.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "埃拉托斯特尼篩法透過標記合數的方式，能高效地找出一定範圍內的所有質數，其時間複雜度為 O(n log log n)，遠優於對每個數字單獨檢查的 O(n√n)。",
      "en": "The Sieve of Eratosthenes efficiently finds all primes in a range by marking composite numbers. Its time complexity is O(n log log n), which is significantly better than O(n√n) for checking each number individually.",
      "wg": [
        {
          "t": "合數",
          "en": "composite number",
          "ps": "N"
        },
        {
          "t": "標記",
          "en": "mark",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Math, Hash Set, Cycle Detection, Floyd's Cycle-Finding",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "快樂數 (Happy Number) 的定義是：從一個正整數開始，將該數替換為其每位數字的平方和，重複此過程。",
        "en": "A Happy Number is defined as follows: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process.",
        "wg": [
          {
            "t": "平方和",
            "en": "sum of the squares",
            "ps": "N"
          },
          {
            "t": "位數",
            "en": "digit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若該過程最終收斂到 1，則該數為快樂數；若進入無限循環且不包含 1，則不是。",
        "en": "If the process eventually converges to 1, the number is a Happy Number; if it enters an infinite cycle that does not include 1, it is not.",
        "wg": [
          {
            "t": "收斂",
            "en": "converge",
            "ps": "V"
          },
          {
            "t": "無限循環",
            "en": "infinite cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在程式實作中，我們通常使用什麼資料結構或演算法來偵測這種「無限循環」？",
        "en": "In programming implementation, what data structure or algorithm do we typically use to detect this 'infinite cycle'?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack) 或 佇列 (Queue)。",
        "en": "(A) Stack or Queue.",
        "wg": []
      },
      {
        "t": "(B) 哈希集合 (Hash Set) 或 弗洛伊德循環查找演算法 (Floyd's Cycle-Finding Algorithm)。",
        "en": "(B) Hash Set or Floyd's Cycle-Finding Algorithm.",
        "wg": [
          {
            "t": "哈希集合",
            "en": "Hash Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 二元搜尋樹 (Binary Search Tree)。",
        "en": "(C) Binary Search Tree.",
        "wg": []
      },
      {
        "t": "(D) 動態規劃 (Dynamic Programming)。",
        "en": "(D) Dynamic Programming.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了判斷是否進入循環，我們需要記錄曾經出現過的數字。使用 Hash Set 可以快速檢查數字是否重複出現。另外，也可以將此過程視為鏈結串列，使用快慢指標 (Floyd's Algorithm) 來偵測循環。",
      "en": "To determine if a cycle has been entered, we need to track numbers that have appeared before. A Hash Set allows for quick checking of duplicate numbers. Alternatively, this process can be viewed as a linked list, using fast and slow pointers (Floyd's Algorithm) to detect cycles.",
      "wg": [
        {
          "t": "快慢指標",
          "en": "fast and slow pointers",
          "ps": "N"
        },
        {
          "t": "鏈結串列",
          "en": "linked list",
          "ps": "N"
        }
      ]
    }
  }
]