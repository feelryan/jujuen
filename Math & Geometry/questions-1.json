[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Geometry, Math, Conditional Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個矩形，分別由其左下角和右上角的座標定義，",
        "en": "Given two rectangles, defined by their bottom-left and top-right coordinates,",
        "wg": [
          {
            "t": "矩形",
            "en": "rectangle",
            "ps": "N"
          },
          {
            "t": "座標",
            "en": "coordinates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要判斷這兩個矩形是否重疊。",
        "en": "you need to determine if these two rectangles overlap.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一種邏輯判斷最常被用來快速排除重疊的可能性（即判斷不重疊）？",
        "en": "Which of the following logic checks is most commonly used to quickly rule out the possibility of overlap (i.e., determine non-overlapping)?",
        "wg": [
          {
            "t": "排除",
            "en": "rule out",
            "ps": "V"
          },
          {
            "t": "邏輯判斷",
            "en": "logic check",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 檢查兩個矩形的面積總和是否大於其聯集面積。",
        "en": "(A) Check if the sum of the areas of the two rectangles is greater than the area of their union.",
        "wg": [
          {
            "t": "聯集",
            "en": "union",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 檢查一個矩形是否完全包含在另一個矩形內。",
        "en": "(B) Check if one rectangle is completely contained within the other.",
        "wg": []
      },
      {
        "t": "(C) 檢查一個矩形是否在另一個矩形的左側、右側、上方或下方。",
        "en": "(C) Check if one rectangle is to the left, right, top, or bottom of the other.",
        "wg": []
      },
      {
        "t": "(D) 計算兩個矩形中心點的距離。",
        "en": "(D) Calculate the distance between the center points of the two rectangles.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "判斷矩形重疊最簡單的方法是檢查它們是否「不重疊」。如果一個矩形完全在另一個的左邊、右邊、上面或下面，則它們不可能重疊，這是最有效的條件檢查。",
      "en": "The simplest way to determine rectangle overlap is to check if they do 'not overlap'. If one rectangle is completely to the left, right, above, or below the other, they cannot overlap, which is the most efficient conditional check.",
      "wg": [
        {
          "t": "有效的",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Math, Prime Numbers, Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要撰寫一個演算法來計算小於非負整數 n 的所有質數數量。",
        "en": "You need to write an algorithm to count the number of prime numbers less than a non-negative integer n.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          },
          {
            "t": "質數",
            "en": "prime numbers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在處理較大的 n 時（例如 n = 5,000,000），下列哪種方法能提供最佳的時間複雜度？",
        "en": "When dealing with a large n (e.g., n = 5,000,000), which of the following methods offers the best time complexity?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個小於 n 的數字進行試除法 (Trial Division)，檢查是否能被 2 到 sqrt(num) 整除。",
        "en": "(A) Perform Trial Division on every number less than n, checking for divisibility by 2 to sqrt(num).",
        "wg": [
          {
            "t": "試除法",
            "en": "Trial Division",
            "ps": "N"
          },
          {
            "t": "整除",
            "en": "divisibility",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用埃拉托斯特尼篩法 (Sieve of Eratosthenes)。",
        "en": "(B) Use the Sieve of Eratosthenes.",
        "wg": [
          {
            "t": "篩法",
            "en": "sieve",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用遞迴檢查每個數字是否為質數。",
        "en": "(C) Use recursion to check if each number is prime.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 預先計算所有偶數，僅檢查奇數是否為質數。",
        "en": "(D) Pre-calculate all even numbers and only check if odd numbers are prime.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "埃拉托斯特尼篩法的時間複雜度為 O(n log log n)，遠優於對每個數字單獨進行質數測試的 O(n√n)。這是在給定範圍內尋找質數的標準高效演算法。",
      "en": "The time complexity of the Sieve of Eratosthenes is O(n log log n), which is significantly better than O(n√n) for testing each number individually. It is the standard efficient algorithm for finding primes within a range.",
      "wg": [
        {
          "t": "範圍",
          "en": "range",
          "ps": "N"
        },
        {
          "t": "高效",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Matrix, Array, In-place, Transformation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]",
    "question": [
      {
        "t": "給定一個 n × n 的二維矩陣代表一張影像，",
        "en": "Given an n × n 2D matrix representing an image,",
        "wg": [
          {
            "t": "二維矩陣",
            "en": "2D matrix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要將影像順時針旋轉 90 度，且必須「原地」(in-place) 修改矩陣。",
        "en": "you need to rotate the image by 90 degrees strictly clockwise and must modify the matrix 'in-place'.",
        "wg": [
          {
            "t": "順時針",
            "en": "clockwise",
            "ps": "Adv"
          },
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "下列哪一個步驟組合可以達成此目標？",
        "en": "Which combination of steps can achieve this goal?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將矩陣上下翻轉，再進行轉置 (Transpose)。",
        "en": "(A) First flip the matrix vertically, then transpose it.",
        "wg": [
          {
            "t": "轉置",
            "en": "transpose",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 先進行轉置 (Transpose)，再將每一列 (Row) 左右翻轉。",
        "en": "(B) First transpose the matrix, then reverse each row (flip horizontally).",
        "wg": [
          {
            "t": "列",
            "en": "row",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 先將每一列左右翻轉，再將矩陣上下翻轉。",
        "en": "(C) First reverse each row, then flip the matrix vertically.",
        "wg": []
      },
      {
        "t": "(D) 建立一個新的矩陣，填入旋轉後的數值，再複製回原矩陣。",
        "en": "(D) Create a new matrix, fill in the rotated values, and copy them back to the original matrix.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "順時針旋轉 90 度的標準原地演算法是先將矩陣轉置（行列互換），然後將每一列的元素順序反轉。選項 (D) 雖然結果正確，但不符合「原地」(in-place) 的空間複雜度要求。",
      "en": "The standard in-place algorithm for 90-degree clockwise rotation is to first transpose the matrix (swap rows and columns) and then reverse the order of elements in each row. Option (D) produces the correct result but does not meet the 'in-place' space complexity requirement.",
      "wg": [
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        },
        {
          "t": "互換",
          "en": "swap",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Geometry, Slope, Division by Zero, Cross Product",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定二維平面上的三個點 p1, p2, p3，您需要判斷它們是否位於同一條直線上。",
        "en": "Given three points p1, p2, and p3 on a 2D plane, you need to determine if they lie on the same straight line.",
        "wg": [
          {
            "t": "二維平面",
            "en": "2D plane",
            "ps": "N"
          },
          {
            "t": "直線",
            "en": "straight line",
            "ps": "N"
          }
        ]
      },
      {
        "t": "直接計算斜率 (Slope) 可能會遇到除以零的問題。",
        "en": "Calculating the slope directly may encounter a division by zero problem.",
        "wg": [
          {
            "t": "斜率",
            "en": "slope",
            "ps": "N"
          },
          {
            "t": "除以零",
            "en": "division by zero",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一個數學式可以避免除法運算並正確判斷共線？",
        "en": "Which of the following mathematical expressions avoids division and correctly determines collinearity?",
        "wg": [
          {
            "t": "共線",
            "en": "collinearity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)",
        "en": "(A) (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)",
        "wg": []
      },
      {
        "t": "(B) (y2 - y1) + (x3 - x2) == (y3 - y2) + (x2 - x1)",
        "en": "(B) (y2 - y1) + (x3 - x2) == (y3 - y2) + (x2 - x1)",
        "wg": []
      },
      {
        "t": "(C) sqrt((x2-x1)^2 + (y2-y1)^2) == sqrt((x3-x2)^2 + (y3-y2)^2)",
        "en": "(C) sqrt((x2-x1)^2 + (y2-y1)^2) == sqrt((x3-x2)^2 + (y3-y2)^2)",
        "wg": []
      },
      {
        "t": "(D) (y2 / x2) == (y3 / x3)",
        "en": "(D) (y2 / x2) == (y3 / x3)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這利用了交叉相乘的概念。原本斜率公式為 (y2-y1)/(x2-x1) = (y3-y2)/(x3-x2)，為了避免分母為零，將其交叉相乘即可得到選項 (A) 的乘法形式，這在程式實作中更為安全。",
      "en": "This utilizes the concept of cross-multiplication. The original slope formula is (y2-y1)/(x2-x1) = (y3-y2)/(x3-x2). To avoid a zero denominator, cross-multiplying yields the multiplication form in option (A), which is safer for implementation.",
      "wg": [
        {
          "t": "交叉相乘",
          "en": "cross-multiplication",
          "ps": "N"
        },
        {
          "t": "分母",
          "en": "denominator",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "easy",
    "keywords": "Math, Base Conversion, String Processing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在試算表軟體（如 Excel）中，欄位標題從 A 開始，接著是 B, C ... Z, AA, AB 等。",
        "en": "In spreadsheet software (like Excel), column titles start with A, followed by B, C ... Z, AA, AB, etc.",
        "wg": [
          {
            "t": "試算表",
            "en": "spreadsheet",
            "ps": "N"
          },
          {
            "t": "欄位標題",
            "en": "column titles",
            "ps": "N"
          }
        ]
      },
      {
        "t": "給定一個欄位名稱（字串），將其轉換為對應的整數欄位編號（例如 \"A\" -> 1, \"AB\" -> 28），這本質上是什麼數學問題？",
        "en": "Given a column title (string), converting it to its corresponding integer column number (e.g., \"A\" -> 1, \"AB\" -> 28) is essentially what kind of mathematical problem?",
        "wg": [
          {
            "t": "本質上",
            "en": "essentially",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 26 進位制的轉換（Base-26 Conversion）。",
        "en": "(A) Base-26 Conversion.",
        "wg": [
          {
            "t": "進位制",
            "en": "base/radix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 費氏數列計算 (Fibonacci Sequence)。",
        "en": "(B) Fibonacci Sequence calculation.",
        "wg": []
      },
      {
        "t": "(C) 排列組合問題 (Permutations and Combinations)。",
        "en": "(C) Permutations and Combinations problem.",
        "wg": []
      },
      {
        "t": "(D) 霍夫曼編碼 (Huffman Coding)。",
        "en": "(D) Huffman Coding.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "Excel 欄位標題本質上是一個 26 進位系統，其中 A=1, B=2 ... Z=26。計算時將每個字元視為 26 的冪次方權重進行加總，類似於將二進位或十六進位轉為十進位。",
      "en": "Excel column titles are essentially a base-26 system where A=1, B=2 ... Z=26. The calculation involves treating each character as a weight of a power of 26 and summing them up, similar to converting binary or hexadecimal to decimal.",
      "wg": [
        {
          "t": "冪次方",
          "en": "power/exponent",
          "ps": "N"
        },
        {
          "t": "權重",
          "en": "weight",
          "ps": "N"
        }
      ]
    }
  }
]