[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Geometry, Math, Inclusion-Exclusion Principle, Rectangle Area",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { ... }",
    "question": [
      {
        "t": "給定兩個軸對齊矩形的座標，您需要計算這兩個矩形所覆蓋的總面積。",
        "en": "Given the coordinates of two rectilinear rectangles, you need to calculate the total area covered by them.",
        "wg": [
          {
            "t": "軸對齊",
            "en": "rectilinear",
            "ps": "Adj"
          },
          {
            "t": "座標",
            "en": "coordinates",
            "ps": "N"
          },
          {
            "t": "覆蓋",
            "en": "covered",
            "ps": "V"
          }
        ]
      },
      {
        "t": "如果兩個矩形重疊，重疊區域的面積應該只計算一次。",
        "en": "If the rectangles overlap, the area of the overlap should be counted only once.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          },
          {
            "t": "區域",
            "en": "region",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總面積 = 矩形A面積 + 矩形B面積 + 重疊面積",
        "en": "(A) Total Area = Area A + Area B + Overlap Area",
        "wg": []
      },
      {
        "t": "(B) 總面積 = 矩形A面積 + 矩形B面積 - 重疊面積",
        "en": "(B) Total Area = Area A + Area B - Overlap Area",
        "wg": []
      },
      {
        "t": "(C) 總面積 = max(矩形A面積, 矩形B面積)",
        "en": "(C) Total Area = max(Area A, Area B)",
        "wg": []
      },
      {
        "t": "(D) 總面積 = (矩形A寬 + 矩形B寬) * (矩形A高 + 矩形B高)",
        "en": "(D) Total Area = (Width A + Width B) * (Height A + Height B)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個經典的排容原理應用。簡單地將兩個矩形的面積相加會導致重疊部分被計算兩次，因此必須減去一次重疊部分的面積。",
      "en": "This is a classic application of the Inclusion-Exclusion Principle. Simply adding the areas of the two rectangles causes the overlapping part to be counted twice, so the area of the overlap must be subtracted once.",
      "wg": [
        {
          "t": "排容原理",
          "en": "Inclusion-Exclusion Principle",
          "ps": "N"
        },
        {
          "t": "相加",
          "en": "add up",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Math, Number Theory, Primes, Sieve of Eratosthenes",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int countPrimes(int n);",
    "question": [
      {
        "t": "您需要實作一個函數來計算小於非負整數 n 的質數數量。",
        "en": "You need to implement a function to count the number of prime numbers less than a non-negative integer n.",
        "wg": [
          {
            "t": "質數",
            "en": "prime numbers",
            "ps": "N"
          },
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 n 非常大（例如 500 萬）時，下列哪種演算法能提供最佳的時間複雜度與效能？",
        "en": "When n is very large (e.g., 5 million), which of the following algorithms offers the best time complexity and performance?",
        "wg": [
          {
            "t": "演算法",
            "en": "algorithm",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個小於 n 的數字進行試除法 (Trial Division)，檢查是否能被 2 到 sqrt(x) 整除。",
        "en": "(A) Perform Trial Division for every number less than n, checking divisibility from 2 to sqrt(x).",
        "wg": [
          {
            "t": "試除法",
            "en": "Trial Division",
            "ps": "N"
          },
          {
            "t": "整除",
            "en": "divisible",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 使用埃拉托斯特尼篩法 (Sieve of Eratosthenes)。",
        "en": "(B) Use the Sieve of Eratosthenes.",
        "wg": [
          {
            "t": "篩法",
            "en": "Sieve",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用遞迴檢查每個數字是否為質數。",
        "en": "(C) Use recursion to check if each number is prime.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 產生所有奇數並假設它們是質數，然後過濾掉偶數。",
        "en": "(D) Generate all odd numbers and assume they are prime, then filter out even numbers.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "埃拉托斯特尼篩法的時間複雜度為 O(n log log n)，遠優於對每個數字進行獨立質數測試的 O(n * sqrt(n))，特別是在 n 很大時。",
      "en": "The time complexity of the Sieve of Eratosthenes is O(n log log n), which is significantly better than O(n * sqrt(n)) for testing each number independently, especially when n is large.",
      "wg": [
        {
          "t": "獨立",
          "en": "independently",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Geometry, Ray Casting, Polygon, Point in Polygon",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在計算幾何中，要判斷一個點是否位於一個任意多邊形（可能是非凸多邊形）內部，最常用的演算法是什麼？",
        "en": "In computational geometry, what is the most common algorithm to determine if a point lies inside an arbitrary polygon (possibly non-convex)?",
        "wg": [
          {
            "t": "計算幾何",
            "en": "computational geometry",
            "ps": "N"
          },
          {
            "t": "任意",
            "en": "arbitrary",
            "ps": "Adj"
          },
          {
            "t": "非凸",
            "en": "non-convex",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "該方法涉及從該點發射一條射線並計算交點數量。",
        "en": "The method involves casting a ray from the point and counting the number of intersections.",
        "wg": [
          {
            "t": "射線",
            "en": "ray",
            "ps": "N"
          },
          {
            "t": "交點",
            "en": "intersections",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 射線投射演算法 (Ray Casting Algorithm) / 奇偶規則",
        "en": "(A) Ray Casting Algorithm / Even-Odd Rule",
        "wg": [
          {
            "t": "奇偶",
            "en": "Even-Odd",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 凸包演算法 (Convex Hull Algorithm)",
        "en": "(B) Convex Hull Algorithm",
        "wg": [
          {
            "t": "凸包",
            "en": "Convex Hull",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 歐幾里得距離計算 (Euclidean Distance Calculation)",
        "en": "(C) Euclidean Distance Calculation",
        "wg": []
      },
      {
        "t": "(D) 最小平方法 (Least Squares Method)",
        "en": "(D) Least Squares Method",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "射線投射演算法透過從該點向任意方向發射一條射線，計算與多邊形邊界的交點數量。如果交點數為奇數，則點在內部；若為偶數，則在外部。",
      "en": "The Ray Casting Algorithm works by casting a ray from the point in any direction and counting intersections with the polygon's edges. If the number of intersections is odd, the point is inside; if even, it is outside.",
      "wg": [
        {
          "t": "邊界",
          "en": "edges/boundaries",
          "ps": "N"
        },
        {
          "t": "外部",
          "en": "outside",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "easy",
    "keywords": "Math, Bit Manipulation, Power of Two, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isPowerOfTwo(int n) { ... }",
    "question": [
      {
        "t": "在不使用迴圈或遞迴的情況下，如何利用位元運算最有效率地判斷一個正整數 n 是否為 2 的次方？",
        "en": "How can you most efficiently determine if a positive integer n is a power of two using bitwise operations, without using loops or recursion?",
        "wg": [
          {
            "t": "位元運算",
            "en": "bitwise operations",
            "ps": "N"
          },
          {
            "t": "次方",
            "en": "power",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) n % 2 == 0",
        "en": "(A) n % 2 == 0",
        "wg": []
      },
      {
        "t": "(B) (n & (n - 1)) == 0",
        "en": "(B) (n & (n - 1)) == 0",
        "wg": []
      },
      {
        "t": "(C) n ^ 2 == 0",
        "en": "(C) n ^ 2 == 0",
        "wg": []
      },
      {
        "t": "(D) n >> 1 == 0",
        "en": "(D) n >> 1 == 0",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "2 的次方在二進位表示中只有一個位元是 1。運算 (n & (n - 1)) 會將 n 最右邊的 1 變為 0。如果結果為 0（且 n > 0），則表示 n 原本只有一個位元是 1，即為 2 的次方。",
      "en": "A power of two has exactly one bit set to 1 in binary representation. The operation (n & (n - 1)) flips the rightmost 1 bit to 0. If the result is 0 (and n > 0), it means n originally had only one bit set, making it a power of two.",
      "wg": [
        {
          "t": "二進位表示",
          "en": "binary representation",
          "ps": "N"
        },
        {
          "t": "最右邊",
          "en": "rightmost",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Geometry, Math, Valid Square, Coordinates",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定二維平面上的 4 個點座標，您需要驗證它們是否構成一個有效的正方形。",
        "en": "Given the coordinates of 4 points on a 2D plane, you need to verify if they form a valid square.",
        "wg": [
          {
            "t": "驗證",
            "en": "verify",
            "ps": "V"
          },
          {
            "t": "構成",
            "en": "form",
            "ps": "V"
          }
        ]
      },
      {
        "t": "僅檢查四條邊長是否相等是不夠的，因為這也可能是一個菱形。",
        "en": "Checking only that the four side lengths are equal is insufficient, as it could also be a rhombus.",
        "wg": [
          {
            "t": "菱形",
            "en": "rhombus",
            "ps": "N"
          },
          {
            "t": "不足的",
            "en": "insufficient",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪種檢查邏輯是正確且充分的？",
        "en": "Which of the following checking logics is correct and sufficient?",
        "wg": [
          {
            "t": "充分的",
            "en": "sufficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 檢查四條邊長相等，並且兩條對角線長度相等。",
        "en": "(A) Check that four side lengths are equal AND the two diagonal lengths are equal.",
        "wg": [
          {
            "t": "對角線",
            "en": "diagonal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 僅檢查四個角是否都為 90 度。",
        "en": "(B) Check only that all four angles are 90 degrees.",
        "wg": []
      },
      {
        "t": "(C) 檢查兩組對邊是否平行。",
        "en": "(C) Check if two pairs of opposite sides are parallel.",
        "wg": [
          {
            "t": "平行",
            "en": "parallel",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 計算四個點的中心點，檢查點到中心的距離是否相等。",
        "en": "(D) Calculate the centroid of the four points and check if the distance from each point to the centroid is equal.",
        "wg": [
          {
            "t": "中心點",
            "en": "centroid",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "正方形是特殊的菱形。菱形四邊相等，但對角線不一定相等。若四邊相等且對角線也相等，則該四邊形必為正方形（這也隱含了直角）。",
      "en": "A square is a special type of rhombus. A rhombus has four equal sides, but its diagonals are not necessarily equal. If four sides are equal AND the diagonals are equal, the quadrilateral must be a square (which also implies right angles).",
      "wg": [
        {
          "t": "四邊形",
          "en": "quadrilateral",
          "ps": "N"
        },
        {
          "t": "隱含",
          "en": "implies",
          "ps": "V"
        }
      ]
    }
  }
]