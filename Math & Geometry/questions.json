[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Geometry, Coordinate System, Overlap, Bounding Box",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個軸對齊矩形 (Axis-Aligned Rectangles)，分別由其左下角 (x1, y1) 和右上角 (x2, y2) 座標定義。",
        "en": "Given two axis-aligned rectangles, defined by their bottom-left (x1, y1) and top-right (x2, y2) coordinates.",
        "wg": [
          {
            "t": "軸對齊",
            "en": "axis-aligned",
            "ps": "Adj"
          },
          {
            "t": "座標",
            "en": "coordinates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "判斷這兩個矩形是否重疊的最佳邏輯是什麼？",
        "en": "What is the best logic to determine if these two rectangles overlap?",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          },
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 檢查兩個矩形的面積總和是否大於其聯集邊界框的面積。",
        "en": "(A) Check if the sum of the areas of the two rectangles is greater than the area of their union bounding box.",
        "wg": [
          {
            "t": "聯集",
            "en": "union",
            "ps": "N"
          },
          {
            "t": "邊界框",
            "en": "bounding box",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 檢查其中一個矩形的四個角是否位於另一個矩形內部。",
        "en": "(B) Check if any of the four corners of one rectangle lies inside the other rectangle.",
        "wg": []
      },
      {
        "t": "(C) 檢查水平投影和垂直投影是否同時重疊（即 max(L1, L2) < min(R1, R2) 且 max(B1, B2) < min(T1, T2)）。",
        "en": "(C) Check if both horizontal and vertical projections overlap (i.e., max(L1, L2) < min(R1, R2) and max(B1, B2) < min(T1, T2)).",
        "wg": [
          {
            "t": "投影",
            "en": "projection",
            "ps": "N"
          },
          {
            "t": "垂直",
            "en": "vertical",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 計算兩個矩形中心點之間的距離是否小於寬度和高度總和的一半。",
        "en": "(D) Calculate if the distance between the centers of the two rectangles is less than half the sum of their widths and heights.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "矩形重疊問題最簡單的解法是檢查它們在 X 軸和 Y 軸上的投影是否都重疊。如果一個矩形的右邊小於另一個矩形的左邊，或者上邊小於另一個矩形的下邊，則它們不重疊；反之則重疊。選項 (B) 是錯誤的，因為這無法檢測到形成「十字形」交叉的情況。",
      "en": "The simplest solution to the rectangle overlap problem is to check if their projections overlap on both the X and Y axes. If the right side of one rectangle is less than the left side of the other, or the top is less than the bottom, they do not overlap; otherwise, they do. Option (B) is incorrect because it fails to detect 'cross' intersection cases.",
      "wg": [
        {
          "t": "檢測",
          "en": "detect",
          "ps": "V"
        },
        {
          "t": "交叉",
          "en": "intersection",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Math, Greatest Common Divisor, Euclidean Algorithm, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a % b);\n}",
    "question": [
      {
        "t": "在處理數論相關的演算法問題時，經常需要計算兩個整數的最大公因數 (GCD)。",
        "en": "When dealing with algorithm problems related to number theory, it is often necessary to compute the Greatest Common Divisor (GCD) of two integers.",
        "wg": [
          {
            "t": "數論",
            "en": "number theory",
            "ps": "N"
          },
          {
            "t": "最大公因數",
            "en": "Greatest Common Divisor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上述程式碼片段實作了哪種演算法，且其時間複雜度為何？",
        "en": "Which algorithm does the code snippet implement, and what is its time complexity?",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 輾轉相除法 (Euclidean Algorithm)，複雜度為 O(log(min(a, b)))。",
        "en": "(A) Euclidean Algorithm, with a complexity of O(log(min(a, b))).",
        "wg": [
          {
            "t": "輾轉相除法",
            "en": "Euclidean Algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 質因數分解法 (Prime Factorization)，複雜度為 O(sqrt(min(a, b)))。",
        "en": "(B) Prime Factorization, with a complexity of O(sqrt(min(a, b))).",
        "wg": [
          {
            "t": "質因數分解",
            "en": "prime factorization",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 更相減損術 (Binary GCD)，複雜度為 O(min(a, b))。",
        "en": "(C) Binary GCD (Stein's Algorithm), with a complexity of O(min(a, b)).",
        "wg": []
      },
      {
        "t": "(D) 線性篩法 (Linear Sieve)，複雜度為 O(a + b)。",
        "en": "(D) Linear Sieve, with a complexity of O(a + b).",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "該程式碼是輾轉相除法 (Euclidean Algorithm) 的標準遞迴實作。其時間複雜度是對數級別的，具體取決於較小數值的位數，即 O(log(min(a, b)))。這是計算 GCD 最常用且高效的方法。",
      "en": "The code is the standard recursive implementation of the Euclidean Algorithm. Its time complexity is logarithmic, depending on the number of digits in the smaller number, i.e., O(log(min(a, b))). This is the most common and efficient way to compute GCD.",
      "wg": [
        {
          "t": "遞迴",
          "en": "recursive",
          "ps": "Adj"
        },
        {
          "t": "對數級別",
          "en": "logarithmic",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Math, Prime Numbers, Sieve of Eratosthenes, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要編寫一個函數來計算小於非負整數 n 的所有質數的數量。",
        "en": "You need to write a function to count the number of prime numbers less than a non-negative integer n.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          },
          {
            "t": "質數",
            "en": "prime numbers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 n 非常大時（例如 n = 5,000,000），下列哪種方法最有效率？",
        "en": "When n is very large (e.g., n = 5,000,000), which of the following methods is the most efficient?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個小於 n 的數字 i，檢查從 2 到 i-1 是否有因數。",
        "en": "(A) For each number i less than n, check for factors from 2 to i-1.",
        "wg": [
          {
            "t": "因數",
            "en": "factor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 對每個小於 n 的數字 i，檢查從 2 到 sqrt(i) 是否有因數。",
        "en": "(B) For each number i less than n, check for factors from 2 to sqrt(i).",
        "wg": []
      },
      {
        "t": "(C) 使用埃拉托斯特尼篩法 (Sieve of Eratosthenes)。",
        "en": "(C) Use the Sieve of Eratosthenes.",
        "wg": [
          {
            "t": "篩法",
            "en": "sieve",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用遞迴檢查每個數字是否為質數。",
        "en": "(D) Use recursion to check if each number is prime.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "埃拉托斯特尼篩法 (Sieve of Eratosthenes) 透過標記合數來找出質數，其時間複雜度為 O(n log log n)，遠優於對每個數字單獨進行質數測試的 O(n sqrt(n)) 方法（選項 B）。選項 A 的複雜度為 O(n^2)，效率極低。",
      "en": "The Sieve of Eratosthenes finds primes by marking composite numbers, with a time complexity of O(n log log n), which is significantly better than testing each number for primality individually at O(n sqrt(n)) (Option B). Option A has a complexity of O(n^2), which is extremely inefficient.",
      "wg": [
        {
          "t": "合數",
          "en": "composite numbers",
          "ps": "N"
        },
        {
          "t": "顯著地",
          "en": "significantly",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Matrix, Array, In-place, Rotation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個 n x n 的二維矩陣代表一張影像，您需要將影像順時針旋轉 90 度。",
        "en": "Given an n x n 2D matrix representing an image, you need to rotate the image 90 degrees clockwise.",
        "wg": [
          {
            "t": "二維矩陣",
            "en": "2D matrix",
            "ps": "N"
          },
          {
            "t": "順時針",
            "en": "clockwise",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "若要求必須「原地」(in-place) 修改矩陣，不使用額外的二維陣列，正確的步驟順序為何？",
        "en": "If you are required to modify the matrix 'in-place' without using an extra 2D array, what is the correct sequence of steps?",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          },
          {
            "t": "額外的",
            "en": "extra",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將矩陣上下翻轉，然後將矩陣轉置 (Transpose)。",
        "en": "(A) First flip the matrix vertically, then transpose the matrix.",
        "wg": [
          {
            "t": "轉置",
            "en": "transpose",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 先將矩陣轉置 (Transpose)，然後將每一列 (Row) 反轉 (Reverse)。",
        "en": "(B) First transpose the matrix, then reverse each row.",
        "wg": [
          {
            "t": "列",
            "en": "row",
            "ps": "N"
          },
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 先將每一列反轉，然後將矩陣轉置。",
        "en": "(C) First reverse each row, then transpose the matrix.",
        "wg": []
      },
      {
        "t": "(D) 將矩陣對角線元素交換，然後將矩陣左右翻轉。",
        "en": "(D) Swap diagonal elements, then flip the matrix horizontally.",
        "wg": [
          {
            "t": "對角線",
            "en": "diagonal",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "順時針旋轉 90 度的標準原地演算法是先轉置矩陣（交換 matrix[i][j] 與 matrix[j][i]），然後反轉每一列。若先上下翻轉再轉置（選項 A）會得到順時針 270 度（或逆時針 90 度）的結果。",
      "en": "The standard in-place algorithm for 90-degree clockwise rotation is to first transpose the matrix (swap matrix[i][j] with matrix[j][i]) and then reverse each row. Flipping vertically then transposing (Option A) results in a 270-degree clockwise (or 90-degree counter-clockwise) rotation.",
      "wg": [
        {
          "t": "逆時針",
          "en": "counter-clockwise",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "easy",
    "keywords": "Bit Manipulation, Math, Power of Two",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在不使用迴圈或遞迴的情況下，判斷一個整數 n 是否為 2 的次方（Power of Two）。",
        "en": "Determine if an integer n is a power of two without using loops or recursion.",
        "wg": [
          {
            "t": "迴圈",
            "en": "loop",
            "ps": "N"
          },
          {
            "t": "次方",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪個表達式可以正確達成此目的？（假設 n > 0）",
        "en": "Which of the following expressions correctly achieves this? (Assume n > 0)",
        "wg": [
          {
            "t": "表達式",
            "en": "expression",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) n % 2 == 0",
        "en": "(A) n % 2 == 0",
        "wg": []
      },
      {
        "t": "(B) (n & 1) == 0",
        "en": "(B) (n & 1) == 0",
        "wg": []
      },
      {
        "t": "(C) (n & (n - 1)) == 0",
        "en": "(C) (n & (n - 1)) == 0",
        "wg": []
      },
      {
        "t": "(D) (n ^ (n - 1)) == 0",
        "en": "(D) (n ^ (n - 1)) == 0",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "2 的次方在二進位表示中只有一個位元是 1（例如 4 是 100，8 是 1000）。當 n 是 2 的次方時，n-1 會將該位元變為 0 並將其右邊所有位元變為 1（例如 4-1=3 是 011）。因此，n & (n-1) 的結果必為 0。選項 A 和 B 僅檢查 n 是否為偶數。",
      "en": "A power of two has exactly one bit set to 1 in its binary representation (e.g., 4 is 100, 8 is 1000). When n is a power of two, n-1 flips that bit to 0 and all bits to its right to 1 (e.g., 4-1=3 is 011). Therefore, the result of n & (n-1) must be 0. Options A and B only check if n is even.",
      "wg": [
        {
          "t": "二進位",
          "en": "binary",
          "ps": "Adj"
        },
        {
          "t": "偶數",
          "en": "even number",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Matrix, Array, In-place, Rotation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個 n × n 的二維矩陣代表一張影像，您需要將影像順時針旋轉 90 度。",
        "en": "Given an n × n 2D matrix representing an image, you need to rotate the image by 90 degrees (clockwise).",
        "wg": [
          {
            "t": "二維矩陣",
            "en": "2D matrix",
            "ps": "N"
          },
          {
            "t": "順時針",
            "en": "clockwise",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "若要求必須「原地」(in-place) 修改矩陣，請問對於矩陣中座標為 (i, j) 的元素，旋轉後的新位置應該為何？",
        "en": "If you are required to modify the matrix 'in-place', what should be the new position for the element at coordinate (i, j) after rotation?",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          },
          {
            "t": "座標",
            "en": "coordinate",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) (j, i)",
        "en": "(A) (j, i)",
        "wg": []
      },
      {
        "t": "(B) (j, n - 1 - i)",
        "en": "(B) (j, n - 1 - i)",
        "wg": []
      },
      {
        "t": "(C) (n - 1 - j, i)",
        "en": "(C) (n - 1 - j, i)",
        "wg": []
      },
      {
        "t": "(D) (n - 1 - i, n - 1 - j)",
        "en": "(D) (n - 1 - i, n - 1 - j)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "順時針旋轉 90 度時，原矩陣的第一列會變成新矩陣的最後一欄。",
      "en": "When rotating 90 degrees clockwise, the first row of the original matrix becomes the last column of the new matrix.",
      "wg": [
        {
          "t": "列",
          "en": "row",
          "ps": "N"
        },
        {
          "t": "欄",
          "en": "column",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Math, Hash Set, Cycle Detection, Digits",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「快樂數」(Happy Number) 問題時，我們重複將該數字替換為其各個位數的平方和。",
        "en": "When solving the 'Happy Number' problem, we repeatedly replace the number with the sum of the squares of its digits.",
        "wg": [
          {
            "t": "平方和",
            "en": "sum of the squares",
            "ps": "N phrase"
          },
          {
            "t": "位數",
            "en": "digits",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果該過程陷入無限循環且永遠不到達 1，則該數字不是快樂數。",
        "en": "If this process enters an infinite loop and never reaches 1, then the number is not a Happy Number.",
        "wg": [
          {
            "t": "無限循環",
            "en": "infinite loop",
            "ps": "N phrase"
          }
        ]
      },
      {
        "t": "下列哪種資料結構或演算法最適合用來檢測這種循環？",
        "en": "Which of the following data structures or algorithms is best suited to detect this cycle?",
        "wg": [
          {
            "t": "檢測",
            "en": "detect",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)",
        "en": "(A) Stack",
        "wg": []
      },
      {
        "t": "(B) 雜湊集合 (Hash Set) 或弗洛伊德循環查找算法 (Floyd's Cycle-Finding)",
        "en": "(B) Hash Set or Floyd's Cycle-Finding Algorithm",
        "wg": [
          {
            "t": "雜湊集合",
            "en": "Hash Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 二元搜尋樹 (Binary Search Tree)",
        "en": "(C) Binary Search Tree",
        "wg": []
      },
      {
        "t": "(D) 優先佇列 (Priority Queue)",
        "en": "(D) Priority Queue",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們可以使用雜湊集合來儲存出現過的數字，若計算出的總和已存在於集合中，即代表產生了循環；或者使用快慢指針法 (Floyd's) 來偵測。",
      "en": "We can use a Hash Set to store numbers that have appeared; if the calculated sum already exists in the set, it indicates a cycle; alternatively, use the fast and slow pointer method (Floyd's) to detect it.",
      "wg": [
        {
          "t": "快慢指針",
          "en": "fast and slow pointer",
          "ps": "N phrase"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Math, Recursion, Bit Manipulation, Exponentiation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "pow(x, n)",
    "question": [
      {
        "t": "實作 `pow(x, n)` 即計算 x 的 n 次方函數時，若 n 非常大，直接使用迴圈相乘會導致時間複雜度為 O(n)，效率低落。",
        "en": "When implementing `pow(x, n)` to calculate x raised to the power of n, if n is very large, using a direct multiplication loop results in O(n) time complexity, which is inefficient.",
        "wg": [
          {
            "t": "效率低落",
            "en": "inefficient",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問應使用何種演算法將時間複雜度優化至 O(log n)？",
        "en": "Which algorithm should be used to optimize the time complexity to O(log n)?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 快速傅立葉變換 (Fast Fourier Transform)",
        "en": "(A) Fast Fourier Transform",
        "wg": []
      },
      {
        "t": "(B) 埃拉托斯特尼篩法 (Sieve of Eratosthenes)",
        "en": "(B) Sieve of Eratosthenes",
        "wg": []
      },
      {
        "t": "(C) 快速冪 / 二分取冪 (Binary Exponentiation)",
        "en": "(C) Binary Exponentiation / Fast Power",
        "wg": [
          {
            "t": "二分取冪",
            "en": "Binary Exponentiation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 動態規劃 (Dynamic Programming)",
        "en": "(D) Dynamic Programming",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "快速冪演算法利用 $x^n = x^{n/2} \\times x^{n/2}$ (當 n 為偶數) 的特性，每次將問題規模減半，從而達到對數級的時間複雜度。",
      "en": "The Binary Exponentiation algorithm utilizes the property $x^n = x^{n/2} \\times x^{n/2}$ (when n is even) to halve the problem size at each step, achieving logarithmic time complexity.",
      "wg": [
        {
          "t": "對數級",
          "en": "logarithmic",
          "ps": "Adj"
        },
        {
          "t": "規模",
          "en": "size/scale",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Geometry, Simulation, Matrix",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個 m x n 的矩陣，若要以「螺旋狀」(Spiral Order) 順時針遍歷所有元素。",
        "en": "Given an m x n matrix, if you want to traverse all elements in a 'Spiral Order' clockwise.",
        "wg": [
          {
            "t": "螺旋狀",
            "en": "spiral order",
            "ps": "N phrase"
          },
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在實作過程中，通常需要維護四個邊界變數 (top, bottom, left, right)。",
        "en": "In the implementation process, it is usually necessary to maintain four boundary variables (top, bottom, left, right).",
        "wg": [
          {
            "t": "邊界變數",
            "en": "boundary variables",
            "ps": "N phrase"
          }
        ]
      },
      {
        "t": "請問當完成「從左到右」的遍歷後，應該如何調整邊界？",
        "en": "How should the boundaries be adjusted after completing the 'left to right' traversal?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `top` 增加 1 (top++)",
        "en": "(A) Increment `top` by 1 (top++)",
        "wg": []
      },
      {
        "t": "(B) `bottom` 減少 1 (bottom--)",
        "en": "(B) Decrement `bottom` by 1 (bottom--)",
        "wg": []
      },
      {
        "t": "(C) `left` 增加 1 (left++)",
        "en": "(C) Increment `left` by 1 (left++)",
        "wg": []
      },
      {
        "t": "(D) `right` 減少 1 (right--)",
        "en": "(D) Decrement `right` by 1 (right--)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "從左到右遍歷的是當前的最上層列 (top row)，遍歷完成後該列已被處理，因此需要將上邊界向下移動 (top++) 以避免重複訪問。",
      "en": "Traversing from left to right covers the current top row; once completed, that row is processed, so the top boundary needs to be moved down (top++) to avoid revisiting.",
      "wg": [
        {
          "t": "重複訪問",
          "en": "revisiting",
          "ps": "V/N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "easy",
    "keywords": "Geometry, Coordinates, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "rec1 = [x1, y1, x2, y2], rec2 = [x3, y3, x4, y4]",
    "question": [
      {
        "t": "判斷兩個軸對齊矩形 (Axis-Aligned Rectangle) 是否重疊時，通常檢查它們「不重疊」的條件比較容易。",
        "en": "When determining whether two Axis-Aligned Rectangles overlap, it is usually easier to check the condition for them 'NOT overlapping'.",
        "wg": [
          {
            "t": "軸對齊",
            "en": "axis-aligned",
            "ps": "Adj"
          },
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設矩形由左下角 (x1, y1) 和右上角 (x2, y2) 定義。",
        "en": "Assume rectangles are defined by the bottom-left corner (x1, y1) and top-right corner (x2, y2).",
        "wg": []
      },
      {
        "t": "下列哪個條件代表兩個矩形**沒有**重疊？",
        "en": "Which of the following conditions represents that the two rectangles do **NOT** overlap?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `rec1[x2] > rec2[x1]` AND `rec1[y2] > rec2[y1]`",
        "en": "(A) `rec1[x2] > rec2[x1]` AND `rec1[y2] > rec2[y1]`",
        "wg": []
      },
      {
        "t": "(B) `rec1[x2] <= rec2[x1]` OR `rec1[x1] >= rec2[x2]` OR `rec1[y2] <= rec2[y1]` OR `rec1[y1] >= rec2[y2]`",
        "en": "(B) `rec1[x2] <= rec2[x1]` OR `rec1[x1] >= rec2[x2]` OR `rec1[y2] <= rec2[y1]` OR `rec1[y1] >= rec2[y2]`",
        "wg": []
      },
      {
        "t": "(C) `rec1[x1] == rec2[x1]` AND `rec1[y1] == rec2[y1]`",
        "en": "(C) `rec1[x1] == rec2[x1]` AND `rec1[y1] == rec2[y1]`",
        "wg": []
      },
      {
        "t": "(D) `rec1` 的面積 + `rec2` 的面積 > 聯集面積",
        "en": "(D) Area of `rec1` + Area of `rec2` > Area of Union",
        "wg": [
          {
            "t": "聯集",
            "en": "union",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若矩形 1 在矩形 2 的左側、右側、下方或上方，則它們不可能重疊；這是檢查重疊最直觀的反向邏輯。",
      "en": "If rectangle 1 is to the left, right, below, or above rectangle 2, they cannot overlap; this is the most intuitive reverse logic for checking overlap.",
      "wg": [
        {
          "t": "反向邏輯",
          "en": "reverse logic",
          "ps": "N phrase"
        },
        {
          "t": "直觀",
          "en": "intuitive",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Math, GCD, Euclidean Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}",
    "question": [
      {
        "t": "在解決數學問題時，我們經常需要計算兩個整數的最大公因數 (GCD)。",
        "en": "When solving math problems, we often need to compute the Greatest Common Divisor (GCD) of two integers.",
        "wg": [
          {
            "t": "最大公因數",
            "en": "Greatest Common Divisor",
            "ps": "N"
          },
          {
            "t": "整數",
            "en": "integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "歐幾里得演算法（輾轉相除法）是解決此問題的標準方法。",
        "en": "The Euclidean algorithm is the standard method for solving this problem.",
        "wg": [
          {
            "t": "歐幾里得演算法",
            "en": "Euclidean algorithm",
            "ps": "N"
          },
          {
            "t": "標準方法",
            "en": "standard method",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於此演算法的時間複雜度，下列敘述何者正確？",
        "en": "Which of the following statements regarding the time complexity of this algorithm is true?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(min(a, b))，因為它取決於較小的數字。",
        "en": "(A) O(min(a, b)), because it depends on the smaller number.",
        "wg": []
      },
      {
        "t": "(B) O(a * b)，因為最壞情況涉及兩個數字的乘積。",
        "en": "(B) O(a * b), because the worst case involves the product of the two numbers.",
        "wg": []
      },
      {
        "t": "(C) O(log(min(a, b)))，因為每次迭代數值至少會減少一半（近似費波那契數列增長）。",
        "en": "(C) O(log(min(a, b))), because the value decreases by at least half in each iteration (approximating Fibonacci sequence growth).",
        "wg": [
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          },
          {
            "t": "費波那契數列",
            "en": "Fibonacci sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) O(1)，因為整數運算在現代 CPU 上是常數時間。",
        "en": "(D) O(1), because integer operations are constant time on modern CPUs.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "歐幾里得演算法的時間複雜度是對數級別的，具體來說與較小數字的位數成正比，最壞情況發生在兩個連續的費波那契數上。",
      "en": "The time complexity of the Euclidean algorithm is logarithmic, specifically proportional to the number of digits in the smaller number, with the worst case occurring with two consecutive Fibonacci numbers.",
      "wg": [
        {
          "t": "對數級別",
          "en": "logarithmic",
          "ps": "Adj"
        },
        {
          "t": "連續的",
          "en": "consecutive",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Math, Primes, Sieve of Eratosthenes, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要編寫一個函數來計算小於非負整數 n 的質數數量。",
        "en": "You need to write a function to count the number of prime numbers less than a non-negative integer n.",
        "wg": [
          {
            "t": "質數",
            "en": "prime number",
            "ps": "N"
          },
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 n 非常大（例如 500 萬）時，為了避免超時，應該優先使用哪種演算法？",
        "en": "When n is very large (e.g., 5 million), which algorithm should be prioritized to avoid time limit exceeded?",
        "wg": [
          {
            "t": "超時",
            "en": "time limit exceeded",
            "ps": "N"
          },
          {
            "t": "優先使用",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對每個小於 n 的數字進行試除法 (Trial Division)。",
        "en": "(A) Perform Trial Division on every number less than n.",
        "wg": [
          {
            "t": "試除法",
            "en": "Trial Division",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 埃拉托斯特尼篩法 (Sieve of Eratosthenes)。",
        "en": "(B) Sieve of Eratosthenes.",
        "wg": [
          {
            "t": "篩法",
            "en": "sieve",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 遞迴檢查每個數字是否只有兩個因數。",
        "en": "(C) Recursively check if each number has exactly two divisors.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          },
          {
            "t": "因數",
            "en": "divisor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用費馬小定理進行機率性測試。",
        "en": "(D) Use Fermat's Little Theorem for probabilistic testing.",
        "wg": [
          {
            "t": "機率性",
            "en": "probabilistic",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "埃拉托斯特尼篩法的時間複雜度為 O(n log log n)，遠優於對每個數字進行試除法的 O(n√n)，非常適合大量質數計數。",
      "en": "The Sieve of Eratosthenes has a time complexity of O(n log log n), which is far superior to O(n√n) for trial division on each number, making it ideal for counting primes in bulk.",
      "wg": [
        {
          "t": "大量",
          "en": "in bulk",
          "ps": "Adv"
        },
        {
          "t": "優於",
          "en": "superior to",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Geometry, Coordinates, Overlap, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定兩個軸對齊的矩形，分別由其左下角 (x1, y1) 和右上角 (x2, y2) 座標定義。",
        "en": "Given two axis-aligned rectangles, defined by their bottom-left (x1, y1) and top-right (x2, y2) coordinates.",
        "wg": [
          {
            "t": "軸對齊",
            "en": "axis-aligned",
            "ps": "Adj"
          },
          {
            "t": "座標",
            "en": "coordinate",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要判斷這兩個矩形是否重疊，最簡潔的邏輯通常是檢查它們「不重疊」的情況。",
        "en": "To determine if these two rectangles overlap, the most concise logic is often to check the conditions where they do 'not' overlap.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          },
          {
            "t": "簡潔的",
            "en": "concise",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪種情況代表兩個矩形 A 和 B **沒有**重疊？",
        "en": "Which of the following conditions represents that two rectangles A and B do **not** overlap?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) A 的左邊 > B 的右邊，或 A 的右邊 < B 的左邊，或 A 的頂部 < B 的底部，或 A 的底部 > B 的頂部。",
        "en": "(A) A.left > B.right, or A.right < B.left, or A.top < B.bottom, or A.bottom > B.top.",
        "wg": []
      },
      {
        "t": "(B) A 的面積 + B 的面積 > 聯合面積。",
        "en": "(B) Area of A + Area of B > Union Area.",
        "wg": [
          {
            "t": "聯合",
            "en": "union",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) A 的中心點在 B 的範圍內。",
        "en": "(C) The center point of A is within the bounds of B.",
        "wg": [
          {
            "t": "範圍",
            "en": "bounds",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) A 的左下角座標大於 B 的左下角座標。",
        "en": "(D) The bottom-left coordinate of A is greater than the bottom-left coordinate of B.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "如果一個矩形完全在另一個矩形的左側、右側、上方或下方，則它們不可能重疊；這是檢查重疊最直觀的反向邏輯。",
      "en": "If one rectangle is completely to the left, right, above, or below the other, they cannot overlap; this is the most intuitive reverse logic for checking overlap.",
      "wg": [
        {
          "t": "直觀的",
          "en": "intuitive",
          "ps": "Adj"
        },
        {
          "t": "反向邏輯",
          "en": "reverse logic",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Geometry, Hash Map, Slope, Precision",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「直線上最多的點」問題中，我們需要計算在 2D 平面上同一直線上的最大點數。",
        "en": "In the 'Max Points on a Line' problem, we need to calculate the maximum number of points on the same line in a 2D plane.",
        "wg": [
          {
            "t": "平面",
            "en": "plane",
            "ps": "N"
          }
        ]
      },
      {
        "t": "通常我們會固定一個點，並計算其他點相對於該點的斜率。",
        "en": "Typically, we fix one point and calculate the slopes of other points relative to it.",
        "wg": [
          {
            "t": "固定",
            "en": "fix",
            "ps": "V"
          },
          {
            "t": "斜率",
            "en": "slope",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了避免浮點數精度問題導致錯誤的雜湊鍵值 (Hash Key)，最佳的實作方式是什麼？",
        "en": "To avoid incorrect Hash Keys caused by floating-point precision issues, what is the best implementation approach?",
        "wg": [
          {
            "t": "浮點數精度",
            "en": "floating-point precision",
            "ps": "N"
          },
          {
            "t": "雜湊鍵值",
            "en": "Hash Key",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 double 類型存儲斜率，並使用極小的 epsilon 進行比較。",
        "en": "(A) Store the slope as a double and use a tiny epsilon for comparison.",
        "wg": [
          {
            "t": "極小的",
            "en": "tiny",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 將斜率 (dy/dx) 化簡為最簡分數，並以 (dy, dx) 的字串或元組作為鍵值。",
        "en": "(B) Reduce the slope (dy/dx) to its simplest fraction and use a string or tuple of (dy, dx) as the key.",
        "wg": [
          {
            "t": "化簡",
            "en": "reduce",
            "ps": "V"
          },
          {
            "t": "最簡分數",
            "en": "simplest fraction",
            "ps": "N"
          },
          {
            "t": "元組",
            "en": "tuple",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 僅使用 y 截距作為鍵值。",
        "en": "(C) Only use the y-intercept as the key.",
        "wg": [
          {
            "t": "截距",
            "en": "intercept",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將所有座標乘以 100 轉換為整數後計算斜率。",
        "en": "(D) Multiply all coordinates by 100 to convert to integers before calculating the slope.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用最大公因數 (GCD) 將 dy 和 dx 化簡，可以精確地表示斜率，完全避免浮點數運算的誤差。",
      "en": "Using the Greatest Common Divisor (GCD) to reduce dy and dx allows for an exact representation of the slope, completely avoiding floating-point arithmetic errors.",
      "wg": [
        {
          "t": "誤差",
          "en": "error",
          "ps": "N"
        },
        {
          "t": "運算",
          "en": "arithmetic",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Matrix, Rotation, In-place, Geometry",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: \n[[1,2,3],\n [4,5,6],\n [7,8,9]]\n\nOutput: \n[[7,4,1],\n [8,5,2],\n [9,6,3]]",
    "question": [
      {
        "t": "給定一個 n x n 的二維矩陣，您需要將圖像順時針旋轉 90 度。",
        "en": "Given an n x n 2D matrix, you need to rotate the image 90 degrees clockwise.",
        "wg": [
          {
            "t": "二維矩陣",
            "en": "2D matrix",
            "ps": "N"
          },
          {
            "t": "順時針",
            "en": "clockwise",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "題目要求必須「原地」(In-place) 修改矩陣，不得使用額外的矩陣空間。",
        "en": "The problem requires modifying the matrix 'in-place', without using extra matrix space.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          },
          {
            "t": "額外的",
            "en": "extra",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "最常見的兩步幾何變換策略是什麼？",
        "en": "What is the most common two-step geometric transformation strategy?",
        "wg": [
          {
            "t": "幾何變換",
            "en": "geometric transformation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先將矩陣轉置 (Transpose)，然後反轉每一列 (Reverse each row)。",
        "en": "(A) First transpose the matrix, then reverse each row.",
        "wg": [
          {
            "t": "轉置",
            "en": "transpose",
            "ps": "V"
          },
          {
            "t": "反轉",
            "en": "reverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 先反轉每一列，然後將矩陣轉置。",
        "en": "(B) First reverse each row, then transpose the matrix.",
        "wg": []
      },
      {
        "t": "(C) 先沿著副對角線翻轉，然後反轉每一行。",
        "en": "(C) First flip along the anti-diagonal, then reverse each column.",
        "wg": [
          {
            "t": "副對角線",
            "en": "anti-diagonal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 將矩陣分為四個同心環，逐一旋轉。",
        "en": "(D) Divide the matrix into four concentric rings and rotate them one by one.",
        "wg": [
          {
            "t": "同心環",
            "en": "concentric rings",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "轉置矩陣會交換 (i, j) 與 (j, i)，接著反轉每一列會將元素移至正確的旋轉位置；這是實現順時針 90 度旋轉的標準線性代數技巧。",
      "en": "Transposing the matrix swaps (i, j) with (j, i), and subsequently reversing each row moves the elements to their correct rotated positions; this is a standard linear algebra technique for achieving a 90-degree clockwise rotation.",
      "wg": [
        {
          "t": "線性代數",
          "en": "linear algebra",
          "ps": "N"
        },
        {
          "t": "隨後",
          "en": "subsequently",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "Easy",
    "keywords": "Geometry, Coordinate System, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "rec1 = [x1, y1, x2, y2], rec2 = [x3, y3, x4, y4]",
    "question": [
      {
        "t": "給定兩個軸對齊的矩形，分別由其左下角和右上角的座標定義。",
        "en": "Given two axis-aligned rectangles, defined by the coordinates of their bottom-left and top-right corners.",
        "wg": [
          {
            "t": "軸對齊",
            "en": "axis-aligned",
            "ps": "Adj"
          },
          {
            "t": "座標",
            "en": "coordinate",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您需要編寫一個函數來判斷這兩個矩形是否重疊。",
        "en": "You need to write a function to determine if these two rectangles overlap.",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一種邏輯判斷最簡潔且正確？",
        "en": "Which of the following logic checks is the most concise and correct?",
        "wg": [
          {
            "t": "簡潔",
            "en": "concise",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計算兩個矩形的面積總和，若大於聯集面積則重疊。",
        "en": "(A) Calculate the sum of the areas of both rectangles; if it is greater than the area of their union, they overlap.",
        "wg": [
          {
            "t": "聯集",
            "en": "union",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 檢查其中一個矩形的四個角是否位於另一個矩形內部。",
        "en": "(B) Check if any of the four corners of one rectangle lies inside the other rectangle.",
        "wg": []
      },
      {
        "t": "(C) 檢查兩個矩形是否在水平或垂直方向上完全錯開，若都不是，則必重疊。",
        "en": "(C) Check if the two rectangles are completely separated horizontally or vertically; if neither, they must overlap.",
        "wg": [
          {
            "t": "錯開",
            "en": "separated",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 計算兩個矩形中心點的距離，若小於寬度與高度的一半總和則重疊。",
        "en": "(D) Calculate the distance between the centers of the two rectangles; if it is less than half the sum of their widths and heights, they overlap.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "判斷重疊最簡單的方法是反向思考：判斷它們何時「不重疊」。如果一個矩形在另一個的左邊、右邊、上面或下面，則它們不重疊；反之則重疊。選項 (B) 是常見錯誤，因為這無法偵測十字交叉型的重疊。",
      "en": "The simplest way to determine overlap is to think in reverse: determine when they do NOT overlap. If one rectangle is to the left, right, above, or below the other, they do not overlap; otherwise, they do. Option (B) is a common mistake because it fails to detect cross-shaped overlaps.",
      "wg": [
        {
          "t": "反向思考",
          "en": "reverse thinking",
          "ps": "N"
        },
        {
          "t": "十字交叉型",
          "en": "cross-shaped",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "Medium",
    "keywords": "Math, Combinatorics, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "一個機器人位於一個 m x n 網格的左上角。",
        "en": "A robot is located at the top-left corner of an m x n grid.",
        "wg": [
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "機器人每次只能向下或向右移動一步。",
        "en": "The robot can only move either down or right at any point in time.",
        "wg": []
      },
      {
        "t": "請問有多少種不同的路徑可以到達網格的右下角？",
        "en": "How many unique paths are there to reach the bottom-right corner of the grid?",
        "wg": [
          {
            "t": "不同的",
            "en": "unique",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) (m * n) / 2",
        "en": "(A) (m * n) / 2",
        "wg": []
      },
      {
        "t": "(B) 2^(m+n)",
        "en": "(B) 2^(m+n)",
        "wg": []
      },
      {
        "t": "(C) (m + n - 2)! / ((m - 1)! * (n - 1)!)",
        "en": "(C) (m + n - 2)! / ((m - 1)! * (n - 1)!)",
        "wg": [
          {
            "t": "階乘",
            "en": "factorial",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) (m + n)! / (m! * n!)",
        "en": "(D) (m + n)! / (m! * n!)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是一個經典的組合數學問題。機器人總共需要走 m-1 步向下和 n-1 步向右，總步數為 m+n-2。問題等同於在總步數中選擇哪幾步是向下（或向右），故公式為 C(m+n-2, m-1)。",
      "en": "This is a classic combinatorics problem. The robot needs to take a total of m-1 steps down and n-1 steps right, making the total steps m+n-2. The problem is equivalent to choosing which steps are down (or right) from the total steps, so the formula is C(m+n-2, m-1).",
      "wg": [
        {
          "t": "組合數學",
          "en": "combinatorics",
          "ps": "N"
        },
        {
          "t": "等同於",
          "en": "equivalent to",
          "ps": "Phr"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "Medium",
    "keywords": "Math, String, GCD",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "對於字串 S 和 T，如果 S 可以由 T 重複多次連接而成，我們稱 T 能除盡 S。",
        "en": "For strings S and T, we say \"T divides S\" if S consists of multiple concatenations of T.",
        "wg": [
          {
            "t": "連接",
            "en": "concatenation",
            "ps": "N"
          },
          {
            "t": "除盡",
            "en": "divides",
            "ps": "V"
          }
        ]
      },
      {
        "t": "給定兩個字串 str1 和 str2，若存在最大公因字串 X，其長度應如何計算？",
        "en": "Given two strings str1 and str2, if a greatest common divisor string X exists, how should its length be calculated?",
        "wg": [
          {
            "t": "最大公因字串",
            "en": "greatest common divisor string",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 若 str1 + str2 == str2 + str1，則長度為 gcd(len(str1), len(str2))。",
        "en": "(A) If str1 + str2 == str2 + str1, then the length is gcd(len(str1), len(str2)).",
        "wg": [
          {
            "t": "長度",
            "en": "length",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 長度總是等於 min(len(str1), len(str2))。",
        "en": "(B) The length is always equal to min(len(str1), len(str2)).",
        "wg": []
      },
      {
        "t": "(C) 只要兩個字串包含相同的字元集合，長度即為 gcd(len(str1), len(str2))。",
        "en": "(C) As long as both strings contain the same set of characters, the length is gcd(len(str1), len(str2)).",
        "wg": [
          {
            "t": "字元集合",
            "en": "character set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 需使用 KMP 演算法找出最長前綴後綴。",
        "en": "(D) Need to use the KMP algorithm to find the longest proper prefix which is also a suffix.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "後綴",
            "en": "suffix",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是字串的最大公因數問題。如果兩個字串有公因字串，它們相加的順序必定不影響結果（即 A+B = B+A）。如果此條件成立，最大公因字串的長度就是兩個字串長度的最大公因數 (GCD)。",
      "en": "This is a Greatest Common Divisor of strings problem. If two strings have a common divisor string, the order of concatenation must not affect the result (i.e., A+B = B+A). If this condition holds, the length of the GCD string is the mathematical GCD of the lengths of the two strings.",
      "wg": [
        {
          "t": "成立",
          "en": "holds",
          "ps": "V"
        },
        {
          "t": "順序",
          "en": "order",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "Easy",
    "keywords": "Geometry, Slope, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "coordinates = [[1,2],[2,3],[3,4],[4,5]]",
    "question": [
      {
        "t": "給定一個二維平面上的座標陣列，您需要判斷這些點是否全部位於同一條直線上。",
        "en": "Given an array of coordinates on a 2D plane, you need to determine if all these points lie on the same straight line.",
        "wg": [
          {
            "t": "二維平面",
            "en": "2D plane",
            "ps": "N"
          },
          {
            "t": "直線",
            "en": "straight line",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在實作斜率比較時，為了避免除以零的錯誤（垂直線），最佳的實作方式為何？",
        "en": "When implementing slope comparison, what is the best approach to avoid division by zero errors (vertical lines)?",
        "wg": [
          {
            "t": "斜率",
            "en": "slope",
            "ps": "N"
          },
          {
            "t": "除以零",
            "en": "division by zero",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 try-catch 區塊來捕捉除以零的例外。",
        "en": "(A) Use a try-catch block to catch division by zero exceptions.",
        "wg": [
          {
            "t": "例外",
            "en": "exception",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 將斜率計算轉換為乘法形式：(y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)。",
        "en": "(B) Convert the slope calculation into multiplication form: (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1).",
        "wg": [
          {
            "t": "乘法形式",
            "en": "multiplication form",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 如果 x 座標差值為 0，則將斜率設為無限大 (Infinity)。",
        "en": "(C) If the difference in x-coordinates is 0, set the slope to Infinity.",
        "wg": []
      },
      {
        "t": "(D) 使用浮點數運算並允許極小誤差 (Epsilon)。",
        "en": "(D) Use floating-point arithmetic and allow for a small error margin (Epsilon).",
        "wg": [
          {
            "t": "浮點數",
            "en": "floating-point",
            "ps": "N"
          },
          {
            "t": "誤差",
            "en": "error margin",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用交叉相乘（外積的概念）可以完全避免除法運算，從而消除除以零的風險以及浮點數精確度的問題。這是計算幾何中處理共線問題的標準做法。",
      "en": "Using cross-multiplication (concept of cross product) completely avoids division, thereby eliminating the risk of division by zero and floating-point precision issues. This is the standard practice for handling collinearity in computational geometry.",
      "wg": [
        {
          "t": "交叉相乘",
          "en": "cross-multiplication",
          "ps": "N"
        },
        {
          "t": "共線",
          "en": "collinearity",
          "ps": "N"
        },
        {
          "t": "精確度",
          "en": "precision",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "Medium",
    "keywords": "Math, Cycle Detection, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "編寫一個演算法來判斷一個數字 n 是否為「快樂數」(Happy Number)。",
        "en": "Write an algorithm to determine if a number n is a \"Happy Number\".",
        "wg": [
          {
            "t": "演算法",
            "en": "algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "快樂數定義為：對於一個正整數，每一次將該數替換為其每個位數的平方和。",
        "en": "A happy number is defined as: starting with any positive integer, replace the number by the sum of the squares of its digits.",
        "wg": [
          {
            "t": "替換",
            "en": "replace",
            "ps": "V"
          },
          {
            "t": "平方和",
            "en": "sum of the squares",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若過程最終收斂到 1 則為快樂數，否則會進入無限循環。偵測此循環最有效率的方法是？",
        "en": "If the process eventually converges to 1, it is a happy number; otherwise, it enters an infinite loop. What is the most efficient way to detect this loop?",
        "wg": [
          {
            "t": "收斂",
            "en": "converge",
            "ps": "V"
          },
          {
            "t": "無限循環",
            "en": "infinite loop",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 設定遞迴深度限制，超過 1000 層即視為非快樂數。",
        "en": "(A) Set a recursion depth limit; if it exceeds 1000 levels, consider it a non-happy number.",
        "wg": [
          {
            "t": "遞迴深度",
            "en": "recursion depth",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用快慢指針 (Floyd's Cycle-Finding Algorithm)。",
        "en": "(B) Use fast and slow pointers (Floyd's Cycle-Finding Algorithm).",
        "wg": [
          {
            "t": "快慢指針",
            "en": "fast and slow pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 檢查數字是否變為 4，因為所有非快樂數都會經過 4。",
        "en": "(C) Check if the number becomes 4, as all non-happy numbers eventually pass through 4.",
        "wg": []
      },
      {
        "t": "(D) 選項 (B) 和 (C) 都是有效的策略。",
        "en": "(D) Both options (B) and (C) are valid strategies.",
        "wg": [
          {
            "t": "有效的",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "這題可以使用快慢指針來偵測循環（類似 Linked List 判圈）。另外，數學上已證明非快樂數的循環序列必定包含 4，因此檢查是否出現 4 也是一種有效的數學捷徑。故 (B) 和 (C) 皆可行。",
      "en": "This problem can use fast and slow pointers to detect cycles (similar to cycle detection in a Linked List). Additionally, it has been mathematically proven that the cycle sequence for non-happy numbers must contain 4, so checking for the occurrence of 4 is also a valid mathematical shortcut. Therefore, both (B) and (C) are feasible.",
      "wg": [
        {
          "t": "捷徑",
          "en": "shortcut",
          "ps": "N"
        },
        {
          "t": "證明",
          "en": "proven",
          "ps": "V"
        }
      ]
    }
  }
]