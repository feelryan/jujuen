[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Space Optimization, Rolling Array, 2D DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j] + dp[i][j-1]",
    "question": [
      {
        "t": "在許多網格類型的 2D DP 問題中（例如「不同路徑」），狀態轉移方程式通常只依賴於上方和左方的格子。",
        "en": "In many grid-based 2D DP problems (such as 'Unique Paths'), the state transition equation often depends only on the cells above and to the left.",
        "wg": [
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          },
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若原始 DP 表格大小為 M x N，我們可以使用「滾動陣列」技巧來優化空間複雜度。",
        "en": "If the original DP table size is M x N, we can use the 'rolling array' technique to optimize space complexity.",
        "wg": [
          {
            "t": "滾動陣列",
            "en": "rolling array",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問優化後的空間複雜度最理想可以達到多少？",
        "en": "What is the optimal space complexity achievable after optimization?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N) 或 O(min(M, N))",
        "en": "(C) O(N) or O(min(M, N))",
        "wg": []
      },
      {
        "t": "(D) O(M * N / 2)",
        "en": "(D) O(M * N / 2)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為計算當前列 (row) 的值只需要用到前一列的值，因此我們只需要維護一維陣列（長度為 N）即可。",
      "en": "Since calculating the values of the current row only requires values from the previous row, we only need to maintain a 1D array (of length N).",
      "wg": [
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "一維陣列",
          "en": "1D array",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "LCS, Longest Common Subsequence, Recurrence Relation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「最長公共子序列」(Longest Common Subsequence, LCS) 問題，我們定義 dp[i][j] 為字串 text1 前 i 個字元與 text2 前 j 個字元的 LCS 長度。",
        "en": "Regarding the 'Longest Common Subsequence' (LCS) problem, we define dp[i][j] as the LCS length of the first i characters of text1 and the first j characters of text2.",
        "wg": [
          {
            "t": "最長公共子序列",
            "en": "Longest Common Subsequence",
            "ps": "N"
          },
          {
            "t": "字元",
            "en": "character",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 text1[i] 不等於 text2[j] 時，正確的狀態轉移方程式為何？",
        "en": "When text1[i] is not equal to text2[j], what is the correct state transition equation?",
        "wg": [
          {
            "t": "不等於",
            "en": "not equal to",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = dp[i-1][j-1]",
        "en": "(A) dp[i][j] = dp[i-1][j-1]",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(B) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = dp[i-1][j-1] + 1",
        "en": "(C) dp[i][j] = dp[i-1][j-1] + 1",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = 0",
        "en": "(D) dp[i][j] = 0",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當字元不匹配時，LCS 的長度取決於「忽略 text1 當前字元」或「忽略 text2 當前字元」兩者中的最大值，即繼承左方或上方的最大值。",
      "en": "When characters do not match, the length of the LCS depends on the maximum of either 'ignoring the current character of text1' or 'ignoring the current character of text2', which means inheriting the maximum value from the left or above.",
      "wg": [
        {
          "t": "不匹配",
          "en": "mismatch",
          "ps": "V"
        },
        {
          "t": "忽略",
          "en": "ignore",
          "ps": "V"
        },
        {
          "t": "繼承",
          "en": "inherit",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Edit Distance, Levenshtein Distance, Operations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「編輯距離」(Edit Distance) 問題中，dp[i][j] 代表將 word1 的前 i 個字元轉換成 word2 的前 j 個字元所需的最少操作數。",
        "en": "In the 'Edit Distance' problem, dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若 word1[i] != word2[j]，轉移方程式 dp[i][j] = 1 + dp[i-1][j-1] 對應於哪一種操作？",
        "en": "If word1[i] != word2[j], which operation does the transition equation dp[i][j] = 1 + dp[i-1][j-1] correspond to?",
        "wg": [
          {
            "t": "對應",
            "en": "correspond",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設 dp[i-1][j] 對應刪除，dp[i][j-1] 對應插入。",
        "en": "Assume dp[i-1][j] corresponds to deletion and dp[i][j-1] corresponds to insertion.",
        "wg": [
          {
            "t": "刪除",
            "en": "deletion",
            "ps": "N"
          },
          {
            "t": "插入",
            "en": "insertion",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 交換 (Swap)",
        "en": "(D) Swap",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "dp[i-1][j-1] 代表 word1 前 i-1 個字元已轉換為 word2 前 j-1 個字元，因此若當前字元不同，我們只需花費 1 次操作將 word1[i] 「替換」為 word2[j]。",
      "en": "dp[i-1][j-1] represents that the first i-1 characters of word1 have already been converted to the first j-1 characters of word2, so if the current characters differ, we only need 1 operation to 'replace' word1[i] with word2[j].",
      "wg": [
        {
          "t": "替換",
          "en": "replace",
          "ps": "V"
        },
        {
          "t": "花費",
          "en": "cost",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Interval DP, Palindrome, Iteration Order",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i+1][j-1] + 2",
    "question": [
      {
        "t": "考慮「最長迴文子序列」(Longest Palindromic Subsequence) 問題，其中 dp[i][j] 代表字串從索引 i 到 j 的範圍內的最長迴文長度。",
        "en": "Consider the 'Longest Palindromic Subsequence' problem, where dp[i][j] represents the length of the longest palindromic subsequence within the range from index i to j.",
        "wg": [
          {
            "t": "最長迴文子序列",
            "en": "Longest Palindromic Subsequence",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "由於 dp[i][j] 依賴於 dp[i+1][j-1]（即左下方的格子），我們不能使用簡單的 i: 0->N, j: 0->N 雙重迴圈。",
        "en": "Since dp[i][j] depends on dp[i+1][j-1] (the cell to the bottom-left), we cannot use a simple double loop with i: 0->N and j: 0->N.",
        "wg": [
          {
            "t": "依賴於",
            "en": "depend on",
            "ps": "V"
          },
          {
            "t": "雙重迴圈",
            "en": "double loop",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種遍歷順序是正確的？",
        "en": "Which of the following traversal orders is correct?",
        "wg": [
          {
            "t": "遍歷順序",
            "en": "traversal order",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) i 從 0 到 N，j 從 0 到 N",
        "en": "(A) i from 0 to N, j from 0 to N",
        "wg": []
      },
      {
        "t": "(B) i 從 N-1 遞減到 0，j 從 i+1 到 N-1",
        "en": "(B) i decreases from N-1 to 0, j from i+1 to N-1",
        "wg": [
          {
            "t": "遞減",
            "en": "decrease",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) i 從 0 到 N，j 從 N-1 遞減到 0",
        "en": "(C) i from 0 to N, j decreases from N-1 to 0",
        "wg": []
      },
      {
        "t": "(D) 隨機順序計算",
        "en": "(D) Calculate in random order",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "區間 DP 需要先計算小區間或「內部」的值。透過讓 i 逆向遍歷（從下往上），我們可以確保計算 dp[i][j] 時，其依賴的 dp[i+1][...] 已經被計算過。",
      "en": "Interval DP requires calculating smaller intervals or 'inner' values first. By traversing i in reverse (bottom-up), we ensure that when calculating dp[i][j], the dependent dp[i+1][...] has already been computed.",
      "wg": [
        {
          "t": "區間",
          "en": "interval",
          "ps": "N"
        },
        {
          "t": "逆向",
          "en": "reverse",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "2D Knapsack, Constraints, Ones and Zeroes",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "傳統的 0/1 背包問題通常使用一維或二維陣列來處理單一限制（重量）。",
        "en": "The traditional 0/1 Knapsack problem usually uses a 1D or 2D array to handle a single constraint (weight).",
        "wg": [
          {
            "t": "背包問題",
            "en": "Knapsack problem",
            "ps": "N"
          },
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果問題變成有「兩個」限制條件（例如：選取物品時，總重量不能超過 W 且總體積不能超過 V），DP 狀態定義應該如何調整？",
        "en": "If the problem changes to have 'two' constraints (e.g., when selecting items, total weight cannot exceed W AND total volume cannot exceed V), how should the DP state definition be adjusted?",
        "wg": [
          {
            "t": "體積",
            "en": "volume",
            "ps": "N"
          },
          {
            "t": "調整",
            "en": "adjust",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設我們想求最大價值。",
        "en": "Assume we want to find the maximum value.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 仍然使用 dp[w]，取兩者限制的最小值。",
        "en": "(A) Still use dp[w], taking the minimum of the two constraints.",
        "wg": []
      },
      {
        "t": "(B) 使用 dp[w+v] 將限制相加。",
        "en": "(B) Use dp[w+v] by summing the constraints.",
        "wg": []
      },
      {
        "t": "(C) 使用二維陣列 dp[i][j]，其中 i 代表當前重量，j 代表當前體積。",
        "en": "(C) Use a 2D array dp[i][j], where i represents current weight and j represents current volume.",
        "wg": []
      },
      {
        "t": "(D) 必須使用遞迴，無法使用 DP。",
        "en": "(D) Must use recursion; DP cannot be used.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當有兩個獨立的背包限制時，我們需要增加一個維度來記錄第二個限制的狀態，形成二維費用背包問題（若包含物品索引則為三維）。",
      "en": "When there are two independent knapsack constraints, we need to add a dimension to track the state of the second constraint, forming a 2D cost knapsack problem (or 3D if including the item index).",
      "wg": [
        {
          "t": "獨立的",
          "en": "independent",
          "ps": "Adj"
        },
        {
          "t": "維度",
          "en": "dimension",
          "ps": "N"
        }
      ]
    }
  }
]