[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Grid, Unique Paths, State Transition, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j] + dp[i][j-1]",
    "question": [
      {
        "t": "在一個 m x n 的網格中，機器人位於左上角，試圖移動到右下角。",
        "en": "In an m x n grid, a robot is located at the top-left corner and attempts to move to the bottom-right corner.",
        "wg": [
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          },
          {
            "t": "位於",
            "en": "located at",
            "ps": "V"
          }
        ]
      },
      {
        "t": "機器人每次只能向下或向右移動一步。",
        "en": "The robot can only move either down or right at any point in time.",
        "wg": [
          {
            "t": "向下",
            "en": "down",
            "ps": "Adv"
          },
          {
            "t": "向右",
            "en": "right",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "若定義 dp[i][j] 為到達座標 (i, j) 的唯一路徑數量，下列哪個狀態轉移方程式是正確的？",
        "en": "If dp[i][j] is defined as the number of unique paths to reach coordinate (i, j), which of the following state transition equations is correct?",
        "wg": [
          {
            "t": "唯一路徑",
            "en": "unique paths",
            "ps": "N"
          },
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(A) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "en": "(B) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = dp[i-1][j] * dp[i][j-1]",
        "en": "(C) dp[i][j] = dp[i-1][j] * dp[i][j-1]",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])",
        "en": "(D) dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "到達當前格子的路徑數量等於「從上方來的路徑數」加上「從左方來的路徑數」，因為機器人只能從這兩個方向進入該格子。",
      "en": "The number of paths to reach the current cell is equal to the 'number of paths from above' plus the 'number of paths from the left', since the robot can only enter the cell from these two directions.",
      "wg": [
        {
          "t": "上方",
          "en": "above",
          "ps": "N"
        },
        {
          "t": "左方",
          "en": "left",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Minimum Path Sum, Optimization, Grid, Cost",
    "parentNo": null,
    "images": null,
    "codeSnippet": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
    "question": [
      {
        "t": "給定一個包含非負整數的 m x n 網格，請找出一條從左上角到右下角的路徑，使得路徑上的數字總和最小。",
        "en": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integers",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在計算 dp[i][j] 時（代表到達 (i, j) 的最小路徑和），我們應該如何選擇前一步驟？",
        "en": "When calculating dp[i][j] (representing the minimum path sum to reach (i, j)), how should we choose the previous step?",
        "wg": [
          {
            "t": "前一步驟",
            "en": "previous step",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 選擇上方和左方中較大的一個，即 max(dp[i-1][j], dp[i][j-1])。",
        "en": "(A) Choose the larger one between the top and left, i.e., max(dp[i-1][j], dp[i][j-1]).",
        "wg": []
      },
      {
        "t": "(B) 選擇上方和左方中較小的一個，並加上當前格子的數值。",
        "en": "(B) Choose the smaller one between the top and left, and add the value of the current cell.",
        "wg": [
          {
            "t": "數值",
            "en": "value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 將上方和左方的路徑和相加，即 dp[i-1][j] + dp[i][j-1]。",
        "en": "(C) Sum up the path sums from the top and left, i.e., dp[i-1][j] + dp[i][j-1].",
        "wg": []
      },
      {
        "t": "(D) 僅考慮左方的路徑，忽略上方的路徑。",
        "en": "(D) Only consider the path from the left, ignoring the path from above.",
        "wg": [
          {
            "t": "忽略",
            "en": "ignoring",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了最小化總和，我們必須選擇從「累積成本較小」的相鄰格子（上方或左方）進入當前格子，再加上當前格子的成本。",
      "en": "To minimize the sum, we must choose to enter the current cell from the adjacent cell (top or left) that has the 'smaller accumulated cost', and then add the cost of the current cell.",
      "wg": [
        {
          "t": "累積成本",
          "en": "accumulated cost",
          "ps": "N"
        },
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "LCS, Longest Common Subsequence, String, Subsequence vs Substring",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「最長共同子序列」(Longest Common Subsequence, LCS) 問題，下列敘述何者正確？",
        "en": "Regarding the 'Longest Common Subsequence' (LCS) problem, which of the following statements is true?",
        "wg": [
          {
            "t": "最長共同子序列",
            "en": "Longest Common Subsequence",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請注意區分「子序列」(Subsequence) 與「子字串」(Substring) 的定義。",
        "en": "Please note the distinction between the definitions of 'Subsequence' and 'Substring'.",
        "wg": [
          {
            "t": "區分",
            "en": "distinction",
            "ps": "N"
          },
          {
            "t": "子字串",
            "en": "Substring",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 子序列中的字元在原字串中必須是連續的。",
        "en": "(A) Characters in a subsequence must be contiguous in the original string.",
        "wg": [
          {
            "t": "連續的",
            "en": "contiguous",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 若兩個字元不匹配，狀態轉移方程通常涉及 max(dp[i-1][j], dp[i][j-1])。",
        "en": "(B) If two characters do not match, the state transition equation typically involves max(dp[i-1][j], dp[i][j-1]).",
        "wg": [
          {
            "t": "匹配",
            "en": "match",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) LCS 問題無法使用 2-D Dynamic Programming 解決。",
        "en": "(C) The LCS problem cannot be solved using 2-D Dynamic Programming.",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] 代表的是 text1 前 i 個字元與 text2 前 j 個字元的最長共同子字串長度。",
        "en": "(D) dp[i][j] represents the length of the longest common substring between the first i characters of text1 and the first j characters of text2.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "子序列不需要連續（選項 A 錯）；LCS 是經典的 2-D DP 問題（選項 C 錯）；dp[i][j] 定義的是子序列而非子字串（選項 D 錯）。當字元不匹配時，我們繼承上方或左方的最大值，這是正確的邏輯。",
      "en": "Subsequences do not need to be contiguous (Option A is wrong); LCS is a classic 2-D DP problem (Option C is wrong); dp[i][j] defines a subsequence, not a substring (Option D is wrong). When characters do not match, inheriting the maximum value from above or the left is the correct logic.",
      "wg": [
        {
          "t": "繼承",
          "en": "inherit",
          "ps": "V"
        },
        {
          "t": "邏輯",
          "en": "logic",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Space Complexity, Optimization, Rolling Array, Memory",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決許多 2-D DP 問題（如 Unique Paths 或 LCS）時，我們通常可以將空間複雜度從 O(M*N) 優化到 O(N)（假設 N 是較短的一邊）。",
        "en": "When solving many 2-D DP problems (such as Unique Paths or LCS), we can often optimize the space complexity from O(M*N) to O(N) (assuming N is the shorter side).",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這種優化技術通常被稱為什麼？",
        "en": "What is this optimization technique commonly called?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遞迴記憶化 (Recursion with Memoization)",
        "en": "(A) Recursion with Memoization",
        "wg": [
          {
            "t": "記憶化",
            "en": "Memoization",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 滾動陣列 (Rolling Array)",
        "en": "(B) Rolling Array",
        "wg": [
          {
            "t": "滾動陣列",
            "en": "Rolling Array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 分治法 (Divide and Conquer)",
        "en": "(C) Divide and Conquer",
        "wg": [
          {
            "t": "分治法",
            "en": "Divide and Conquer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 貪婪演算法 (Greedy Algorithm)",
        "en": "(D) Greedy Algorithm",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Algorithm",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為計算當前列 (Row) 的值通常只需要上一列的資訊，我們不需要儲存整個二維矩陣，只需保留前一列的狀態，這種技巧稱為滾動陣列。",
      "en": "Since calculating the values of the current row usually only requires information from the previous row, we don't need to store the entire 2D matrix, but only keep the state of the previous row. This technique is called a Rolling Array.",
      "wg": [
        {
          "t": "矩陣",
          "en": "matrix",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "keep/retain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Edit Distance, Levenshtein Distance, String Operations, DP Table",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])",
    "question": [
      {
        "t": "在「編輯距離」(Edit Distance) 問題中，我們想將字串 word1 轉換為 word2。",
        "en": "In the 'Edit Distance' problem, we want to convert string word1 to word2.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "dp[i][j] 代表將 word1 的前 i 個字元轉換為 word2 的前 j 個字元所需的最少操作數。",
        "en": "dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.",
        "wg": [
          {
            "t": "最少操作數",
            "en": "minimum number of operations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 word1[i] != word2[j] 時，轉移方程式中的 dp[i-1][j-1] 對應到哪一種操作？",
        "en": "When word1[i] != word2[j], which operation does dp[i-1][j-1] in the transition equation correspond to?",
        "wg": [
          {
            "t": "對應",
            "en": "correspond to",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 保持不變 (Keep)",
        "en": "(D) Keep",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "dp[i-1][j-1] 代表處理這兩個字元之前的狀態。如果我們選擇「替換」當前字元，則操作數加 1，並接續使用 dp[i-1][j-1] 的結果。（註：dp[i][j-1] 對應插入，dp[i-1][j] 對應刪除）。",
      "en": "dp[i-1][j-1] represents the state before processing these two characters. If we choose to 'Replace' the current character, the operation count increases by 1, and we continue using the result of dp[i-1][j-1]. (Note: dp[i][j-1] corresponds to Insert, and dp[i-1][j] corresponds to Delete).",
      "wg": [
        {
          "t": "處理",
          "en": "processing",
          "ps": "V"
        },
        {
          "t": "接續",
          "en": "continue",
          "ps": "V"
        }
      ]
    }
  }
]