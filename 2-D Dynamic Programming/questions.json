[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Dynamic Programming, Grid Traversal, Unique Paths",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j] + dp[i][j-1]",
    "question": [
      {
        "t": "在一個 m x n 的網格中，機器人位於左上角 (0, 0)，試圖移動到右下角。",
        "en": "In an m x n grid, a robot is located at the top-left corner (0, 0) and attempts to move to the bottom-right corner.",
        "wg": [
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "機器人每次只能向下或向右移動一步。",
        "en": "The robot can only move either down or right at any point in time.",
        "wg": []
      },
      {
        "t": "若定義 dp[i][j] 為到達座標 (i, j) 的唯一路徑數量，下列哪一個狀態轉移方程式是正確的？",
        "en": "If dp[i][j] is defined as the number of unique paths to reach coordinate (i, j), which of the following state transition equations is correct?",
        "wg": [
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          },
          {
            "t": "唯一路徑",
            "en": "unique paths",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "en": "(A) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1",
        "en": "(B) dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(C) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = dp[i-1][j-1] + 1",
        "en": "(D) dp[i][j] = dp[i-1][j-1] + 1",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "因為機器人只能從「上方」或「左方」來到達當前格子 (i, j)，所以到達該格子的路徑總數等於到達「上方格子」的路徑數加上到達「左方格子」的路徑數。",
      "en": "Since the robot can only arrive at the current cell (i, j) from 'above' or 'left', the total number of paths to reach this cell equals the sum of the paths to the 'cell above' and the paths to the 'cell to the left'.",
      "wg": [
        {
          "t": "上方",
          "en": "above",
          "ps": "Prep"
        },
        {
          "t": "總數",
          "en": "total number",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Minimum Path Sum, Optimization, 2D Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
    "question": [
      {
        "t": "給定一個包含非負整數的 m x n 網格，請找出從左上角到右下角的路徑，使得路徑上的數字總和最小。",
        "en": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integers",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 dp[i][j] 代表到達 (i, j) 的最小路徑和，對於非邊界點，正確的遞迴關係式為何？",
        "en": "Assuming dp[i][j] represents the minimum path sum to reach (i, j), what is the correct recurrence relation for non-boundary points?",
        "wg": [
          {
            "t": "遞迴關係式",
            "en": "recurrence relation",
            "ps": "N"
          },
          {
            "t": "邊界點",
            "en": "boundary points",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "en": "(A) dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "en": "(B) dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = min(dp[i-1][j], dp[i][j-1])",
        "en": "(C) dp[i][j] = min(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = grid[i][j] + dp[i-1][j] + dp[i][j-1]",
        "en": "(D) dp[i][j] = grid[i][j] + dp[i-1][j] + dp[i][j-1]",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個最小化問題。到達當前格子的成本等於「當前格子的數值」加上「從上方或左方過來的較小累積成本」。",
      "en": "This is a minimization problem. The cost to reach the current cell equals the 'value of the current cell' plus the 'smaller accumulated cost coming from either above or the left'.",
      "wg": [
        {
          "t": "最小化問題",
          "en": "minimization problem",
          "ps": "N"
        },
        {
          "t": "累積成本",
          "en": "accumulated cost",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "LCS, Longest Common Subsequence, String Processing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在計算兩個字串 text1 和 text2 的「最長公共子序列」(LCS) 長度時，我們定義 dp[i][j] 為 text1 前 i 個字元與 text2 前 j 個字元的 LCS 長度。",
        "en": "When computing the length of the 'Longest Common Subsequence' (LCS) of two strings text1 and text2, we define dp[i][j] as the LCS length of the first i characters of text1 and the first j characters of text2.",
        "wg": [
          {
            "t": "最長公共子序列",
            "en": "Longest Common Subsequence",
            "ps": "N"
          },
          {
            "t": "字元",
            "en": "characters",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 text1[i-1] 等於 text2[j-1] 時，dp[i][j] 的值應如何計算？",
        "en": "When text1[i-1] is equal to text2[j-1], how should the value of dp[i][j] be calculated?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(A) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = dp[i-1][j-1] + 1",
        "en": "(B) dp[i][j] = dp[i-1][j-1] + 1",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = dp[i-1][j-1]",
        "en": "(C) dp[i][j] = dp[i-1][j-1]",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = 0",
        "en": "(D) dp[i][j] = 0",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當兩個字元匹配時，表示這個字元可以貢獻 1 個長度到 LCS 中，因此我們取「不包含這兩個字元之前的 LCS 長度」(即 dp[i-1][j-1]) 並加 1。",
      "en": "When two characters match, it means this character contributes a length of 1 to the LCS. Therefore, we take the 'LCS length before including these two characters' (i.e., dp[i-1][j-1]) and add 1.",
      "wg": [
        {
          "t": "匹配",
          "en": "match",
          "ps": "V"
        },
        {
          "t": "貢獻",
          "en": "contribute",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Knapsack Problem, 0/1 Knapsack, Decision Making",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮經典的 0/1 背包問題：有 N 個物品，每個物品有重量 w 和價值 v，背包最大承重為 W。",
        "en": "Consider the classic 0/1 Knapsack problem: there are N items, each with weight w and value v, and a knapsack with maximum capacity W.",
        "wg": [
          {
            "t": "背包問題",
            "en": "Knapsack problem",
            "ps": "N"
          },
          {
            "t": "承重",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "定義 dp[i][w] 為考慮前 i 個物品且當前剩餘容量為 w 時的最大價值。",
        "en": "Define dp[i][w] as the maximum value considering the first i items with a current remaining capacity w.",
        "wg": [
          {
            "t": "剩餘容量",
            "en": "remaining capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若決定「不放入」第 i 個物品，則狀態轉移為何？",
        "en": "If the decision is 'not to include' the i-th item, what is the state transition?",
        "wg": [
          {
            "t": "不放入",
            "en": "not to include",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][w] = dp[i-1][w]",
        "en": "(A) dp[i][w] = dp[i-1][w]",
        "wg": []
      },
      {
        "t": "(B) dp[i][w] = dp[i-1][w - weight[i]] + value[i]",
        "en": "(B) dp[i][w] = dp[i-1][w - weight[i]] + value[i]",
        "wg": []
      },
      {
        "t": "(C) dp[i][w] = dp[i][w-1]",
        "en": "(C) dp[i][w] = dp[i][w-1]",
        "wg": []
      },
      {
        "t": "(D) dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])",
        "en": "(D) dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "如果不選擇第 i 個物品，則最大價值完全繼承自「考慮前 i-1 個物品且容量仍為 w」的狀態，即 dp[i-1][w]。",
      "en": "If the i-th item is not chosen, the maximum value is entirely inherited from the state 'considering the first i-1 items with capacity still being w', which is dp[i-1][w].",
      "wg": [
        {
          "t": "繼承",
          "en": "inherit",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Space Complexity, Rolling Array, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在許多 2-D DP 問題（如路徑總數、LCS、編輯距離）中，我們通常可以將空間複雜度從 O(M*N) 優化到 O(N)。",
        "en": "In many 2-D DP problems (such as Unique Paths, LCS, Edit Distance), we can often optimize the space complexity from O(M*N) to O(N).",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這種優化技巧通常被稱為什麼？",
        "en": "What is this optimization technique commonly called?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪演算法 (Greedy Algorithm)",
        "en": "(A) Greedy Algorithm",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 滾動陣列 (Rolling Array)",
        "en": "(B) Rolling Array",
        "wg": [
          {
            "t": "滾動陣列",
            "en": "Rolling Array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 分治法 (Divide and Conquer)",
        "en": "(C) Divide and Conquer",
        "wg": [
          {
            "t": "分治法",
            "en": "Divide and Conquer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 回溯法 (Backtracking)",
        "en": "(D) Backtracking",
        "wg": [
          {
            "t": "回溯法",
            "en": "Backtracking",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為在計算 dp[i][...] 時，通常只需要用到 dp[i-1][...] (上一列) 的資料，因此不需要儲存整個二維矩陣，只需維護一列或兩列陣列不斷更新即可，這稱為滾動陣列。",
      "en": "Since calculating dp[i][...] usually only requires data from dp[i-1][...] (the previous row), there is no need to store the entire 2D matrix; maintaining one or two rows and updating them continuously is sufficient. This is called a Rolling Array.",
      "wg": [
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "矩陣",
          "en": "matrix",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "2D DP, Grid, Unique Paths II, Obstacles",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (obstacleGrid[i][j] == 1) {\n    dp[i][j] = 0;\n} else {\n    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n}",
    "question": [
      {
        "t": "在「不同路徑 II」(Unique Paths II) 問題中，機器人試圖在一個包含障礙物的 m x n 網格中從左上角移動到右下角。",
        "en": "In the 'Unique Paths II' problem, a robot attempts to move from the top-left to the bottom-right of an m x n grid containing obstacles.",
        "wg": [
          {
            "t": "障礙物",
            "en": "obstacles",
            "ps": "N"
          },
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果網格中的某個位置 `grid[i][j]` 設有障礙物，則該位置的動態規劃狀態值 `dp[i][j]` 應該如何處理？",
        "en": "If a specific position `grid[i][j]` in the grid contains an obstacle, how should the dynamic programming state value `dp[i][j]` be handled?",
        "wg": [
          {
            "t": "狀態值",
            "en": "state value",
            "ps": "N"
          },
          {
            "t": "處理",
            "en": "handled",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 設為 `dp[i-1][j] + dp[i][j-1]`，因為機器人可以繞過它。",
        "en": "(A) Set to `dp[i-1][j] + dp[i][j-1]`, because the robot can bypass it.",
        "wg": []
      },
      {
        "t": "(B) 設為 0，表示沒有任何路徑可以到達或通過此位置。",
        "en": "(B) Set to 0, indicating no paths can reach or pass through this position.",
        "wg": [
          {
            "t": "通過",
            "en": "pass through",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 設為 -1，作為標記以在後續計算中忽略。",
        "en": "(C) Set to -1, as a flag to ignore in subsequent calculations.",
        "wg": []
      },
      {
        "t": "(D) 設為 `Math.max(dp[i-1][j], dp[i][j-1])`。",
        "en": "(D) Set to `Math.max(dp[i-1][j], dp[i][j-1])`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "如果有障礙物，機器人無法到達或通過該格子，因此到達該格子的路徑數為 0。這會阻斷所有經過此點的路徑貢獻。",
      "en": "If there is an obstacle, the robot cannot reach or pass through that cell, so the number of paths to that cell is 0. This blocks the contribution of all paths passing through this point.",
      "wg": [
        {
          "t": "阻斷",
          "en": "blocks",
          "ps": "V"
        },
        {
          "t": "貢獻",
          "en": "contribution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "2D DP, Minimum Path Sum, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);",
    "question": [
      {
        "t": "在計算「最小路徑和」(Minimum Path Sum) 時，我們使用上述的狀態轉移方程式。",
        "en": "When calculating the 'Minimum Path Sum', we use the state transition equation shown above.",
        "wg": [
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "針對網格的第一列 (Row 0) 與第一行 (Column 0)，我們需要特別處理邊界條件。",
        "en": "For the first row (Row 0) and first column (Column 0) of the grid, we need to handle boundary conditions specifically.",
        "wg": [
          {
            "t": "邊界條件",
            "en": "boundary conditions",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列關於初始化的描述何者正確？",
        "en": "Which of the following descriptions regarding initialization is correct?",
        "wg": [
          {
            "t": "初始化",
            "en": "initialization",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 第一列的每個格子只能從左邊過來，第一行的每個格子只能從上面下來。",
        "en": "(A) Each cell in the first row can only be reached from the left, and each cell in the first column can only be reached from above.",
        "wg": [
          {
            "t": "只能",
            "en": "only",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 第一列與第一行的格子都應該初始化為 0。",
        "en": "(B) Cells in both the first row and first column should be initialized to 0.",
        "wg": []
      },
      {
        "t": "(C) 邊界格子的值僅取決於它們自身的 `grid` 數值，與前一個格子無關。",
        "en": "(C) The values of boundary cells depend only on their own `grid` values, unrelated to the previous cell.",
        "wg": [
          {
            "t": "取決於",
            "en": "depend on",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 應該將第一列與第一行填入無限大 (Infinity) 以避免被選取。",
        "en": "(D) The first row and first column should be filled with Infinity to avoid being selected.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在第一列 `dp[0][j]`，路徑只能來自左側 `dp[0][j-1]`；在第一行 `dp[i][0]`，路徑只能來自上方 `dp[i-1][0]`。這是累積路徑和的基礎。",
      "en": "In the first row `dp[0][j]`, the path can only come from the left `dp[0][j-1]`; in the first column `dp[i][0]`, the path can only come from above `dp[i-1][0]`. This is the basis for the accumulated path sum.",
      "wg": [
        {
          "t": "累積",
          "en": "accumulated",
          "ps": "Adj"
        },
        {
          "t": "基礎",
          "en": "basis",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "LCS, Longest Common Subsequence, String",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「最長公共子序列」(Longest Common Subsequence, LCS) 問題中，`dp[i][j]` 代表字串 `text1` 的前 `i` 個字元與 `text2` 的前 `j` 個字元的 LCS 長度。",
        "en": "In the 'Longest Common Subsequence' (LCS) problem, `dp[i][j]` represents the LCS length of the first `i` characters of `text1` and the first `j` characters of `text2`.",
        "wg": [
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          },
          {
            "t": "字元",
            "en": "characters",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 `text1[i-1]` 不等於 `text2[j-1]` 時，正確的狀態轉移方程式為何？",
        "en": "When `text1[i-1]` is not equal to `text2[j-1]`, what is the correct state transition equation?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i][j] = dp[i-1][j-1]`",
        "en": "(A) `dp[i][j] = dp[i-1][j-1]`",
        "wg": []
      },
      {
        "t": "(B) `dp[i][j] = 0`",
        "en": "(B) `dp[i][j] = 0`",
        "wg": []
      },
      {
        "t": "(C) `dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`",
        "en": "(C) `dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`",
        "wg": []
      },
      {
        "t": "(D) `dp[i][j] = dp[i-1][j] + dp[i][j-1]`",
        "en": "(D) `dp[i][j] = dp[i-1][j] + dp[i][j-1]`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當字元不匹配時，LCS 的長度取決於「捨棄 text1 的當前字元」或「捨棄 text2 的當前字元」這兩種情況中的最大值，即繼承左方或上方的最佳結果。",
      "en": "When characters do not match, the length of the LCS depends on the maximum of either 'discarding the current character of text1' or 'discarding the current character of text2', effectively inheriting the best result from the left or above.",
      "wg": [
        {
          "t": "不匹配",
          "en": "do not match",
          "ps": "V"
        },
        {
          "t": "捨棄",
          "en": "discarding",
          "ps": "V"
        },
        {
          "t": "繼承",
          "en": "inheriting",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Edit Distance, Levenshtein Distance, Operations",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = 1 + Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1]));",
    "question": [
      {
        "t": "在「編輯距離」(Edit Distance) 問題中，我們希望將 `word1` 轉換為 `word2`。",
        "en": "In the 'Edit Distance' problem, we want to convert `word1` to `word2`.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當前字元不相同時，我們取插入、刪除、替換操作的最小值（如上方代碼所示）。",
        "en": "When the current characters are different, we take the minimum of insert, delete, and replace operations (as shown in the code above).",
        "wg": [
          {
            "t": "替換",
            "en": "replace",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問代碼中的 `dp[i-1][j-1]` 對應到哪一種操作？",
        "en": "Which operation does `dp[i-1][j-1]` in the code correspond to?",
        "wg": [
          {
            "t": "對應",
            "en": "correspond",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 保持不變 (Keep)",
        "en": "(D) Keep",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "`dp[i-1][j-1]` 代表我們同時處理了 `word1` 和 `word2` 的當前字元。",
      "en": "`dp[i-1][j-1]` represents that we have processed the current characters of both `word1` and `word2` simultaneously.",
      "wg": [
        {
          "t": "同時",
          "en": "simultaneously",
          "ps": "Adv"
        }
      ]
    },
    "why_extended": {
      "t": "加上 1 的操作成本後，這意味著我們將 `word1[i]` 替換成了 `word2[j]`。",
      "en": "Adding the operation cost of 1 implies that we replaced `word1[i]` with `word2[j]`."
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Space Optimization, Rolling Array, Memory Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "許多 2-D DP 問題（如最小路徑和、不同路徑）可以將空間複雜度從 O(M*N) 優化至 O(N)。",
        "en": "Many 2-D DP problems (such as Minimum Path Sum, Unique Paths) can have their space complexity optimized from O(M*N) to O(N).",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimized",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這種優化技術通常被稱為「滾動陣列」(Rolling Array)。其核心原理是什麼？",
        "en": "This optimization technique is often called 'Rolling Array'. What is its core principle?",
        "wg": [
          {
            "t": "滾動陣列",
            "en": "Rolling Array",
            "ps": "N"
          },
          {
            "t": "核心原理",
            "en": "core principle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當前列的狀態計算僅依賴於「上一列」或「當前列」的舊值，不需要更早的歷史數據。",
        "en": "(A) The calculation of the current row's state depends only on the 'previous row' or the old values of the 'current row', without needing earlier historical data.",
        "wg": [
          {
            "t": "依賴於",
            "en": "depends on",
            "ps": "V"
          },
          {
            "t": "歷史數據",
            "en": "historical data",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 我們可以使用遞迴 (Recursion) 來取代迭代，從而節省堆疊空間。",
        "en": "(B) We can use recursion instead of iteration to save stack space.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          },
          {
            "t": "堆疊",
            "en": "stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 透過將二維陣列壓縮成字串來儲存。",
        "en": "(C) By compressing the 2D array into a string for storage.",
        "wg": [
          {
            "t": "壓縮",
            "en": "compressing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 只有當網格是正方形 (M=N) 時才能使用此技巧。",
        "en": "(D) This technique can only be used when the grid is a square (M=N).",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在標準的網格 DP 中，計算 `dp[i][j]` 通常只需要 `dp[i-1][...]` (上一列) 和 `dp[i][...]` (當前列已計算部分) 的資訊，因此只需要保留一列（或兩列）的空間即可。",
      "en": "In standard grid DP, calculating `dp[i][j]` usually only requires information from `dp[i-1][...]` (previous row) and `dp[i][...]` (computed parts of current row), so keeping space for just one (or two) rows is sufficient.",
      "wg": [
        {
          "t": "保留",
          "en": "keeping",
          "ps": "V"
        },
        {
          "t": "足夠的",
          "en": "sufficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Edit Distance, Levenshtein Distance, String Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (word1[i-1] == word2[j-1]) {\n    dp[i][j] = dp[i-1][j-1];\n} else {\n    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);\n}",
    "question": [
      {
        "t": "在計算兩個字串之間的「編輯距離」(Edit Distance) 時，我們定義 dp[i][j] 為將 word1 的前 i 個字元轉換為 word2 的前 j 個字元所需的最少操作數。",
        "en": "When calculating the 'Edit Distance' between two strings, we define dp[i][j] as the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          },
          {
            "t": "操作數",
            "en": "number of operations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請參考上方的程式碼片段，當字元不匹配時，dp[i-1][j-1] 對應到哪一種操作？",
        "en": "Referring to the code snippet above, when characters do not match, which operation does dp[i-1][j-1] correspond to?",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "不匹配",
            "en": "do not match",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 交換 (Swap)",
        "en": "(D) Swap",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "dp[i-1][j-1] 代表我們已經處理了 word1 的前 i-1 個字元和 word2 的前 j-1 個字元。若當前字元不匹配，從 (i-1, j-1) 狀態轉移到 (i, j) 並加上 1 次操作，意味著我們將 word1[i] 替換成了 word2[j]。",
      "en": "dp[i-1][j-1] represents that we have already processed the first i-1 characters of word1 and the first j-1 characters of word2. If the current characters do not match, transitioning from state (i-1, j-1) to (i, j) with 1 additional operation implies replacing word1[i] with word2[j].",
      "wg": [
        {
          "t": "狀態轉移",
          "en": "state transition",
          "ps": "N"
        },
        {
          "t": "意味著",
          "en": "implies",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "0/1 Knapsack, Space Optimization, Rolling Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for (int i = 0; i < n; i++) {\n    for (int w = W; w >= weights[i]; w--) {\n        dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);\n    }\n}",
    "question": [
      {
        "t": "在 0/1 背包問題中，我們可以將 2-D DP 陣列優化為 1-D 陣列以節省空間。",
        "en": "In the 0/1 Knapsack problem, we can optimize the 2-D DP array into a 1-D array to save space.",
        "wg": [
          {
            "t": "背包問題",
            "en": "Knapsack problem",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為什麼在內層迴圈中，我們必須「反向」遍歷重量 w (從最大容量 W 到當前物品重量)？",
        "en": "Why must we iterate the weight w in 'reverse' order (from maximum capacity W down to the current item's weight) in the inner loop?",
        "wg": [
          {
            "t": "內層迴圈",
            "en": "inner loop",
            "ps": "N"
          },
          {
            "t": "反向遍歷",
            "en": "iterate in reverse",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免在同一次迭代中重複選取同一個物品。",
        "en": "(A) To avoid selecting the same item multiple times in the same iteration.",
        "wg": [
          {
            "t": "重複選取",
            "en": "selecting multiple times",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 為了確保較重的物品優先被放入背包。",
        "en": "(B) To ensure heavier items are put into the knapsack first.",
        "wg": []
      },
      {
        "t": "(C) 為了讓 DP 陣列能夠正確初始化為 0。",
        "en": "(C) To allow the DP array to be correctly initialized to 0.",
        "wg": []
      },
      {
        "t": "(D) 這是完全背包問題 (Unbounded Knapsack) 的解法，而非 0/1 背包。",
        "en": "(D) This is the solution for the Unbounded Knapsack problem, not 0/1 Knapsack.",
        "wg": [
          {
            "t": "完全背包問題",
            "en": "Unbounded Knapsack problem",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若正向遍歷 (從 0 到 W)，計算 dp[w] 時會用到更新後的 dp[w - weights[i]]，這意味著當前物品在同一輪中被使用了兩次（變成了完全背包問題）。反向遍歷確保 dp[w - weights[i]] 來自於「上一輪」的狀態（即尚未放入當前物品的狀態）。",
      "en": "If iterating forward (from 0 to W), calculating dp[w] would use the updated dp[w - weights[i]], meaning the current item is used twice in the same round (becoming Unbounded Knapsack). Reverse iteration ensures dp[w - weights[i]] comes from the 'previous round' state (i.e., without the current item).",
      "wg": [
        {
          "t": "正向遍歷",
          "en": "iterating forward",
          "ps": "N"
        },
        {
          "t": "上一輪",
          "en": "previous round",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Interval DP, Palindrome, Longest Palindromic Subsequence",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮「最長迴文子序列」(Longest Palindromic Subsequence) 問題，我們定義 dp[i][j] 為字串從索引 i 到 j 的範圍內最長迴文子序列的長度。",
        "en": "Consider the 'Longest Palindromic Subsequence' problem, where we define dp[i][j] as the length of the longest palindromic subsequence within the range of index i to j.",
        "wg": [
          {
            "t": "最長迴文子序列",
            "en": "Longest Palindromic Subsequence",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "狀態轉移方程通常涉及 dp[i+1][j-1]。為了正確計算，下列哪種迴圈遍歷順序是正確的？",
        "en": "The state transition equation usually involves dp[i+1][j-1]. To calculate correctly, which of the following loop traversal orders is correct?",
        "wg": [
          {
            "t": "狀態轉移方程",
            "en": "state transition equation",
            "ps": "N"
          },
          {
            "t": "遍歷順序",
            "en": "traversal order",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) i 從 0 到 n，j 從 0 到 n (標準雙層迴圈)。",
        "en": "(A) i from 0 to n, j from 0 to n (standard nested loops).",
        "wg": []
      },
      {
        "t": "(B) i 從 n-1 遞減到 0，j 從 i+1 到 n-1。",
        "en": "(B) i decreases from n-1 to 0, j from i+1 to n-1.",
        "wg": [
          {
            "t": "遞減",
            "en": "decreases",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) i 從 0 到 n，j 從 n-1 遞減到 0。",
        "en": "(C) i from 0 to n, j decreases from n-1 to 0.",
        "wg": []
      },
      {
        "t": "(D) 隨機順序計算。",
        "en": "(D) Calculate in random order.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這屬於區間 DP。計算 dp[i][j] 需要用到 dp[i+1][j-1] (即更小的內部區間)。因此，我們必須先算出較大的 i (較下面的列) 或較短的區間長度。選項 (B) 讓 i 從大到小遍歷，保證計算 dp[i][...] 時，dp[i+1][...] 已經計算完成。",
      "en": "This is Interval DP. Calculating dp[i][j] requires dp[i+1][j-1] (a smaller internal interval). Therefore, we must first compute larger i (lower rows) or shorter interval lengths. Option (B) iterates i from large to small, ensuring that when computing dp[i][...], dp[i+1][...] has already been computed.",
      "wg": [
        {
          "t": "區間",
          "en": "interval",
          "ps": "N"
        },
        {
          "t": "保證",
          "en": "ensuring",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Distinct Subsequences, String Matching, Counting",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (s[i-1] == t[j-1]) {\n    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n} else {\n    dp[i][j] = dp[i-1][j];\n}",
    "question": [
      {
        "t": "在「相異子序列」(Distinct Subsequences) 問題中，我們要計算字串 S 有多少種子序列等於字串 T。",
        "en": "In the 'Distinct Subsequences' problem, we want to count how many subsequences of string S are equal to string T.",
        "wg": [
          {
            "t": "相異子序列",
            "en": "Distinct Subsequences",
            "ps": "N"
          },
          {
            "t": "等於",
            "en": "equal to",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "當 S[i-1] == T[j-1] 時，狀態轉移方程為 dp[i][j] = dp[i-1][j-1] + dp[i-1][j]。請問 dp[i-1][j] 代表什麼意義？",
        "en": "When S[i-1] == T[j-1], the state transition is dp[i][j] = dp[i-1][j-1] + dp[i-1][j]. What does dp[i-1][j] represent?",
        "wg": [
          {
            "t": "意義",
            "en": "meaning",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用 S[i-1] 來匹配 T[j-1] 的情況。",
        "en": "(A) The case where S[i-1] is used to match T[j-1].",
        "wg": []
      },
      {
        "t": "(B) 放棄使用 S[i-1]，嘗試用 S 之前的字元來匹配目前的 T[0...j-1]。",
        "en": "(B) Skip using S[i-1] and try to match the current T[0...j-1] using previous characters of S.",
        "wg": [
          {
            "t": "放棄",
            "en": "skip/discard",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 刪除 T[j-1] 以匹配 S[i-1]。",
        "en": "(C) Delete T[j-1] to match S[i-1].",
        "wg": []
      },
      {
        "t": "(D) 代表字串 S 和 T 不匹配的情況。",
        "en": "(D) Represents the case where strings S and T do not match.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "dp[i-1][j-1] 代表「使用」當前的 S[i-1] 來匹配 T[j-1]；而 dp[i-1][j] 代表「不使用」當前的 S[i-1] (將其視為多餘字元)，並保留 S 的前 i-1 個字元已經組成的 T 的前 j 個字元的方案數。這兩者相加即為所有可能的組合。",
      "en": "dp[i-1][j-1] represents 'using' the current S[i-1] to match T[j-1]; whereas dp[i-1][j] represents 'not using' the current S[i-1] (treating it as an extra character) and keeping the count of ways S's first i-1 characters formed T's first j characters. The sum of these two covers all possible combinations.",
      "wg": [
        {
          "t": "多餘字元",
          "en": "extra character",
          "ps": "N"
        },
        {
          "t": "方案數",
          "en": "count of ways",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Maximal Square, Matrix DP, Geometry",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (matrix[i][j] == '1') {\n    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;\n}",
    "question": [
      {
        "t": "在一個由 '0' 和 '1' 組成的矩陣中，尋找包含全 '1' 的最大正方形面積。",
        "en": "Given a matrix consisting of '0's and '1's, find the area of the largest square containing only '1's.",
        "wg": [
          {
            "t": "矩陣",
            "en": "matrix",
            "ps": "N"
          },
          {
            "t": "最大正方形",
            "en": "largest square",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們定義 dp[i][j] 為以 (i, j) 為右下角的最大正方形邊長。為什麼轉移方程需要取左方、上方、左上方的最小值？",
        "en": "We define dp[i][j] as the side length of the largest square ending at the bottom-right corner (i, j). Why does the transition equation take the minimum of the left, top, and top-left values?",
        "wg": [
          {
            "t": "右下角",
            "en": "bottom-right corner",
            "ps": "N"
          },
          {
            "t": "邊長",
            "en": "side length",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為正方形的大小受限於其相鄰三個方向中「最短」的那個邊長，這確保了內部填滿 '1'。",
        "en": "(A) Because the square's size is limited by the 'shortest' side among its three adjacent directions, ensuring the interior is filled with '1's.",
        "wg": [
          {
            "t": "受限於",
            "en": "limited by",
            "ps": "V"
          },
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 取最小值是為了節省記憶體空間。",
        "en": "(B) Taking the minimum is to save memory space.",
        "wg": []
      },
      {
        "t": "(C) 應該取最大值 (max)，這樣才能找到最大的正方形。",
        "en": "(C) We should take the maximum (max) to find the largest square.",
        "wg": []
      },
      {
        "t": "(D) 這公式是錯誤的，應該只看左上角 dp[i-1][j-1]。",
        "en": "(D) This formula is incorrect; it should only look at the top-left dp[i-1][j-1].",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若要構成一個邊長為 k 的正方形，其左方、上方及左上方的區域都必須至少能構成邊長為 k-1 的正方形。若其中任一方向的邊長較短（例如有 '0' 造成的缺口），則當前位置只能延伸該最短邊長 + 1 的長度。",
      "en": "To form a square of side length k, the regions to its left, top, and top-left must all be able to form a square of side length at least k-1. If any of these directions has a shorter side length (e.g., due to a gap caused by '0'), the current position can only extend by that shortest side length + 1.",
      "wg": [
        {
          "t": "缺口",
          "en": "gap",
          "ps": "N"
        },
        {
          "t": "延伸",
          "en": "extend",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Interval DP, Matrix Chain Multiplication, Burst Balloons, Iteration Order",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for (int len = 2; len <= n; len++) {\n    for (int i = 0; i <= n - len; i++) {\n        int j = i + len - 1;\n        for (int k = i; k < j; k++) {\n            ...\n        }\n    }\n}",
    "question": [
      {
        "t": "在解決「矩陣鏈乘積」(Matrix Chain Multiplication) 或「戳氣球」(Burst Balloons) 等區間動態規劃問題時，我們通常採用上述程式碼片段中的迴圈結構。",
        "en": "When solving Interval DP problems like 'Matrix Chain Multiplication' or 'Burst Balloons', we usually adopt the loop structure shown in the code snippet above.",
        "wg": [
          {
            "t": "區間動態規劃",
            "en": "Interval DP",
            "ps": "N"
          },
          {
            "t": "矩陣鏈乘積",
            "en": "Matrix Chain Multiplication",
            "ps": "N"
          },
          {
            "t": "戳氣球",
            "en": "Burst Balloons",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼最外層的迴圈必須是「區間長度」(len)，而不是單純的起點索引 (i)？",
        "en": "Why must the outermost loop be the 'interval length' (len) rather than simply the start index (i)?",
        "wg": [
          {
            "t": "最外層",
            "en": "outermost",
            "ps": "Adj"
          },
          {
            "t": "區間長度",
            "en": "interval length",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了減少記憶體空間的使用。",
        "en": "(A) To reduce memory space usage.",
        "wg": []
      },
      {
        "t": "(B) 為了確保計算大區間 (i, j) 時，其包含的所有小區間 (i, k) 與 (k+1, j) 都已經被計算過。",
        "en": "(B) To ensure that when calculating a large interval (i, j), all smaller sub-intervals (i, k) and (k+1, j) contained within it have already been computed.",
        "wg": [
          {
            "t": "包含",
            "en": "contained",
            "ps": "V"
          },
          {
            "t": "小區間",
            "en": "sub-intervals",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 因為這樣可以避免整數溢位的問題。",
        "en": "(C) Because this avoids integer overflow issues.",
        "wg": []
      },
      {
        "t": "(D) 這種寫法可以將時間複雜度降低至 O(N^2)。",
        "en": "(D) This approach can reduce the time complexity to O(N^2).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "區間 DP 的核心是由小區間推導大區間。若只按索引 i 遞增，當計算 dp[i][j] 時，所需的右半部子區間 dp[k+1][j] 可能尚未計算，因此必須先遍歷長度。",
      "en": "The core of Interval DP is deriving larger intervals from smaller ones. If we only iterate by index i, when calculating dp[i][j], the required right sub-interval dp[k+1][j] might not be computed yet, so we must iterate by length first.",
      "wg": [
        {
          "t": "推導",
          "en": "derive",
          "ps": "V"
        },
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Space Optimization, Rolling Array, Grid DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j] + dp[i][j-1]",
    "question": [
      {
        "t": "考慮一個二維動態規劃問題，其狀態轉移方程式如上所示（例如計算網格路徑數）。",
        "en": "Consider a 2-D Dynamic Programming problem with the state transition equation shown above (e.g., counting grid paths).",
        "wg": [
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          },
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若網格大小為 M x N，我們可以利用「滾動陣列」技巧將空間複雜度優化至多少？",
        "en": "If the grid size is M x N, to what can we optimize the space complexity using the 'Rolling Array' technique?",
        "wg": [
          {
            "t": "滾動陣列",
            "en": "Rolling Array",
            "ps": "N"
          },
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(min(M, N))",
        "en": "(B) O(min(M, N))",
        "wg": []
      },
      {
        "t": "(C) O(M + N)",
        "en": "(C) O(M + N)",
        "wg": []
      },
      {
        "t": "(D) O(log(M * N))",
        "en": "(D) O(log(M * N))",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "由於 dp[i][j] 僅依賴於上一列 (i-1) 和當前列 (i) 的值，我們只需要維護一維陣列來儲存上一列的結果。透過選擇較小的維度作為內層迴圈，空間可降至 O(min(M, N))。",
      "en": "Since dp[i][j] only depends on the values from the previous row (i-1) and the current row (i), we only need to maintain a 1D array to store the previous row's results. By choosing the smaller dimension for the inner loop, space can be reduced to O(min(M, N)).",
      "wg": [
        {
          "t": "依賴",
          "en": "depend on",
          "ps": "V"
        },
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "維度",
          "en": "dimension",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Wildcard Matching, String DP, Boolean Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (p[j-1] == '*') {\n    dp[i][j] = dp[i][j-1] || dp[i-1][j];\n}",
    "question": [
      {
        "t": "在「萬用字元匹配」(Wildcard Matching) 問題中，字元 '*' 可以匹配任何字元序列（包括空序列）。",
        "en": "In the 'Wildcard Matching' problem, the character '*' can match any sequence of characters (including an empty sequence).",
        "wg": [
          {
            "t": "萬用字元匹配",
            "en": "Wildcard Matching",
            "ps": "N"
          },
          {
            "t": "序列",
            "en": "sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "上述程式碼片段展示了當模式字元為 '*' 時的轉移邏輯。",
        "en": "The code snippet above shows the transition logic when the pattern character is '*'.",
        "wg": [
          {
            "t": "模式",
            "en": "pattern",
            "ps": "N"
          },
          {
            "t": "轉移邏輯",
            "en": "transition logic",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問 `dp[i][j-1]` 和 `dp[i-1][j]` 分別代表什麼意義？",
        "en": "What do `dp[i][j-1]` and `dp[i-1][j]` represent respectively?",
        "wg": [
          {
            "t": "分別",
            "en": "respectively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i][j-1]` 代表 '*' 匹配空字串；`dp[i-1][j]` 代表 '*' 匹配當前字元並可能繼續匹配更多。",
        "en": "(A) `dp[i][j-1]` represents '*' matching an empty string; `dp[i-1][j]` represents '*' matching the current character and potentially more.",
        "wg": [
          {
            "t": "空字串",
            "en": "empty string",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) `dp[i][j-1]` 代表 '*' 匹配一個字元；`dp[i-1][j]` 代表 '*' 匹配空字串。",
        "en": "(B) `dp[i][j-1]` represents '*' matching one character; `dp[i-1][j]` represents '*' matching an empty string.",
        "wg": []
      },
      {
        "t": "(C) 兩者都代表 '*' 匹配任意長度的字串，只是方向不同。",
        "en": "(C) Both represent '*' matching a string of arbitrary length, just in different directions.",
        "wg": []
      },
      {
        "t": "(D) 這個轉移方程式是錯誤的，應該使用 `dp[i-1][j-1]`。",
        "en": "(D) This transition equation is incorrect; `dp[i-1][j-1]` should be used.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "`dp[i][j-1]` 表示忽略 '*'（視為匹配空字串）；`dp[i-1][j]` 表示 '*' 消耗了字串 s 的第 i 個字元，且因為 '*' 可重複使用，狀態仍停留在 j。",
      "en": "`dp[i][j-1]` means ignoring '*' (treating it as an empty match); `dp[i-1][j]` means '*' consumes the i-th character of string s, and since '*' can be reused, the state remains at j.",
      "wg": [
        {
          "t": "忽略",
          "en": "ignore",
          "ps": "V"
        },
        {
          "t": "消耗",
          "en": "consume",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Subset Sum, Knapsack Problem, Boolean DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「分割等和子集」(Partition Equal Subset Sum) 問題中，我們希望判斷一個陣列是否能被分為兩個總和相等的子集。",
        "en": "In the 'Partition Equal Subset Sum' problem, we want to determine if an array can be partitioned into two subsets with equal sums.",
        "wg": [
          {
            "t": "分割等和子集",
            "en": "Partition Equal Subset Sum",
            "ps": "N"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若定義 `dp[i][j]` 為二維 DP 狀態，其中 `i` 代表考慮前 i 個數字，`j` 代表目標總和。",
        "en": "If we define `dp[i][j]` as the 2D DP state, where `i` represents considering the first i numbers and `j` represents the target sum.",
        "wg": [
          {
            "t": "目標總和",
            "en": "target sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問 `dp[i][j]` 的資料型態與值應為何？",
        "en": "What should be the data type and value of `dp[i][j]`?",
        "wg": [
          {
            "t": "資料型態",
            "en": "data type",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 整數 (Integer)：代表前 i 個數字組成總和 j 的方法數。",
        "en": "(A) Integer: Represents the number of ways to form sum j using the first i numbers.",
        "wg": []
      },
      {
        "t": "(B) 整數 (Integer)：代表前 i 個數字組成總和 j 所需的最少數字個數。",
        "en": "(B) Integer: Represents the minimum count of numbers needed to form sum j using the first i numbers.",
        "wg": []
      },
      {
        "t": "(C) 布林值 (Boolean)：代表是否能夠從前 i 個數字中選出子集，使其總和恰好為 j。",
        "en": "(C) Boolean: Represents whether it is possible to select a subset from the first i numbers such that their sum is exactly j.",
        "wg": [
          {
            "t": "恰好",
            "en": "exactly",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 整數 (Integer)：代表前 i 個數字中，小於等於 j 的最大子集和。",
        "en": "(D) Integer: Represents the maximum subset sum less than or equal to j using the first i numbers.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "此問題是 0/1 背包問題的變形，我們只關心「可達性」(Reachability)，因此使用布林值來記錄是否能組出特定總和即可。",
      "en": "This problem is a variation of the 0/1 Knapsack problem. We only care about 'Reachability', so using a Boolean value to record whether a specific sum can be formed is sufficient.",
      "wg": [
        {
          "t": "變形",
          "en": "variation",
          "ps": "N"
        },
        {
          "t": "可達性",
          "en": "reachability",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "LCS, Backtracking, Reconstruction",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當我們完成「最長公共子序列」(LCS) 的 DP 表格填寫後，`dp[m][n]` 儲存了 LCS 的長度。",
        "en": "After filling the DP table for 'Longest Common Subsequence' (LCS), `dp[m][n]` stores the length of the LCS.",
        "wg": [
          {
            "t": "最長公共子序列",
            "en": "Longest Common Subsequence",
            "ps": "N"
          },
          {
            "t": "填寫",
            "en": "filling",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要印出實際的子序列字串，通常採用什麼策略？",
        "en": "If we want to print the actual subsequence string, what strategy is typically used?",
        "wg": [
          {
            "t": "印出",
            "en": "print",
            "ps": "V"
          },
          {
            "t": "實際的",
            "en": "actual",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從 `dp[0][0]` 開始，向右下角進行貪婪搜尋 (Greedy Search)。",
        "en": "(A) Start from `dp[0][0]` and perform a Greedy Search towards the bottom-right.",
        "wg": [
          {
            "t": "貪婪搜尋",
            "en": "Greedy Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 從 `dp[m][n]` 開始回溯 (Backtrack)，若字元匹配則往左上移動，否則往值較大的鄰居移動。",
        "en": "(B) Backtrack from `dp[m][n]`. If characters match, move diagonally up-left; otherwise, move to the neighbor with the larger value.",
        "wg": [
          {
            "t": "回溯",
            "en": "backtrack",
            "ps": "V"
          },
          {
            "t": "鄰居",
            "en": "neighbor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 重新執行一次 DP，但在過程中儲存所有可能的字串 (String Concatenation)。",
        "en": "(C) Rerun the DP, but store all possible strings (String Concatenation) during the process.",
        "wg": [
          {
            "t": "字串串接",
            "en": "String Concatenation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 隨機選取路徑直到長度符合 `dp[m][n]`。",
        "en": "(D) Randomly select a path until the length matches `dp[m][n]`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "重建解的標準做法是從終點回溯。如果當前字元相等，表示該字元是 LCS 的一部分；如果不等，則依據 DP 轉移來源（上方或左方較大者）回推。",
      "en": "The standard approach to reconstruct the solution is backtracking from the end. If current characters match, it's part of the LCS; otherwise, trace back based on the DP transition source (the larger value from above or left).",
      "wg": [
        {
          "t": "重建",
          "en": "reconstruct",
          "ps": "V"
        },
        {
          "t": "回推",
          "en": "trace back",
          "ps": "V"
        }
      ]
    }
  }
]