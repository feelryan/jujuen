[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Grid Traversal, Obstacles, State Transition",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (obstacleGrid[i][j] == 1) {\n    dp[i][j] = ?;\n} else {\n    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n}",
    "question": [
      {
        "t": "在「不同路徑 II」(Unique Paths II) 問題中，機器人試圖從網格左上角移動到右下角，但網格中包含障礙物。",
        "en": "In the 'Unique Paths II' problem, a robot attempts to move from the top-left to the bottom-right of a grid that contains obstacles.",
        "wg": [
          {
            "t": "障礙物",
            "en": "obstacle",
            "ps": "N"
          },
          {
            "t": "網格",
            "en": "grid",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果 `obstacleGrid[i][j] == 1` 表示該位置有障礙物，",
        "en": "If `obstacleGrid[i][j] == 1` indicates an obstacle at that position,",
        "wg": [
          {
            "t": "表示",
            "en": "indicates",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問在動態規劃表格 `dp[i][j]` 中，該位置的路徑數應如何設定？",
        "en": "How should the number of paths be set for this position in the dynamic programming table `dp[i][j]`?",
        "wg": [
          {
            "t": "設定",
            "en": "set",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "en": "(A) dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = 0",
        "en": "(B) dp[i][j] = 0",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = -1",
        "en": "(C) dp[i][j] = -1",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(D) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當遇到障礙物時，機器人無法到達或通過該格子，因此到達該格子的路徑數為 0。這會阻斷後續路徑的計算。",
      "en": "When an obstacle is encountered, the robot cannot reach or pass through that cell, so the number of paths to that cell is 0. This blocks the calculation for subsequent paths.",
      "wg": [
        {
          "t": "阻斷",
          "en": "block",
          "ps": "V"
        },
        {
          "t": "後續的",
          "en": "subsequent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Minimum Path Sum, Cost Optimization, 2D Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個充滿非負整數的 `m x n` 網格，您需要找出一條從左上角到右下角的路徑，使得路徑上的數字總和最小。",
        "en": "Given an `m x n` grid filled with non-negative integers, you need to find a path from top-left to bottom-right which minimizes the sum of all numbers along its path.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integers",
            "ps": "N"
          },
          {
            "t": "總和",
            "en": "sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 `grid[i][j]` 是當前格子的成本，下列哪個轉移方程式是正確的？",
        "en": "Assuming `grid[i][j]` is the cost of the current cell, which of the following transition equations is correct?",
        "wg": [
          {
            "t": "轉移方程式",
            "en": "transition equation",
            "ps": "N"
          },
          {
            "t": "成本",
            "en": "cost",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "en": "(A) dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "en": "(B) dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = min(dp[i-1][j], dp[i][j-1])",
        "en": "(C) dp[i][j] = min(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = grid[i][j] + dp[i-1][j] + dp[i][j-1]",
        "en": "(D) dp[i][j] = grid[i][j] + dp[i-1][j] + dp[i][j-1]",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了最小化路徑總和，到達當前格子 `(i, j)` 的最小成本應該是當前格子的值加上「從上方來」或「從左方來」兩者中較小的那個累積成本。",
      "en": "To minimize the path sum, the minimum cost to reach the current cell `(i, j)` should be the value of the current cell plus the smaller accumulated cost between 'coming from above' and 'coming from the left'.",
      "wg": [
        {
          "t": "累積成本",
          "en": "accumulated cost",
          "ps": "N"
        },
        {
          "t": "最小化",
          "en": "minimize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "LCS, Longest Common Subsequence, String",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在計算兩個字串 `text1` 和 `text2` 的「最長公共子序列」(LCS) 時，我們定義 `dp[i][j]` 為 `text1[0...i-1]` 與 `text2[0...j-1]` 的 LCS 長度。",
        "en": "When computing the 'Longest Common Subsequence' (LCS) of two strings `text1` and `text2`, we define `dp[i][j]` as the LCS length of `text1[0...i-1]` and `text2[0...j-1]`.",
        "wg": [
          {
            "t": "最長公共子序列",
            "en": "Longest Common Subsequence",
            "ps": "N"
          },
          {
            "t": "定義",
            "en": "define",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當 `text1[i-1]` 不等於 `text2[j-1]` 時，正確的狀態轉移是什麼？",
        "en": "When `text1[i-1]` is not equal to `text2[j-1]`, what is the correct state transition?",
        "wg": [
          {
            "t": "不等於",
            "en": "not equal to",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i][j] = dp[i-1][j-1]",
        "en": "(A) dp[i][j] = dp[i-1][j-1]",
        "wg": []
      },
      {
        "t": "(B) dp[i][j] = dp[i-1][j-1] + 1",
        "en": "(B) dp[i][j] = dp[i-1][j-1] + 1",
        "wg": []
      },
      {
        "t": "(C) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "en": "(C) dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "wg": []
      },
      {
        "t": "(D) dp[i][j] = 0",
        "en": "(D) dp[i][j] = 0",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "如果當前字元不匹配，LCS 的長度將延續「不包含 text1 當前字元」或「不包含 text2 當前字元」兩者中的最大值，因為當前字元無法貢獻於子序列長度。",
      "en": "If the current characters do not match, the LCS length carries over the maximum value between 'excluding text1's current char' and 'excluding text2's current char', as the current characters cannot contribute to the subsequence length.",
      "wg": [
        {
          "t": "匹配",
          "en": "match",
          "ps": "V"
        },
        {
          "t": "貢獻",
          "en": "contribute",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Edit Distance, Levenshtein, Operations",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「編輯距離」(Edit Distance) 問題，我們希望將字串 word1 轉換成 word2。",
        "en": "Regarding the 'Edit Distance' problem, we want to convert string word1 to word2.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "N"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在 DP 表格中，`dp[i][j]` 代表將 `word1[0...i]` 轉換為 `word2[0...j]` 的最小操作數。",
        "en": "In the DP table, `dp[i][j]` represents the minimum number of operations to convert `word1[0...i]` to `word2[0...j]`.",
        "wg": [
          {
            "t": "操作數",
            "en": "number of operations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若 `dp[i][j]` 是由 `dp[i-1][j-1] + 1` 導出，這通常代表執行了哪種操作？",
        "en": "If `dp[i][j]` is derived from `dp[i-1][j-1] + 1`, which operation does this typically represent?",
        "wg": [
          {
            "t": "導出",
            "en": "derived",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 保持不變 (Keep)",
        "en": "(D) Keep",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "`dp[i-1][j-1]` 代表處理完前一個位置的狀態。若從對角線移動並 `+1`，表示當前字元不匹配，我們消耗一次操作將 `word1[i]` 替換成 `word2[j]`。",
      "en": "`dp[i-1][j-1]` represents the state after processing the previous positions. Moving from the diagonal and adding `1` implies the current characters don't match, and we consume one operation to replace `word1[i]` with `word2[j]`.",
      "wg": [
        {
          "t": "對角線",
          "en": "diagonal",
          "ps": "N"
        },
        {
          "t": "消耗",
          "en": "consume",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Space Optimization, Rolling Array, Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "許多 2-D DP 問題（如 LCS 或最小路徑和）的狀態 `dp[i][j]` 僅依賴於上一列 `i-1` 和當前列 `i` 的值。",
        "en": "In many 2-D DP problems (like LCS or Minimum Path Sum), the state `dp[i][j]` depends only on values from the previous row `i-1` and the current row `i`.",
        "wg": [
          {
            "t": "依賴於",
            "en": "depends on",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了優化空間複雜度，我們可以使用「滾動陣列」(Rolling Array) 技巧。",
        "en": "To optimize space complexity, we can use the 'Rolling Array' technique.",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "滾動陣列",
            "en": "Rolling Array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問對於一個 `M x N` 的網格問題，這通常能將空間複雜度從 `O(M*N)` 降低到多少？",
        "en": "For an `M x N` grid problem, to what extent does this usually reduce the space complexity from `O(M*N)`?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          },
          {
            "t": "降低",
            "en": "reduce",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(min(M, N))",
        "en": "(B) O(min(M, N))",
        "wg": []
      },
      {
        "t": "(C) O(log(M*N))",
        "en": "(C) O(log(M*N))",
        "wg": []
      },
      {
        "t": "(D) O(M + N)",
        "en": "(D) O(M + N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們只需要保存一列（或兩列）的數據來計算下一列。因此空間需求變為列的長度。若我們選擇較短的邊作為列寬，空間複雜度為 `O(min(M, N))`。",
      "en": "We only need to store one (or two) rows of data to calculate the next row. Thus, the space requirement becomes the length of a row. If we choose the shorter side as the row width, the space complexity is `O(min(M, N))`.",
      "wg": [
        {
          "t": "列寬",
          "en": "row width",
          "ps": "N"
        },
        {
          "t": "保存",
          "en": "store",
          "ps": "V"
        }
      ]
    }
  }
]