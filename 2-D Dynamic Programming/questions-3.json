[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Edit Distance, Levenshtein Distance, State Transition",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (word1[i-1] == word2[j-1]) {\n  dp[i][j] = dp[i-1][j-1];\n} else {\n  dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);\n}",
    "question": [
      {
        "t": "在計算兩個字串之間的「編輯距離」(Edit Distance) 時，我們定義 dp[i][j] 為將 word1 的前 i 個字元轉換為 word2 的前 j 個字元所需的最少操作數。",
        "en": "When calculating the 'Edit Distance' between two strings, we define dp[i][j] as the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.",
        "wg": [
          {
            "t": "編輯距離",
            "en": "Edit Distance",
            "ps": "NP"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          },
          {
            "t": "最少操作數",
            "en": "minimum number of operations",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "當 word1[i-1] 不等於 word2[j-1] 時，狀態轉移方程涉及三個相鄰狀態的最小值。",
        "en": "When word1[i-1] is not equal to word2[j-1], the state transition equation involves the minimum of three adjacent states.",
        "wg": [
          {
            "t": "狀態轉移方程",
            "en": "state transition equation",
            "ps": "NP"
          },
          {
            "t": "相鄰狀態",
            "en": "adjacent states",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問 dp[i-1][j-1] 在此情境下代表哪一種編輯操作？",
        "en": "Which edit operation does dp[i-1][j-1] represent in this context?",
        "wg": [
          {
            "t": "情境",
            "en": "context",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 插入 (Insert)",
        "en": "(A) Insert",
        "wg": []
      },
      {
        "t": "(B) 刪除 (Delete)",
        "en": "(B) Delete",
        "wg": []
      },
      {
        "t": "(C) 替換 (Replace)",
        "en": "(C) Replace",
        "wg": []
      },
      {
        "t": "(D) 交換 (Swap)",
        "en": "(D) Swap",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "dp[i-1][j-1] 代表我們已經處理了 word1 的前 i-1 個字元和 word2 的前 j-1 個字元。如果當前字元不匹配，我們消耗一次操作將 word1 的第 i 個字元「替換」成 word2 的第 j 個字元，從而繼承 dp[i-1][j-1] 的結果。",
      "en": "dp[i-1][j-1] represents that we have already processed the first i-1 characters of word1 and the first j-1 characters of word2. If the current characters do not match, we use one operation to 'replace' the ith character of word1 with the jth character of word2, thereby inheriting the result from dp[i-1][j-1].",
      "wg": [
        {
          "t": "消耗",
          "en": "consume/use",
          "ps": "V"
        },
        {
          "t": "繼承",
          "en": "inherit",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "LCS, Space Optimization, Rolling Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「最長共同子序列」(Longest Common Subsequence, LCS) 問題時，標準的 2-D DP 表格大小為 M x N。",
        "en": "When solving the 'Longest Common Subsequence' (LCS) problem, the standard 2-D DP table size is M x N.",
        "wg": [
          {
            "t": "最長共同子序列",
            "en": "Longest Common Subsequence",
            "ps": "NP"
          },
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "如果我們只需要求出 LCS 的長度而不需要重建具體的字串，可以使用空間優化技巧。",
        "en": "If we only need to find the length of the LCS and do not need to reconstruct the specific string, we can use space optimization techniques.",
        "wg": [
          {
            "t": "重建",
            "en": "reconstruct",
            "ps": "V"
          },
          {
            "t": "空間優化",
            "en": "space optimization",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問最優化後的空間複雜度是多少？",
        "en": "What is the space complexity after maximum optimization?",
        "wg": [
          {
            "t": "複雜度",
            "en": "complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(min(M, N))",
        "en": "(B) O(min(M, N))",
        "wg": []
      },
      {
        "t": "(C) O(M + N)",
        "en": "(C) O(M + N)",
        "wg": []
      },
      {
        "t": "(D) O(max(M, N))",
        "en": "(D) O(max(M, N))",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "計算 dp[i][j] 時，我們只需要上一列 (row) 的資訊。因此，我們可以使用兩個一維陣列（滾動陣列）甚至一個一維陣列來儲存狀態。為了進一步優化，我們可以選擇較短的字串作為列數，因此空間複雜度為 O(min(M, N))。",
      "en": "When calculating dp[i][j], we only need information from the previous row. Therefore, we can use two 1D arrays (rolling arrays) or even a single 1D array to store the state. To further optimize, we can choose the shorter string as the column count, making the space complexity O(min(M, N)).",
      "wg": [
        {
          "t": "滾動陣列",
          "en": "rolling array",
          "ps": "NP"
        },
        {
          "t": "列數",
          "en": "column count",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Distinct Subsequences, Counting, String DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j]; \nif (s[i-1] == t[j-1]) {\n    dp[i][j] += dp[i-1][j-1];\n}",
    "question": [
      {
        "t": "考慮「相異子序列」(Distinct Subsequences) 問題：給定字串 S 和 T，計算 S 中有多少個子序列等於 T。",
        "en": "Consider the 'Distinct Subsequences' problem: Given strings S and T, count how many subsequences of S are equal to T.",
        "wg": [
          {
            "t": "相異子序列",
            "en": "Distinct Subsequences",
            "ps": "NP"
          },
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 S[i-1] == T[j-1] 時（字元匹配），為什麼我們需要將 dp[i-1][j] 和 dp[i-1][j-1] 相加？",
        "en": "When S[i-1] == T[j-1] (characters match), why do we need to add dp[i-1][j] and dp[i-1][j-1]?",
        "wg": [
          {
            "t": "字元匹配",
            "en": "characters match",
            "ps": "VP"
          },
          {
            "t": "相加",
            "en": "add",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i-1][j-1] 代表使用當前 S[i-1] 進行匹配的情況，而 dp[i-1][j] 代表不使用 S[i-1]（將其視為刪除）的情況。",
        "en": "(A) dp[i-1][j-1] represents the case of using the current S[i-1] for matching, while dp[i-1][j] represents the case of not using S[i-1] (treating it as deleted).",
        "wg": [
          {
            "t": "視為",
            "en": "treat as",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) dp[i-1][j-1] 代表插入操作，dp[i-1][j] 代表替換操作。",
        "en": "(B) dp[i-1][j-1] represents an insert operation, and dp[i-1][j] represents a replace operation.",
        "wg": []
      },
      {
        "t": "(C) 這是為了避免重複計算相同的子序列。",
        "en": "(C) This is to avoid double counting the same subsequences.",
        "wg": [
          {
            "t": "重複計算",
            "en": "double counting",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(D) dp[i-1][j] 包含了 S 的前綴與 T 的後綴匹配的所有可能性。",
        "en": "(D) dp[i-1][j] contains all possibilities where the prefix of S matches the suffix of T.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "後綴",
            "en": "suffix",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是計數型 DP 的核心邏輯。當字元匹配時，我們有兩個選擇：1. 使用 S[i-1] 來匹配 T[j-1]，方案數來自 dp[i-1][j-1]；2. 忽略 S[i-1]（保留給後面可能的匹配或直接丟棄），繼續用 S 的前 i-1 個字元去匹配 T 的前 j 個字元，方案數來自 dp[i-1][j]。兩者相加即為總數。",
      "en": "This is the core logic of counting DP. When characters match, we have two choices: 1. Use S[i-1] to match T[j-1], with counts from dp[i-1][j-1]; 2. Ignore S[i-1] (reserve it for later or discard it) and continue matching the first j characters of T with the first i-1 characters of S, with counts from dp[i-1][j]. The sum of both gives the total.",
      "wg": [
        {
          "t": "計數型",
          "en": "counting-type",
          "ps": "Adj"
        },
        {
          "t": "忽略",
          "en": "ignore",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Subset Sum, Boolean DP, Knapsack Variation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = dp[i-1][j] || dp[i-1][j - nums[i]];",
    "question": [
      {
        "t": "在「子集合加總」(Subset Sum) 問題中，我們想知道是否能從陣列中選出若干數字使其總和等於特定目標值 K。",
        "en": "In the 'Subset Sum' problem, we want to know if we can select some numbers from an array such that their sum equals a specific target value K.",
        "wg": [
          {
            "t": "子集合加總",
            "en": "Subset Sum",
            "ps": "NP"
          },
          {
            "t": "特定目標值",
            "en": "specific target value",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "dp[i][j] 為布林值，表示前 i 個數字是否能組成和為 j。",
        "en": "dp[i][j] is a boolean value indicating whether the first i numbers can form a sum of j.",
        "wg": [
          {
            "t": "布林值",
            "en": "boolean value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用 1-D 陣列進行空間優化，內層迴圈必須「從後往前」(iterate backwards) 遍歷，其主要原因為何？",
        "en": "If using a 1-D array for space optimization, the inner loop must iterate backwards. What is the main reason for this?",
        "wg": [
          {
            "t": "內層迴圈",
            "en": "inner loop",
            "ps": "NP"
          },
          {
            "t": "遍歷",
            "en": "iterate/traverse",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免在計算 dp[j] 時使用了當前這一輪更新過的 dp[j - nums[i]]，導致同一個物品被重複選取。",
        "en": "(A) To avoid using the updated dp[j - nums[i]] from the current round when calculating dp[j], which would cause the same item to be selected multiple times.",
        "wg": [
          {
            "t": "重複選取",
            "en": "selected multiple times",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(B) 因為陣列索引從 0 開始，從後往前可以避免索引越界。",
        "en": "(B) Because array indices start at 0, iterating backwards avoids index out of bounds errors.",
        "wg": [
          {
            "t": "索引越界",
            "en": "index out of bounds",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 這是為了配合遞迴堆疊 (Recursion Stack) 的順序。",
        "en": "(C) This is to match the order of the recursion stack.",
        "wg": []
      },
      {
        "t": "(D) 從後往前遍歷可以提高快取 (Cache) 的命中率。",
        "en": "(D) Iterating backwards improves cache hit rate.",
        "wg": [
          {
            "t": "命中率",
            "en": "hit rate",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "若從前往後遍歷，dp[j - nums[i]] 可能已經在當前迴圈被更新為「包含當前物品」的狀態。如果 dp[j] 再依據它更新，就等於使用了當前物品兩次（變成了無限背包問題）。從後往前遍歷確保 dp[j - nums[i]] 來自於「上一輪」（即不包含當前物品）的狀態。",
      "en": "If iterating forwards, dp[j - nums[i]] might have already been updated in the current loop to a state that 'includes the current item'. If dp[j] is then updated based on it, it amounts to using the current item twice (becoming an Unbounded Knapsack problem). Iterating backwards ensures that dp[j - nums[i]] comes from the 'previous round' (i.e., without the current item).",
      "wg": [
        {
          "t": "無限背包問題",
          "en": "Unbounded Knapsack problem",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Interval DP, Palindrome, Diagonal Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for (int len = 2; len <= n; len++) {\n    for (int i = 0; i < n - len + 1; i++) {\n        int j = i + len - 1;\n        // ... logic ...\n    }\n}",
    "question": [
      {
        "t": "在處理「區間 DP」(Interval DP) 問題，例如「最長迴文子序列」(Longest Palindromic Subsequence) 時，我們通常定義 dp[i][j] 為區間 [i, j] 內的最佳解。",
        "en": "When dealing with 'Interval DP' problems, such as 'Longest Palindromic Subsequence', we usually define dp[i][j] as the optimal solution within the interval [i, j].",
        "wg": [
          {
            "t": "區間",
            "en": "interval",
            "ps": "N"
          },
          {
            "t": "迴文",
            "en": "palindrome",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這類問題的迴圈遍歷順序通常不同於一般的 row-by-row。",
        "en": "The loop traversal order for such problems is usually different from the general row-by-row approach.",
        "wg": [
          {
            "t": "遍歷順序",
            "en": "traversal order",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問上述程式碼片段中的遍歷方式是基於什麼邏輯？",
        "en": "What is the logic behind the traversal method in the code snippet above?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 按照區間長度 (Length) 由小到大遍歷，確保計算大區間時，其內部的子區間都已計算完畢。",
        "en": "(A) Traverse by interval length from small to large, ensuring that when calculating a large interval, its internal sub-intervals have already been calculated.",
        "wg": [
          {
            "t": "子區間",
            "en": "sub-intervals",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 按照左端點 i 由小到大遍歷，這是一般的線性掃描。",
        "en": "(B) Traverse by the left endpoint i from small to large, which is a standard linear scan.",
        "wg": [
          {
            "t": "左端點",
            "en": "left endpoint",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 按照右端點 j 由大到小遍歷，為了節省空間。",
        "en": "(C) Traverse by the right endpoint j from large to small to save space.",
        "wg": []
      },
      {
        "t": "(D) 隨機遍歷，因為區間 DP 的狀態之間沒有依賴關係。",
        "en": "(D) Traverse randomly, because there are no dependencies between states in Interval DP.",
        "wg": [
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "區間 DP 的狀態 dp[i][j] 通常依賴於 dp[i+1][j-1] (更小的內部區間)。如果只按 i 或 j 的順序遍歷，可能會遇到需要的子區間尚未計算的情況。按長度 (len) 遍歷保證了當我們處理長度為 k 的區間時，所有長度小於 k 的區間都已準備好。",
      "en": "The state dp[i][j] in Interval DP usually depends on dp[i+1][j-1] (a smaller internal interval). If we traverse only by i or j, we might encounter situations where the required sub-intervals have not yet been calculated. Traversing by length (len) ensures that when we process an interval of length k, all intervals with length less than k are ready.",
      "wg": [
        {
          "t": "依賴於",
          "en": "depends on",
          "ps": "VP"
        }
      ]
    }
  }
]