[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Maximum Product Subarray, State Management, Negative Numbers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [2, 3, -2, 4]",
    "question": [
      {
        "t": "在處理「最大乘積子陣列」(Maximum Product Subarray) 問題時，",
        "en": "When dealing with the 'Maximum Product Subarray' problem,",
        "wg": [
          {
            "t": "最大乘積子陣列",
            "en": "Maximum Product Subarray",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為什麼我們不能只維護一個 `dp[i]` 來記錄到目前為止的最大乘積，而通常需要同時維護最大值與最小值？",
        "en": "why can't we just maintain a single `dp[i]` to record the maximum product so far, but usually need to maintain both a maximum and a minimum?",
        "wg": [
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          },
          {
            "t": "最大值",
            "en": "maximum",
            "ps": "N"
          },
          {
            "t": "最小值",
            "en": "minimum",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為陣列中可能包含零，這會重置乘積。",
        "en": "(A) Because the array might contain zeros, which reset the product.",
        "wg": [
          {
            "t": "重置",
            "en": "reset",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 因為負數乘以負數會變成正數，當前的最小值乘以負數可能變成新的最大值。",
        "en": "(B) Because a negative number multiplied by a negative number becomes positive, the current minimum multiplied by a negative number might become the new maximum.",
        "wg": [
          {
            "t": "負數",
            "en": "negative number",
            "ps": "N"
          },
          {
            "t": "正數",
            "en": "positive number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 因為我們需要計算平均值來進行正規化。",
        "en": "(C) Because we need to calculate the average for normalization.",
        "wg": []
      },
      {
        "t": "(D) 這是為了防止整數溢位 (Integer Overflow)。",
        "en": "(D) This is to prevent Integer Overflow.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在乘積問題中，負數具有「翻轉」大小的特性。若當前數字為負數，它乘以之前的「最小乘積」（如果是負數）可能會得到一個非常大的正數，因此必須同時追蹤最大與最小值以涵蓋此情況。",
      "en": "In product problems, negative numbers have the property of 'flipping' the magnitude. If the current number is negative, multiplying it by the previous 'minimum product' (if negative) can result in a very large positive number, so both maximum and minimum must be tracked to cover this case.",
      "wg": [
        {
          "t": "翻轉",
          "en": "flipping",
          "ps": "V"
        },
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "House Robber II, Circular Dependency, Problem Transformation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您正在解決「打家劫舍 II」(House Robber II) 問題，其中房屋是圍成一圈排列的。",
        "en": "Suppose you are solving the 'House Robber II' problem, where the houses are arranged in a circle.",
        "wg": [
          {
            "t": "打家劫舍",
            "en": "House Robber",
            "ps": "NP"
          },
          {
            "t": "圍成一圈",
            "en": "arranged in a circle",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "這意味著第一間房屋和最後一間房屋相鄰，不能同時被搶。",
        "en": "This means the first house and the last house are adjacent and cannot be robbed together.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "如何利用標準的 1-D DP (線性排列版本) 來解決這個環狀問題？",
        "en": "How can you utilize the standard 1-D DP (linear version) to solve this circular problem?",
        "wg": [
          {
            "t": "線性排列",
            "en": "linear arrangement",
            "ps": "NP"
          },
          {
            "t": "環狀",
            "en": "circular",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 在陣列末尾複製第一個元素，然後執行一次線性 DP。",
        "en": "(A) Duplicate the first element at the end of the array, then run linear DP once.",
        "wg": []
      },
      {
        "t": "(B) 執行兩次線性 DP：一次範圍是 0 到 n-2 (不含最後一間)，一次範圍是 1 到 n-1 (不含第一間)，取兩者最大值。",
        "en": "(B) Run linear DP twice: once for the range 0 to n-2 (excluding the last), and once for 1 to n-1 (excluding the first), then take the maximum of the two.",
        "wg": [
          {
            "t": "範圍",
            "en": "range",
            "ps": "N"
          },
          {
            "t": "不含",
            "en": "excluding",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "(C) 將所有房屋的金額減半，然後執行一次線性 DP。",
        "en": "(C) Halve the amount of all houses, then run linear DP once.",
        "wg": []
      },
      {
        "t": "(D) 使用二維 DP 矩陣來記錄是否搶了第一間房屋。",
        "en": "(D) Use a 2D DP matrix to record whether the first house was robbed.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "環狀問題的核心限制是「頭尾不能同時選」。將問題拆解為兩種線性情況：(1) 考慮選頭但不選尾，(2) 考慮選尾但不選頭（或都不選）。執行兩次標準 DP 並取最大值即可涵蓋所有合法情況。",
      "en": "The core constraint of the circular problem is 'cannot choose both head and tail'. Breaking the problem into two linear cases: (1) consider head but exclude tail, (2) consider tail but exclude head (or neither). Running standard DP twice and taking the maximum covers all valid scenarios.",
      "wg": [
        {
          "t": "核心限制",
          "en": "core constraint",
          "ps": "NP"
        },
        {
          "t": "拆解",
          "en": "break down",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Longest Increasing Subsequence, Time Complexity, Algorithm Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i] = max(dp[j]) + 1 for 0 <= j < i",
    "question": [
      {
        "t": "關於「最長遞增子序列」(Longest Increasing Subsequence, LIS) 問題，",
        "en": "Regarding the 'Longest Increasing Subsequence' (LIS) problem,",
        "wg": [
          {
            "t": "最長遞增子序列",
            "en": "Longest Increasing Subsequence",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "若使用標準的 1-D DP 方法 (即 `dp[i]` 代表以索引 `i` 結尾的 LIS 長度)，其時間複雜度為何？",
        "en": "If using the standard 1-D DP approach (where `dp[i]` represents the LIS length ending at index `i`), what is the time complexity?",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(n)",
        "en": "(A) O(n)",
        "wg": []
      },
      {
        "t": "(B) O(n log n)",
        "en": "(B) O(n log n)",
        "wg": []
      },
      {
        "t": "(C) O(n^2)",
        "en": "(C) O(n^2)",
        "wg": []
      },
      {
        "t": "(D) O(2^n)",
        "en": "(D) O(2^n)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "標準 DP 解法對於每個元素 `i`，都需要回頭檢查所有先前的元素 `j` (0 到 i-1) 來找到可接續的最大長度，這是一個雙重迴圈結構，故為 O(n^2)。(註：O(n log n) 解法使用的是貪婪演算法配合二分搜尋，而非純粹的 1-D DP 狀態轉移)。",
      "en": "The standard DP solution requires checking all previous elements `j` (0 to i-1) for each element `i` to find the maximum extendable length. This is a nested loop structure, resulting in O(n^2). (Note: The O(n log n) solution uses Greedy algorithm with Binary Search, not the pure 1-D DP state transition).",
      "wg": [
        {
          "t": "雙重迴圈",
          "en": "nested loop",
          "ps": "NP"
        },
        {
          "t": "貪婪演算法",
          "en": "Greedy algorithm",
          "ps": "NP"
        },
        {
          "t": "二分搜尋",
          "en": "Binary Search",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Decode Ways, Edge Cases, String Processing",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"10203\"",
    "question": [
      {
        "t": "在「解碼方法」(Decode Ways) 問題中，我們將 'A'-'Z' 映射為 1-26。",
        "en": "In the 'Decode Ways' problem, we map 'A'-'Z' to 1-26.",
        "wg": [
          {
            "t": "解碼",
            "en": "decode",
            "ps": "V"
          },
          {
            "t": "映射",
            "en": "map",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當處理字串中的字元 '0' 時，下列哪個敘述是正確的 DP 轉移邏輯？",
        "en": "When processing the character '0' in the string, which of the following statements is the correct DP transition logic?",
        "wg": [
          {
            "t": "轉移邏輯",
            "en": "transition logic",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) '0' 可以單獨解碼，所以 `dp[i] += dp[i-1]`。",
        "en": "(A) '0' can be decoded individually, so `dp[i] += dp[i-1]`.",
        "wg": [
          {
            "t": "單獨",
            "en": "individually",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) '0' 總是無效的，直接回傳 0。",
        "en": "(B) '0' is always invalid, return 0 immediately.",
        "wg": []
      },
      {
        "t": "(C) '0' 無法單獨解碼，必須與前一個數字結合成 '10' 或 '20'。若無法結合，則該路徑無效。",
        "en": "(C) '0' cannot be decoded individually; it must combine with the previous digit to form '10' or '20'. If it cannot combine, the path is invalid.",
        "wg": [
          {
            "t": "結合",
            "en": "combine",
            "ps": "V"
          },
          {
            "t": "路徑",
            "en": "path",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) '0' 代表略過前一個字元，所以 `dp[i] = dp[i-2]`。",
        "en": "(D) '0' represents skipping the previous character, so `dp[i] = dp[i-2]`.",
        "wg": [
          {
            "t": "略過",
            "en": "skip",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在映射規則中，沒有對應 '0' 的字母。因此 '0' 只能作為後綴出現於 '10' (J) 或 '20' (T)。若 '0' 前面不是 '1' 或 '2'，則無法構成合法編碼，該子問題的解碼方法數應為 0。",
      "en": "In the mapping rules, there is no letter corresponding to '0'. Therefore, '0' can only appear as a suffix in '10' (J) or '20' (T). If '0' is not preceded by '1' or '2', a valid encoding cannot be formed, and the number of decode ways for that subproblem should be 0.",
      "wg": [
        {
          "t": "後綴",
          "en": "suffix",
          "ps": "N"
        },
        {
          "t": "合法編碼",
          "en": "valid encoding",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Coin Change, Initialization, Minimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp = new int[amount + 1];",
    "question": [
      {
        "t": "在「零錢兌換」(Coin Change) 問題中，目標是找出組成特定金額所需的「最少」硬幣數量。",
        "en": "In the 'Coin Change' problem, the goal is to find the 'minimum' number of coins needed to make up a specific amount.",
        "wg": [
          {
            "t": "零錢兌換",
            "en": "Coin Change",
            "ps": "NP"
          },
          {
            "t": "硬幣",
            "en": "coin",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在開始填表之前，除了 `dp[0] = 0` 之外，`dp` 陣列的其他位置通常應該初始化為什麼值？",
        "en": "Before filling the table, besides `dp[0] = 0`, what value should the other positions in the `dp` array usually be initialized to?",
        "wg": [
          {
            "t": "填表",
            "en": "filling the table",
            "ps": "VP"
          },
          {
            "t": "初始化",
            "en": "initialize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) -1",
        "en": "(B) -1",
        "wg": []
      },
      {
        "t": "(C) 一個比可能的最大硬幣數還大的值 (例如 amount + 1 或 Infinity)。",
        "en": "(C) A value larger than the maximum possible number of coins (e.g., amount + 1 or Infinity).",
        "wg": [
          {
            "t": "無限大",
            "en": "Infinity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 1",
        "en": "(D) 1",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為狀態轉移方程式通常包含 `min(dp[i], dp[i - coin] + 1)`。如果初始化為 0，`min` 函數會錯誤地保留 0 作為最小值。初始化為一個夠大的數可以確保第一次找到合法組合時能正確更新最小值。",
      "en": "Because the state transition equation usually involves `min(dp[i], dp[i - coin] + 1)`. If initialized to 0, the `min` function would incorrectly keep 0 as the minimum. Initializing to a sufficiently large number ensures that the minimum is correctly updated when a valid combination is found for the first time.",
      "wg": [
        {
          "t": "狀態轉移方程式",
          "en": "state transition equation",
          "ps": "NP"
        },
        {
          "t": "合法組合",
          "en": "valid combination",
          "ps": "NP"
        }
      ]
    }
  }
]