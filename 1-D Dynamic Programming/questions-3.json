[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Dynamic Programming, Circular Array, House Robber",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [2, 3, 2]",
    "question": [
      {
        "t": "在「打家劫舍 II」(House Robber II) 問題中，房屋排列成一個圓圈。",
        "en": "In the 'House Robber II' problem, the houses are arranged in a circle.",
        "wg": [
          {
            "t": "排列",
            "en": "arranged",
            "ps": "V"
          },
          {
            "t": "圓圈",
            "en": "circle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這意味著第一間房屋與最後一間房屋是相鄰的。",
        "en": "This means the first house is adjacent to the last house.",
        "wg": [
          {
            "t": "相鄰的",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了重複使用線性動態規劃的解法，我們應該如何處理這個環狀限制？",
        "en": "To reuse the linear dynamic programming solution, how should we handle this circular constraint?",
        "wg": [
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          },
          {
            "t": "重複使用",
            "en": "reuse",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接在環狀陣列上應用轉移方程式，不需修改。",
        "en": "(A) Apply the transition equation directly on the circular array without modification.",
        "wg": []
      },
      {
        "t": "(B) 將問題拆分為兩個線性問題：範圍 0 到 n-2 和範圍 1 到 n-1，並取兩者的最大值。",
        "en": "(B) Break the problem into two linear problems: range 0 to n-2 and range 1 to n-1, and take the maximum of both.",
        "wg": [
          {
            "t": "拆分",
            "en": "break/split",
            "ps": "V"
          },
          {
            "t": "範圍",
            "en": "range",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 增加一個虛擬房屋，其價值為 0，並將其插入陣列末端。",
        "en": "(C) Add a dummy house with value 0 and insert it at the end of the array.",
        "wg": [
          {
            "t": "虛擬",
            "en": "dummy",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 總是跳過第一間房屋，只計算剩餘房屋的最大值。",
        "en": "(D) Always skip the first house and calculate the maximum of the remaining houses.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "由於第一間和最後一間房屋不能同時被搶，我們可以將環狀問題簡化為兩種線性情況：要麼不搶最後一間（考慮範圍 0 到 n-2），要麼不搶第一間（考慮範圍 1 到 n-1），最後取兩者的較大值。",
      "en": "Since the first and last houses cannot be robbed simultaneously, we can reduce the circular problem to two linear cases: either exclude the last house (consider range 0 to n-2) or exclude the first house (consider range 1 to n-1), and then take the maximum of the two.",
      "wg": [
        {
          "t": "同時",
          "en": "simultaneously",
          "ps": "Adv"
        },
        {
          "t": "簡化",
          "en": "reduce/simplify",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "String, Decoding, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"20\"",
    "question": [
      {
        "t": "考慮「解碼方法」(Decode Ways) 問題，其中 'A' 對應 1，'B' 對應 2，依此類推。",
        "en": "Consider the 'Decode Ways' problem, where 'A' maps to 1, 'B' maps to 2, and so on.",
        "wg": [
          {
            "t": "對應",
            "en": "maps to",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當處理包含 '0' 的字串時（例如 \"10\", \"20\", \"06\"），下列關於狀態轉移的敘述何者正確？",
        "en": "When handling strings containing '0' (e.g., \"10\", \"20\", \"06\"), which of the following statements about state transition is correct?",
        "wg": [
          {
            "t": "狀態轉移",
            "en": "state transition",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 數字 '0' 可以單獨解碼，因此 dp[i] 總是等於 dp[i-1] + dp[i-2]。",
        "en": "(A) The digit '0' can be decoded individually, so dp[i] always equals dp[i-1] + dp[i-2].",
        "wg": []
      },
      {
        "t": "(B) 如果當前數字是 '0'，則 dp[i] 必定為 0，除非它與前一個數字組成有效的 '10' 或 '20'。",
        "en": "(B) If the current digit is '0', dp[i] must be 0, unless it forms a valid '10' or '20' with the previous digit.",
        "wg": [
          {
            "t": "有效的",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) '0' 總是無效的，遇到 '0' 應直接回傳錯誤。",
        "en": "(C) '0' is always invalid; return error immediately upon encountering '0'.",
        "wg": []
      },
      {
        "t": "(D) '0' 僅能作為前綴使用，不影響動態規劃的計算。",
        "en": "(D) '0' can only be used as a prefix and does not affect the dynamic programming calculation.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在解碼問題中，'0' 沒有對應的字母，因此無法單獨解碼。它必須與前一個數字結合成 '10' 或 '20' 才是合法的。如果無法結合，則該路徑無效。",
      "en": "In the decoding problem, '0' has no corresponding letter and cannot be decoded alone. It must be combined with the previous digit to form '10' or '20' to be valid. If it cannot be combined, the path is invalid.",
      "wg": [
        {
          "t": "結合",
          "en": "combined",
          "ps": "V"
        },
        {
          "t": "合法的",
          "en": "valid/legal",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "LIS, Time Complexity, Binary Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "標準的「最長遞增子序列」(Longest Increasing Subsequence, LIS) 動態規劃解法之時間複雜度為 O(N^2)。",
        "en": "The standard Dynamic Programming solution for 'Longest Increasing Subsequence' (LIS) has a time complexity of O(N^2).",
        "wg": [
          {
            "t": "遞增",
            "en": "increasing",
            "ps": "Adj"
          },
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要將時間複雜度優化至 O(N log N)，我們需要結合什麼技術？",
        "en": "To optimize the time complexity to O(N log N), what technique do we need to combine?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "結合",
            "en": "combine",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 貪婪演算法與二分搜尋法 (Greedy + Binary Search)。",
        "en": "(A) Greedy Algorithm and Binary Search.",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 滑動視窗 (Sliding Window)。",
        "en": "(B) Sliding Window.",
        "wg": []
      },
      {
        "t": "(C) 深度優先搜尋 (DFS) 與記憶化 (Memoization)。",
        "en": "(C) Depth-First Search (DFS) with Memoization.",
        "wg": [
          {
            "t": "記憶化",
            "en": "Memoization",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 雙指標技術 (Two Pointers)。",
        "en": "(D) Two Pointers technique.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "優化解法維護一個 `tails` 陣列，其中 `tails[i]` 儲存長度為 `i+1` 的所有遞增子序列中，結尾數值最小的那個數。透過貪婪策略盡可能讓結尾數值變小，並利用二分搜尋法在 `tails` 陣列中找到替換或插入的位置。",
      "en": "The optimized solution maintains a `tails` array, where `tails[i]` stores the smallest tail of all increasing subsequences of length `i+1`. It uses a greedy strategy to keep tail values as small as possible and uses Binary Search to find the position to replace or append in the `tails` array.",
      "wg": [
        {
          "t": "維護",
          "en": "maintains",
          "ps": "V"
        },
        {
          "t": "替換",
          "en": "replace",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Word Break, Boolean DP, Dictionary",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"leetcode\", wordDict = [\"leet\", \"code\"]",
    "question": [
      {
        "t": "在「單字拆分」(Word Break) 問題中，我們需要判斷字串 `s` 是否可以被分割成一個或多個字典中存在的單字。",
        "en": "In the 'Word Break' problem, we need to determine if string `s` can be segmented into one or more words present in the dictionary.",
        "wg": [
          {
            "t": "分割",
            "en": "segmented",
            "ps": "V"
          },
          {
            "t": "字典",
            "en": "dictionary",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若定義 `dp[i]` 為狀態陣列，下列哪個定義最適合此問題？",
        "en": "If we define `dp[i]` as the state array, which of the following definitions is most suitable for this problem?",
        "wg": [
          {
            "t": "適合",
            "en": "suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i]` 是字串 `s[0...i-1]` 中包含的單字總數 (整數)。",
        "en": "(A) `dp[i]` is the total count of words contained in string `s[0...i-1]` (Integer).",
        "wg": []
      },
      {
        "t": "(B) `dp[i]` 是字串 `s[0...i-1]` 能否被成功分割 (布林值)。",
        "en": "(B) `dp[i]` is whether string `s[0...i-1]` can be successfully segmented (Boolean).",
        "wg": [
          {
            "t": "布林值",
            "en": "Boolean",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) `dp[i]` 是字串 `s` 中第 `i` 個字元是否出現在字典中。",
        "en": "(C) `dp[i]` is whether the `i`-th character of string `s` appears in the dictionary.",
        "wg": []
      },
      {
        "t": "(D) `dp[i]` 是以索引 `i` 結尾的最長單字長度。",
        "en": "(D) `dp[i]` is the length of the longest word ending at index `i`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個可行性問題 (Feasibility Problem)。我們只關心前 `i` 個字元組成的子字串是否能被合法拆分，因此使用布林值來記錄狀態最為直接且有效。",
      "en": "This is a feasibility problem. We only care whether the substring formed by the first `i` characters can be validly segmented, so using a Boolean value to record the state is the most direct and efficient approach.",
      "wg": [
        {
          "t": "可行性",
          "en": "feasibility",
          "ps": "N"
        },
        {
          "t": "拆分",
          "en": "segmented/break",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Coin Change, Initialization, Minimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp = [?] * (amount + 1)",
    "question": [
      {
        "t": "在「零錢兌換」(Coin Change) 問題中，目標是找出組成特定金額所需的「最少」硬幣數量。",
        "en": "In the 'Coin Change' problem, the goal is to find the 'minimum' number of coins needed to make up a specific amount.",
        "wg": [
          {
            "t": "零錢兌換",
            "en": "Coin Change",
            "ps": "N"
          },
          {
            "t": "組成",
            "en": "make up/compose",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在計算最小值 `min()` 之前，我們應該將 DP 陣列（除了 `dp[0]` 以外）初始化為什麼值？",
        "en": "Before calculating the minimum value `min()`, what value should we initialize the DP array (except for `dp[0]`) with?",
        "wg": [
          {
            "t": "初始化",
            "en": "initialize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) -1",
        "en": "(B) -1",
        "wg": []
      },
      {
        "t": "(C) 一個比目標金額大的數 (例如 amount + 1 或無限大)。",
        "en": "(C) A number larger than the target amount (e.g., amount + 1 or infinity).",
        "wg": [
          {
            "t": "無限大",
            "en": "infinity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 1",
        "en": "(D) 1",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為轉移方程式涉及取最小值 `min(dp[i], dp[i-coin] + 1)`，初始化值必須大於任何可能的解，以確保第一次更新時能正確寫入計算出的硬幣數量。若初始化為 0，則 `min` 函數會永遠保留 0。",
      "en": "Since the transition equation involves taking the minimum `min(dp[i], dp[i-coin] + 1)`, the initial value must be larger than any possible solution to ensure the calculated coin count is correctly written upon the first update. If initialized to 0, the `min` function would always retain 0.",
      "wg": [
        {
          "t": "轉移方程式",
          "en": "transition equation",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "retain",
          "ps": "V"
        }
      ]
    }
  }
]