[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Recursion, Overlapping Subproblems, Fibonacci, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def fib(n):\n    if n <= 1: return n\n    return fib(n-1) + fib(n-2)",
    "question": [
      {
        "t": "考慮以下計算費氏數列的樸素遞迴實作。",
        "en": "Consider the following naive recursive implementation for calculating the Fibonacci sequence.",
        "wg": [
          {
            "t": "樸素",
            "en": "naive",
            "ps": "Adj"
          },
          {
            "t": "遞迴",
            "en": "recursive",
            "ps": "Adj"
          },
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼這種方法在 `n` 很大時效率極低？",
        "en": "Why is this approach extremely inefficient for large values of `n`?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為它導致堆疊溢位錯誤。",
        "en": "(A) Because it causes a stack overflow error.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 因為它重複計算了相同的重疊子問題。",
        "en": "(B) Because it repeatedly calculates the same overlapping subproblems.",
        "wg": [
          {
            "t": "重疊子問題",
            "en": "overlapping subproblems",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 因為整數溢位導致計算錯誤。",
        "en": "(C) Because integer overflow leads to calculation errors.",
        "wg": []
      },
      {
        "t": "(D) 因為遞迴的基本情況定義錯誤。",
        "en": "(D) Because the base case of the recursion is defined incorrectly.",
        "wg": [
          {
            "t": "基本情況",
            "en": "base case",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "樸素遞迴解法具有指數級的時間複雜度 O(2^n)，因為它會多次重新計算相同的子問題（例如 `fib(n-2)` 會在計算 `fib(n)` 和 `fib(n-1)` 時被呼叫）。動態規劃透過儲存這些結果來解決此問題。",
      "en": "The naive recursive solution has exponential time complexity O(2^n) because it recomputes the same subproblems multiple times (e.g., `fib(n-2)` is called within both `fib(n)` and `fib(n-1)`). Dynamic programming solves this by storing these results.",
      "wg": [
        {
          "t": "指數級",
          "en": "exponential",
          "ps": "Adj"
        },
        {
          "t": "重新計算",
          "en": "recomputes",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Climbing Stairs, Transition Equation, 1-D DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您正在爬樓梯，需要 `n` 階才能到達頂端。",
        "en": "Suppose you are climbing a staircase that takes `n` steps to reach the top.",
        "wg": [
          {
            "t": "樓梯",
            "en": "staircase",
            "ps": "N"
          }
        ]
      },
      {
        "t": "每次您可以爬 1 階或 2 階。",
        "en": "Each time you can either climb 1 or 2 steps.",
        "wg": []
      },
      {
        "t": "若 `dp[i]` 代表到達第 `i` 階的不同方式總數，下列哪個轉移方程式是正確的？",
        "en": "If `dp[i]` represents the total number of distinct ways to reach the `i`-th step, which of the following transition equations is correct?",
        "wg": [
          {
            "t": "不同方式",
            "en": "distinct ways",
            "ps": "N"
          },
          {
            "t": "轉移方程式",
            "en": "transition equation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i] = dp[i-1] + dp[i-2]`",
        "en": "(A) `dp[i] = dp[i-1] + dp[i-2]`",
        "wg": []
      },
      {
        "t": "(B) `dp[i] = dp[i-1] * dp[i-2]`",
        "en": "(B) `dp[i] = dp[i-1] * dp[i-2]`",
        "wg": []
      },
      {
        "t": "(C) `dp[i] = dp[i-1] + 1`",
        "en": "(C) `dp[i] = dp[i-1] + 1`",
        "wg": []
      },
      {
        "t": "(D) `dp[i] = max(dp[i-1], dp[i-2]) + 1`",
        "en": "(D) `dp[i] = max(dp[i-1], dp[i-2]) + 1`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "要到達第 `i` 階，您只能從第 `i-1` 階（爬 1 步）或第 `i-2` 階（爬 2 步）過來。因此，到達第 `i` 階的方法數是到達這兩階的方法數之和。",
      "en": "To reach the `i`-th step, you could have only come from the `i-1`-th step (by climbing 1 step) or the `i-2`-th step (by climbing 2 steps). Therefore, the number of ways to reach step `i` is the sum of the ways to reach those two steps.",
      "wg": []
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Memoization, Tabulation, Top-down, Bottom-up",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在 1-D 動態規劃中，關於「記憶法」與「列表法」的敘述，下列何者正確？",
        "en": "In 1-D Dynamic Programming, which of the following statements regarding 'Memoization' and 'Tabulation' is correct?",
        "wg": [
          {
            "t": "記憶法",
            "en": "Memoization",
            "ps": "N"
          },
          {
            "t": "列表法",
            "en": "Tabulation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 記憶法通常是「由下而上」的方法，而列表法是「由上而下」的。",
        "en": "(A) Memoization is typically a 'bottom-up' approach, while Tabulation is 'top-down'.",
        "wg": [
          {
            "t": "由下而上",
            "en": "bottom-up",
            "ps": "Adj"
          },
          {
            "t": "由上而下",
            "en": "top-down",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 列表法使用遞迴來解決子問題。",
        "en": "(B) Tabulation uses recursion to solve subproblems.",
        "wg": []
      },
      {
        "t": "(C) 記憶法涉及快取遞迴呼叫的結果以避免重複計算。",
        "en": "(C) Memoization involves caching the results of recursive calls to avoid redundant computations.",
        "wg": [
          {
            "t": "快取",
            "en": "caching",
            "ps": "V"
          },
          {
            "t": "重複計算",
            "en": "redundant computations",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 列表法總是比記憶法使用更多的記憶體空間。",
        "en": "(D) Tabulation always uses more memory space than Memoization.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "記憶法（Top-down）透過遞迴並儲存結果來優化；列表法（Bottom-up）則透過迭代填充表格來解決問題。選項 (A) 顛倒了定義，選項 (D) 不一定正確，因為列表法常可進行空間優化。",
      "en": "Memoization (Top-down) optimizes by recursing and storing results; Tabulation (Bottom-up) solves problems by iteratively filling a table. Option (A) reverses the definitions, and option (D) is not necessarily true as tabulation often allows for space optimization.",
      "wg": [
        {
          "t": "迭代",
          "en": "iteratively",
          "ps": "Adv"
        },
        {
          "t": "空間優化",
          "en": "space optimization",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "House Robber, Recurrence Relation, Constraints",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「打家劫舍」問題中，您不能搶劫相鄰的房屋。",
        "en": "In the 'House Robber' problem, you cannot rob adjacent houses.",
        "wg": [
          {
            "t": "打家劫舍",
            "en": "House Robber",
            "ps": "N"
          },
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "給定一個陣列 `nums` 代表每間房子的金額，`dp[i]` 代表搶到第 `i` 間房子時的最大獲利。",
        "en": "Given an array `nums` representing the money in each house, let `dp[i]` be the maximum profit up to the `i`-th house.",
        "wg": [
          {
            "t": "最大獲利",
            "en": "maximum profit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪個遞迴關係式正確描述了這個限制？",
        "en": "Which of the following recurrence relations correctly describes this constraint?",
        "wg": [
          {
            "t": "遞迴關係式",
            "en": "recurrence relation",
            "ps": "N"
          },
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`",
        "en": "(A) `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`",
        "wg": []
      },
      {
        "t": "(B) `dp[i] = dp[i-1] + nums[i]`",
        "en": "(B) `dp[i] = dp[i-1] + nums[i]`",
        "wg": []
      },
      {
        "t": "(C) `dp[i] = max(dp[i-1] + nums[i], dp[i-2])`",
        "en": "(C) `dp[i] = max(dp[i-1] + nums[i], dp[i-2])`",
        "wg": []
      },
      {
        "t": "(D) `dp[i] = dp[i-2] + nums[i]`",
        "en": "(D) `dp[i] = dp[i-2] + nums[i]`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "對於第 `i` 間房子，您有兩個選擇：(1) 不搶這間，則最大值為 `dp[i-1]`；(2) 搶這間，則不能搶第 `i-1` 間，最大值為 `dp[i-2] + nums[i]`。我們取兩者中的較大值。",
      "en": "For the `i`-th house, you have two choices: (1) Do not rob it, so the max is `dp[i-1]`; (2) Rob it, which means you cannot rob the `i-1`-th house, so the max is `dp[i-2] + nums[i]`. We take the maximum of these two.",
      "wg": []
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Space Complexity, Optimization, Rolling Variables",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當解決像費氏數列或爬樓梯這類只依賴前兩項狀態 `dp[i-1]` 和 `dp[i-2]` 的 1-D DP 問題時。",
        "en": "When solving 1-D DP problems like Fibonacci or Climbing Stairs that only depend on the previous two states `dp[i-1]` and `dp[i-2]`.",
        "wg": [
          {
            "t": "依賴",
            "en": "depend on",
            "ps": "V"
          }
        ]
      },
      {
        "t": "我們可以將空間複雜度優化到什麼程度？",
        "en": "To what extent can we optimize the space complexity?",
        "wg": [
          {
            "t": "空間複雜度",
            "en": "space complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(n)，因為我們需要陣列來儲存所有狀態。",
        "en": "(A) O(n), because we need an array to store all states.",
        "wg": []
      },
      {
        "t": "(B) O(1)，透過使用滾動變數只追蹤最後兩個狀態。",
        "en": "(B) O(1), by using rolling variables to track only the last two states.",
        "wg": [
          {
            "t": "滾動變數",
            "en": "rolling variables",
            "ps": "N"
          },
          {
            "t": "追蹤",
            "en": "track",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) O(log n)，使用二分搜尋法。",
        "en": "(C) O(log n), using binary search.",
        "wg": []
      },
      {
        "t": "(D) O(n^2)，因為遞迴深度。",
        "en": "(D) O(n^2), because of recursion depth.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為計算當前狀態只需要前兩個狀態的值，我們不需要保留整個 `dp` 陣列。只需兩個變數不斷更新即可，這將空間複雜度從 O(n) 降低到 O(1)。",
      "en": "Since calculating the current state only requires the values of the previous two states, we do not need to keep the entire `dp` array. Only two variables updating continuously are needed, reducing space complexity from O(n) to O(1).",
      "wg": [
        {
          "t": "保留",
          "en": "keep/retain",
          "ps": "V"
        }
      ]
    }
  }
]