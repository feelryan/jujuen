[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Fibonacci, Climbing Stairs, Recurrence Relation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設你正在爬樓梯，需要 n 階才能到達頂端。",
        "en": "Suppose you are climbing a staircase, and it takes n steps to reach the top.",
        "wg": [
          {
            "t": "階",
            "en": "steps",
            "ps": "N"
          }
        ]
      },
      {
        "t": "每次你可以爬 1 階或 2 階。",
        "en": "Each time you can either climb 1 or 2 steps.",
        "wg": []
      },
      {
        "t": "若定義 f(n) 為到達第 n 階的方法數，下列哪個遞迴關係式是正確的？",
        "en": "If f(n) is defined as the number of distinct ways to reach the nth step, which of the following recurrence relations is correct?",
        "wg": [
          {
            "t": "遞迴關係式",
            "en": "recurrence relation",
            "ps": "N"
          },
          {
            "t": "方法數",
            "en": "number of distinct ways",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) f(n) = f(n-1) + f(n-2)",
        "en": "(A) f(n) = f(n-1) + f(n-2)",
        "wg": []
      },
      {
        "t": "(B) f(n) = f(n-1) * f(n-2)",
        "en": "(B) f(n) = f(n-1) * f(n-2)",
        "wg": []
      },
      {
        "t": "(C) f(n) = max(f(n-1), f(n-2)) + 1",
        "en": "(C) f(n) = max(f(n-1), f(n-2)) + 1",
        "wg": []
      },
      {
        "t": "(D) f(n) = f(n-1) + 2",
        "en": "(D) f(n) = f(n-1) + 2",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "到達第 n 階只有兩種可能：從第 n-1 階爬 1 步，或從第 n-2 階爬 2 步。因此，到達第 n 階的方法總數是這兩個來源的方法數之和。",
      "en": "There are only two ways to reach the nth step: taking 1 step from (n-1) or taking 2 steps from (n-2). Therefore, the total ways to reach n is the sum of the ways to reach these two previous steps.",
      "wg": [
        {
          "t": "來源",
          "en": "source",
          "ps": "N"
        },
        {
          "t": "總數",
          "en": "total count",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Memoization, Tabulation, Overlapping Subproblems",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決 1-D 動態規劃問題時，使用「記憶化」(Memoization) 的主要目的是什麼？",
        "en": "When solving 1-D Dynamic Programming problems, what is the primary purpose of using 'Memoization'?",
        "wg": [
          {
            "t": "記憶化",
            "en": "Memoization",
            "ps": "N"
          },
          {
            "t": "主要目的",
            "en": "primary purpose",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將遞迴解法轉換為迭代解法以節省堆疊空間。",
        "en": "(A) To convert a recursive solution into an iterative one to save stack space.",
        "wg": [
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          },
          {
            "t": "堆疊空間",
            "en": "stack space",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 避免重複計算相同的子問題，從而降低時間複雜度。",
        "en": "(B) To avoid re-calculating the same subproblems, thereby reducing time complexity.",
        "wg": [
          {
            "t": "重複計算",
            "en": "re-calculating",
            "ps": "V"
          },
          {
            "t": "子問題",
            "en": "subproblems",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 確保找到全域最佳解而非區域最佳解。",
        "en": "(C) To ensure finding the global optimum instead of a local optimum.",
        "wg": [
          {
            "t": "全域最佳解",
            "en": "global optimum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 減少用於儲存 DP 表格的記憶體空間。",
        "en": "(D) To reduce the memory space used for storing the DP table.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "記憶化透過快取先前計算過的結果來優化遞迴，解決了重疊子問題導致的指數級時間複雜度問題。(A) 描述的是 Tabulation，(D) 記憶化通常會增加空間使用來換取時間。",
      "en": "Memoization optimizes recursion by caching previously computed results, solving the exponential time complexity caused by overlapping subproblems. (A) describes Tabulation, and (D) Memoization usually increases space usage in exchange for time.",
      "wg": [
        {
          "t": "快取",
          "en": "cache",
          "ps": "V"
        },
        {
          "t": "指數級",
          "en": "exponential",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "House Robber, Constraints, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [2, 7, 9, 3, 1]",
    "question": [
      {
        "t": "考慮經典的「打家劫舍」(House Robber) 問題，您是一個專業的小偷，計畫偷竊沿街的房屋。",
        "en": "Consider the classic 'House Robber' problem where you are a professional robber planning to rob houses along a street.",
        "wg": [
          {
            "t": "打家劫舍",
            "en": "House Robber",
            "ps": "N"
          },
          {
            "t": "偷竊",
            "en": "rob",
            "ps": "V"
          }
        ]
      },
      {
        "t": "每間房內都藏有一定數量的現金，唯一的限制是相鄰的房屋裝有連線防盜系統。",
        "en": "Each house has a certain amount of money stashed, the only constraint stopping you is that adjacent houses have security systems connected.",
        "wg": [
          {
            "t": "相鄰的",
            "en": "adjacent",
            "ps": "Adj"
          },
          {
            "t": "防盜系統",
            "en": "security systems",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若 `dp[i]` 代表偷到第 i 間房子時能獲得的最大金額，下列哪個狀態轉移方程式是正確的？",
        "en": "If `dp[i]` represents the maximum amount of money you can rob up to house i, which state transition equation is correct?",
        "wg": [
          {
            "t": "狀態轉移方程式",
            "en": "state transition equation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
        "en": "(A) dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
        "wg": []
      },
      {
        "t": "(B) dp[i] = dp[i-1] + nums[i]",
        "en": "(B) dp[i] = dp[i-1] + nums[i]",
        "wg": []
      },
      {
        "t": "(C) dp[i] = max(dp[i-1] + nums[i], dp[i-2])",
        "en": "(C) dp[i] = max(dp[i-1] + nums[i], dp[i-2])",
        "wg": []
      },
      {
        "t": "(D) dp[i] = max(dp[i-1], nums[i])",
        "en": "(D) dp[i] = max(dp[i-1], nums[i])",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "對於第 i 間房子，你有兩個選擇：(1) 不偷第 i 間，則最大金額為 `dp[i-1]`；(2) 偷第 i 間，則不能偷第 i-1 間，最大金額為 `dp[i-2] + nums[i]`。必須取兩者之最大值。",
      "en": "For the i-th house, you have two choices: (1) Do not rob house i, so the max amount is `dp[i-1]`; (2) Rob house i, which means you cannot rob house i-1, so the max amount is `dp[i-2] + nums[i]`. You must take the maximum of these two.",
      "wg": [
        {
          "t": "選擇",
          "en": "choice",
          "ps": "N"
        },
        {
          "t": "最大值",
          "en": "maximum",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Maximum Subarray, Kadane's Algorithm, State Definition",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「最大子陣列和」(Maximum Subarray Sum) 問題時，我們通常使用 Kadane 演算法。",
        "en": "When solving the 'Maximum Subarray Sum' problem, we typically use Kadane's Algorithm.",
        "wg": [
          {
            "t": "最大子陣列和",
            "en": "Maximum Subarray Sum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若定義 `dp[i]` 為「必須包含索引 i 的元素」之最大子陣列和，則 `dp[i]` 的計算方式為何？",
        "en": "If we define `dp[i]` as the maximum subarray sum that 'must include the element at index i', how is `dp[i]` calculated?",
        "wg": [
          {
            "t": "必須包含",
            "en": "must include",
            "ps": "V"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) dp[i] = max(nums[i], dp[i-1] + nums[i])",
        "en": "(A) dp[i] = max(nums[i], dp[i-1] + nums[i])",
        "wg": []
      },
      {
        "t": "(B) dp[i] = max(dp[i-1], nums[i])",
        "en": "(B) dp[i] = max(dp[i-1], nums[i])",
        "wg": []
      },
      {
        "t": "(C) dp[i] = dp[i-1] + nums[i]",
        "en": "(C) dp[i] = dp[i-1] + nums[i]",
        "wg": []
      },
      {
        "t": "(D) dp[i] = max(0, dp[i-1] + nums[i])",
        "en": "(D) dp[i] = max(0, dp[i-1] + nums[i])",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "Kadane 演算法的核心在於：對於當前元素 `nums[i]`，我們要決定是「延續前一個子陣列 (`dp[i-1] + nums[i]`)」還是「重新開始一個新的子陣列 (`nums[i]`)」。(D) 是錯誤的，因為最大子陣列和可能為負數（如果所有元素皆為負）。",
      "en": "The core of Kadane's Algorithm is deciding for the current element `nums[i]` whether to 'extend the previous subarray (`dp[i-1] + nums[i]`)' or 'start a new subarray (`nums[i]`)'. (D) is incorrect because the maximum subarray sum can be negative (if all elements are negative).",
      "wg": [
        {
          "t": "延續",
          "en": "extend",
          "ps": "V"
        },
        {
          "t": "重新開始",
          "en": "start new",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Coin Change, Minimization, Unbounded Knapsack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「零錢兌換」(Coin Change) 問題中，你需要用最少數量的硬幣湊成總金額 `amount`。",
        "en": "In the 'Coin Change' problem, you need to make up a total `amount` using the fewest number of coins.",
        "wg": [
          {
            "t": "零錢兌換",
            "en": "Coin Change",
            "ps": "N"
          },
          {
            "t": "湊成",
            "en": "make up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設 `dp[i]` 代表湊成金額 `i` 所需的最少硬幣數，且硬幣面額陣列為 `coins`。",
        "en": "Assume `dp[i]` represents the minimum number of coins needed to make amount `i`, and the array of coin denominations is `coins`.",
        "wg": [
          {
            "t": "面額",
            "en": "denomination",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在初始化 DP 陣列時，`dp[0]` 應設為 0，而其他位置 `dp[1...amount]` 通常應初始化為什麽值？",
        "en": "When initializing the DP array, `dp[0]` should be set to 0. What value should other positions `dp[1...amount]` typically be initialized to?",
        "wg": [
          {
            "t": "初始化",
            "en": "initialize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) -1",
        "en": "(B) -1",
        "wg": []
      },
      {
        "t": "(C) 一個比 amount 大的數值 (如 infinity 或 amount + 1)",
        "en": "(C) A value larger than amount (e.g., infinity or amount + 1)",
        "wg": [
          {
            "t": "數值",
            "en": "value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 最小的硬幣面額",
        "en": "(D) The smallest coin denomination",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為我們在狀態轉移時使用 `min()` 函數來尋找最小值，若初始化為 0 或 -1 會導致錯誤的結果（0 會被誤判為最小）。初始化為一個「不可能的大數」可以確保第一次更新時能正確寫入計算出的硬幣數。",
      "en": "Since we use the `min()` function during state transition to find the minimum, initializing to 0 or -1 would lead to incorrect results (0 would be mistaken as the minimum). Initializing to an 'impossibly large number' ensures that the calculated coin count is correctly written during the first update.",
      "wg": [
        {
          "t": "誤判",
          "en": "mistaken",
          "ps": "V"
        },
        {
          "t": "不可能的大數",
          "en": "impossibly large number",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Dynamic Programming, Recurrence Relation, House Robber",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, 2, 3, 1]\ndp = [0] * len(nums)",
    "question": [
      {
        "t": "假設您正在設計一個資源分配演算法，目標是從一系列任務中獲取最大收益。",
        "en": "Suppose you are designing a resource allocation algorithm aimed at maximizing profit from a series of tasks.",
        "wg": [
          {
            "t": "資源分配",
            "en": "resource allocation",
            "ps": "N"
          },
          {
            "t": "最大收益",
            "en": "maximum profit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "限制是您不能選擇列表中相鄰的兩個任務，否則會導致系統衝突。",
        "en": "The constraint is that you cannot select two adjacent tasks from the list, otherwise it will cause a system conflict.",
        "wg": [
          {
            "t": "相鄰的",
            "en": "adjacent",
            "ps": "Adj"
          },
          {
            "t": "衝突",
            "en": "conflict",
            "ps": "N"
          }
        ]
      },
      {
        "t": "令 `dp[i]` 表示考慮到第 `i` 個任務時能獲得的最大收益，下列哪個遞迴關係式是正確的？",
        "en": "Let `dp[i]` denote the maximum profit obtainable when considering up to the `i`-th task. Which of the following recurrence relations is correct?",
        "wg": [
          {
            "t": "遞迴關係式",
            "en": "recurrence relation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`",
        "en": "(A) `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`",
        "wg": []
      },
      {
        "t": "(B) `dp[i] = max(dp[i-1] + nums[i], dp[i-2])`",
        "en": "(B) `dp[i] = max(dp[i-1] + nums[i], dp[i-2])`",
        "wg": []
      },
      {
        "t": "(C) `dp[i] = dp[i-1] + nums[i]`",
        "en": "(C) `dp[i] = dp[i-1] + nums[i]`",
        "wg": []
      },
      {
        "t": "(D) `dp[i] = max(dp[i-1], nums[i])`",
        "en": "(D) `dp[i] = max(dp[i-1], nums[i])`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是經典的「打家劫舍」(House Robber) 問題。對於第 `i` 個任務，我們有兩個選擇：不選它（收益為 `dp[i-1]`）或選它（收益為 `dp[i-2] + nums[i]`，因為選了 `i` 就不能選 `i-1`）。我們取兩者中的最大值。",
      "en": "This is the classic 'House Robber' problem. For the `i`-th task, we have two choices: do not select it (profit is `dp[i-1]`) or select it (profit is `dp[i-2] + nums[i]`, since selecting `i` prevents selecting `i-1`). We take the maximum of the two.",
      "wg": [
        {
          "t": "打家劫舍",
          "en": "House Robber",
          "ps": "Proper Noun"
        },
        {
          "t": "收益",
          "en": "profit/yield",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Kadane's Algorithm, Maximum Subarray, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for i in range(1, len(nums)):\n    dp[i] = max(nums[i], dp[i-1] + nums[i])",
    "question": [
      {
        "t": "在分析股票市場數據時，您需要找出一段連續期間內的最大利潤總和（最大子陣列和）。",
        "en": "When analyzing stock market data, you need to find the maximum total profit within a contiguous period (Maximum Subarray Sum).",
        "wg": [
          {
            "t": "連續期間",
            "en": "contiguous period",
            "ps": "N"
          },
          {
            "t": "子陣列",
            "en": "subarray",
            "ps": "N"
          }
        ]
      },
      {
        "t": "觀察上方的程式碼片段（Kadane 演算法的核心），`dp[i]` 代表什麼意義？",
        "en": "Observing the code snippet above (the core of Kadane's Algorithm), what does `dp[i]` represent?",
        "wg": [
          {
            "t": "核心",
            "en": "core",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從索引 0 到索引 i 的所有元素總和。",
        "en": "(A) The sum of all elements from index 0 to index i.",
        "wg": []
      },
      {
        "t": "(B) 整個陣列中，截至索引 i 為止所發現的最大子陣列和。",
        "en": "(B) The maximum subarray sum found so far in the entire array up to index i.",
        "wg": [
          {
            "t": "截至...為止",
            "en": "up to...",
            "ps": "Prep"
          }
        ]
      },
      {
        "t": "(C) 必須包含索引 i (以 i 結尾) 的最大連續子陣列和。",
        "en": "(C) The maximum contiguous subarray sum that must include index i (ending at i).",
        "wg": [
          {
            "t": "包含",
            "en": "include",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 從索引 i 開始到陣列末尾的最大子陣列和。",
        "en": "(D) The maximum subarray sum starting from index i to the end of the array.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 Kadane 演算法中，狀態 `dp[i]` 定義為「以索引 `i` 結尾的最大子陣列和」。這讓我們可以決定是將 `nums[i]` 加入前一個子陣列（`dp[i-1] + nums[i]`），還是從 `nums[i]` 重新開始一個新的子陣列（若 `dp[i-1]` 為負數）。",
      "en": "In Kadane's Algorithm, the state `dp[i]` is defined as 'the maximum subarray sum ending at index `i`'. This allows us to decide whether to append `nums[i]` to the previous subarray (`dp[i-1] + nums[i]`) or start a new subarray at `nums[i]` (if `dp[i-1]` is negative).",
      "wg": [
        {
          "t": "定義為",
          "en": "defined as",
          "ps": "V"
        },
        {
          "t": "重新開始",
          "en": "restart",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "easy",
    "keywords": "Min Cost Climbing Stairs, Memoization, Cost Minimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮一個樓梯，每一步驟都有特定的體力消耗成本 `cost[i]`。",
        "en": "Consider a staircase where each step has a specific physical cost `cost[i]`.",
        "wg": [
          {
            "t": "體力消耗",
            "en": "physical cost/exertion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您可以選擇一次爬一階或兩階。您需要計算到達樓頂的最小總成本。",
        "en": "You can choose to climb either one or two steps at a time. You need to calculate the minimum total cost to reach the top.",
        "wg": []
      },
      {
        "t": "若 `dp[i]` 代表到達第 `i` 階的最小成本，下列轉移方程式何者正確？",
        "en": "If `dp[i]` represents the minimum cost to reach the `i`-th step, which of the following transition equations is correct?",
        "wg": [
          {
            "t": "轉移方程式",
            "en": "transition equation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`",
        "en": "(A) `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`",
        "wg": []
      },
      {
        "t": "(B) `dp[i] = cost[i] + max(dp[i-1], dp[i-2])`",
        "en": "(B) `dp[i] = cost[i] + max(dp[i-1], dp[i-2])`",
        "wg": []
      },
      {
        "t": "(C) `dp[i] = min(dp[i-1], dp[i-2])`",
        "en": "(C) `dp[i] = min(dp[i-1], dp[i-2])`",
        "wg": []
      },
      {
        "t": "(D) `dp[i] = dp[i-1] + dp[i-2]`",
        "en": "(D) `dp[i] = dp[i-1] + dp[i-2]`",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "要到達第 `i` 階，我們必須從第 `i-1` 階或第 `i-2` 階上來。為了最小化成本，我們選擇兩者中較小的一個，並加上當前階梯 `i` 的成本 `cost[i]`（假設題目定義支付成本後才能站上該階或離開該階）。",
      "en": "To reach the `i`-th step, we must come from either the `i-1`-th or `i-2`-th step. To minimize the cost, we choose the smaller of the two and add the cost of the current step `cost[i]` (assuming the problem defines paying the cost to stand on or leave that step).",
      "wg": [
        {
          "t": "最小化",
          "en": "minimize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Coin Change, Initialization, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp = [amount + 1] * (amount + 1)\ndp[0] = 0",
    "question": [
      {
        "t": "在解決「零錢兌換」(Coin Change) 問題時，目標是用最少數量的硬幣湊成總金額 `amount`。",
        "en": "When solving the 'Coin Change' problem, the goal is to make up the total `amount` using the fewest number of coins.",
        "wg": [
          {
            "t": "零錢兌換",
            "en": "Coin Change",
            "ps": "Proper Noun"
          },
          {
            "t": "湊成",
            "en": "make up/compose",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在動態規劃陣列初始化時，我們通常將 `dp` 陣列（除了 `dp[0]`）填入 `amount + 1` 或無限大。",
        "en": "When initializing the dynamic programming array, we usually fill the `dp` array (except for `dp[0]`) with `amount + 1` or infinity.",
        "wg": [
          {
            "t": "初始化",
            "en": "initialization",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這樣做的主要原因是什麼？",
        "en": "What is the main reason for doing this?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 為了避免陣列索引越界。",
        "en": "(A) To avoid array index out of bounds.",
        "wg": [
          {
            "t": "索引越界",
            "en": "index out of bounds",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 為了確保在執行 `min()` 函數比較時，任何有效的硬幣組合都能替換掉初始值。",
        "en": "(B) To ensure that during the `min()` comparison, any valid coin combination can replace the initial value.",
        "wg": [
          {
            "t": "替換",
            "en": "replace/overwrite",
            "ps": "V"
          },
          {
            "t": "有效",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 因為 `amount + 1` 代表硬幣的面額總和。",
        "en": "(C) Because `amount + 1` represents the sum of coin denominations.",
        "wg": []
      },
      {
        "t": "(D) 為了計算所有可能的硬幣排列組合數。",
        "en": "(D) To calculate the number of all possible coin permutations.",
        "wg": [
          {
            "t": "排列組合",
            "en": "permutations and combinations",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為我們要求的是「最小」硬幣數，轉移方程通常包含 `min(dp[current], ...)`。若初始化為 0，則 `min` 函數永遠會取 0，導致錯誤。初始化為一個比任何可能解都大的數（如 `amount + 1`，因為硬幣最小面額通常為 1），能確保第一次找到有效解時能成功更新狀態。",
      "en": "Since we are looking for the 'minimum' number of coins, the transition equation usually involves `min(dp[current], ...)`. If initialized to 0, the `min` function would always pick 0, leading to errors. Initializing with a value larger than any possible solution (like `amount + 1`, since the smallest coin is usually 1) ensures the state is successfully updated when a valid solution is first found.",
      "wg": [
        {
          "t": "面額",
          "en": "denomination",
          "ps": "N"
        },
        {
          "t": "轉移方程",
          "en": "transition equation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Decode Ways, String Processing, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在處理一個解碼問題，規則是 'A'->1, 'B'->2 ... 'Z'->26。",
        "en": "You are working on a decoding problem where the rule is 'A'->1, 'B'->2 ... 'Z'->26.",
        "wg": [
          {
            "t": "解碼",
            "en": "decoding",
            "ps": "V/N"
          }
        ]
      },
      {
        "t": "給定一個只包含數字的字串，計算有多少種解碼方式。例如 \"12\" 可以是 \"AB\" (1, 2) 或 \"L\" (12)。",
        "en": "Given a string containing only digits, calculate the number of ways to decode it. For example, \"12\" can be \"AB\" (1, 2) or \"L\" (12).",
        "wg": []
      },
      {
        "t": "在實作 1-D DP 時，遇到字元 '0' (例如字串 \"10\" 或 \"06\") 需要特別處理。下列敘述何者正確？",
        "en": "When implementing 1-D DP, encountering the character '0' (e.g., string \"10\" or \"06\") requires special handling. Which of the following statements is correct?",
        "wg": [
          {
            "t": "特別處理",
            "en": "special handling",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) '0' 可以單獨解碼，對應到空字元，所以 `dp[i] = dp[i-1]`。",
        "en": "(A) '0' can be decoded independently, corresponding to an empty character, so `dp[i] = dp[i-1]`.",
        "wg": []
      },
      {
        "t": "(B) 若當前數字為 '0'，它無法單獨解碼；若它無法與前一個數字組成有效編碼 (如 10 或 20)，則整個字串無法解碼 (return 0)。",
        "en": "(B) If the current digit is '0', it cannot be decoded alone; if it cannot form a valid code with the previous digit (like 10 or 20), then the entire string cannot be decoded (return 0).",
        "wg": [
          {
            "t": "單獨",
            "en": "alone/independently",
            "ps": "Adv"
          },
          {
            "t": "有效編碼",
            "en": "valid code",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) '0' 總是代表 10 或 20，所以我們直接將 `dp[i]` 設為 `dp[i-2]`，不需檢查前一個數字。",
        "en": "(C) '0' always represents 10 or 20, so we directly set `dp[i]` to `dp[i-2]` without checking the previous digit.",
        "wg": []
      },
      {
        "t": "(D) 遇到 '0' 時，解碼方法數會加倍。",
        "en": "(D) When encountering '0', the number of decoding ways doubles.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在映射規則中，沒有數字對應到 '0'。因此 '0' 必須與前一個數字結合成 '10' 或 '20' 才能解碼。若前一個數字不是 1 或 2，或者 '0' 出現在字串開頭，則該字串為無效編碼。",
      "en": "In the mapping rules, no number corresponds to '0'. Therefore, '0' must be combined with the previous digit to form '10' or '20' to be decoded. If the previous digit is not 1 or 2, or if '0' appears at the beginning of the string, the string is invalid.",
      "wg": [
        {
          "t": "映射",
          "en": "mapping",
          "ps": "N"
        },
        {
          "t": "無效",
          "en": "invalid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Dynamic Programming, House Robber, Circular Array, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [2, 3, 2]",
    "question": [
      {
        "t": "在「打家劫舍 II」(House Robber II) 問題中，房屋是圍成一圈排列的。",
        "en": "In the 'House Robber II' problem, the houses are arranged in a circle.",
        "wg": [
          {
            "t": "圍成一圈",
            "en": "arranged in a circle",
            "ps": "Phrase"
          },
          {
            "t": "排列",
            "en": "arranged",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這意味著第一間房屋和最後一間房屋是相鄰的。",
        "en": "This means the first house and the last house are adjacent.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若要重複使用線性 DP 的解法來解決這個環狀問題，下列哪種策略是正確的？",
        "en": "To reuse the linear DP solution for this circular problem, which of the following strategies is correct?",
        "wg": [
          {
            "t": "重複使用",
            "en": "reuse",
            "ps": "V"
          },
          {
            "t": "環狀",
            "en": "circular",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接將陣列複製一份接在尾端，然後對長度為 2n 的陣列執行線性 DP。",
        "en": "(A) Directly append a copy of the array to the end, then perform linear DP on the array of length 2n.",
        "wg": [
          {
            "t": "複製",
            "en": "copy",
            "ps": "V"
          },
          {
            "t": "接在尾端",
            "en": "append",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 計算兩次線性 DP：一次範圍是 0 到 n-2，另一次是 1 到 n-1，並取兩者之最大值。",
        "en": "(B) Compute linear DP twice: once for the range 0 to n-2, and once for 1 to n-1, then take the maximum of the two.",
        "wg": [
          {
            "t": "範圍",
            "en": "range",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 忽略環狀限制，直接對整個陣列執行一次線性 DP 即可。",
        "en": "(C) Ignore the circular constraint and simply perform linear DP once on the entire array.",
        "wg": [
          {
            "t": "忽略",
            "en": "ignore",
            "ps": "V"
          },
          {
            "t": "限制",
            "en": "constraint",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 找出陣列中數值最小的房屋，將其移除後變成線性陣列。",
        "en": "(D) Find the house with the minimum value in the array, remove it to make it a linear array.",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為首尾相連，偷了第一間就不能偷最後一間，反之亦然。因此可以將問題拆解為兩種情況：不包含最後一間（範圍 0 到 n-2）與不包含第一間（範圍 1 到 n-1），兩者分別進行線性 DP 後取最大值即為全域最佳解。",
      "en": "Since the first and last houses are connected, robbing the first prevents robbing the last, and vice versa. Thus, the problem can be decomposed into two cases: excluding the last house (range 0 to n-2) and excluding the first house (range 1 to n-1). Performing linear DP on both and taking the maximum yields the global optimal solution.",
      "wg": [
        {
          "t": "首尾相連",
          "en": "connected end-to-end",
          "ps": "Adj"
        },
        {
          "t": "拆解",
          "en": "decompose",
          "ps": "V"
        },
        {
          "t": "全域最佳解",
          "en": "global optimal solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Decode Ways, Edge Cases, String DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "s = \"10203\"",
    "question": [
      {
        "t": "在「解碼方法」(Decode Ways) 問題中，我們將 'A'-'Z' 映射為 1-26。",
        "en": "In the 'Decode Ways' problem, we map 'A'-'Z' to 1-26.",
        "wg": [
          {
            "t": "映射",
            "en": "map",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在定義狀態轉移時，處理數字 '0' 是一個關鍵難點。",
        "en": "Handling the digit '0' is a key difficulty when defining state transitions.",
        "wg": [
          {
            "t": "狀態轉移",
            "en": "state transitions",
            "ps": "N"
          },
          {
            "t": "難點",
            "en": "difficulty",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果當前字元 `s[i]` 為 '0'，下列關於 `dp[i]` (截至索引 i 的解碼方法數) 的敘述何者正確？",
        "en": "If the current character `s[i]` is '0', which of the following statements about `dp[i]` (number of decode ways up to index i) is correct?",
        "wg": [
          {
            "t": "截至",
            "en": "up to",
            "ps": "Prep"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) '0' 可以單獨解碼，因此 `dp[i] = dp[i-1]`。",
        "en": "(A) '0' can be decoded individually, so `dp[i] = dp[i-1]`.",
        "wg": [
          {
            "t": "單獨",
            "en": "individually",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) '0' 必須被忽略，直接繼承前一個狀態，即 `dp[i] = dp[i-1]`。",
        "en": "(B) '0' must be ignored, directly inheriting the previous state, i.e., `dp[i] = dp[i-1]`.",
        "wg": [
          {
            "t": "繼承",
            "en": "inherit",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) '0' 無法單獨解碼，必須與前一個數字組成 10 或 20；若無法組成有效數字則解碼失敗 (return 0)。",
        "en": "(C) '0' cannot be decoded individually and must form 10 or 20 with the preceding digit; if a valid number cannot be formed, decoding fails (return 0).",
        "wg": [
          {
            "t": "組成",
            "en": "form",
            "ps": "V"
          },
          {
            "t": "有效數字",
            "en": "valid number",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) '0' 代表字串結束，應直接回傳目前的計數。",
        "en": "(D) '0' represents the end of the string, should return the current count immediately.",
        "wg": [
          {
            "t": "字串結束",
            "en": "end of string",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在映射規則中，沒有對應到 '0' 的字母。'0' 必須依附在前一個數字 '1' 或 '2' 之後形成 '10' (J) 或 '20' (T)。如果前一個數字不是 1 或 2 (例如 '30')，或者 '0' 出現在字串開頭，則該字串無法被合法解碼。",
      "en": "In the mapping rules, no letter corresponds to '0'. '0' must be attached to the preceding digit '1' or '2' to form '10' (J) or '20' (T). If the preceding digit is not 1 or 2 (e.g., '30'), or if '0' appears at the start of the string, the string cannot be validly decoded.",
      "wg": [
        {
          "t": "依附",
          "en": "attached to",
          "ps": "V"
        },
        {
          "t": "合法",
          "en": "validly",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "LIS, Time Complexity, Subsequence",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for i in range(n):\n  for j in range(i):\n    if nums[i] > nums[j]:\n      dp[i] = max(dp[i], dp[j] + 1)",
    "question": [
      {
        "t": "考慮「最長遞增子序列」(Longest Increasing Subsequence, LIS) 的標準 1-D DP 解法。",
        "en": "Consider the standard 1-D DP solution for the 'Longest Increasing Subsequence' (LIS).",
        "wg": [
          {
            "t": "遞增",
            "en": "increasing",
            "ps": "Adj"
          },
          {
            "t": "子序列",
            "en": "subsequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們定義 `dp[i]` 為以索引 `i` 結尾的最長遞增子序列長度。",
        "en": "We define `dp[i]` as the length of the longest increasing subsequence ending at index `i`.",
        "wg": [
          {
            "t": "結尾",
            "en": "ending at",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問此特定解法的時間複雜度為何？",
        "en": "What is the time complexity of this specific solution?",
        "wg": [
          {
            "t": "特定",
            "en": "specific",
            "ps": "Adj"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(n)",
        "en": "(A) O(n)",
        "wg": []
      },
      {
        "t": "(B) O(n log n)",
        "en": "(B) O(n log n)",
        "wg": []
      },
      {
        "t": "(C) O(n^2)",
        "en": "(C) O(n^2)",
        "wg": []
      },
      {
        "t": "(D) O(2^n)",
        "en": "(D) O(2^n)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "標準的 DP 解法包含兩層巢狀迴圈：外層遍歷每個元素 `i`，內層遍歷所有在 `i` 之前的元素 `j` 來尋找可接續的子序列。因此總運算次數約為 n*(n-1)/2，複雜度為 O(n^2)。(註：存在使用貪婪加二分搜尋的 O(n log n) 解法，但題目問的是此 DP 定義下的複雜度)。",
      "en": "The standard DP solution involves two nested loops: the outer loop iterates through each element `i`, and the inner loop iterates through all elements `j` before `i` to find extendable subsequences. Thus, the total operations are approximately n*(n-1)/2, resulting in O(n^2) complexity. (Note: An O(n log n) solution exists using greedy plus binary search, but the question asks about this specific DP definition).",
      "wg": [
        {
          "t": "巢狀迴圈",
          "en": "nested loops",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        },
        {
          "t": "接續",
          "en": "extend",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Word Break, Boolean DP, String Segmentation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「單詞拆分」(Word Break) 問題中，我們需要判斷字串 `s` 是否可以被空白拆分為一個或多個字典中出現的單詞。",
        "en": "In the 'Word Break' problem, we need to determine if string `s` can be segmented by spaces into one or more dictionary words.",
        "wg": [
          {
            "t": "拆分",
            "en": "segment",
            "ps": "V"
          },
          {
            "t": "字典",
            "en": "dictionary",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若定義 `dp[i]` 為布林值，表示字串的前 `i` 個字元 (`s[0...i-1]`) 是否能被成功拆分。",
        "en": "If we define `dp[i]` as a boolean indicating whether the first `i` characters of the string (`s[0...i-1]`) can be successfully segmented.",
        "wg": [
          {
            "t": "布林值",
            "en": "boolean",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一個是計算 `dp[i]` 的正確轉移邏輯？",
        "en": "Which of the following is the correct transition logic to compute `dp[i]`?",
        "wg": [
          {
            "t": "轉移邏輯",
            "en": "transition logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `dp[i]` 為真，若存在一個 `j < i`，使得 `dp[j]` 為真 且 `s[j...i-1]` 存在於字典中。",
        "en": "(A) `dp[i]` is true if there exists a `j < i` such that `dp[j]` is true AND `s[j...i-1]` exists in the dictionary.",
        "wg": [
          {
            "t": "存在",
            "en": "exists",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) `dp[i]` 為真，若 `s[0...i-1]` 直接存在於字典中，不需要檢查之前的狀態。",
        "en": "(B) `dp[i]` is true if `s[0...i-1]` directly exists in the dictionary, without checking previous states.",
        "wg": []
      },
      {
        "t": "(C) `dp[i]` 為真，若 `dp[i-1]` 為真 且 `s[i]` 是一個單獨的單詞。",
        "en": "(C) `dp[i]` is true if `dp[i-1]` is true AND `s[i]` is a standalone word.",
        "wg": [
          {
            "t": "單獨的",
            "en": "standalone",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) `dp[i]` 為真，只要字典中任何一個單詞是 `s` 的子字串即可。",
        "en": "(D) `dp[i]` is true as long as any word in the dictionary is a substring of `s`.",
        "wg": [
          {
            "t": "子字串",
            "en": "substring",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這是一個典型的劃分型 DP。要確認前 `i` 個字元可被拆分，我們需要找到一個分割點 `j`，確保前半段 `0` 到 `j` 是可拆分的 (即 `dp[j]` 為 true)，且後半段 `j` 到 `i` (即子字串 `s[j...i-1]`) 是一個合法的字典單詞。",
      "en": "This is a typical partition DP. To confirm that the first `i` characters can be segmented, we need to find a split point `j` such that the first part `0` to `j` is segmentable (i.e., `dp[j]` is true), and the second part `j` to `i` (i.e., substring `s[j...i-1]`) is a valid dictionary word.",
      "wg": [
        {
          "t": "劃分型",
          "en": "partition type",
          "ps": "Adj"
        },
        {
          "t": "分割點",
          "en": "split point",
          "ps": "N"
        },
        {
          "t": "前半段",
          "en": "first part",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Coin Change, Initialization, Min Value",
    "parentNo": null,
    "images": null,
    "codeSnippet": "amount = 11, coins = [1, 2, 5]",
    "question": [
      {
        "t": "在「零錢兌換」(Coin Change) 問題中，目標是找出組成總金額 `amount` 所需的「最少」硬幣數量。",
        "en": "In the 'Coin Change' problem, the goal is to find the 'minimum' number of coins needed to make up the total `amount`.",
        "wg": [
          {
            "t": "零錢兌換",
            "en": "Coin Change",
            "ps": "N"
          },
          {
            "t": "組成",
            "en": "make up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "我們建立一個長度為 `amount + 1` 的 DP 陣列。",
        "en": "We create a DP array of length `amount + 1`.",
        "wg": []
      },
      {
        "t": "為了確保狀態轉移方程 `dp[i] = min(dp[i], dp[i - coin] + 1)` 能正確運作，初始化 DP 陣列的最佳方式為何？",
        "en": "To ensure the transition equation `dp[i] = min(dp[i], dp[i - coin] + 1)` works correctly, what is the best way to initialize the DP array?",
        "wg": [
          {
            "t": "狀態轉移方程",
            "en": "transition equation",
            "ps": "N"
          },
          {
            "t": "初始化",
            "en": "initialize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 全部初始化為 0。",
        "en": "(A) Initialize all to 0.",
        "wg": []
      },
      {
        "t": "(B) 全部初始化為 -1。",
        "en": "(B) Initialize all to -1.",
        "wg": []
      },
      {
        "t": "(C) `dp[0] = 0`，其餘初始化為一個大於 `amount` 的數值 (如 infinity)。",
        "en": "(C) `dp[0] = 0`, and initialize the rest to a value greater than `amount` (e.g., infinity).",
        "wg": [
          {
            "t": "其餘",
            "en": "the rest",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) `dp[0] = 1`，其餘初始化為 0。",
        "en": "(D) `dp[0] = 1`, and initialize the rest to 0.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為我們在尋找「最小值」(min)，如果初始化為 0，`min(0, ...)` 永遠會得到 0，導致錯誤。必須將非 0 金額的初始值設為無限大(或大於可能的最大硬幣數)，才能在比較時被計算出的較小值覆蓋。而 `dp[0]=0` 是 Base Case，代表金額 0 需要 0 個硬幣。",
      "en": "Since we are looking for the 'minimum', if initialized to 0, `min(0, ...)` will always result in 0, leading to errors. Non-zero amounts must be initialized to infinity (or a value larger than the maximum possible coins) so they can be overwritten by a smaller calculated value during comparison. `dp[0]=0` is the Base Case, representing that amount 0 requires 0 coins.",
      "wg": [
        {
          "t": "覆蓋",
          "en": "overwritten",
          "ps": "V"
        },
        {
          "t": "基本情況",
          "en": "Base Case",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "Longest Increasing Subsequence, LIS, Time Complexity, O(N^2)",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i] = max(dp[i], dp[j] + 1) for all 0 <= j < i",
    "question": [
      {
        "t": "關於「最長遞增子序列」(LIS) 問題的標準動態規劃解法，下列敘述何者正確？",
        "en": "Regarding the standard Dynamic Programming solution for the 'Longest Increasing Subsequence' (LIS) problem, which of the following statements is true?",
        "wg": [
          {
            "t": "最長遞增子序列",
            "en": "Longest Increasing Subsequence",
            "ps": "NP"
          },
          {
            "t": "標準",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "假設輸入陣列長度為 N。",
        "en": "Assume the input array length is N.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 狀態轉移方程式僅依賴於 dp[i-1]，因此時間複雜度為 O(N)。",
        "en": "(A) The state transition depends only on dp[i-1], so the time complexity is O(N).",
        "wg": [
          {
            "t": "依賴於",
            "en": "depends on",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 計算 dp[i] 時，必須檢查所有小於 i 的索引 j，導致整體時間複雜度為 O(N^2)。",
        "en": "(B) When calculating dp[i], one must check all indices j less than i, resulting in an overall time complexity of O(N^2).",
        "wg": [
          {
            "t": "索引",
            "en": "indices",
            "ps": "N"
          },
          {
            "t": "導致",
            "en": "resulting in",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 此 DP 解法可以透過貪婪演算法優化至 O(1) 空間複雜度。",
        "en": "(C) This DP solution can be optimized to O(1) space complexity using a greedy algorithm.",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "greedy algorithm",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) dp[i] 代表的是以索引 0 為結尾的最長遞增子序列長度。",
        "en": "(D) dp[i] represents the length of the longest increasing subsequence ending at index 0.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "標準 DP 解法定義 dp[i] 為「以索引 i 結尾的 LIS 長度」。為了找到這個值，必須遍歷所有之前的元素 j (0 到 i-1)，若 nums[i] > nums[j]，則嘗試更新 dp[i]。這是一個巢狀迴圈結構，故複雜度為 O(N^2)。",
      "en": "The standard DP solution defines dp[i] as the 'length of the LIS ending at index i'. To find this value, one must iterate through all previous elements j (0 to i-1). If nums[i] > nums[j], we attempt to update dp[i]. This is a nested loop structure, so the complexity is O(N^2).",
      "wg": [
        {
          "t": "巢狀迴圈",
          "en": "nested loop",
          "ps": "NP"
        },
        {
          "t": "遍歷",
          "en": "iterate through",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Maximum Product Subarray, State Tracking, Negative Numbers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "maxDP[i] = max(nums[i], nums[i]*maxDP[i-1], nums[i]*minDP[i-1])",
    "question": [
      {
        "t": "在解決「最大乘積子陣列」(Maximum Product Subarray) 問題時，為什麼通常需要同時維護 `maxDP` 和 `minDP` 兩個狀態陣列？",
        "en": "When solving the 'Maximum Product Subarray' problem, why is it usually necessary to maintain two state arrays, `maxDP` and `minDP`?",
        "wg": [
          {
            "t": "最大乘積子陣列",
            "en": "Maximum Product Subarray",
            "ps": "NP"
          },
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為陣列中可能包含 0，需要分開處理。",
        "en": "(A) Because the array may contain 0, which needs to be handled separately.",
        "wg": []
      },
      {
        "t": "(B) 因為負數乘以負數會變正數，當前的最小值乘以負數可能變成新的最大值。",
        "en": "(B) Because a negative number multiplied by a negative number becomes positive, the current minimum multiplied by a negative number might become the new maximum.",
        "wg": [
          {
            "t": "變正數",
            "en": "becomes positive",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(C) 為了避免整數溢位 (Integer Overflow)，將數值分散儲存。",
        "en": "(C) To avoid Integer Overflow, values are stored separately.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "NP"
          },
          {
            "t": "分散儲存",
            "en": "stored separately",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(D) 這是一種空間優化技巧，實際上只需要其中一個。",
        "en": "(D) This is a space optimization technique; actually, only one is needed.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "乘積問題的特性在於負負得正。若當前數字是負數，它乘以之前的「最小累積乘積」（如果是負很大）會變成一個「最大累積乘積」。因此必須同時追蹤當前的最大值與最小值。",
      "en": "The characteristic of product problems is that a negative times a negative is positive. If the current number is negative, multiplying it by the previous 'minimum cumulative product' (if it's a large negative) results in a 'maximum cumulative product'. Therefore, both the current maximum and minimum must be tracked.",
      "wg": [
        {
          "t": "負負得正",
          "en": "negative times a negative is positive",
          "ps": "Phrase"
        },
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Word Break, Boolean DP, String Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (dp[j] && dict.contains(s.substring(j, i))) dp[i] = true;",
    "question": [
      {
        "t": "在「單字拆分」(Word Break) 問題中，`dp[i]` 為布林值，表示字串的前 `i` 個字元是否可以被字典中的單字拆解。",
        "en": "In the 'Word Break' problem, `dp[i]` is a boolean indicating whether the first `i` characters of the string can be segmented into dictionary words.",
        "wg": [
          {
            "t": "單字拆分",
            "en": "Word Break",
            "ps": "NP"
          },
          {
            "t": "拆解",
            "en": "segmented",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一個邏輯正確描述了狀態轉移的過程？",
        "en": "Which of the following logic correctly describes the state transition process?",
        "wg": [
          {
            "t": "狀態轉移",
            "en": "state transition",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只要目前的子字串 `s[0...i]` 在字典中，`dp[i]` 就為 true。",
        "en": "(A) As long as the current substring `s[0...i]` is in the dictionary, `dp[i]` is true.",
        "wg": []
      },
      {
        "t": "(B) 我們需要找到一個分割點 `j` (0 <= j < i)，使得 `dp[j]` 為 true 且子字串 `s[j...i]` 存在於字典中。",
        "en": "(B) We need to find a split point `j` (0 <= j < i) such that `dp[j]` is true AND the substring `s[j...i]` exists in the dictionary.",
        "wg": [
          {
            "t": "分割點",
            "en": "split point",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) `dp[i]` 的值等於 `dp[i-1]`，除非遇到字典中的單字。",
        "en": "(C) The value of `dp[i]` equals `dp[i-1]` unless a dictionary word is encountered.",
        "wg": []
      },
      {
        "t": "(D) 必須使用遞迴 (Recursion) 才能解決，無法使用迭代 DP。",
        "en": "(D) Recursion must be used to solve this; iterative DP cannot be used.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Word Break 的核心在於檢查是否存在一個切分點 `j`，使得前半段 `0~j` 是合法的（由 `dp[j]` 決定），且後半段 `j~i` 是一個字典中的單字。兩者皆成立，`dp[i]` 才為 true。",
      "en": "The core of Word Break is checking if there exists a split point `j` such that the first part `0~j` is valid (determined by `dp[j]`) and the second part `j~i` is a word in the dictionary. `dp[i]` is true only if both conditions are met.",
      "wg": [
        {
          "t": "切分點",
          "en": "split point",
          "ps": "N"
        },
        {
          "t": "合法的",
          "en": "valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Decode Ways, Edge Cases, String DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (twoDigit >= 10 && twoDigit <= 26) dp[i] += dp[i-2];",
    "question": [
      {
        "t": "在「解碼方法」(Decode Ways) 問題中，將 'A'-'Z' 映射為 1-26。",
        "en": "In the 'Decode Ways' problem, mapping 'A'-'Z' to 1-26.",
        "wg": [
          {
            "t": "解碼方法",
            "en": "Decode Ways",
            "ps": "NP"
          },
          {
            "t": "映射",
            "en": "mapping",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若輸入字串包含字元 '0' (例如 \"10\", \"06\")，下列處理方式何者正確？",
        "en": "If the input string contains the character '0' (e.g., \"10\", \"06\"), which of the following handling methods is correct?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) '0' 可以單獨解碼，不影響狀態轉移。",
        "en": "(A) '0' can be decoded individually and does not affect state transition.",
        "wg": [
          {
            "t": "單獨",
            "en": "individually",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 若當前數字為 '0'，則 `dp[i]` 必定為 0，因為 '0' 無法單獨解碼。",
        "en": "(B) If the current digit is '0', then `dp[i]` must be 0 because '0' cannot be decoded individually.",
        "wg": []
      },
      {
        "t": "(C) '0' 只能作為兩位數的結尾 (如 \"10\", \"20\") 參與解碼；若出現 \"06\" 或 \"30\" 則該路徑無效。",
        "en": "(C) '0' can only participate in decoding as the end of a two-digit number (e.g., \"10\", \"20\"); if \"06\" or \"30\" appears, that path is invalid.",
        "wg": [
          {
            "t": "路徑無效",
            "en": "path is invalid",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(D) 遇到 '0' 時應直接跳過，繼承 `dp[i-1]` 的值。",
        "en": "(D) When encountering '0', skip it directly and inherit the value of `dp[i-1]`.",
        "wg": [
          {
            "t": "繼承",
            "en": "inherit",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在映射規則中，沒有對應 '0' 的字母。因此 '0' 不能單獨計算 (dp[i] 不加 dp[i-1])。它必須與前一個數字結合成 10 或 20 才能有效 (dp[i] 加 dp[i-2])。若組合成 06, 30 等則無效。",
      "en": "In the mapping rules, there is no letter corresponding to '0'. Therefore, '0' cannot be counted individually (do not add dp[i-1] to dp[i]). It must combine with the previous digit to form 10 or 20 to be valid (add dp[i-2] to dp[i]). Combinations like 06 or 30 are invalid.",
      "wg": [
        {
          "t": "對應",
          "en": "corresponding",
          "ps": "Adj"
        },
        {
          "t": "結合",
          "en": "combine",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Space Optimization, Rolling Array, 1-D DP",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int curr = prev1 + prev2; prev2 = prev1; prev1 = curr;",
    "question": [
      {
        "t": "對於許多依賴 `dp[i-1]` 和 `dp[i-2]` 的 1-D DP 問題 (如爬樓梯、費氏數列)，我們可以進行「空間優化」。",
        "en": "For many 1-D DP problems that depend on `dp[i-1]` and `dp[i-2]` (like Climbing Stairs, Fibonacci), we can perform 'space optimization'.",
        "wg": [
          {
            "t": "空間優化",
            "en": "space optimization",
            "ps": "NP"
          },
          {
            "t": "依賴",
            "en": "depend on",
            "ps": "V"
          }
        ]
      },
      {
        "t": "優化後的空間複雜度為何？且其原理是什麼？",
        "en": "What is the space complexity after optimization, and what is the principle behind it?",
        "wg": [
          {
            "t": "原理",
            "en": "principle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)；因為我們只需要保存前兩個狀態即可計算當前狀態，不需要保留整個陣列。",
        "en": "(A) O(1); because we only need to save the previous two states to calculate the current state, without keeping the entire array.",
        "wg": [
          {
            "t": "保留",
            "en": "keeping",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) O(N)；雖然變數變少了，但記憶體配置依然與 N 成正比。",
        "en": "(B) O(N); although there are fewer variables, memory allocation is still proportional to N.",
        "wg": [
          {
            "t": "成正比",
            "en": "proportional to",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) O(log N)；這是透過矩陣快速冪 (Matrix Exponentiation) 達成的。",
        "en": "(C) O(log N); this is achieved through Matrix Exponentiation.",
        "wg": [
          {
            "t": "矩陣快速冪",
            "en": "Matrix Exponentiation",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) O(1)；這是因為我們使用了雜湊表 (Hash Map) 來取代陣列。",
        "en": "(D) O(1); this is because we used a Hash Map to replace the array.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這被稱為「滾動陣列」或「狀態壓縮」技巧。當計算 `dp[i]` 只需用到 `dp[i-1]` 和 `dp[i-2]` 時，我們僅需兩個變數來暫存這兩個值，計算完後更新變數即可，無須配置長度為 N 的陣列。",
      "en": "This is called the 'Rolling Array' or 'State Compression' technique. When calculating `dp[i]` only requires `dp[i-1]` and `dp[i-2]`, we only need two variables to temporarily store these values. After calculation, we update the variables, eliminating the need to allocate an array of length N.",
      "wg": [
        {
          "t": "滾動陣列",
          "en": "Rolling Array",
          "ps": "NP"
        },
        {
          "t": "暫存",
          "en": "temporarily store",
          "ps": "V"
        }
      ]
    }
  }
]