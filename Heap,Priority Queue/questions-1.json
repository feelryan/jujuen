[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Heap, Array Representation, Binary Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個以 0 為起始索引的陣列中實作二元堆積 (Binary Heap)，",
        "en": "In a 0-indexed array implementation of a Binary Heap,",
        "wg": [
          {
            "t": "起始索引",
            "en": "start index",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若某個節點的索引為 i，則其左子節點 (Left Child) 的索引為何？",
        "en": "if a node has an index i, what is the index of its Left Child?",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2i",
        "en": "(A) 2i",
        "wg": []
      },
      {
        "t": "(B) 2i + 1",
        "en": "(B) 2i + 1",
        "wg": []
      },
      {
        "t": "(C) 2i + 2",
        "en": "(C) 2i + 2",
        "wg": []
      },
      {
        "t": "(D) i / 2",
        "en": "(D) i / 2",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 0-indexed 的陣列表示法中，索引 i 的左子節點位於 2i + 1，右子節點位於 2i + 2，而父節點位於 (i - 1) / 2。",
      "en": "In a 0-indexed array representation, the left child of index i is at 2i + 1, the right child is at 2i + 2, and the parent is at (i - 1) / 2.",
      "wg": [
        {
          "t": "表示法",
          "en": "representation",
          "ps": "N"
        },
        {
          "t": "位於",
          "en": "located at",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Time Complexity, Insertion, Priority Queue",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個包含 N 個元素的二元堆積 (Binary Heap) 中插入一個新元素，",
        "en": "Inserting a new element into a Binary Heap containing N elements,",
        "wg": [
          {
            "t": "插入",
            "en": "insert",
            "ps": "V"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "其最差情況的時間複雜度是多少？",
        "en": "what is the worst-case time complexity?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "插入新元素時，我們先將其放在陣列末端，然後執行「向上過濾」(Percolate Up) 以維持堆積屬性；由於堆積的高度為 log N，因此最差情況需交換 log N 次。",
      "en": "When inserting a new element, we place it at the end of the array and then perform 'Percolate Up' to maintain the heap property; since the height of the heap is log N, the worst case requires log N swaps.",
      "wg": [
        {
          "t": "向上過濾",
          "en": "percolate up",
          "ps": "V"
        },
        {
          "t": "維持",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "屬性",
          "en": "property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Max-Heap, Validation, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "下列哪一個陣列代表一個合法的最大堆積 (Max-Heap)？",
        "en": "Which of the following arrays represents a valid Max-Heap?",
        "wg": [
          {
            "t": "合法的",
            "en": "valid",
            "ps": "Adj"
          },
          {
            "t": "最大堆積",
            "en": "Max-Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請假設陣列索引從 0 開始。",
        "en": "Assume the array index starts from 0.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [10, 5, 8, 2, 7]",
        "en": "(A) [10, 5, 8, 2, 7]",
        "wg": []
      },
      {
        "t": "(B) [10, 8, 5, 2, 9]",
        "en": "(B) [10, 8, 5, 2, 9]",
        "wg": []
      },
      {
        "t": "(C) [10, 9, 8, 7, 6]",
        "en": "(C) [10, 9, 8, 7, 6]",
        "wg": []
      },
      {
        "t": "(D) [5, 10, 8, 2, 7]",
        "en": "(D) [5, 10, 8, 2, 7]",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (C) 中，10 的子節點是 9 和 8 (10>=9, 10>=8)，9 的子節點是 7 和 6 (9>=7, 9>=6)，皆符合父節點大於等於子節點的規則；選項 (A) 中 5 的子節點有 7 (5<7) 違反規則；選項 (B) 中 8 的子節點有 9 (8<9) 違反規則。",
      "en": "In option (C), the children of 10 are 9 and 8 (10>=9, 10>=8), and the children of 9 are 7 and 6 (9>=7, 9>=6), all satisfying the rule that parent >= child; in option (A), 5 has a child 7 (5<7) which violates the rule; in option (B), 8 has a child 9 (8<9) which violates the rule.",
      "wg": [
        {
          "t": "符合",
          "en": "satisfy",
          "ps": "V"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Deletion, Extract-Max, Heapify",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當從最大堆積 (Max-Heap) 中移除根節點 (Extract-Max) 時，",
        "en": "When removing the root node (Extract-Max) from a Max-Heap,",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "根節點",
            "en": "root node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了保持完全二元樹 (Complete Binary Tree) 的結構，標準的步驟為何？",
        "en": "what is the standard procedure to maintain the Complete Binary Tree structure?",
        "wg": [
          {
            "t": "完全二元樹",
            "en": "Complete Binary Tree",
            "ps": "N"
          },
          {
            "t": "結構",
            "en": "structure",
            "ps": "N"
          },
          {
            "t": "步驟",
            "en": "procedure",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接刪除根節點，並將所有元素向前移動一位。",
        "en": "(A) Delete the root node directly and shift all elements forward by one position.",
        "wg": [
          {
            "t": "向前移動",
            "en": "shift forward",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將根節點與最後一個元素交換，移除最後一個元素，再對新的根節點執行向下過濾 (Sift Down)。",
        "en": "(B) Swap the root with the last element, remove the last element, and then perform Sift Down on the new root.",
        "wg": [
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          },
          {
            "t": "向下過濾",
            "en": "sift down",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 將根節點與左子節點交換，直到到達底部。",
        "en": "(C) Swap the root with the left child until it reaches the bottom.",
        "wg": []
      },
      {
        "t": "(D) 將根節點與最後一個元素交換，然後對新的根節點執行向上過濾 (Sift Up)。",
        "en": "(D) Swap the root with the last element, and then perform Sift Up on the new root.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了不破壞完全二元樹的結構，必須使用最後一個葉節點來填補根節點的位置，然後透過向下過濾 (Sift Down/Heapify) 來恢復堆積的順序性。",
      "en": "To preserve the Complete Binary Tree structure, the last leaf node must be used to fill the root's position, followed by Sift Down (Heapify) to restore the heap order property.",
      "wg": [
        {
          "t": "破壞",
          "en": "break",
          "ps": "V"
        },
        {
          "t": "填補",
          "en": "fill",
          "ps": "V"
        },
        {
          "t": "恢復",
          "en": "restore",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Top K, Min-Heap, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要在一個非常大的資料串流中，即時找出「第 K 大」的元素，",
        "en": "To find the 'K-th largest' element in a very large data stream in real-time,",
        "wg": [
          {
            "t": "資料串流",
            "en": "data stream",
            "ps": "N"
          },
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "最適合的資料結構與策略為何？",
        "en": "what is the most suitable data structure and strategy?",
        "wg": [
          {
            "t": "適合的",
            "en": "suitable",
            "ps": "Adj"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 K 的最大堆積 (Max-Heap)。",
        "en": "(A) Maintain a Max-Heap of size K.",
        "wg": [
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": []
      },
      {
        "t": "(C) 將所有資料存入陣列並進行快速排序 (Quicksort)。",
        "en": "(C) Store all data in an array and perform Quicksort.",
        "wg": []
      },
      {
        "t": "(D) 使用二元搜尋樹 (BST) 儲存所有元素。",
        "en": "(D) Use a Binary Search Tree (BST) to store all elements.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積，可以保留當前看到最大的 K 個元素；堆積的根節點 (Root) 即為這 K 個元素中最小的一個，也就是整體的「第 K 大」元素。",
      "en": "Using a Min-Heap of size K keeps the K largest elements seen so far; the root of the heap is the smallest among these K elements, which corresponds to the 'K-th largest' element overall.",
      "wg": [
        {
          "t": "保留",
          "en": "keep/retain",
          "ps": "V"
        },
        {
          "t": "整體的",
          "en": "overall",
          "ps": "Adj"
        }
      ]
    }
  }
]