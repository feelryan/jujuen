[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Binary Heap, Array Representation, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二元堆積 (Binary Heap) 通常使用陣列來實作。",
        "en": "A Binary Heap is typically implemented using an array.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "陣列",
            "en": "array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設陣列索引從 0 開始，對於位於索引 `i` 的節點，其左子節點 (Left Child) 的索引位置為何？",
        "en": "Assuming the array index starts at 0, what is the index of the left child for the node at index `i`?",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          },
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "左子節點",
            "en": "left child",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2i",
        "en": "(A) 2i",
        "wg": []
      },
      {
        "t": "(B) 2i + 1",
        "en": "(B) 2i + 1",
        "wg": []
      },
      {
        "t": "(C) 2i + 2",
        "en": "(C) 2i + 2",
        "wg": []
      },
      {
        "t": "(D) i / 2",
        "en": "(D) i / 2",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在從 0 開始索引的陣列實作中，節點 `i` 的左子節點位於 `2i + 1`，右子節點位於 `2i + 2`，而父節點位於 `(i - 1) / 2`。",
      "en": "In a 0-indexed array implementation, the left child of node `i` is at `2i + 1`, the right child is at `2i + 2`, and the parent is at `(i - 1) / 2`.",
      "wg": [
        {
          "t": "父節點",
          "en": "parent node",
          "ps": "N"
        },
        {
          "t": "右子節點",
          "en": "right child",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Time Complexity, Insertion, Sift Up",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個包含 N 個元素的二元堆積 (Binary Heap) 中插入一個新元素，其最差情況的時間複雜度是多少？",
        "en": "What is the worst-case time complexity of inserting a new element into a Binary Heap containing N elements?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case",
            "ps": "Adj"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "插入",
            "en": "insert",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "插入操作會將新元素放在陣列末端，然後執行「上濾」(Sift Up) 操作以維持堆積屬性。由於二元堆積是完全二元樹，其高度為 log N，因此最差情況下需要交換 log N 次。",
      "en": "Insertion places the new element at the end of the array and then performs a 'Sift Up' operation to maintain the heap property. Since a binary heap is a complete binary tree, its height is log N, requiring at most log N swaps in the worst case.",
      "wg": [
        {
          "t": "上濾",
          "en": "sift up",
          "ps": "V"
        },
        {
          "t": "堆積屬性",
          "en": "heap property",
          "ps": "N"
        },
        {
          "t": "完全二元樹",
          "en": "complete binary tree",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Top K, Min-Heap, Data Stream",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在處理一個即時數據流，需要隨時找出目前為止「前 K 大」的元素。",
        "en": "You are processing a real-time data stream and need to find the 'Top K largest' elements seen so far at any time.",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          },
          {
            "t": "數據流",
            "en": "data stream",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了最佳化空間與時間效率，您應該選擇哪種資料結構策略？",
        "en": "To optimize space and time efficiency, which data structure strategy should you choose?",
        "wg": [
          {
            "t": "最佳化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "效率",
            "en": "efficiency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 K 的最大堆積 (Max-Heap)。",
        "en": "(A) Maintain a Max-Heap of size K.",
        "wg": [
          {
            "t": "最大堆積",
            "en": "Max-Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 每次數據進來時，對所有數據進行快速排序 (Quick Sort)。",
        "en": "(C) Perform Quick Sort on all data whenever new data arrives.",
        "wg": []
      },
      {
        "t": "(D) 使用二元搜尋樹 (BST) 儲存所有元素。",
        "en": "(D) Use a Binary Search Tree (BST) to store all elements.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積可以保留目前最大的 K 個數。堆積頂端 (Root) 是這 K 個數中最小的，當新元素大於堆積頂端時，移除頂端並插入新元素，這樣可以確保堆積內始終是前 K 大的元素。",
      "en": "Using a Min-Heap of size K allows you to keep the K largest numbers. The root of the heap is the smallest among these K numbers; when a new element is larger than the root, you remove the root and insert the new element, ensuring the heap always contains the top K largest elements.",
      "wg": [
        {
          "t": "堆積頂端",
          "en": "heap root",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "retain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Build Heap, Complexity, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個未排序的陣列，若使用最佳演算法將其轉換為二元堆積 (Build Heap)，其時間複雜度為何？",
        "en": "Given an unsorted array, what is the time complexity of converting it into a Binary Heap using the optimal algorithm (Build Heap)?",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          },
          {
            "t": "最佳演算法",
            "en": "optimal algorithm",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N)",
        "en": "(A) O(N)",
        "wg": []
      },
      {
        "t": "(B) O(N log N)",
        "en": "(B) O(N log N)",
        "wg": []
      },
      {
        "t": "(C) O(log N)",
        "en": "(C) O(log N)",
        "wg": []
      },
      {
        "t": "(D) O(N^2)",
        "en": "(D) O(N^2)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "雖然逐一插入元素建立堆積是 O(N log N)，但使用「由下而上」(Bottom-up) 的 Heapify 方法可以在 O(N) 的線性時間內完成建堆。",
      "en": "While building a heap by inserting elements one by one takes O(N log N), using the 'Bottom-up' Heapify approach allows building the heap in linear time, O(N).",
      "wg": [
        {
          "t": "由下而上",
          "en": "bottom-up",
          "ps": "Adj"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "easy",
    "keywords": "Extract Min, Deletion, Heapify Down",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在最小堆積 (Min-Heap) 中執行「移除最小值」(Extract Min) 操作時，正確的步驟順序為何？",
        "en": "What is the correct sequence of steps when performing an 'Extract Min' operation in a Min-Heap?",
        "wg": [
          {
            "t": "移除最小值",
            "en": "extract min",
            "ps": "V"
          },
          {
            "t": "順序",
            "en": "sequence",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接刪除根節點，將陣列中所有元素向前移動一格。",
        "en": "(A) Directly delete the root node and shift all elements in the array forward by one position.",
        "wg": [
          {
            "t": "向前移動",
            "en": "shift forward",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行下濾 (Sift Down)。",
        "en": "(B) Swap the root node with the last node, remove the last node, and then perform Sift Down on the new root.",
        "wg": [
          {
            "t": "交換",
            "en": "swap",
            "ps": "V"
          },
          {
            "t": "下濾",
            "en": "sift down",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行上濾 (Sift Up)。",
        "en": "(C) Swap the root node with the last node, remove the last node, and then perform Sift Up on the new root.",
        "wg": []
      },
      {
        "t": "(D) 找出左、右子節點中較小的一個直接取代根節點，並遞迴執行此動作。",
        "en": "(D) Find the smaller of the left and right children to directly replace the root, and perform this recursively.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "標準的移除步驟是將根節點 (最小值) 與堆積末端元素交換，移除末端元素後，新的根節點可能會破壞堆積性質，因此需要執行「下濾」將其移動到正確位置。",
      "en": "The standard removal procedure involves swapping the root (minimum value) with the last element of the heap. After removing the last element, the new root might violate the heap property, so 'Sift Down' is required to move it to the correct position.",
      "wg": [
        {
          "t": "破壞",
          "en": "violate",
          "ps": "V"
        },
        {
          "t": "堆積性質",
          "en": "heap property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Heapify, Time Complexity, Build Heap, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個包含 N 個元素的未排序陣列，若要將其轉換為二元堆積 (Binary Heap)，",
        "en": "Given an unsorted array containing N elements, to convert it into a Binary Heap,",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "轉換",
            "en": "convert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用最佳化的「由下而上」(Bottom-up) 建堆演算法 (Heapify)，其時間複雜度為何？",
        "en": "what is the time complexity using the optimized 'Bottom-up' heap construction algorithm (Heapify)?",
        "wg": [
          {
            "t": "由下而上",
            "en": "Bottom-up",
            "ps": "Adj"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雖然將元素逐一插入堆積的時間複雜度為 O(N log N)，但使用由下而上的 Heapify 方法時，由於大部分節點的高度較低，總操作次數呈現收斂級數，數學上證明其總時間複雜度為線性時間 O(N)。",
      "en": "While inserting elements one by one into a heap takes O(N log N), using the bottom-up Heapify method results in a linear time complexity O(N) because most nodes have small heights, and the sum of operations forms a convergent series.",
      "wg": [
        {
          "t": "逐一",
          "en": "one by one",
          "ps": "Adv"
        },
        {
          "t": "收斂級數",
          "en": "convergent series",
          "ps": "N"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Top K, Min-Heap, Streaming Data, K-th Largest",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在處理一個不斷湧入的數值資料流，需要即時維護並找出目前所有看過的數值中「第 K 大」的元素。",
        "en": "You are processing a continuous stream of numerical data and need to maintain and find the 'K-th largest' element among all seen values in real-time.",
        "wg": [
          {
            "t": "資料流",
            "en": "data stream",
            "ps": "N"
          },
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj/Adv"
          }
        ]
      },
      {
        "t": "請問下列哪種資料結構配置最為合適且記憶體效率最高？",
        "en": "Which of the following data structure configurations is the most suitable and memory-efficient?",
        "wg": [
          {
            "t": "配置",
            "en": "configuration",
            "ps": "N"
          },
          {
            "t": "記憶體效率",
            "en": "memory-efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 大小為 K 的最大堆積 (Max-Heap)",
        "en": "(A) Max-Heap of size K",
        "wg": []
      },
      {
        "t": "(B) 大小為 K 的最小堆積 (Min-Heap)",
        "en": "(B) Min-Heap of size K",
        "wg": []
      },
      {
        "t": "(C) 大小為 N 的最大堆積 (Max-Heap)，其中 N 為總資料量",
        "en": "(C) Max-Heap of size N, where N is the total data volume",
        "wg": []
      },
      {
        "t": "(D) 已排序的陣列 (Sorted Array)",
        "en": "(D) Sorted Array",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積可以保存目前最大的 K 個元素。堆積的根節點 (Root) 即為這 K 個元素中的最小值，也就是整體的「第 K 大」元素。當新元素大於根節點時，替換根節點並進行調整，空間複雜度僅需 O(K)。",
      "en": "Using a Min-Heap of size K allows you to store the current top K largest elements. The root of the heap is the smallest among these K elements, which corresponds to the 'K-th largest' element overall. When a new element is larger than the root, replace the root and adjust; the space complexity is only O(K).",
      "wg": [
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        },
        {
          "t": "替換",
          "en": "replace",
          "ps": "V"
        },
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "easy",
    "keywords": "Array Representation, Binary Heap, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在以「0 為起始索引」(0-indexed) 的陣列來實作二元堆積 (Binary Heap) 時，",
        "en": "When implementing a Binary Heap using a '0-indexed' array,",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "起始索引",
            "en": "starting index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若某個節點位於索引 `i`，則其「右子節點」(Right Child) 的索引位置為何？",
        "en": "if a node is located at index `i`, what is the index position of its 'Right Child'?",
        "wg": [
          {
            "t": "右子節點",
            "en": "right child",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2i",
        "en": "(A) 2i",
        "wg": []
      },
      {
        "t": "(B) 2i + 1",
        "en": "(B) 2i + 1",
        "wg": []
      },
      {
        "t": "(C) 2i + 2",
        "en": "(C) 2i + 2",
        "wg": []
      },
      {
        "t": "(D) floor(i / 2)",
        "en": "(D) floor(i / 2)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 0-indexed 的陣列表示法中，左子節點為 `2i + 1`，右子節點為 `2i + 2`，父節點則為 `floor((i - 1) / 2)`。選項 (A) 是 1-indexed 的左子節點公式。",
      "en": "In a 0-indexed array representation, the left child is at `2i + 1`, the right child is at `2i + 2`, and the parent is at `floor((i - 1) / 2)`. Option (A) is the formula for the left child in a 1-indexed system.",
      "wg": [
        {
          "t": "表示法",
          "en": "representation",
          "ps": "N"
        },
        {
          "t": "公式",
          "en": "formula",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Heap Deletion, Extract-Min, Sift-Down, Complete Binary Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當從二元最小堆積 (Binary Min-Heap) 中執行 `pop` 或 `extract-min` 操作移除根節點時，下列哪個步驟順序是正確的？",
        "en": "When performing a `pop` or `extract-min` operation to remove the root node from a Binary Min-Heap, which of the following sequences of steps is correct?",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "步驟順序",
            "en": "sequence of steps",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接刪除根節點，將陣列中所有元素向前移動一格。",
        "en": "(A) Directly delete the root node and shift all elements in the array forward by one position.",
        "wg": [
          {
            "t": "向前移動",
            "en": "shift forward",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行「向上篩選」(Sift-Up)。",
        "en": "(B) Swap the root node with the last node, remove the last node, and then perform 'Sift-Up' on the new root.",
        "wg": [
          {
            "t": "向上篩選",
            "en": "sift-up",
            "ps": "V/N"
          }
        ]
      },
      {
        "t": "(C) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行「向下篩選」(Sift-Down)。",
        "en": "(C) Swap the root node with the last node, remove the last node, and then perform 'Sift-Down' on the new root.",
        "wg": [
          {
            "t": "向下篩選",
            "en": "sift-down",
            "ps": "V/N"
          }
        ]
      },
      {
        "t": "(D) 找出左右子節點中較小的一個直接取代根節點，並遞迴此過程直到葉節點。",
        "en": "(D) Find the smaller of the left and right children to directly replace the root, and recurse this process until a leaf node is reached.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recurse",
            "ps": "V"
          },
          {
            "t": "葉節點",
            "en": "leaf node",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "為了保持「完全二元樹」(Complete Binary Tree) 的結構特性，必須將最後一個元素移至根位置填補空缺，接著執行 Sift-Down (或稱 Heapify) 以恢復堆積的順序性質 (Heap Property)。",
      "en": "To maintain the 'Complete Binary Tree' structural property, the last element must be moved to the root position to fill the gap, followed by performing Sift-Down (or Heapify) to restore the Heap Property.",
      "wg": [
        {
          "t": "完全二元樹",
          "en": "complete binary tree",
          "ps": "N"
        },
        {
          "t": "填補",
          "en": "fill",
          "ps": "V"
        },
        {
          "t": "順序性質",
          "en": "order property",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Merge K Sorted Lists, Priority Queue, Complexity Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若有 K 個已排序的鏈結串列 (Linked Lists)，其元素總數為 N。",
        "en": "If there are K sorted Linked Lists with a total of N elements.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "linked lists",
            "ps": "N"
          }
        ]
      },
      {
        "t": "利用優先佇列 (Priority Queue) 將它們合併成一個單一的排序串列，其時間複雜度為何？",
        "en": "What is the time complexity to merge them into a single sorted list using a Priority Queue?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "單一",
            "en": "single",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N log N)",
        "en": "(A) O(N log N)",
        "wg": []
      },
      {
        "t": "(B) O(K log N)",
        "en": "(B) O(K log N)",
        "wg": []
      },
      {
        "t": "(C) O(N log K)",
        "en": "(C) O(N log K)",
        "wg": []
      },
      {
        "t": "(D) O(N * K)",
        "en": "(D) O(N * K)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "優先佇列中最多同時維持 K 個元素 (每個串列一個)。每次取出最小值並插入下一個元素的操作花費 O(log K)。總共有 N 個元素需要被處理，因此總時間複雜度為 O(N log K)。",
      "en": "The priority queue maintains at most K elements at a time (one from each list). Each operation to extract the minimum and insert the next element takes O(log K). Since there are N elements in total to process, the total time complexity is O(N log K).",
      "wg": [
        {
          "t": "維持",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "花費",
          "en": "takes/costs",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Data Stream, Top-K, Min-Heap, Algorithm Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統來處理即時數據流，並需要隨時查詢該數據流中第 K 大的元素。",
        "en": "You are designing a system to process a real-time data stream and need to query the K-th largest element at any time.",
        "wg": [
          {
            "t": "即時數據流",
            "en": "real-time data stream",
            "ps": "NP"
          },
          {
            "t": "第 K 大",
            "en": "K-th largest",
            "ps": "AdjP"
          }
        ]
      },
      {
        "t": "假設 K 遠小於數據總量 N，下列哪種資料結構策略最為高效？",
        "en": "Assuming K is much smaller than the total data size N, which data structure strategy is the most efficient?",
        "wg": [
          {
            "t": "高效",
            "en": "efficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 N 的最大堆積 (Max-Heap)。",
        "en": "(A) Maintain a Max-Heap of size N.",
        "wg": []
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": []
      },
      {
        "t": "(C) 每次查詢時對所有數據進行快速排序 (Quicksort)。",
        "en": "(C) Perform Quicksort on all data for every query.",
        "wg": []
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 儲存所有頻率。",
        "en": "(D) Use a Hash Map to store all frequencies.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積可以只保留當前最大的 K 個元素。堆積的根節點 (Root) 即為這 K 個元素中最小的一個，也就是整體的第 K 大元素。新元素進來時，若大於根節點則替換並重新調整，時間複雜度為 O(log K)，優於維護全量堆積的 O(log N)。",
      "en": "Using a Min-Heap of size K allows you to keep only the current K largest elements. The root of the heap is the smallest among these K elements, which corresponds to the K-th largest element overall. When a new element arrives, if it is larger than the root, it replaces the root and the heap is readjusted, with a time complexity of O(log K), which is better than O(log N) for maintaining a full heap.",
      "wg": [
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        },
        {
          "t": "時間複雜度",
          "en": "time complexity",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Heap Sort, Stability, Sorting Algorithms",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，面試官詢問關於堆積排序 (Heap Sort) 的特性。",
        "en": "In an interview, the interviewer asks about the characteristics of Heap Sort.",
        "wg": [
          {
            "t": "特性",
            "en": "characteristics",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列關於堆積排序的敘述，何者是正確的？",
        "en": "Which of the following statements about Heap Sort is correct?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆積排序是一種穩定排序 (Stable Sort)。",
        "en": "(A) Heap Sort is a stable sort.",
        "wg": [
          {
            "t": "穩定排序",
            "en": "stable sort",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 堆積排序在最差情況下的時間複雜度是 O(N^2)。",
        "en": "(B) The worst-case time complexity of Heap Sort is O(N^2).",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 堆積排序需要 O(N) 的額外記憶體空間來進行排序。",
        "en": "(C) Heap Sort requires O(N) extra memory space to perform sorting.",
        "wg": [
          {
            "t": "額外記憶體空間",
            "en": "extra memory space",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 堆積排序是不穩定的，且可以在原地 (In-place) 進行。",
        "en": "(D) Heap Sort is unstable and can be performed in-place.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "堆積排序是不穩定的，因為在交換堆積頂端元素與末端元素時，可能會改變相同數值的相對順序。它的時間複雜度穩定在 O(N log N)，且只需要 O(1) 的輔助空間 (In-place)。",
      "en": "Heap Sort is unstable because swapping the top element with the last element can change the relative order of identical values. Its time complexity is consistently O(N log N), and it requires only O(1) auxiliary space (In-place).",
      "wg": [
        {
          "t": "相對順序",
          "en": "relative order",
          "ps": "NP"
        },
        {
          "t": "輔助空間",
          "en": "auxiliary space",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "easy",
    "keywords": "Array Implementation, Binary Heap, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當使用陣列 (Array) 來實作二元堆積 (Binary Heap) 時，通常採用 0-based indexing (索引從 0 開始)。",
        "en": "When implementing a Binary Heap using an array, 0-based indexing is typically used.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "索引",
            "en": "indexing",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若某個節點的索引值為 `i` (且 `i > 0`)，則其父節點 (Parent) 的索引值為何？",
        "en": "If a node has an index `i` (where `i > 0`), what is the index of its parent node?",
        "wg": [
          {
            "t": "父節點",
            "en": "parent node",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `i / 2`",
        "en": "(A) `i / 2`",
        "wg": []
      },
      {
        "t": "(B) `(i - 1) / 2` (無條件捨去小數)",
        "en": "(B) `(i - 1) / 2` (floor division)",
        "wg": [
          {
            "t": "無條件捨去",
            "en": "floor / round down",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) `2 * i + 1`",
        "en": "(C) `2 * i + 1`",
        "wg": []
      },
      {
        "t": "(D) `(i + 1) / 2`",
        "en": "(D) `(i + 1) / 2`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 0-based indexing 中，左子節點為 `2i + 1`，右子節點為 `2i + 2`。反推父節點時，無論是左或右子節點，其父節點索引皆為 `floor((i - 1) / 2)`。",
      "en": "In 0-based indexing, the left child is `2i + 1` and the right child is `2i + 2`. When calculating the parent backwards, for both left and right children, the parent index is `floor((i - 1) / 2)`.",
      "wg": [
        {
          "t": "反推",
          "en": "reverse calculate / deduce backwards",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Merge K Sorted Lists, Priority Queue, Complexity Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要合併 K 個已排序的陣列 (Sorted Arrays)，這些陣列總共有 N 個元素。",
        "en": "You need to merge K sorted arrays, which have a total of N elements combined.",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "已排序的",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "使用優先佇列 (Priority Queue) 來輔助合併過程，其最佳的時間複雜度為何？",
        "en": "Using a Priority Queue to assist the merging process, what is the optimal time complexity?",
        "wg": [
          {
            "t": "輔助",
            "en": "assist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N log N)",
        "en": "(A) O(N log N)",
        "wg": []
      },
      {
        "t": "(B) O(K log N)",
        "en": "(B) O(K log N)",
        "wg": []
      },
      {
        "t": "(C) O(N log K)",
        "en": "(C) O(N log K)",
        "wg": []
      },
      {
        "t": "(D) O(N * K)",
        "en": "(D) O(N * K)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "我們將 K 個陣列的第一個元素放入大小為 K 的最小堆積 (Min-Heap)。每次取出堆頂最小值 (花費 O(log K)) 並將該元素所屬陣列的下一個元素放入堆積。總共有 N 個元素需要被處理，因此總時間複雜度為 O(N log K)。這比直接將所有元素排序 O(N log N) 更快 (因為 K 通常小於 N)。",
      "en": "We put the first element of each of the K arrays into a Min-Heap of size K. Each time, we extract the minimum value from the top (taking O(log K)) and push the next element from the same array into the heap. Since there are N elements in total to process, the total time complexity is O(N log K). This is faster than sorting all elements directly, which is O(N log N) (since K is usually smaller than N).",
      "wg": [
        {
          "t": "堆頂",
          "en": "top of the heap",
          "ps": "N"
        },
        {
          "t": "所屬",
          "en": "belonging to",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Heap Operations, Extract-Max, Sift-Down",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二元最大堆積 (Max-Heap) 中執行 `extract-max` (移除最大值) 操作時，標準的演算法步驟順序為何？",
        "en": "When performing the `extract-max` (remove maximum) operation in a Binary Max-Heap, what is the standard sequence of algorithm steps?",
        "wg": [
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          },
          {
            "t": "順序",
            "en": "sequence",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接刪除根節點，將所有元素向前移動填補空缺。",
        "en": "(A) Directly delete the root node and shift all elements forward to fill the gap.",
        "wg": [
          {
            "t": "填補",
            "en": "fill",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行向下調整 (Heapify Down / Sift Down)。",
        "en": "(B) Swap the root node with the last node, remove the last node, and then perform Heapify Down (Sift Down) on the new root.",
        "wg": [
          {
            "t": "向下調整",
            "en": "Heapify Down / Sift Down",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 將根節點與最後一個節點交換，移除最後一個節點，然後對新的根節點執行向上調整 (Heapify Up / Sift Up)。",
        "en": "(C) Swap the root node with the last node, remove the last node, and then perform Heapify Up (Sift Up) on the new root.",
        "wg": [
          {
            "t": "向上調整",
            "en": "Heapify Up / Sift Up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 刪除根節點，並從左子樹中選出最大的元素遞補。",
        "en": "(D) Delete the root node and select the largest element from the left subtree to replace it.",
        "wg": [
          {
            "t": "遞補",
            "en": "replace / fill in",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了保持完全二元樹 (Complete Binary Tree) 的結構特性，我們必須將最後一個葉節點移至根位置 (透過交換)，然後移除原根節點。接著，因為新的根節點可能違反堆積性質 (比子節點小)，必須執行向下調整 (Sift Down) 直到恢復最大堆積的性質。",
      "en": "To maintain the structure of a Complete Binary Tree, we must move the last leaf node to the root position (via swapping) and then remove the original root. Then, since the new root might violate the heap property (being smaller than its children), we must perform Sift Down until the Max-Heap property is restored.",
      "wg": [
        {
          "t": "完全二元樹",
          "en": "Complete Binary Tree",
          "ps": "NP"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "Data Stream, Top-K, Min-Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統來處理即時的數值資料流，",
        "en": "You are designing a system to process a real-time stream of numerical data,",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          },
          {
            "t": "資料流",
            "en": "data stream",
            "ps": "N"
          }
        ]
      },
      {
        "t": "並且需要隨時能夠查詢到目前為止所有數值中的「第 K 大」元素。",
        "en": "and you need to be able to query the 'K-th largest' element among all values seen so far at any time.",
        "wg": [
          {
            "t": "查詢",
            "en": "query",
            "ps": "V"
          },
          {
            "t": "第 K 大",
            "en": "K-th largest",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問下列哪種資料結構與策略最適合用來維持這個狀態？",
        "en": "Which of the following data structures and strategies is most suitable for maintaining this state?",
        "wg": [
          {
            "t": "維持",
            "en": "maintain",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 K 的最大堆積 (Max-Heap)，堆頂即為第 K 大元素。",
        "en": "(A) Maintain a Max-Heap of size K, where the top is the K-th largest element.",
        "wg": []
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)，堆頂即為第 K 大元素。",
        "en": "(B) Maintain a Min-Heap of size K, where the top is the K-th largest element.",
        "wg": []
      },
      {
        "t": "(C) 每次查詢時對所有數據進行快速排序 (Quick Sort)。",
        "en": "(C) Perform Quick Sort on all data for every query.",
        "wg": []
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 儲存所有頻率。",
        "en": "(D) Use a Hash Map to store all frequencies.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "要找出第 K 大元素，我們只需要保留目前為止最大的 K 個數字。使用大小為 K 的最小堆積 (Min-Heap)，堆積中最小的元素（堆頂）就是這前 K 大數字中的最小值，也就是整體的第 K 大元素。當新元素大於堆頂時，移除堆頂並插入新元素，複雜度僅為 O(log K)。",
      "en": "To find the K-th largest element, we only need to keep the largest K numbers seen so far. Using a Min-Heap of size K, the smallest element in the heap (the root) is the minimum of these top K numbers, which corresponds to the K-th largest element overall. When a new element is larger than the root, we remove the root and insert the new element, with a complexity of only O(log K).",
      "wg": [
        {
          "t": "堆頂",
          "en": "root (of a heap)",
          "ps": "N"
        },
        {
          "t": "複雜度",
          "en": "complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "Merge K Sorted Lists, Complexity, Divide and Conquer",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設有 K 個已經排序好的鏈結串列 (Linked Lists)，這些串列總共包含 N 個元素。",
        "en": "Suppose there are K sorted Linked Lists, containing a total of N elements.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked Lists",
            "ps": "N"
          },
          {
            "t": "包含",
            "en": "contain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來協助合併這些串列成為一個排序好的串列，其時間複雜度為何？",
        "en": "If a Min-Heap is used to assist in merging these lists into a single sorted list, what is the time complexity?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N log N)",
        "en": "(A) O(N log N)",
        "wg": []
      },
      {
        "t": "(B) O(N log K)",
        "en": "(B) O(N log K)",
        "wg": []
      },
      {
        "t": "(C) O(K log N)",
        "en": "(C) O(K log N)",
        "wg": []
      },
      {
        "t": "(D) O(N * K)",
        "en": "(D) O(N * K)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "演算法會將每個串列的頭節點放入大小為 K 的最小堆積中。每次從堆積取出最小值（花費 O(log K)），並將該節點的下一個節點放入堆積（花費 O(log K)）。因為總共有 N 個元素需要被處理，總時間複雜度為 O(N log K)。這比將所有元素放進陣列重排的 O(N log N) 更有效率，因為通常 K << N。",
      "en": "The algorithm puts the head node of each list into a Min-Heap of size K. Each time, the minimum value is extracted from the heap (taking O(log K)), and the next node from that specific list is inserted into the heap (taking O(log K)). Since there are N elements in total to process, the total time complexity is O(N log K). This is more efficient than resorting all elements in an array, which is O(N log N), because typically K << N.",
      "wg": [
        {
          "t": "頭節點",
          "en": "head node",
          "ps": "N"
        },
        {
          "t": "有效率",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Sorting, Stability, Heap Sort",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於堆積排序 (Heap Sort) 的特性，下列敘述何者正確？",
        "en": "Regarding the characteristics of Heap Sort, which of the following statements is correct?",
        "wg": [
          {
            "t": "特性",
            "en": "characteristic",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "特別是針對「穩定性 (Stability)」的討論。",
        "en": "Specifically regarding the discussion of 'Stability'.",
        "wg": [
          {
            "t": "穩定性",
            "en": "stability",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它是穩定的排序演算法，因為它基於比較進行交換。",
        "en": "(A) It is a stable sorting algorithm because it performs swaps based on comparison.",
        "wg": []
      },
      {
        "t": "(B) 它是不穩定的排序演算法，因為在刪除最大值時會將堆頂與末端元素交換，可能打亂相同鍵值的相對順序。",
        "en": "(B) It is an unstable sorting algorithm because swapping the root with the last element during max extraction can disrupt the relative order of equal keys.",
        "wg": [
          {
            "t": "打亂",
            "en": "disrupt",
            "ps": "V"
          },
          {
            "t": "相對順序",
            "en": "relative order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 只有在使用最小堆積 (Min-Heap) 時才是穩定的。",
        "en": "(C) It is stable only when using a Min-Heap.",
        "wg": []
      },
      {
        "t": "(D) 它的空間複雜度是 O(N)，因為需要額外的堆積空間。",
        "en": "(D) Its space complexity is O(N) because it requires extra heap space.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "堆積排序是不穩定的。主要原因在於「取出最大值」的步驟：我們將堆頂（最大值）與陣列最後一個元素交換。這個長距離的交換可能會把一個元素移動到具有相同鍵值的其他元素之後，從而改變它們原本的相對順序。",
      "en": "Heap Sort is unstable. The main reason lies in the 'extract max' step: we swap the root (max value) with the last element of the array. This long-distance swap can move an element behind other elements with the same key value, thereby changing their original relative order.",
      "wg": [
        {
          "t": "長距離",
          "en": "long-distance",
          "ps": "Adj"
        },
        {
          "t": "交換",
          "en": "swap",
          "ps": "N/V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Decrease Key, Dijkstra, Binary Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 Dijkstra 最短路徑演算法時，我們經常需要更新優先權佇列中某個頂點的距離值（使其變小）。",
        "en": "When implementing Dijkstra's shortest path algorithm, we often need to update the distance value of a vertex in the priority queue (making it smaller).",
        "wg": [
          {
            "t": "最短路徑",
            "en": "shortest path",
            "ps": "N"
          },
          {
            "t": "頂點",
            "en": "vertex",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這個操作稱為 Decrease-Key。若使用二元堆積 (Binary Heap) 實作，該操作的時間複雜度為何？",
        "en": "This operation is called Decrease-Key. If implemented using a Binary Heap, what is the time complexity of this operation?",
        "wg": [
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Decrease-Key 操作會減小節點的值，這可能導致它比父節點還小（違反最小堆積性質）。因此，我們需要執行「向上調整 (Percolate Up / Bubble Up)」操作，將該節點與父節點交換，直到性質恢復。由於二元堆積的高度為 log N，最壞情況下需要交換至根節點，故複雜度為 O(log N)。(註：若使用費氏堆積 Fibonacci Heap，此操作攤銷後可為 O(1))。",
      "en": "The Decrease-Key operation reduces a node's value, which may cause it to be smaller than its parent (violating the Min-Heap property). Therefore, we need to perform a 'Percolate Up' (or Bubble Up) operation, swapping the node with its parent until the property is restored. Since the height of a Binary Heap is log N, in the worst case, we swap up to the root, so the complexity is O(log N). (Note: If using a Fibonacci Heap, this operation is O(1) amortized).",
      "wg": [
        {
          "t": "向上調整",
          "en": "Percolate Up",
          "ps": "V"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        },
        {
          "t": "攤銷",
          "en": "amortized",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Search, BST, Comparison",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "為什麼二元堆積 (Binary Heap) 不適合作為「搜尋任意值」的主要資料結構，相較於二元搜尋樹 (BST)？",
        "en": "Why is a Binary Heap not suitable as a primary data structure for 'searching for arbitrary values' compared to a Binary Search Tree (BST)?",
        "wg": [
          {
            "t": "任意值",
            "en": "arbitrary value",
            "ps": "N"
          },
          {
            "t": "二元搜尋樹",
            "en": "Binary Search Tree",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆積佔用的記憶體空間比 BST 多。",
        "en": "(A) Heaps consume more memory space than BSTs.",
        "wg": []
      },
      {
        "t": "(B) 堆積的插入操作比 BST 慢。",
        "en": "(B) Insertion operations in a Heap are slower than in a BST.",
        "wg": []
      },
      {
        "t": "(C) 堆積缺乏左右子節點的大小關係，導致搜尋任意值的時間複雜度為 O(N)。",
        "en": "(C) Heaps lack a size relationship between left and right children, resulting in a time complexity of O(N) for searching arbitrary values.",
        "wg": [
          {
            "t": "缺乏",
            "en": "lack",
            "ps": "V"
          },
          {
            "t": "大小關係",
            "en": "size relationship",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 堆積只能儲存整數，不能儲存物件。",
        "en": "(D) Heaps can only store integers, not objects.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "BST 的特性是「左子樹 < 根 < 右子樹」，這使得我們可以在 O(log N) 時間內進行二分搜尋。然而，堆積只保證「父節點 < 子節點」（最小堆積），但兄弟節點之間沒有順序關係。因此，要尋找一個非堆頂的特定值，我們無法確定要往左還是往右走，必須遍歷整個陣列，導致搜尋複雜度為 O(N)。",
      "en": "The property of a BST is 'Left Subtree < Root < Right Subtree', which allows us to perform binary search in O(log N) time. However, a Heap only guarantees 'Parent < Children' (in a Min-Heap), but there is no order relationship between sibling nodes. Therefore, to find a specific value other than the root, we cannot determine whether to go left or right and must traverse the entire array, resulting in a search complexity of O(N).",
      "wg": [
        {
          "t": "兄弟節點",
          "en": "sibling nodes",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  }
]