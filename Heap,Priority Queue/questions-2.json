[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Array Representation, Binary Heap, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設我們使用從索引 0 開始的陣列來實作二元堆積 (Binary Heap)。",
        "en": "Suppose we implement a Binary Heap using an array with 0-based indexing.",
        "wg": [
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "indexing",
            "ps": "N"
          }
        ]
      },
      {
        "t": "對於位於索引 i 的節點，其左子節點和右子節點的索引分別為何？",
        "en": "For a node at index i, what are the indices of its left child and right child respectively?",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "分別",
            "en": "respectively",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 左子節點：2i，右子節點：2i + 1",
        "en": "(A) Left child: 2i, Right child: 2i + 1",
        "wg": []
      },
      {
        "t": "(B) 左子節點：2i + 1，右子節點：2i + 2",
        "en": "(B) Left child: 2i + 1, Right child: 2i + 2",
        "wg": []
      },
      {
        "t": "(C) 左子節點：i / 2，右子節點：i / 2 + 1",
        "en": "(C) Left child: i / 2, Right child: i / 2 + 1",
        "wg": []
      },
      {
        "t": "(D) 左子節點：i + 1，右子節點：i + 2",
        "en": "(D) Left child: i + 1, Right child: i + 2",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 0-based 索引系統中，根節點位於 0。對於任意節點 i，左子節點位於 2i + 1，右子節點位於 2i + 2，而父節點位於 (i - 1) / 2。",
      "en": "In a 0-based indexing system, the root is at 0. For any node i, the left child is at 2i + 1, the right child is at 2i + 2, and the parent is at (i - 1) / 2.",
      "wg": [
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        },
        {
          "t": "父節點",
          "en": "parent node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Insertion, Percolate Up, Heap Property",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當我們向「最小堆積 (Min-Heap)」中插入一個新元素時，正確的操作步驟是什麼？",
        "en": "When inserting a new element into a 'Min-Heap', what is the correct sequence of operations?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "插入",
            "en": "inserting",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請選出能維持堆積屬性 (Heap Property) 的流程。",
        "en": "Please select the process that maintains the Heap Property.",
        "wg": [
          {
            "t": "堆積屬性",
            "en": "Heap Property",
            "ps": "N"
          },
          {
            "t": "維持",
            "en": "maintains",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將元素放在根節點，然後執行「下濾 (Sift Down)」操作。",
        "en": "(A) Place the element at the root, then perform the 'Sift Down' operation.",
        "wg": [
          {
            "t": "下濾",
            "en": "Sift Down",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 將元素放在陣列的末端，然後執行「上濾 (Bubble Up)」操作。",
        "en": "(B) Place the element at the end of the array, then perform the 'Bubble Up' operation.",
        "wg": [
          {
            "t": "上濾",
            "en": "Bubble Up",
            "ps": "V"
          },
          {
            "t": "末端",
            "en": "end",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 如果新元素小於根節點，則直接替換根節點，否則丟棄。",
        "en": "(C) If the new element is smaller than the root, replace the root directly; otherwise, discard it.",
        "wg": [
          {
            "t": "丟棄",
            "en": "discard",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 將元素放在陣列的中間位置，並重新排序整個陣列。",
        "en": "(D) Place the element in the middle of the array and resort the entire array.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "插入操作總是先將新元素放在堆積的最後一個位置 (維持完全二元樹結構)，然後與父節點比較並交換 (上濾)，直到滿足堆積屬性為止。",
      "en": "The insertion operation always places the new element at the last position of the heap (maintaining the complete binary tree structure), then compares and swaps with the parent (Bubble Up) until the heap property is satisfied.",
      "wg": [
        {
          "t": "完全二元樹",
          "en": "complete binary tree",
          "ps": "N"
        },
        {
          "t": "交換",
          "en": "swaps",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Deletion, Extract Max, Percolate Down",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「最大堆積 (Max-Heap)」中執行移除最大值 (Extract-Max) 的操作時，",
        "en": "When performing the Extract-Max operation in a 'Max-Heap',",
        "wg": [
          {
            "t": "最大堆積",
            "en": "Max-Heap",
            "ps": "N"
          },
          {
            "t": "移除",
            "en": "performing ... removal",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了保持完全二元樹的結構與堆積順序，我們通常會如何處理？",
        "en": "how do we usually proceed to maintain the complete binary tree structure and heap order?",
        "wg": [
          {
            "t": "結構",
            "en": "structure",
            "ps": "N"
          },
          {
            "t": "順序",
            "en": "order",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 移除根節點，將陣列中所有元素向前移動一格。",
        "en": "(A) Remove the root node and shift all elements in the array forward by one position.",
        "wg": [
          {
            "t": "向前移動",
            "en": "shift ... forward",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 移除根節點，將最後一個葉節點移至根位置，並執行「下濾 (Sift Down)」。",
        "en": "(B) Remove the root node, move the last leaf node to the root position, and perform 'Sift Down'.",
        "wg": [
          {
            "t": "葉節點",
            "en": "leaf node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 移除根節點，將最後一個葉節點移至根位置，並執行「上濾 (Bubble Up)」。",
        "en": "(C) Remove the root node, move the last leaf node to the root position, and perform 'Bubble Up'.",
        "wg": []
      },
      {
        "t": "(D) 找出第二大的節點直接遞補根節點。",
        "en": "(D) Find the second largest node to directly replace the root node.",
        "wg": [
          {
            "t": "遞補",
            "en": "replace/fill in",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了保持結構完整性，我們將最後一個元素移到根節點填補空缺，但這會破壞堆積順序，因此需要執行下濾 (Sift Down) 將其與較大的子節點交換，直到位置正確。",
      "en": "To maintain structural integrity, we move the last element to the root to fill the gap, but this violates the heap order, so we need to perform Sift Down to swap it with the larger child until it is in the correct position.",
      "wg": [
        {
          "t": "完整性",
          "en": "integrity",
          "ps": "N"
        },
        {
          "t": "填補",
          "en": "fill",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Time Complexity, Build Heap, Heapify",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個未排序的陣列，大小為 N。",
        "en": "Given an unsorted array of size N.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若使用最佳的「由下而上 (Bottom-Up)」建堆演算法 (Heapify)，其時間複雜度為何？",
        "en": "If using the optimal 'Bottom-Up' heap construction algorithm (Heapify), what is its time complexity?",
        "wg": [
          {
            "t": "由下而上",
            "en": "Bottom-Up",
            "ps": "Adj"
          },
          {
            "t": "建堆",
            "en": "heap construction",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N)",
        "en": "(A) O(N)",
        "wg": []
      },
      {
        "t": "(B) O(N log N)",
        "en": "(B) O(N log N)",
        "wg": []
      },
      {
        "t": "(C) O(log N)",
        "en": "(C) O(log N)",
        "wg": []
      },
      {
        "t": "(D) O(N^2)",
        "en": "(D) O(N^2)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "雖然單次插入是 O(log N)，導致 N 次插入為 O(N log N)；但由下而上的 Heapify 演算法利用了「大部分節點位於底部且下濾路徑短」的特性，經數學級數加總證明其總成本收斂於 O(N)。",
      "en": "Although a single insertion is O(log N), leading to O(N log N) for N insertions; the bottom-up Heapify algorithm exploits the fact that 'most nodes are at the bottom with short sift-down paths', and mathematical series summation proves the total cost converges to O(N).",
      "wg": [
        {
          "t": "收斂",
          "en": "converges",
          "ps": "V"
        },
        {
          "t": "級數",
          "en": "series",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Kth Largest, Data Stream, Min-Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要在一個不斷湧入的資料流 (Data Stream) 中，即時找出「第 K 大」的元素。",
        "en": "If you need to find the 'Kth largest' element in real-time from a continuously arriving data stream.",
        "wg": [
          {
            "t": "資料流",
            "en": "data stream",
            "ps": "N"
          },
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "下列哪種資料結構策略在空間與時間效率上最為合適？",
        "en": "Which of the following data structure strategies is most appropriate in terms of space and time efficiency?",
        "wg": [
          {
            "t": "策略",
            "en": "strategies",
            "ps": "N"
          },
          {
            "t": "效率",
            "en": "efficiency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 K 的最大堆積 (Max-Heap)。",
        "en": "(A) Maintain a Max-Heap of size K.",
        "wg": [
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": []
      },
      {
        "t": "(C) 維護一個大小為 N (目前所有元素) 的最大堆積。",
        "en": "(C) Maintain a Max-Heap of size N (all current elements).",
        "wg": []
      },
      {
        "t": "(D) 每次新資料進來時，對整個陣列進行快速排序 (Quick Sort)。",
        "en": "(D) Perform Quick Sort on the entire array every time new data arrives.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積可以保存目前最大的 K 個數字。堆積的根節點 (Root) 即為這 K 個數字中的最小值，也就是整體的「第 K 大」元素。新元素若大於根節點則替換並下濾。",
      "en": "Using a Min-Heap of size K preserves the current top K largest numbers. The root of the heap is the minimum of these K numbers, which corresponds to the 'Kth largest' element overall. If a new element is larger than the root, it replaces the root and sifts down.",
      "wg": [
        {
          "t": "保存",
          "en": "preserves",
          "ps": "V"
        },
        {
          "t": "整體",
          "en": "overall",
          "ps": "Adj"
        }
      ]
    }
  }
]