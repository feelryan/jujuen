[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Heap Sort, Algorithm Analysis, Stability, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於堆積排序 (Heap Sort) 的特性，下列敘述何者正確？",
        "en": "Which of the following statements about Heap Sort is true?",
        "wg": [
          {
            "t": "堆積排序",
            "en": "Heap Sort",
            "ps": "N"
          },
          {
            "t": "特性",
            "en": "characteristics",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請考慮其時間複雜度、空間複雜度以及穩定性。",
        "en": "Please consider its time complexity, space complexity, and stability.",
        "wg": [
          {
            "t": "穩定性",
            "en": "stability",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它是穩定的排序演算法，且最差時間複雜度為 O(N log N)。",
        "en": "(A) It is a stable sorting algorithm with a worst-case time complexity of O(N log N).",
        "wg": [
          {
            "t": "穩定的",
            "en": "stable",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 它是不穩定的排序演算法，且可以在 O(1) 的額外空間下運作 (原地排序)。",
        "en": "(B) It is an unstable sorting algorithm and can operate with O(1) extra space (in-place sorting).",
        "wg": [
          {
            "t": "不穩定的",
            "en": "unstable",
            "ps": "Adj"
          },
          {
            "t": "原地排序",
            "en": "in-place sorting",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它的平均時間複雜度優於快速排序 (Quick Sort)，因此實務上總是比快速排序快。",
        "en": "(C) Its average time complexity is better than Quick Sort, so it is practically always faster than Quick Sort.",
        "wg": []
      },
      {
        "t": "(D) 建構堆積 (Build Heap) 的過程需要 O(N log N) 的時間。",
        "en": "(D) The process of building the heap takes O(N log N) time.",
        "wg": [
          {
            "t": "建構堆積",
            "en": "Build Heap",
            "ps": "VP"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "堆積排序涉及交換堆積頂端與末端元素，這會破壞相同鍵值元素的相對順序，因此是不穩定的。它是原地演算法 (In-place)，僅需常數額外空間。選項 (D) 錯誤，因為線性建構堆積的時間複雜度為 O(N)。",
      "en": "Heap sort involves swapping the top of the heap with the last element, which disrupts the relative order of elements with equal keys, making it unstable. It is an in-place algorithm requiring only constant extra space. Option (D) is incorrect because linear heap construction takes O(N) time.",
      "wg": [
        {
          "t": "相對順序",
          "en": "relative order",
          "ps": "N"
        },
        {
          "t": "常數",
          "en": "constant",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Priority Queue, Top K, Data Stream, Min-Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統來處理即時資料流，需要隨時找出目前所有已接收數據中的「第 K 大」元素。",
        "en": "You are designing a system to process a real-time data stream and need to find the 'K-th largest' element among all received data at any time.",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          },
          {
            "t": "資料流",
            "en": "data stream",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 N 代表目前接收到的數據總量，且 N 遠大於 K。",
        "en": "Assume N represents the total amount of data received so far, and N is much larger than K.",
        "wg": []
      },
      {
        "t": "下列哪種資料結構與策略最有效率？",
        "en": "Which of the following data structures and strategies is the most efficient?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 N 的最大堆積 (Max-Heap)，堆積頂端即為答案。",
        "en": "(A) Maintain a Max-Heap of size N; the top of the heap is the answer.",
        "wg": []
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": []
      },
      {
        "t": "(C) 每次查詢時對所有數據進行快速排序 (Quick Sort)。",
        "en": "(C) Perform Quick Sort on all data for every query.",
        "wg": []
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 儲存所有頻率。",
        "en": "(D) Use a Hash Map to store all frequencies.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用大小為 K 的最小堆積，可以保留目前看過的最大的 K 個元素。堆積頂端 (Root) 始終是這 K 個元素中最小的，也就是整體的「第 K 大」元素。當新元素大於堆積頂端時，替換並調整堆積，複雜度僅為 O(log K)。",
      "en": "Using a Min-Heap of size K allows you to keep the K largest elements seen so far. The root of the heap is always the smallest of these K elements, which corresponds to the 'K-th largest' overall. When a new element is larger than the root, replace and adjust, with a complexity of only O(log K).",
      "wg": [
        {
          "t": "堆積頂端",
          "en": "root (of heap)",
          "ps": "N"
        },
        {
          "t": "替換",
          "en": "replace",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Array Implementation, Indexing, Binary Heap",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int parent = (i - 1) / 2;\nint left = 2 * i + 1;\nint right = ???;",
    "question": [
      {
        "t": "在以「從 0 開始索引 (0-based indexing)」的陣列來實作二元堆積 (Binary Heap) 時，",
        "en": "When implementing a Binary Heap using a '0-based indexing' array,",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "從 0 開始索引",
            "en": "0-based indexing",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "若某個節點的索引值為 `i`，則其「右子節點 (Right Child)」的索引值應為何？",
        "en": "if a node has an index `i`, what should be the index of its 'Right Child'?",
        "wg": [
          {
            "t": "右子節點",
            "en": "Right Child",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 2 * i",
        "en": "(A) 2 * i",
        "wg": []
      },
      {
        "t": "(B) 2 * i + 1",
        "en": "(B) 2 * i + 1",
        "wg": []
      },
      {
        "t": "(C) 2 * i + 2",
        "en": "(C) 2 * i + 2",
        "wg": []
      },
      {
        "t": "(D) i / 2 + 1",
        "en": "(D) i / 2 + 1",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 0-based 索引中，根節點為 0。對於索引 i，左子節點為 2*i + 1，右子節點為 2*i + 2。若為 1-based 索引，右子節點才會是 2*i + 1。",
      "en": "In 0-based indexing, the root is at 0. For index i, the left child is 2*i + 1, and the right child is 2*i + 2. If it were 1-based indexing, the right child would be 2*i + 1.",
      "wg": [
        {
          "t": "索引",
          "en": "index",
          "ps": "N"
        },
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Merge Sort, K-way Merge, Priority Queue, Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要合併 K 個已排序的鏈結串列 (Sorted Linked Lists)，且所有串列的元素總數為 N。",
        "en": "You need to merge K sorted linked lists, where the total number of elements across all lists is N.",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "鏈結串列",
            "en": "linked lists",
            "ps": "N"
          }
        ]
      },
      {
        "t": "利用優先佇列 (Priority Queue) 來優化此過程，其最佳的時間複雜度為何？",
        "en": "Using a Priority Queue to optimize this process, what is the optimal time complexity?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N log N)",
        "en": "(A) O(N log N)",
        "wg": []
      },
      {
        "t": "(B) O(N log K)",
        "en": "(B) O(N log K)",
        "wg": []
      },
      {
        "t": "(C) O(K log N)",
        "en": "(C) O(K log N)",
        "wg": []
      },
      {
        "t": "(D) O(N * K)",
        "en": "(D) O(N * K)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們將 K 個串列的頭節點放入最小堆積 (Min-Heap) 中。每次取出最小值 (花費 O(log K)) 並將該節點的下一個元素放入堆積。總共需處理 N 個元素，因此總時間複雜度為 O(N log K)。這比將所有元素混在一起重排的 O(N log N) 更有效率。",
      "en": "We put the head nodes of the K lists into a Min-Heap. Each time, we extract the minimum value (taking O(log K)) and push the next element of that node into the heap. Since we process N elements in total, the total time complexity is O(N log K). This is more efficient than O(N log N) for resorting all elements mixed together.",
      "wg": [
        {
          "t": "頭節點",
          "en": "head node",
          "ps": "N"
        },
        {
          "t": "取出",
          "en": "extract",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Build Heap, Time Complexity, Algorithm Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for (int i = n / 2 - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n}",
    "question": [
      {
        "t": "給定一個未排序的陣列，使用「由下而上 (Bottom-up)」的方式建構堆積 (Build Heap) (如程式碼片段所示)。",
        "en": "Given an unsorted array, constructing a heap using the 'Bottom-up' approach (as shown in the code snippet).",
        "wg": [
          {
            "t": "未排序的",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "由下而上",
            "en": "Bottom-up",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問此操作的時間複雜度為何？",
        "en": "What is the time complexity of this operation?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N)",
        "en": "(A) O(N)",
        "wg": []
      },
      {
        "t": "(B) O(N log N)",
        "en": "(B) O(N log N)",
        "wg": []
      },
      {
        "t": "(C) O(log N)",
        "en": "(C) O(log N)",
        "wg": []
      },
      {
        "t": "(D) O(N^2)",
        "en": "(D) O(N^2)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "雖然單次 heapify 是 O(log N)，但由下而上建構時，大部分節點位於底部，只需移動很少層。透過級數求和可證明，所有節點移動高度的總和收斂於線性時間 O(N)，而非 O(N log N)。",
      "en": "Although a single heapify is O(log N), when building bottom-up, most nodes are at the bottom and move very few levels. By summing the series, it can be proven that the total height moved by all nodes converges to linear time O(N), not O(N log N).",
      "wg": [
        {
          "t": "級數求和",
          "en": "summing the series",
          "ps": "VP"
        },
        {
          "t": "收斂",
          "en": "converges",
          "ps": "V"
        }
      ]
    }
  }
]