[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Time Complexity, Build Heap, Heapify, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個包含 N 個元素的未排序陣列，我們希望將其轉換為一個二元堆積 (Binary Heap)。",
        "en": "Given an unsorted array of N elements, we want to convert it into a Binary Heap.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "考慮兩種方法：方法 A 是建立一個空堆積並逐一插入 N 個元素；方法 B 是使用由下而上的 `heapify` 演算法直接在陣列上操作。",
        "en": "Consider two methods: Method A is to create an empty heap and insert N elements one by one; Method B is to use the bottom-up `heapify` algorithm directly on the array.",
        "wg": [
          {
            "t": "逐一",
            "en": "one by one",
            "ps": "Adv"
          },
          {
            "t": "由下而上",
            "en": "bottom-up",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問這兩種方法的時間複雜度分別為何？",
        "en": "What are the time complexities of these two methods respectively?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 方法 A：O(N)，方法 B：O(N log N)",
        "en": "(A) Method A: O(N), Method B: O(N log N)",
        "wg": []
      },
      {
        "t": "(B) 方法 A：O(N log N)，方法 B：O(N)",
        "en": "(B) Method A: O(N log N), Method B: O(N)",
        "wg": []
      },
      {
        "t": "(C) 兩者皆為 O(N log N)",
        "en": "(C) Both are O(N log N)",
        "wg": []
      },
      {
        "t": "(D) 兩者皆為 O(N)",
        "en": "(D) Both are O(N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "方法 A 涉及 N 次插入，每次插入最壞情況需 O(log N)，總共 O(N log N)。方法 B (Build Heap) 雖然看起來像迴圈，但由於大部分節點高度較低，經過數學級數加總證明其複雜度收斂於 O(N)，這是一個常見的面試優化考點。",
      "en": "Method A involves N insertions, each taking O(log N) in the worst case, totaling O(N log N). Method B (Build Heap), while looking like a loop, converges to O(N) because most nodes have small heights. This is proven by summing the series and is a common optimization topic in interviews.",
      "wg": [
        {
          "t": "收斂",
          "en": "converge",
          "ps": "V"
        },
        {
          "t": "級數",
          "en": "series",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Top-K, Streaming Data, Min-Heap, Architecture",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統來處理即時數據串流，並需要隨時維護目前「最大的 K 個數字」。",
        "en": "You are designing a system to process a real-time data stream and need to maintain the 'top K largest numbers' at all times.",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          },
          {
            "t": "數據串流",
            "en": "data stream",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 K 遠小於數據總量 N，下列哪種資料結構策略最為高效？",
        "en": "Assuming K is much smaller than the total data volume N, which data structure strategy is the most efficient?",
        "wg": [
          {
            "t": "遠小於",
            "en": "much smaller than",
            "ps": "Phrase"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 維護一個大小為 K 的最大堆積 (Max-Heap)。",
        "en": "(A) Maintain a Max-Heap of size K.",
        "wg": []
      },
      {
        "t": "(B) 維護一個大小為 K 的最小堆積 (Min-Heap)。",
        "en": "(B) Maintain a Min-Heap of size K.",
        "wg": []
      },
      {
        "t": "(C) 每次新數據進來時，對所有數據進行快速排序 (Quicksort)。",
        "en": "(C) Perform Quicksort on all data whenever new data arrives.",
        "wg": []
      },
      {
        "t": "(D) 使用二元搜尋樹 (BST) 儲存所有數據。",
        "en": "(D) Use a Binary Search Tree (BST) to store all data.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了找出最大的 K 個數，我們應該使用大小為 K 的「最小堆積」。堆積頂端 (Root) 儲存的是這 K 個數中最小的一個 (即第 K 大的數)。當新數字大於堆積頂端時，我們移除頂端並插入新數字，確保堆積內始終保留最大的 K 個元素。",
      "en": "To find the top K largest numbers, we should use a 'Min-Heap' of size K. The root of the heap stores the smallest of these K numbers (i.e., the K-th largest). When a new number is larger than the root, we remove the root and insert the new number, ensuring the heap always retains the top K elements.",
      "wg": [
        {
          "t": "堆積頂端",
          "en": "root of the heap",
          "ps": "N"
        },
        {
          "t": "保留",
          "en": "retain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Merge K Sorted Lists, Complexity, Heap Application",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您有 K 個已排序的陣列，所有陣列的元素總數為 N。",
        "en": "You have K sorted arrays, and the total number of elements across all arrays is N.",
        "wg": [
          {
            "t": "已排序的",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來協助將這 K 個陣列合併成一個單一的排序陣列，其時間複雜度為何？",
        "en": "If you use a Min-Heap to assist in merging these K arrays into a single sorted array, what is the time complexity?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "單一的",
            "en": "single",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N log N)",
        "en": "(A) O(N log N)",
        "wg": []
      },
      {
        "t": "(B) O(K log N)",
        "en": "(B) O(K log N)",
        "wg": []
      },
      {
        "t": "(C) O(N log K)",
        "en": "(C) O(N log K)",
        "wg": []
      },
      {
        "t": "(D) O(N K)",
        "en": "(D) O(N K)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "我們維護一個大小為 K 的最小堆積，初始放入每個陣列的第一個元素。每次取出堆積中的最小值 (耗時 O(log K)) 並將該元素所屬陣列的下一個元素放入堆積 (耗時 O(log K))。因為總共有 N 個元素要被處理，總時間複雜度為 O(N log K)。",
      "en": "We maintain a Min-Heap of size K, initially containing the first element of each array. Each time, we extract the minimum value from the heap (taking O(log K)) and push the next element from that value's array into the heap (taking O(log K)). Since there are N elements in total to process, the total time complexity is O(N log K).",
      "wg": [
        {
          "t": "所屬",
          "en": "belonging to",
          "ps": "Adj"
        },
        {
          "t": "處理",
          "en": "process",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Array Representation, Indexing, Binary Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二元堆積通常使用陣列來實作。假設陣列索引從 0 開始 (0-based indexing)。",
        "en": "Binary Heaps are typically implemented using arrays. Assume the array index starts from 0 (0-based indexing).",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "對於位於索引 `i` 的節點，其左子節點 (Left Child) 和右子節點 (Right Child) 的索引分別是什麼？",
        "en": "For a node located at index `i`, what are the indices of its Left Child and Right Child respectively?",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 左: 2i, 右: 2i + 1",
        "en": "(A) Left: 2i, Right: 2i + 1",
        "wg": []
      },
      {
        "t": "(B) 左: 2i + 1, 右: 2i + 2",
        "en": "(B) Left: 2i + 1, Right: 2i + 2",
        "wg": []
      },
      {
        "t": "(C) 左: i/2, 右: i/2 + 1",
        "en": "(C) Left: i/2, Right: i/2 + 1",
        "wg": []
      },
      {
        "t": "(D) 左: i + 1, 右: i + 2",
        "en": "(D) Left: i + 1, Right: i + 2",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在從 0 開始的索引系統中，根節點在 0。節點 i 的左子節點位於 `2*i + 1`，右子節點位於 `2*i + 2`。選項 (A) 是針對從 1 開始的索引系統 (1-based indexing) 的公式。",
      "en": "In a 0-based indexing system, the root is at 0. The left child of node i is at `2*i + 1`, and the right child is at `2*i + 2`. Option (A) is the formula for a 1-based indexing system.",
      "wg": [
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        },
        {
          "t": "公式",
          "en": "formula",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Sorting Algorithm, Stability, Heap Sort",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於堆積排序 (Heap Sort) 的特性，下列敘述何者正確？",
        "en": "Regarding the characteristics of Heap Sort, which of the following statements is correct?",
        "wg": [
          {
            "t": "特性",
            "en": "characteristic",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆積排序是一種穩定的排序演算法 (Stable Sort)。",
        "en": "(A) Heap Sort is a stable sorting algorithm.",
        "wg": [
          {
            "t": "穩定的",
            "en": "stable",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 堆積排序在最壞情況下的時間複雜度為 O(N^2)。",
        "en": "(B) The worst-case time complexity of Heap Sort is O(N^2).",
        "wg": []
      },
      {
        "t": "(C) 堆積排序需要額外的 O(N) 記憶體空間來儲存堆積結構。",
        "en": "(C) Heap Sort requires an additional O(N) memory space to store the heap structure.",
        "wg": [
          {
            "t": "額外的",
            "en": "additional",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 堆積排序是不穩定的排序，且可以原地 (In-place) 執行。",
        "en": "(D) Heap Sort is an unstable sort and can be performed in-place.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "堆積排序是不穩定的，因為在交換堆積頂端與末端元素時，可能會改變相同數值元素的相對順序。它是原地演算法 (In-place)，空間複雜度為 O(1)，且最壞時間複雜度保證為 O(N log N)。",
      "en": "Heap Sort is unstable because swapping the root with the last element can change the relative order of elements with equal values. It is an in-place algorithm with O(1) space complexity, and its worst-case time complexity is guaranteed to be O(N log N).",
      "wg": [
        {
          "t": "相對順序",
          "en": "relative order",
          "ps": "N"
        },
        {
          "t": "保證",
          "en": "guarantee",
          "ps": "V"
        }
      ]
    }
  }
]