[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Intervals, Overlap, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Interval A = [startA, endA]\nInterval B = [startB, endB]",
    "question": [
      {
        "t": "給定兩個區間 A 與 B，判斷它們是否重疊（包含邊界接觸）的最簡潔邏輯條件為何？",
        "en": "Given two intervals A and B, what is the most concise logical condition to determine if they overlap (including touching boundaries)?",
        "wg": [
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          },
          {
            "t": "邊界",
            "en": "boundary",
            "ps": "N"
          },
          {
            "t": "簡潔",
            "en": "concise",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) startA == startB",
        "en": "(A) startA == startB",
        "wg": []
      },
      {
        "t": "(B) endA >= startB && startA <= endB",
        "en": "(B) endA >= startB && startA <= endB",
        "wg": []
      },
      {
        "t": "(C) endA > endB",
        "en": "(C) endA > endB",
        "wg": []
      },
      {
        "t": "(D) startA < startB || endA > endB",
        "en": "(D) startA < startB || endA > endB",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "兩個區間重疊的充要條件是：A 的結束時間大於等於 B 的開始時間，且 A 的開始時間小於等於 B 的結束時間。",
      "en": "The necessary and sufficient condition for two intervals to overlap is: A's end time is greater than or equal to B's start time, and A's start time is less than or equal to B's end time.",
      "wg": [
        {
          "t": "充要條件",
          "en": "necessary and sufficient condition",
          "ps": "N"
        },
        {
          "t": "結束時間",
          "en": "end time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Merge Intervals, Sorting, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「合併區間」(Merge Intervals) 問題時，為了將時間複雜度優化至 O(N log N)，第一步通常需要做什麼操作？",
        "en": "When solving the 'Merge Intervals' problem, what is typically the first step required to optimize the time complexity to O(N log N)?",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據區間的「結束時間」進行排序。",
        "en": "(A) Sort based on the 'end time' of the intervals.",
        "wg": [
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 根據區間的「開始時間」進行排序。",
        "en": "(B) Sort based on the 'start time' of the intervals.",
        "wg": []
      },
      {
        "t": "(C) 使用雜湊表 (Hash Map) 儲存所有區間。",
        "en": "(C) Use a Hash Map to store all intervals.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 建立一個二元搜尋樹 (BST)。",
        "en": "(D) Build a Binary Search Tree (BST).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據「開始時間」排序後，重疊的區間會在陣列中相鄰，這樣只需遍歷一次即可完成合併，這是標準解法。",
      "en": "After sorting by 'start time', overlapping intervals become adjacent in the array, allowing merging to be completed in a single pass, which is the standard solution.",
      "wg": [
        {
          "t": "相鄰",
          "en": "adjacent",
          "ps": "Adj"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Insert Interval, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個已經排序且無重疊的區間列表中插入一個新區間 `newInterval`。",
        "en": "Insert a new interval `newInterval` into a list of intervals that is already sorted and non-overlapping.",
        "wg": [
          {
            "t": "插入",
            "en": "insert",
            "ps": "V"
          },
          {
            "t": "無重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "當遍歷到的當前區間與 `newInterval` 重疊時，應該如何處理？",
        "en": "When the current interval being traversed overlaps with `newInterval`, how should it be handled?",
        "wg": [
          {
            "t": "處理",
            "en": "handle",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接將當前區間加入結果列表。",
        "en": "(A) Directly add the current interval to the result list.",
        "wg": []
      },
      {
        "t": "(B) 放棄 `newInterval`，保留當前區間。",
        "en": "(B) Discard `newInterval` and keep the current interval.",
        "wg": [
          {
            "t": "放棄",
            "en": "discard",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 更新 `newInterval` 的範圍為兩者聯集，即 `[min(start), max(end)]`，並繼續遍歷。",
        "en": "(C) Update the range of `newInterval` to the union of both, i.e., `[min(start), max(end)]`, and continue traversing.",
        "wg": [
          {
            "t": "聯集",
            "en": "union",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 拋出錯誤，因為不應該發生重疊。",
        "en": "(D) Throw an error because overlap should not occur.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當發生重疊時，我們需要合併區間。",
      "en": "When an overlap occurs, we need to merge the intervals.",
      "wg": []
    },
    "why_detail": {
      "t": "正確的做法是擴展 `newInterval` 以包含當前區間，直到不再重疊為止，這樣才能確保合併後的區間是連續的。",
      "en": "The correct approach is to expand `newInterval` to include the current interval until no more overlaps exist, ensuring the merged interval is continuous.",
      "wg": [
        {
          "t": "擴展",
          "en": "expand",
          "ps": "V"
        },
        {
          "t": "連續的",
          "en": "continuous",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Non-overlapping Intervals, Greedy, Scheduling",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若想從一組區間中選出「最多數量」的不重疊區間（類似活動安排問題），最佳的貪婪策略是什麼？",
        "en": "If you want to select the 'maximum number' of non-overlapping intervals from a set (similar to the Activity Selection Problem), what is the best greedy strategy?",
        "wg": [
          {
            "t": "活動安排",
            "en": "activity selection",
            "ps": "N"
          },
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據「開始時間」排序，優先選擇最早開始的。",
        "en": "(A) Sort by 'start time' and prioritize the ones starting earliest.",
        "wg": [
          {
            "t": "優先選擇",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 根據「結束時間」排序，優先選擇最早結束的。",
        "en": "(B) Sort by 'end time' and prioritize the ones ending earliest.",
        "wg": []
      },
      {
        "t": "(C) 根據「區間長度」排序，優先選擇最短的。",
        "en": "(C) Sort by 'interval duration' and prioritize the shortest ones.",
        "wg": [
          {
            "t": "區間長度",
            "en": "interval duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 隨機選擇。",
        "en": "(D) Select randomly.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選擇最早結束的活動可以為後續的活動留出最多的時間，從而最大化能容納的區間數量。",
      "en": "Choosing the activity that ends earliest leaves the most time for subsequent activities, thereby maximizing the number of intervals that can be accommodated.",
      "wg": [
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        },
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Meeting Rooms II, Min-Heap, Sweep Line",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「會議室 II」(Meeting Rooms II) 問題以計算所需最少會議室數量時，若已將會議依開始時間排序。",
        "en": "When solving the 'Meeting Rooms II' problem to calculate the minimum number of conference rooms required, assuming meetings are already sorted by start time.",
        "wg": [
          {
            "t": "最少",
            "en": "minimum",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "使用哪種資料結構來追蹤「當前進行中會議的結束時間」最為合適？",
        "en": "Which data structure is most suitable for tracking the 'end times of currently ongoing meetings'?",
        "wg": [
          {
            "t": "追蹤",
            "en": "track",
            "ps": "V"
          },
          {
            "t": "進行中",
            "en": "ongoing",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆疊 (Stack)",
        "en": "(A) Stack",
        "wg": []
      },
      {
        "t": "(B) 佇列 (Queue)",
        "en": "(B) Queue",
        "wg": []
      },
      {
        "t": "(C) 最小堆積 (Min-Heap / Priority Queue)",
        "en": "(C) Min-Heap / Priority Queue",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 雜湊集 (HashSet)",
        "en": "(D) HashSet",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "最小堆積可以讓我們以 O(1) 的時間取得最早結束的會議。",
      "en": "A Min-Heap allows us to access the meeting that ends the earliest in O(1) time.",
      "wg": []
    },
    "why_detail": {
      "t": "若新會議的開始時間大於堆頂的結束時間，代表可以重複使用該會議室（將堆頂彈出），否則需要開設新房間（推入堆積）。",
      "en": "If the new meeting's start time is greater than the top of the heap's end time, it means the room can be reused (pop the top); otherwise, a new room is needed (push to heap).",
      "wg": [
        {
          "t": "重複使用",
          "en": "reuse",
          "ps": "V"
        },
        {
          "t": "彈出",
          "en": "pop",
          "ps": "V"
        }
      ]
    }
  }
]