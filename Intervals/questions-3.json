[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Intervals, Sorting, Time Complexity, Merge Intervals",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「合併區間」(Merge Intervals) 問題時，我們通常會先根據區間的起始時間進行排序。",
        "en": "When solving the 'Merge Intervals' problem, we usually sort the intervals based on their start times first.",
        "wg": [
          {
            "t": "合併區間",
            "en": "Merge Intervals",
            "ps": "NP"
          },
          {
            "t": "起始時間",
            "en": "start times",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這樣做的主要好處是什麼？",
        "en": "What is the primary benefit of doing this?",
        "wg": [
          {
            "t": "主要好處",
            "en": "primary benefit",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以確保區間的結束時間也是遞增的，簡化邏輯。",
        "en": "(A) It ensures that the end times of the intervals are also increasing, simplifying the logic.",
        "wg": []
      },
      {
        "t": "(B) 它允許我們僅透過一次線性掃描即可完成合併，因為相鄰的區間在排序後更有可能重疊。",
        "en": "(B) It allows us to complete the merge in a single linear scan because adjacent intervals are more likely to overlap after sorting.",
        "wg": [
          {
            "t": "線性掃描",
            "en": "linear scan",
            "ps": "NP"
          },
          {
            "t": "相鄰的",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 這是使用二分搜尋法尋找重疊區間的必要條件。",
        "en": "(C) It is a prerequisite for using binary search to find overlapping intervals.",
        "wg": []
      },
      {
        "t": "(D) 它可以將空間複雜度降低到 O(1)。",
        "en": "(D) It reduces the space complexity to O(1).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據起始時間排序後，對於任何區間 `curr`，我們只需要檢查它是否與前一個合併後的區間 `prev` 重疊。如果 `curr.start <= prev.end`，則重疊並合併；否則，`curr` 開始一個新的不重疊區間。這使得演算法可以在 O(N) 的線性時間內完成（不含排序時間）。",
      "en": "After sorting by start time, for any interval `curr`, we only need to check if it overlaps with the previous merged interval `prev`. If `curr.start <= prev.end`, they overlap and merge; otherwise, `curr` starts a new non-overlapping interval. This allows the algorithm to complete in O(N) linear time (excluding sorting time).",
      "wg": [
        {
          "t": "重疊",
          "en": "overlap",
          "ps": "V"
        },
        {
          "t": "線性時間",
          "en": "linear time",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Intervals, Insert Interval, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "newInterval = [s, e], currentInterval = [a, b]",
    "question": [
      {
        "t": "在「插入區間」(Insert Interval) 問題中，當我們遍歷現有的排序區間列表時，發現 `newInterval` 與 `currentInterval` 重疊。",
        "en": "In the 'Insert Interval' problem, while iterating through the existing sorted list of intervals, we find that `newInterval` overlaps with `currentInterval`.",
        "wg": [
          {
            "t": "插入區間",
            "en": "Insert Interval",
            "ps": "NP"
          },
          {
            "t": "遍歷",
            "en": "iterating",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了合併這兩個區間，我們應該如何更新 `newInterval` 的範圍？",
        "en": "To merge these two intervals, how should we update the range of `newInterval`?",
        "wg": [
          {
            "t": "範圍",
            "en": "range",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [max(s, a), min(e, b)]",
        "en": "(A) [max(s, a), min(e, b)]",
        "wg": []
      },
      {
        "t": "(B) [min(s, a), max(e, b)]",
        "en": "(B) [min(s, a), max(e, b)]",
        "wg": []
      },
      {
        "t": "(C) [s, b]",
        "en": "(C) [s, b]",
        "wg": []
      },
      {
        "t": "(D) [a, e]",
        "en": "(D) [a, e]",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當兩個區間重疊時，合併後的區間必須涵蓋兩者的聯集。因此，新的起始點是兩者起始點的最小值 `min(s, a)`，而新的結束點是兩者結束點的最大值 `max(e, b)`。選項 (A) 計算的是交集而非聯集。",
      "en": "When two intervals overlap, the merged interval must cover the union of both. Therefore, the new start point is the minimum of the two start points `min(s, a)`, and the new end point is the maximum of the two end points `max(e, b)`. Option (A) calculates the intersection, not the union.",
      "wg": [
        {
          "t": "聯集",
          "en": "union",
          "ps": "N"
        },
        {
          "t": "交集",
          "en": "intersection",
          "ps": "N"
        },
        {
          "t": "涵蓋",
          "en": "cover",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Intervals, Meeting Rooms II, Min-Heap, Priority Queue",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "針對「會議室 II」(Meeting Rooms II) 問題，我們需要找出舉辦所有會議所需的最少會議室數量。",
        "en": "For the 'Meeting Rooms II' problem, we need to find the minimum number of conference rooms required to hold all meetings.",
        "wg": [
          {
            "t": "會議室",
            "en": "conference rooms",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來優化解法，堆積中應該儲存什麼資訊？",
        "en": "If using a Min-Heap to optimize the solution, what information should be stored in the heap?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "NP"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 會議的持續時間 (Duration)。",
        "en": "(A) The duration of the meetings.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 目前正在進行的會議的結束時間 (End Times)。",
        "en": "(B) The end times of the currently ongoing meetings.",
        "wg": [
          {
            "t": "正在進行",
            "en": "ongoing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 所有會議的起始時間 (Start Times)。",
        "en": "(C) The start times of all meetings.",
        "wg": []
      },
      {
        "t": "(D) 會議室的編號 (Room IDs)。",
        "en": "(D) The Room IDs.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最小堆積用於追蹤目前佔用會議室的會議何時結束。當處理一個新會議時，我們檢查堆積頂端（最早結束的會議）是否早於新會議的開始時間。如果是，代表該會議室已釋放，我們可以重複使用（pop 出堆積）；否則，我們需要一個新會議室（push 進堆積）。堆積的大小即為所需的會議室數量。",
      "en": "The Min-Heap is used to track when the meetings currently occupying rooms will end. When processing a new meeting, we check if the top of the heap (the meeting ending earliest) is earlier than the new meeting's start time. If so, the room is freed and can be reused (pop from heap); otherwise, a new room is needed (push to heap). The size of the heap represents the number of rooms required.",
      "wg": [
        {
          "t": "釋放",
          "en": "freed",
          "ps": "V"
        },
        {
          "t": "重複使用",
          "en": "reused",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Intervals, Non-overlapping Intervals, Greedy Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「無重疊區間」(Non-overlapping Intervals) 問題中，目標是移除最少數量的區間，使剩餘區間互不重疊。",
        "en": "In the 'Non-overlapping Intervals' problem, the goal is to remove the minimum number of intervals so that the remaining intervals are mutually non-overlapping.",
        "wg": [
          {
            "t": "無重疊區間",
            "en": "Non-overlapping Intervals",
            "ps": "NP"
          },
          {
            "t": "互不重疊",
            "en": "mutually non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "採用貪婪演算法 (Greedy) 時，最常見且直觀的排序策略是什麼？",
        "en": "When adopting a Greedy algorithm, what is the most common and intuitive sorting strategy?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy algorithm",
            "ps": "NP"
          },
          {
            "t": "直觀的",
            "en": "intuitive",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據區間長度由短到長排序。",
        "en": "(A) Sort by interval length from shortest to longest.",
        "wg": []
      },
      {
        "t": "(B) 根據結束時間由早到晚排序。",
        "en": "(B) Sort by end time from earliest to latest.",
        "wg": []
      },
      {
        "t": "(C) 根據結束時間由晚到早排序。",
        "en": "(C) Sort by end time from latest to earliest.",
        "wg": []
      },
      {
        "t": "(D) 隨機排序。",
        "en": "(D) Sort randomly.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據結束時間排序（由早到晚）是標準的貪婪策略。邏輯是：結束時間越早的區間，留給後續區間的空間就越大，從而能容納更多的區間。這等同於經典的「活動選擇問題」(Activity Selection Problem)。雖然根據起始時間排序也可以解題，但邏輯稍微複雜一些。",
      "en": "Sorting by end time (earliest to latest) is the standard greedy strategy. The logic is: the earlier an interval ends, the more space is left for subsequent intervals, thereby accommodating more intervals. This is equivalent to the classic 'Activity Selection Problem'. While sorting by start time can also solve it, the logic is slightly more complex.",
      "wg": [
        {
          "t": "容納",
          "en": "accommodating",
          "ps": "V"
        },
        {
          "t": "活動選擇問題",
          "en": "Activity Selection Problem",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Intervals, Interval List Intersections, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "List A, List B (both sorted)",
    "question": [
      {
        "t": "給定兩個已排序的區間列表 A 和 B，我們使用雙指標 (Two Pointers) 方法來找出它們的交集。",
        "en": "Given two sorted interval lists A and B, we use the Two Pointers method to find their intersection.",
        "wg": [
          {
            "t": "雙指標",
            "en": "Two Pointers",
            "ps": "NP"
          },
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在計算完當前兩個區間的交集後，決定移動哪個指標（`i` 指向 A，`j` 指向 B）的正確邏輯是什麼？",
        "en": "After calculating the intersection of the current two intervals, what is the correct logic to decide which pointer (`i` for A, `j` for B) to move?",
        "wg": [
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 移動結束時間較早的那個區間的指標。",
        "en": "(A) Move the pointer of the interval that ends earlier.",
        "wg": []
      },
      {
        "t": "(B) 移動起始時間較早的那個區間的指標。",
        "en": "(B) Move the pointer of the interval that starts earlier.",
        "wg": []
      },
      {
        "t": "(C) 總是同時移動兩個指標。",
        "en": "(C) Always move both pointers simultaneously.",
        "wg": []
      },
      {
        "t": "(D) 移動區間長度較短的指標。",
        "en": "(D) Move the pointer of the interval with the shorter length.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "我們應該移動結束時間較早的區間指標。因為該區間已經結束，不可能再與另一個列表中的後續區間產生交集。如果 `A[i].end < B[j].end`，我們增加 `i`；否則增加 `j`。",
      "en": "We should move the pointer of the interval that ends earlier. Since that interval has ended, it cannot possibly intersect with any subsequent intervals in the other list. If `A[i].end < B[j].end`, we increment `i`; otherwise, we increment `j`.",
      "wg": [
        {
          "t": "後續區間",
          "en": "subsequent intervals",
          "ps": "NP"
        },
        {
          "t": "產生交集",
          "en": "intersect",
          "ps": "V"
        }
      ]
    }
  }
]