[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Intervals, Linear Scan, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「插入區間」(Insert Interval) 問題時，我們通常會將輸入的區間列表視為已排序且不重疊。",
        "en": "When solving the 'Insert Interval' problem, we usually treat the input list of intervals as sorted and non-overlapping.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          },
          {
            "t": "不重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "演算法通常分為三個階段處理：左側不重疊區間、中間重疊合併區間、以及右側不重疊區間。",
        "en": "The algorithm is typically processed in three stages: left non-overlapping intervals, middle overlapping intervals to merge, and right non-overlapping intervals.",
        "wg": [
          {
            "t": "階段",
            "en": "stage",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問在「中間合併階段」，判斷當前區間 `curr` 與新區間 `newInterval` 是否重疊的正確條件是什麼？",
        "en": "In the 'middle merging stage', what is the correct condition to determine if the current interval `curr` overlaps with the `newInterval`?",
        "wg": [
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          },
          {
            "t": "條件",
            "en": "condition",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `curr.end < newInterval.start`",
        "en": "(A) `curr.end < newInterval.start`",
        "wg": []
      },
      {
        "t": "(B) `curr.start > newInterval.end`",
        "en": "(B) `curr.start > newInterval.end`",
        "wg": []
      },
      {
        "t": "(C) `curr.end >= newInterval.start` 且 `curr.start <= newInterval.end`",
        "en": "(C) `curr.end >= newInterval.start` and `curr.start <= newInterval.end`",
        "wg": []
      },
      {
        "t": "(D) `curr.start == newInterval.start`",
        "en": "(D) `curr.start == newInterval.start`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "兩個區間重疊的定義是：第一個區間的結束時間大於等於第二個區間的開始時間，且第一個區間的開始時間小於等於第二個區間的結束時間。(A) 代表 `curr` 完全在 `newInterval` 左側，(B) 代表 `curr` 完全在 `newInterval` 右側。",
      "en": "The definition of two intervals overlapping is: the end time of the first interval is greater than or equal to the start time of the second, and the start time of the first is less than or equal to the end time of the second. (A) means `curr` is strictly to the left, and (B) means `curr` is strictly to the right.",
      "wg": [
        {
          "t": "定義",
          "en": "definition",
          "ps": "N"
        },
        {
          "t": "嚴格地",
          "en": "strictly",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Intervals, Greedy, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個區間集合，您需要移除最少數量的區間，使剩餘的區間互不重疊（Non-overlapping Intervals）。",
        "en": "Given a collection of intervals, you need to remove the minimum number of intervals to make the rest of the intervals non-overlapping.",
        "wg": [
          {
            "t": "集合",
            "en": "collection",
            "ps": "N"
          },
          {
            "t": "剩餘的",
            "en": "rest of/remaining",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "這是一個典型的貪婪演算法（Greedy）問題。",
        "en": "This is a typical Greedy algorithm problem.",
        "wg": [
          {
            "t": "典型的",
            "en": "typical",
            "ps": "Adj"
          },
          {
            "t": "貪婪演算法",
            "en": "Greedy algorithm",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了達到最佳解，您應該依據什麼屬性來對區間進行排序？",
        "en": "To achieve the optimal solution, based on which attribute should you sort the intervals?",
        "wg": [
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          },
          {
            "t": "屬性",
            "en": "attribute",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據「開始時間」由小到大排序。",
        "en": "(A) Sort by 'start time' in ascending order.",
        "wg": []
      },
      {
        "t": "(B) 依據「結束時間」由小到大排序。",
        "en": "(B) Sort by 'end time' in ascending order.",
        "wg": []
      },
      {
        "t": "(C) 依據「區間長度」由小到大排序。",
        "en": "(C) Sort by 'interval duration' in ascending order.",
        "wg": []
      },
      {
        "t": "(D) 依據「開始時間」由大到小排序。",
        "en": "(D) Sort by 'start time' in descending order.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "依據「結束時間」排序是最佳策略，因為結束時間越早的區間，留給後續區間的空間就越多，從而能容納更多的互不重疊區間。",
      "en": "Sorting by 'end time' is the optimal strategy because an interval that ends earlier leaves more room for subsequent intervals, thereby accommodating more non-overlapping intervals.",
      "wg": [
        {
          "t": "策略",
          "en": "strategy",
          "ps": "N"
        },
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Intervals, Two Pointers, Intersection",
    "parentNo": null,
    "images": null,
    "codeSnippet": "start = max(A[i].start, B[j].start);\nend = min(A[i].end, B[j].end);\nif (start <= end) result.add([start, end]);",
    "question": [
      {
        "t": "在計算兩個已排序區間列表的「交集」(Interval List Intersections) 時，我們常使用雙指標法。",
        "en": "When calculating the 'Interval List Intersections' of two sorted interval lists, we often use the two-pointer approach.",
        "wg": [
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          },
          {
            "t": "雙指標",
            "en": "two-pointer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設指標 `i` 指向列表 A 的區間，指標 `j` 指向列表 B 的區間。",
        "en": "Assume pointer `i` points to an interval in list A, and pointer `j` points to an interval in list B.",
        "wg": []
      },
      {
        "t": "在計算完當前的交集後，我們應該如何移動指標以確保不遺漏任何可能的交集？",
        "en": "After calculating the current intersection, how should we move the pointers to ensure no potential intersections are missed?",
        "wg": [
          {
            "t": "遺漏",
            "en": "miss",
            "ps": "V"
          },
          {
            "t": "潛在的",
            "en": "potential",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 總是同時移動 `i` 和 `j` (即 `i++`, `j++`)。",
        "en": "(A) Always move both `i` and `j` simultaneously (i.e., `i++`, `j++`).",
        "wg": []
      },
      {
        "t": "(B) 移動「結束時間」較早的那個區間的指標。",
        "en": "(B) Move the pointer of the interval with the earlier 'end time'.",
        "wg": []
      },
      {
        "t": "(C) 移動「開始時間」較早的那個區間的指標。",
        "en": "(C) Move the pointer of the interval with the earlier 'start time'.",
        "wg": []
      },
      {
        "t": "(D) 只有當兩個區間完全不重疊時才移動指標。",
        "en": "(D) Only move pointers when the two intervals do not overlap at all.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為結束時間較早的區間不可能再與後續的任何區間產生交集，所以我們應該將其指標向前移動以檢查下一個區間。",
      "en": "Since the interval with the earlier end time cannot possibly intersect with any subsequent intervals, we should advance its pointer to check the next interval.",
      "wg": [
        {
          "t": "後續的",
          "en": "subsequent",
          "ps": "Adj"
        },
        {
          "t": "推進/移動",
          "en": "advance",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Intervals, Sorting, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於「合併區間」(Merge Intervals) 問題的時間複雜度分析，以下敘述何者正確？",
        "en": "Regarding the time complexity analysis of the 'Merge Intervals' problem, which of the following statements is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          },
          {
            "t": "分析",
            "en": "analysis",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設輸入陣列包含 N 個區間。",
        "en": "Assume the input array contains N intervals.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 時間複雜度為 O(N)，因為我們只需要遍歷一次陣列。",
        "en": "(A) The time complexity is O(N) because we only need to iterate through the array once.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate through",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 時間複雜度為 O(N log N)，主要消耗在對區間進行排序。",
        "en": "(B) The time complexity is O(N log N), primarily dominated by sorting the intervals.",
        "wg": [
          {
            "t": "主要",
            "en": "primarily",
            "ps": "Adv"
          },
          {
            "t": "主導/消耗",
            "en": "dominated",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 時間複雜度為 O(N^2)，因為每個區間都需要與其他區間比較。",
        "en": "(C) The time complexity is O(N^2) because each interval needs to be compared with every other interval.",
        "wg": []
      },
      {
        "t": "(D) 空間複雜度必定為 O(1)，因為我們可以原地合併。",
        "en": "(D) The space complexity is definitely O(1) because we can merge in-place.",
        "wg": [
          {
            "t": "原地",
            "en": "in-place",
            "ps": "Adv"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "合併區間的前提是區間必須按開始時間排序。排序通常需要 O(N log N)。排序後，線性掃描只需要 O(N)，因此總複雜度由排序主導。",
      "en": "The prerequisite for merging intervals is that they must be sorted by start time. Sorting typically takes O(N log N). After sorting, the linear scan takes only O(N), so the total complexity is dominated by sorting.",
      "wg": [
        {
          "t": "前提",
          "en": "prerequisite",
          "ps": "N"
        },
        {
          "t": "線性掃描",
          "en": "linear scan",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Intervals, Sweep Line, Meeting Rooms",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「會議室 II」(Meeting Rooms II) 問題時，我們需要找出同時進行的會議最大數量。",
        "en": "When solving the 'Meeting Rooms II' problem, we need to find the maximum number of concurrent meetings.",
        "wg": [
          {
            "t": "同時進行的",
            "en": "concurrent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "有一種解法是將所有開始時間和結束時間分開處理，並依照時間順序掃描。",
        "en": "One approach is to treat all start times and end times separately and scan them in chronological order.",
        "wg": [
          {
            "t": "依照時間順序",
            "en": "chronological order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當掃描線遇到一個「開始時間」時，計數器應該如何變化？",
        "en": "How should the counter change when the sweep line encounters a 'start time'?",
        "wg": [
          {
            "t": "掃描線",
            "en": "sweep line",
            "ps": "N"
          },
          {
            "t": "遇到",
            "en": "encounter",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 計數器加 1，表示需要一間新的會議室。",
        "en": "(A) Increment the counter by 1, indicating a new room is needed.",
        "wg": [
          {
            "t": "增加",
            "en": "increment",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 計數器減 1，表示會議結束。",
        "en": "(B) Decrement the counter by 1, indicating a meeting has ended.",
        "wg": [
          {
            "t": "減少",
            "en": "decrement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 計數器不變，只記錄時間。",
        "en": "(C) The counter remains unchanged; only the time is recorded.",
        "wg": []
      },
      {
        "t": "(D) 如果當前計數器大於 0，則減 1，否則加 1。",
        "en": "(D) If the current counter is greater than 0, decrement it; otherwise, increment it.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "遇到開始時間意味著一個會議開始，佔用了一個房間，因此計數器（代表當前使用的房間數）需要加 1。相反地，遇到結束時間則減 1。",
      "en": "Encountering a start time means a meeting begins and occupies a room, so the counter (representing currently used rooms) needs to be incremented by 1. Conversely, encountering an end time decrements it.",
      "wg": [
        {
          "t": "佔用",
          "en": "occupy",
          "ps": "V"
        },
        {
          "t": "相反地",
          "en": "conversely",
          "ps": "Adv"
        }
      ]
    }
  }
]