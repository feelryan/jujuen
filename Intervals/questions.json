[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Intervals, Sorting, Array, Merge",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]",
    "question": [
      {
        "t": "在解決「合併區間」(Merge Intervals) 問題時，為了有效地合併重疊的區間，",
        "en": "When solving the 'Merge Intervals' problem, in order to efficiently merge overlapping intervals,",
        "wg": [
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "重疊",
            "en": "overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "通常第一步需要對區間列表執行什麼操作？",
        "en": "what operation is usually required as the first step on the list of intervals?",
        "wg": [
          {
            "t": "執行",
            "en": "perform/execute",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據區間的結束時間進行排序。",
        "en": "(A) Sort based on the end times of the intervals.",
        "wg": []
      },
      {
        "t": "(B) 根據區間的開始時間進行排序。",
        "en": "(B) Sort based on the start times of the intervals.",
        "wg": []
      },
      {
        "t": "(C) 根據區間的長度（結束時間 - 開始時間）進行排序。",
        "en": "(C) Sort based on the length (end time - start time) of the intervals.",
        "wg": []
      },
      {
        "t": "(D) 不需要排序，可以直接遍歷合併。",
        "en": "(D) No sorting is needed; you can iterate and merge directly.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據開始時間排序可以確保在遍歷時，相鄰的區間最有可能重疊。如果當前區間的結束時間大於下一個區間的開始時間，則它們重疊，這樣只需遍歷一次即可完成合併。",
      "en": "Sorting by start time ensures that adjacent intervals are the most likely to overlap during iteration. If the current interval's end time is greater than the next interval's start time, they overlap, allowing merging in a single pass.",
      "wg": [
        {
          "t": "相鄰的",
          "en": "adjacent",
          "ps": "Adj"
        },
        {
          "t": "一次遍歷",
          "en": "single pass",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Intervals, Overlap, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Interval A = [startA, endA]\nInterval B = [startB, endB]",
    "question": [
      {
        "t": "給定兩個區間 A 和 B，判斷這兩個區間是否重疊（Overlap）的通用條件是什麼？",
        "en": "Given two intervals A and B, what is the general condition to determine if these two intervals overlap?",
        "wg": [
          {
            "t": "通用條件",
            "en": "general condition",
            "ps": "N"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設區間包含邊界值。",
        "en": "Assume the intervals are inclusive of their boundaries.",
        "wg": [
          {
            "t": "包含",
            "en": "inclusive",
            "ps": "Adj"
          },
          {
            "t": "邊界值",
            "en": "boundaries",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) startA <= endB && endA >= startB",
        "en": "(A) startA <= endB && endA >= startB",
        "wg": []
      },
      {
        "t": "(B) startA < startB && endA > endB",
        "en": "(B) startA < startB && endA > endB",
        "wg": []
      },
      {
        "t": "(C) startA == startB || endA == endB",
        "en": "(C) startA == startB || endA == endB",
        "wg": []
      },
      {
        "t": "(D) endA > startB",
        "en": "(D) endA > startB",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "兩個區間重疊的充要條件是：A 的開始時間早於 B 的結束時間，且 A 的結束時間晚於 B 的開始時間。選項 (D) 僅適用於已排序的情況。",
      "en": "The necessary and sufficient condition for two intervals to overlap is: A starts before B ends, and A ends after B starts. Option (D) is only valid if the intervals are already sorted.",
      "wg": [
        {
          "t": "充要條件",
          "en": "necessary and sufficient condition",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Intervals, Greedy, Sorting, Non-overlapping",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「無重疊區間」(Non-overlapping Intervals) 問題中，若要移除最少數量的區間使剩餘區間互不重疊，",
        "en": "In the 'Non-overlapping Intervals' problem, to remove the minimum number of intervals so that the remaining intervals are non-overlapping,",
        "wg": [
          {
            "t": "剩餘",
            "en": "remaining",
            "ps": "Adj"
          },
          {
            "t": "互不重疊",
            "en": "mutually non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "採用貪婪演算法（Greedy Algorithm）時，最佳的排序策略通常是什麼？",
        "en": "when using a Greedy Algorithm, what is typically the optimal sorting strategy?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Algorithm",
            "ps": "N"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據開始時間由小到大排序。",
        "en": "(A) Sort by start time in ascending order.",
        "wg": []
      },
      {
        "t": "(B) 根據結束時間由小到大排序。",
        "en": "(B) Sort by end time in ascending order.",
        "wg": []
      },
      {
        "t": "(C) 根據區間長度由小到大排序。",
        "en": "(C) Sort by interval length in ascending order.",
        "wg": []
      },
      {
        "t": "(D) 根據結束時間由大到小排序。",
        "en": "(D) Sort by end time in descending order.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據結束時間排序並選擇結束時間最早的區間，可以為後續的區間留出最大的空間，從而容納更多不重疊的區間，達到移除最少區間的目的。",
      "en": "Sorting by end time and picking the interval that ends earliest leaves the maximum amount of space for subsequent intervals, thereby accommodating more non-overlapping intervals and achieving the goal of removing the minimum number.",
      "wg": [
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        },
        {
          "t": "後續的",
          "en": "subsequent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Intervals, Meeting Rooms, Heap, Priority Queue",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「會議室 II」(Meeting Rooms II) 問題以計算所需的最少會議室數量時，",
        "en": "When solving the 'Meeting Rooms II' problem to calculate the minimum number of conference rooms required,",
        "wg": [
          {
            "t": "會議室",
            "en": "conference room",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用最小堆積（Min-Heap）來輔助，該堆積主要用來儲存什麼資訊？",
        "en": "if a Min-Heap is used to assist, what information is primarily stored in this heap?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "輔助",
            "en": "assist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 所有會議的開始時間。",
        "en": "(A) The start times of all meetings.",
        "wg": []
      },
      {
        "t": "(B) 目前正在進行的會議的結束時間。",
        "en": "(B) The end times of the meetings currently in progress.",
        "wg": [
          {
            "t": "正在進行",
            "en": "in progress",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 會議的持續時間長度。",
        "en": "(C) The duration length of the meetings.",
        "wg": []
      },
      {
        "t": "(D) 已經結束的會議數量。",
        "en": "(D) The count of meetings that have already ended.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最小堆積用來追蹤分配出去的會議室中「最早結束」的時間。當新會議的開始時間大於堆積頂端的結束時間時，表示可以重複使用該會議室（pop 出堆積），否則需要開設新房間（push 進堆積）。",
      "en": "The Min-Heap is used to track the 'earliest ending' time among allocated rooms. When a new meeting's start time is greater than the end time at the top of the heap, it means that room can be reused (pop from heap); otherwise, a new room is needed (push to heap).",
      "wg": [
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        },
        {
          "t": "分配",
          "en": "allocate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Intervals, Intersection, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "A = [[0,2],[5,10]...]\nB = [[1,5],[8,12]...]",
    "question": [
      {
        "t": "給定兩個由「互不重疊」且「已排序」區間組成的列表 A 和 B，若要找出它們的區間交集（Interval List Intersections），",
        "en": "Given two lists A and B consisting of 'disjoint' and 'sorted' intervals, to find their Interval List Intersections,",
        "wg": [
          {
            "t": "互不重疊",
            "en": "disjoint/non-overlapping",
            "ps": "Adj"
          },
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用雙指標法（Two Pointers）遍歷時，決定移動哪個指標（i 或 j）的依據是什麼？",
        "en": "when using the Two Pointers approach, what is the basis for deciding which pointer (i or j) to move?",
        "wg": [
          {
            "t": "雙指標法",
            "en": "Two Pointers approach",
            "ps": "N"
          },
          {
            "t": "依據",
            "en": "basis",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 移動開始時間較小的那個區間的指標。",
        "en": "(A) Move the pointer of the interval with the smaller start time.",
        "wg": []
      },
      {
        "t": "(B) 移動結束時間較小的那個區間的指標。",
        "en": "(B) Move the pointer of the interval with the smaller end time.",
        "wg": []
      },
      {
        "t": "(C) 總是同時移動兩個指標。",
        "en": "(C) Always move both pointers simultaneously.",
        "wg": []
      },
      {
        "t": "(D) 移動區間長度較短的指標。",
        "en": "(D) Move the pointer of the interval with the shorter length.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為列表已排序，結束時間較早的區間不可能再與後面的任何區間有交集，因此應該移動該區間的指標以檢查下一個區間。",
      "en": "Since the lists are sorted, the interval that ends earlier cannot possibly overlap with any subsequent intervals, so its pointer should be moved to check the next interval.",
      "wg": [
        {
          "t": "不可能",
          "en": "impossible",
          "ps": "Adj"
        },
        {
          "t": "檢查",
          "en": "check/examine",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Intervals, Array, Insert Interval, Merge",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「插入區間」(Insert Interval) 的問題中，您被給定一個依起始時間排序且互不重疊的區間列表，以及一個新的區間。",
        "en": "In the 'Insert Interval' problem, you are given a list of non-overlapping intervals sorted by start time and a new interval.",
        "wg": [
          {
            "t": "互不重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          },
          {
            "t": "插入",
            "en": "insert",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當您遍歷列表並發現當前區間與新區間有重疊時，應該如何更新新區間以進行合併？",
        "en": "When you iterate through the list and find that the current interval overlaps with the new interval, how should you update the new interval to merge them?",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          },
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 取兩個區間起始時間的最小值作為新起始時間，取兩個區間結束時間的最大值作為新結束時間。",
        "en": "(A) Take the minimum of the two start times as the new start time, and the maximum of the two end times as the new end time.",
        "wg": [
          {
            "t": "最小值",
            "en": "minimum",
            "ps": "N"
          },
          {
            "t": "最大值",
            "en": "maximum",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 僅更新結束時間為兩個區間結束時間的總和。",
        "en": "(B) Only update the end time to be the sum of the two end times.",
        "wg": []
      },
      {
        "t": "(C) 保留原始列表中的區間，並將新區間插入到其後方。",
        "en": "(C) Keep the interval from the original list and insert the new interval after it.",
        "wg": []
      },
      {
        "t": "(D) 取兩個區間起始時間的最大值作為新起始時間，取兩個區間結束時間的最小值作為新結束時間。",
        "en": "(D) Take the maximum of the two start times as the new start time, and the minimum of the two end times as the new end time.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "當兩個區間重疊時，合併後的區間範圍必須涵蓋兩者的聯集。",
      "en": "When two intervals overlap, the merged interval must cover the union of both.",
      "wg": [
        {
          "t": "聯集",
          "en": "union",
          "ps": "N"
        },
        {
          "t": "涵蓋",
          "en": "cover",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Intervals, Greedy, Sorting, Non-overlapping Intervals",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「無重疊區間」(Non-overlapping Intervals) 問題時，目標是移除最少數量的區間以使剩餘區間互不重疊。",
        "en": "When solving the 'Non-overlapping Intervals' problem, the goal is to remove the minimum number of intervals to make the rest non-overlapping.",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "剩餘",
            "en": "rest / remaining",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了使用貪婪演算法(Greedy Approach)達到最佳解，您應該依據什麼條件對區間進行排序？",
        "en": "To achieve the optimal solution using a Greedy Approach, based on what criteria should you sort the intervals?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Approach",
            "ps": "N"
          },
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據區間的長度（持續時間）由小到大排序。",
        "en": "(A) Sort by the length (duration) of the intervals in ascending order.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 依據區間的起始時間由小到大排序。",
        "en": "(B) Sort by the start time of the intervals in ascending order.",
        "wg": []
      },
      {
        "t": "(C) 依據區間的結束時間由小到大排序。",
        "en": "(C) Sort by the end time of the intervals in ascending order.",
        "wg": []
      },
      {
        "t": "(D) 依據區間的起始時間由大到小排序。",
        "en": "(D) Sort by the start time of the intervals in descending order.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "依據結束時間排序可以確保我們總是選擇最早結束的區間，從而為後續的區間留出最大的空間，這是標準的貪婪策略。",
      "en": "Sorting by end time ensures that we always pick the interval that ends earliest, thereby leaving the most space for subsequent intervals, which is a standard greedy strategy.",
      "wg": [
        {
          "t": "後續的",
          "en": "subsequent",
          "ps": "Adj"
        },
        {
          "t": "空間",
          "en": "room / space",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Intervals, Heap, Priority Queue, Meeting Rooms II",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「會議室 II」(Meeting Rooms II) 問題中，我們需要計算同時進行的會議所需的最少會議室數量。",
        "en": "In the 'Meeting Rooms II' problem, we need to calculate the minimum number of conference rooms required for concurrent meetings.",
        "wg": [
          {
            "t": "同時進行的",
            "en": "concurrent",
            "ps": "Adj"
          },
          {
            "t": "會議室",
            "en": "conference room",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來解決此問題，堆積中儲存的數據應該是什麼？",
        "en": "If using a Min-Heap to solve this problem, what data should be stored in the heap?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "儲存",
            "en": "store",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 所有會議的起始時間，用於排序會議。",
        "en": "(A) The start times of all meetings, used for sorting meetings.",
        "wg": []
      },
      {
        "t": "(B) 目前正在使用會議室的會議之結束時間。",
        "en": "(B) The end times of meetings that are currently using a room.",
        "wg": []
      },
      {
        "t": "(C) 會議的持續時間，用於優先處理短會議。",
        "en": "(C) The duration of meetings, used to prioritize short meetings.",
        "wg": [
          {
            "t": "優先處理",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 已經結束的會議數量。",
        "en": "(D) The count of meetings that have already ended.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最小堆積用來追蹤最早結束的會議。如果新的會議起始時間大於堆積頂端的結束時間，代表可以重複使用該會議室（將堆積頂端彈出並加入新結束時間）；否則需要開設新房間（直接加入堆積）。",
      "en": "The Min-Heap tracks the meeting that ends the earliest. If a new meeting's start time is greater than the heap's top end time, the room can be reused (pop the top and push the new end time); otherwise, a new room is needed (push directly).",
      "wg": [
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        },
        {
          "t": "重複使用",
          "en": "reuse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Intervals, Two Pointers, Intersection",
    "parentNo": null,
    "images": null,
    "codeSnippet": "start = max(A.start, B.start)\nend = min(A.end, B.end)",
    "question": [
      {
        "t": "給定兩個由閉區間組成的列表 A 和 B，若要找出區間 A[i] 與 B[j] 的交集 (Intersection)。",
        "en": "Given two lists of closed intervals A and B, to find the intersection of interval A[i] and B[j].",
        "wg": [
          {
            "t": "閉區間",
            "en": "closed interval",
            "ps": "N"
          },
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們可以使用公式 `start = max(A.start, B.start)` 和 `end = min(A.end, B.end)`。",
        "en": "We can use the formula `start = max(A.start, B.start)` and `end = min(A.end, B.end)`.",
        "wg": []
      },
      {
        "t": "請問判斷兩者「存在交集」的條件為何？",
        "en": "What is the condition to determine that an 'intersection exists' between the two?",
        "wg": [
          {
            "t": "條件",
            "en": "condition",
            "ps": "N"
          },
          {
            "t": "存在",
            "en": "exist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) start <= end",
        "en": "(A) start <= end",
        "wg": []
      },
      {
        "t": "(B) start > end",
        "en": "(B) start > end",
        "wg": []
      },
      {
        "t": "(C) start == end",
        "en": "(C) start == end",
        "wg": []
      },
      {
        "t": "(D) A.start < B.end AND B.start < A.end",
        "en": "(D) A.start < B.end AND B.start < A.end",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "計算出的交集起始點必須小於或等於結束點，該交集才有效。若 `start > end`，表示兩個區間沒有重疊。",
      "en": "The calculated intersection start point must be less than or equal to the end point for the intersection to be valid. If `start > end`, it means the two intervals do not overlap.",
      "wg": [
        {
          "t": "有效",
          "en": "valid",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Intervals, Time Complexity, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理「合併區間」(Merge Intervals) 問題時，如果輸入的區間集合尚未排序。",
        "en": "When dealing with the 'Merge Intervals' problem, if the input collection of intervals is not yet sorted.",
        "wg": [
          {
            "t": "尚未",
            "en": "not yet",
            "ps": "Adv"
          },
          {
            "t": "集合",
            "en": "collection",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問整個演算法的時間複雜度主要受限於哪個步驟，且其複雜度為何？",
        "en": "Which step dominates the time complexity of the entire algorithm, and what is that complexity?",
        "wg": [
          {
            "t": "受限於",
            "en": "dominated by / limited by",
            "ps": "V"
          },
          {
            "t": "複雜度",
            "en": "complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 受限於合併過程，複雜度為 O(N)。",
        "en": "(A) Dominated by the merging process, complexity is O(N).",
        "wg": []
      },
      {
        "t": "(B) 受限於排序過程，複雜度為 O(N log N)。",
        "en": "(B) Dominated by the sorting process, complexity is O(N log N).",
        "wg": []
      },
      {
        "t": "(C) 受限於兩兩比較，複雜度為 O(N^2)。",
        "en": "(C) Dominated by pairwise comparison, complexity is O(N^2).",
        "wg": [
          {
            "t": "兩兩比較",
            "en": "pairwise comparison",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 受限於空間分配，複雜度為 O(1)。",
        "en": "(D) Dominated by space allocation, complexity is O(1).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "合併區間的前提是區間需要依起始時間排序。排序通常需要 O(N log N) 的時間，而排序後的線性掃描合併僅需 O(N)，因此整體複雜度由排序決定。",
      "en": "The prerequisite for merging intervals is that they are sorted by start time. Sorting typically takes O(N log N), while the linear scan for merging after sorting only takes O(N), so the overall complexity is determined by sorting.",
      "wg": [
        {
          "t": "前提",
          "en": "prerequisite",
          "ps": "N"
        },
        {
          "t": "線性掃描",
          "en": "linear scan",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Intervals, Sorting, Merge Intervals, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
    "question": [
      {
        "t": "在解決「合併區間」(Merge Intervals) 問題時，我們通常會先對區間進行排序。",
        "en": "When solving the 'Merge Intervals' problem, we usually sort the intervals first.",
        "wg": [
          {
            "t": "合併區間",
            "en": "Merge Intervals",
            "ps": "NP"
          },
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問最理想的排序依據是什麼，以及為什麼這樣做能簡化問題？",
        "en": "What is the ideal criteria for sorting, and why does it simplify the problem?",
        "wg": [
          {
            "t": "依據",
            "en": "criteria",
            "ps": "N"
          },
          {
            "t": "簡化",
            "en": "simplify",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據結束時間排序；這樣可以確保最早結束的區間被優先處理。",
        "en": "(A) Sort by end time; this ensures intervals that finish earliest are processed first.",
        "wg": []
      },
      {
        "t": "(B) 依據開始時間排序；這樣可以保證重疊的區間在陣列中是相鄰的。",
        "en": "(B) Sort by start time; this ensures that overlapping intervals are adjacent in the array.",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 依據區間長度排序；這樣可以優先合併較短的區間。",
        "en": "(C) Sort by interval length; this allows merging shorter intervals first.",
        "wg": []
      },
      {
        "t": "(D) 不需要排序；使用雜湊表 (Hash Map) 即可在 O(N) 時間內完成合併。",
        "en": "(D) No sorting is needed; a Hash Map can complete the merge in O(N) time.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "依據開始時間排序後，對於任何區間 `curr`，我們只需要檢查它是否與前一個區間 `prev` 重疊（即 `curr.start <= prev.end`）。這將問題簡化為線性掃描，因為所有潛在的合併候選者都聚集在一起。",
      "en": "After sorting by start time, for any interval `curr`, we only need to check if it overlaps with the previous interval `prev` (i.e., `curr.start <= prev.end`). This simplifies the problem to a linear scan because all potential merge candidates are clustered together.",
      "wg": [
        {
          "t": "線性掃描",
          "en": "linear scan",
          "ps": "NP"
        },
        {
          "t": "候選者",
          "en": "candidate",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Insert Interval, Edge Cases, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: intervals = [[1,3],[6,9]], newInterval = [2,5]",
    "question": [
      {
        "t": "在「插入區間」(Insert Interval) 問題中，當我們發現新區間 (newInterval) 與當前遍歷到的區間 (interval) 重疊時，需要進行合併。",
        "en": "In the 'Insert Interval' problem, when we find that the new interval (newInterval) overlaps with the currently traversed interval (interval), we need to merge them.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "重疊",
            "en": "overlap",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一個邏輯正確描述了合併後的新區間範圍？",
        "en": "Which of the following logic correctly describes the range of the merged new interval?",
        "wg": [
          {
            "t": "範圍",
            "en": "range",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `[min(interval.start, newInterval.start), min(interval.end, newInterval.end)]`",
        "en": "(A) `[min(interval.start, newInterval.start), min(interval.end, newInterval.end)]`",
        "wg": []
      },
      {
        "t": "(B) `[max(interval.start, newInterval.start), min(interval.end, newInterval.end)]`",
        "en": "(B) `[max(interval.start, newInterval.start), min(interval.end, newInterval.end)]`",
        "wg": []
      },
      {
        "t": "(C) `[min(interval.start, newInterval.start), max(interval.end, newInterval.end)]`",
        "en": "(C) `[min(interval.start, newInterval.start), max(interval.end, newInterval.end)]`",
        "wg": []
      },
      {
        "t": "(D) `[interval.start, newInterval.end]`",
        "en": "(D) `[interval.start, newInterval.end]`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "合併兩個重疊區間時，新的起始點應為兩者中較早的開始時間，而新的結束點應為兩者中較晚的結束時間，以確保覆蓋所有重疊的時間段。",
      "en": "When merging two overlapping intervals, the new start point should be the earlier start time of the two, and the new end point should be the later end time of the two, ensuring coverage of the entire overlapping period.",
      "wg": [
        {
          "t": "覆蓋",
          "en": "cover",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Meeting Rooms, Heap, Priority Queue, Sweepline",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在解決「會議室 II」(Meeting Rooms II) 問題，目標是找出安排所有會議所需的最少會議室數量。",
        "en": "You are solving the 'Meeting Rooms II' problem, aiming to find the minimum number of conference rooms required to schedule all meetings.",
        "wg": [
          {
            "t": "會議室",
            "en": "conference room",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來輔助解題，堆積中應該儲存什麼資訊，且其代表的意義為何？",
        "en": "If you use a Min-Heap to assist in solving the problem, what information should be stored in the heap, and what does it represent?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "輔助",
            "en": "assist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 儲存會議的「開始時間」；代表最早開始的會議。",
        "en": "(A) Store the 'start time' of meetings; representing the meeting that starts earliest.",
        "wg": []
      },
      {
        "t": "(B) 儲存會議的「持續時間」；代表最短的會議。",
        "en": "(B) Store the 'duration' of meetings; representing the shortest meeting.",
        "wg": []
      },
      {
        "t": "(C) 儲存正在進行中會議的「結束時間」；堆積頂端代表最早釋出的會議室。",
        "en": "(C) Store the 'end time' of ongoing meetings; the top of the heap represents the conference room that will be freed up earliest.",
        "wg": [
          {
            "t": "釋出",
            "en": "free up",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 儲存會議室的「編號」；代表當前空閒的房間索引。",
        "en": "(D) Store the 'ID' of the conference rooms; representing the index of currently empty rooms.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "我們需要追蹤哪些會議室正在使用中。最小堆積儲存「結束時間」可以讓我們以 O(1) 快速查詢最早結束的會議。",
      "en": "We need to track which conference rooms are in use. A Min-Heap storing 'end times' allows us to quickly query the meeting that ends earliest in O(1).",
      "wg": [
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        }
      ]
    },
    "why_extended": {
      "t": "如果新會議的開始時間大於或等於堆積頂端的結束時間，表示該房間已空出，我們可以重複使用（pop 出舊的，push 進新的）；否則就需要開設新房間（直接 push 進新的）。",
      "en": "If the new meeting's start time is greater than or equal to the end time at the top of the heap, it means the room is free and can be reused (pop the old, push the new); otherwise, a new room is needed (push the new directly)."
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Non-overlapping Intervals, Greedy, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一組區間，目標是移除最少數量的區間，使得剩餘的區間互不重疊 (Non-overlapping Intervals)。",
        "en": "Given a collection of intervals, the goal is to remove the minimum number of intervals so that the rest are non-overlapping.",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "互不重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "這是一個典型的貪婪演算法 (Greedy) 問題。請問應該採用哪種貪婪策略來排序和選擇區間？",
        "en": "This is a typical Greedy algorithm problem. Which greedy strategy should be used to sort and select intervals?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy algorithm",
            "ps": "NP"
          },
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據「開始時間」排序；優先保留最早開始的區間。",
        "en": "(A) Sort by 'start time'; prioritize keeping intervals that start earliest.",
        "wg": []
      },
      {
        "t": "(B) 依據「結束時間」排序；優先保留最早結束的區間。",
        "en": "(B) Sort by 'end time'; prioritize keeping intervals that end earliest.",
        "wg": []
      },
      {
        "t": "(C) 依據「區間長度」排序；優先移除最長的區間。",
        "en": "(C) Sort by 'interval length'; prioritize removing the longest intervals.",
        "wg": []
      },
      {
        "t": "(D) 依據「重疊次數」排序；優先移除與最多人重疊的區間。",
        "en": "(D) Sort by 'overlap count'; prioritize removing intervals that overlap with the most others.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "依據「結束時間」排序並選擇最早結束的區間，可以為後續的區間留出最大的空間，從而容納更多互不重疊的區間（即達到移除最少區間的目的）。",
      "en": "Sorting by 'end time' and picking the interval that ends earliest leaves the maximum amount of room for subsequent intervals, thereby accommodating more non-overlapping intervals (which achieves the goal of removing the minimum number of intervals).",
      "wg": [
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "System Design, Data Structure, TreeMap, Balanced BST",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個行事曆系統，需要頻繁地新增預約並檢查是否有時間衝突。",
        "en": "You are designing a calendar system that requires frequent addition of bookings and checking for time conflicts.",
        "wg": [
          {
            "t": "行事曆",
            "en": "calendar",
            "ps": "N"
          },
          {
            "t": "預約",
            "en": "booking",
            "ps": "N"
          },
          {
            "t": "衝突",
            "en": "conflict",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果使用普通的陣列 (Array) 或串列 (List)，每次插入檢查都需要 O(N) 的時間。",
        "en": "If using a plain Array or List, each insertion check takes O(N) time.",
        "wg": []
      },
      {
        "t": "為了將時間複雜度優化至 O(log N)，最適合使用哪種資料結構來儲存區間？",
        "en": "To optimize the time complexity to O(log N), which data structure is most suitable for storing intervals?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 雜湊表 (Hash Map)",
        "en": "(A) Hash Map",
        "wg": []
      },
      {
        "t": "(B) 平衡二元搜尋樹 (Balanced BST)，如 Java 的 TreeMap 或 C++ 的 std::map",
        "en": "(B) Balanced BST, such as Java's TreeMap or C++'s std::map",
        "wg": [
          {
            "t": "平衡二元搜尋樹",
            "en": "Balanced BST",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 優先權佇列 (Priority Queue)",
        "en": "(C) Priority Queue",
        "wg": []
      },
      {
        "t": "(D) 雙向連結串列 (Doubly Linked List)",
        "en": "(D) Doubly Linked List",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "平衡二元搜尋樹 (Balanced BST) 允許我們以 O(log N) 的時間找到小於或大於特定鍵值的最近鄰居（floorKey/ceilingKey）。",
      "en": "A Balanced BST allows us to find the nearest neighbors (floorKey/ceilingKey) less than or greater than a specific key in O(log N) time.",
      "wg": [
        {
          "t": "最近鄰居",
          "en": "nearest neighbor",
          "ps": "NP"
        }
      ]
    },
    "why_extended": {
      "t": "透過檢查新區間是否與這兩個鄰居重疊，即可快速判斷是否可以插入，這比線性掃描更有效率。",
      "en": "By checking if the new interval overlaps with these two neighbors, we can quickly determine if insertion is possible, which is more efficient than a linear scan."
    }
  },
  {
    "no": "16",
    "level": "Medium",
    "keywords": "Intervals, Sorting, Time Complexity, Merge",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]",
    "question": [
      {
        "t": "在解決「合併區間」(Merge Intervals) 問題時，我們通常會先根據區間的起始時間進行排序。",
        "en": "When solving the 'Merge Intervals' problem, we usually sort the intervals based on their start times first.",
        "wg": [
          {
            "t": "合併區間",
            "en": "Merge Intervals",
            "ps": "NP"
          },
          {
            "t": "起始時間",
            "en": "start times",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問這個排序步驟的主要目的是什麼，以及它對整體時間複雜度的影響為何？",
        "en": "What is the primary purpose of this sorting step, and how does it affect the overall time complexity?",
        "wg": [
          {
            "t": "整體",
            "en": "overall",
            "ps": "Adj"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 排序是為了讓重疊的區間在陣列中相鄰，使我們只需線性掃描即可完成合併。整體複雜度由排序決定，為 O(N log N)。",
        "en": "(A) Sorting ensures overlapping intervals are adjacent in the array, allowing us to merge them in a single linear scan. The overall complexity is dominated by sorting, which is O(N log N).",
        "wg": [
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          },
          {
            "t": "線性掃描",
            "en": "linear scan",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 排序是為了使用二元搜尋來尋找重疊區間。整體複雜度為 O(N)。",
        "en": "(B) Sorting is done to use binary search to find overlapping intervals. The overall complexity is O(N).",
        "wg": [
          {
            "t": "二元搜尋",
            "en": "binary search",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 排序並非必要步驟，我們可以使用暴力法比較每對區間，複雜度為 O(N)。",
        "en": "(C) Sorting is not a necessary step; we can use a brute-force approach to compare every pair of intervals with O(N) complexity.",
        "wg": [
          {
            "t": "暴力法",
            "en": "brute-force",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 排序是為了確保結束時間也是遞增的，這樣可以直接取最後一個區間的結束時間。",
        "en": "(D) Sorting ensures that end times are also increasing, so we can directly take the end time of the last interval.",
        "wg": [
          {
            "t": "遞增",
            "en": "increasing",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "排序確保了如果區間 i 與區間 j 重疊 (i < j)，它們在陣列中會是相鄰或接近的。這允許我們只遍歷一次陣列 (O(N)) 就能完成合併。然而，因為排序本身的成本是 O(N log N)，所以整體演算法的時間複雜度受限於排序。",
      "en": "Sorting ensures that if interval i overlaps with interval j (where i < j), they will be adjacent or close in the array. This allows us to merge them by iterating through the array just once (O(N)). However, since the cost of sorting is O(N log N), the overall algorithm's time complexity is dominated by the sorting step.",
      "wg": [
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        },
        {
          "t": "受限於",
          "en": "dominated by",
          "ps": "VP"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "Hard",
    "keywords": "Intervals, Greedy, Sorting, Non-overlapping",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「不重疊區間」(Non-overlapping Intervals) 問題中，目標是移除最少數量的區間，使得剩餘的區間互不重疊。",
        "en": "In the 'Non-overlapping Intervals' problem, the goal is to remove the minimum number of intervals so that the rest are mutually non-overlapping.",
        "wg": [
          {
            "t": "互不重疊",
            "en": "mutually non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若採用貪婪演算法 (Greedy Approach)，最佳的策略通常是根據什麼屬性來排序區間？",
        "en": "If using a Greedy Approach, based on what property should the intervals typically be sorted for the optimal strategy?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Approach",
            "ps": "NP"
          },
          {
            "t": "屬性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據起始時間 (Start Time) 排序。若起始時間相同，則保留較長的區間。",
        "en": "(A) Sort by Start Time. If start times are the same, keep the longer interval.",
        "wg": []
      },
      {
        "t": "(B) 根據區間長度 (Duration) 排序，優先保留短的區間。",
        "en": "(B) Sort by Duration, prioritizing keeping shorter intervals.",
        "wg": [
          {
            "t": "優先",
            "en": "prioritizing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 根據結束時間 (End Time) 排序，並優先選擇結束時間最早的區間。",
        "en": "(C) Sort by End Time, and prioritize selecting the interval that ends the earliest.",
        "wg": []
      },
      {
        "t": "(D) 隨機選擇區間，直到發現重疊為止。",
        "en": "(D) Randomly select intervals until an overlap is found.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "根據結束時間排序並選擇結束最早的區間是標準的貪婪策略。因為結束得越早，留給後續區間的空間就越多，從而能容納更多的區間（即移除最少的區間）。",
      "en": "Sorting by end time and selecting the interval that ends earliest is the standard greedy strategy. Because the sooner an interval ends, the more space is left for subsequent intervals, allowing us to accommodate the maximum number of intervals (i.e., removing the minimum number).",
      "wg": [
        {
          "t": "容納",
          "en": "accommodate",
          "ps": "V"
        },
        {
          "t": "後續",
          "en": "subsequent",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "Medium",
    "keywords": "Intervals, Insert, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "intervals = [[1,3], [6,9]], newInterval = [2,5]",
    "question": [
      {
        "t": "當我們將一個新區間 `newInterval` 插入到一個已經排序且不重疊的區間列表 `intervals` 中時，",
        "en": "When inserting a `newInterval` into an already sorted and non-overlapping list of `intervals`,",
        "wg": [
          {
            "t": "插入",
            "en": "inserting",
            "ps": "V"
          }
        ]
      },
      {
        "t": "我們需要合併所有與 `newInterval` 重疊的區間。",
        "en": "we need to merge all intervals that overlap with `newInterval`.",
        "wg": []
      },
      {
        "t": "請問合併後的區間 `[start, end]` 應該如何計算？",
        "en": "How should the merged interval `[start, end]` be calculated?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) start = min(所有重疊區間的起始點), end = max(所有重疊區間的結束點)。",
        "en": "(A) start = min(start points of all overlapping intervals), end = max(end points of all overlapping intervals).",
        "wg": []
      },
      {
        "t": "(B) start = newInterval.start, end = newInterval.end。",
        "en": "(B) start = newInterval.start, end = newInterval.end.",
        "wg": []
      },
      {
        "t": "(C) start = max(所有重疊區間的起始點), end = min(所有重疊區間的結束點)。",
        "en": "(C) start = max(start points of all overlapping intervals), end = min(end points of all overlapping intervals).",
        "wg": []
      },
      {
        "t": "(D) start = 第一個重疊區間的 start, end = 最後一個重疊區間的 end。",
        "en": "(D) start = start of the first overlapping interval, end = end of the last overlapping interval.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "當多個區間重疊時，合併後的新區間必須涵蓋所有涉及區間的範圍。因此，新的起始點是所有重疊區間（包含 `newInterval`）中最小的起始值，而新的結束點則是最大的結束值。",
      "en": "When multiple intervals overlap, the merged new interval must cover the range of all involved intervals. Therefore, the new start point is the minimum start value among all overlapping intervals (including `newInterval`), and the new end point is the maximum end value.",
      "wg": [
        {
          "t": "涵蓋",
          "en": "cover",
          "ps": "V"
        },
        {
          "t": "涉及",
          "en": "involved",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "Medium",
    "keywords": "Intervals, Intersection, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": "A = [1, 5], B = [4, 8]",
    "question": [
      {
        "t": "給定兩個區間 A 和 B，判斷它們是否重疊的條件為何？",
        "en": "Given two intervals A and B, what is the condition to determine if they overlap?",
        "wg": [
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          },
          {
            "t": "條件",
            "en": "condition",
            "ps": "N"
          }
        ]
      },
      {
        "t": "此外，若它們重疊，其交集區間 (Intersection) 該如何表示？",
        "en": "Furthermore, if they overlap, how is their intersection interval represented?",
        "wg": [
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          },
          {
            "t": "表示",
            "en": "represented",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 重疊條件：A.start <= B.end 且 B.start <= A.end。交集：[max(A.start, B.start), min(A.end, B.end)]。",
        "en": "(A) Overlap condition: A.start <= B.end AND B.start <= A.end. Intersection: [max(A.start, B.start), min(A.end, B.end)].",
        "wg": []
      },
      {
        "t": "(B) 重疊條件：A.start == B.start。交集：[min(A.start, B.start), max(A.end, B.end)]。",
        "en": "(B) Overlap condition: A.start == B.start. Intersection: [min(A.start, B.start), max(A.end, B.end)].",
        "wg": []
      },
      {
        "t": "(C) 重疊條件：A.end > B.start。交集：[A.start, B.end]。",
        "en": "(C) Overlap condition: A.end > B.start. Intersection: [A.start, B.end].",
        "wg": []
      },
      {
        "t": "(D) 重疊條件：A.start < B.end。交集：[B.start, A.end]。",
        "en": "(D) Overlap condition: A.start < B.end. Intersection: [B.start, A.end].",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "兩個區間重疊的充要條件是：一個區間的起始時間必須早於或等於另一個區間的結束時間（雙向皆須成立）。交集的範圍由「較晚開始的時間」到「較早結束的時間」決定。",
      "en": "The necessary and sufficient condition for two intervals to overlap is that the start time of one must be earlier than or equal to the end time of the other (must hold both ways). The range of the intersection is determined from the 'later start time' to the 'earlier end time'.",
      "wg": [
        {
          "t": "充要條件",
          "en": "necessary and sufficient condition",
          "ps": "NP"
        },
        {
          "t": "雙向",
          "en": "both ways",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "Medium",
    "keywords": "Intervals, Meeting Rooms II, Heap, Sweep Line",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「會議室 II」(Meeting Rooms II) 問題中，我們需要找出舉辦所有會議所需的最少會議室數量。",
        "en": "In the 'Meeting Rooms II' problem, we need to find the minimum number of conference rooms required to hold all meetings.",
        "wg": [
          {
            "t": "舉辦",
            "en": "hold",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若使用最小堆積 (Min-Heap) 來解決此問題，堆積中儲存的資料應該是什麼？",
        "en": "If using a Min-Heap to solve this problem, what data should be stored in the heap?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "NP"
          },
          {
            "t": "儲存",
            "en": "stored",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 儲存正在進行中的會議的「結束時間」。",
        "en": "(A) Store the 'end times' of the meetings currently in progress.",
        "wg": [
          {
            "t": "正在進行中",
            "en": "in progress",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 儲存所有會議的「起始時間」。",
        "en": "(B) Store the 'start times' of all meetings.",
        "wg": []
      },
      {
        "t": "(C) 儲存會議的「持續時間」(Duration)。",
        "en": "(C) Store the 'duration' of the meetings.",
        "wg": []
      },
      {
        "t": "(D) 儲存已經結束的會議數量。",
        "en": "(D) Store the count of meetings that have already ended.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "我們將會議按起始時間排序後，依序遍歷。最小堆積用來追蹤目前佔用會議室的會議中「最早結束」的那一個。如果當前會議的起始時間大於堆積頂端的結束時間，代表可以重複使用該會議室（將堆積頂端移除並加入新結束時間）；否則，需要開設新會議室（直接加入堆積）。堆積的大小即為所需的最少房間數。",
      "en": "After sorting meetings by start time, we iterate through them. The Min-Heap is used to track the 'earliest ending' meeting among those currently occupying rooms. If the current meeting's start time is greater than the heap's top end time, we can reuse that room (pop the top and push the new end time); otherwise, a new room is needed (push to heap). The size of the heap represents the minimum number of rooms required.",
      "wg": [
        {
          "t": "追蹤",
          "en": "track",
          "ps": "V"
        },
        {
          "t": "重複使用",
          "en": "reuse",
          "ps": "V"
        }
      ]
    }
  }
]