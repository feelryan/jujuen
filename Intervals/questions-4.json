[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Intervals, Sorting, Time Complexity, Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]",
    "question": [
      {
        "t": "給定一個未排序的區間集合，您需要合併所有重疊的區間。",
        "en": "Given an unsorted collection of intervals, you need to merge all overlapping intervals.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "集合",
            "en": "collection",
            "ps": "N"
          },
          {
            "t": "重疊",
            "en": "overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了有效地解決這個問題，演算法的第一步通常是什麼？這對時間複雜度有何影響？",
        "en": "To solve this problem efficiently, what is typically the first step of the algorithm, and how does it affect the time complexity?",
        "wg": [
          {
            "t": "有效地",
            "en": "efficiently",
            "ps": "Adv"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 根據結束時間排序；總時間複雜度由排序決定，為 O(N log N)。",
        "en": "(A) Sort by end time; total time complexity is dominated by sorting, which is O(N log N).",
        "wg": [
          {
            "t": "由...決定",
            "en": "dominated by",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 根據起始時間排序；總時間複雜度由排序決定，為 O(N log N)。",
        "en": "(B) Sort by start time; total time complexity is dominated by sorting, which is O(N log N).",
        "wg": []
      },
      {
        "t": "(C) 不需要排序，直接使用雙指針比較；時間複雜度為 O(N)。",
        "en": "(C) No sorting needed, compare directly using two pointers; time complexity is O(N).",
        "wg": [
          {
            "t": "雙指針",
            "en": "two pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 建立一個布林陣列來標記時間軸；時間複雜度取決於最大時間值。",
        "en": "(D) Create a boolean array to mark the timeline; time complexity depends on the maximum time value.",
        "wg": [
          {
            "t": "時間軸",
            "en": "timeline",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "合併區間最直觀的方法是根據「起始時間」排序。這樣可以確保在遍歷時，只需比較當前區間的結束時間與下一個區間的起始時間即可判斷是否重疊。排序的時間複雜度為 O(N log N)，這通常是此類問題的瓶頸。",
      "en": "The most intuitive way to merge intervals is to sort by 'start time'. This ensures that during iteration, you only need to compare the end time of the current interval with the start time of the next interval to determine overlap. The sorting complexity is O(N log N), which is typically the bottleneck for such problems.",
      "wg": [
        {
          "t": "直觀的",
          "en": "intuitive",
          "ps": "Adj"
        },
        {
          "t": "瓶頸",
          "en": "bottleneck",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Intervals, Greedy, Non-overlapping",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「無重疊區間」(Non-overlapping Intervals) 問題中，目標是移除最少數量的區間，使剩餘的區間互不重疊。",
        "en": "In the 'Non-overlapping Intervals' problem, the goal is to remove the minimum number of intervals so that the rest are non-overlapping.",
        "wg": [
          {
            "t": "移除",
            "en": "remove",
            "ps": "V"
          },
          {
            "t": "互不重疊",
            "en": "non-overlapping",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若採用貪婪演算法 (Greedy Approach)，應該依據什麼標準對區間進行排序以達到最佳解？",
        "en": "If using a Greedy Approach, based on what criteria should the intervals be sorted to achieve the optimal solution?",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "Greedy Approach",
            "ps": "N"
          },
          {
            "t": "標準",
            "en": "criteria",
            "ps": "N"
          },
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 依據起始時間遞增排序。",
        "en": "(A) Sort by start time in ascending order.",
        "wg": []
      },
      {
        "t": "(B) 依據區間長度（持續時間）遞增排序。",
        "en": "(B) Sort by interval length (duration) in ascending order.",
        "wg": [
          {
            "t": "持續時間",
            "en": "duration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 依據結束時間遞增排序。",
        "en": "(C) Sort by end time in ascending order.",
        "wg": [
          {
            "t": "遞增",
            "en": "ascending",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 依據結束時間遞減排序。",
        "en": "(D) Sort by end time in descending order.",
        "wg": [
          {
            "t": "遞減",
            "en": "descending",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "根據結束時間排序是貪婪策略的關鍵。總是選擇結束時間最早的區間，可以為後續的區間留出最多的空間，從而最大化能保留的區間數量（即最小化移除數量）。",
      "en": "Sorting by end time is key to the greedy strategy. Always picking the interval that ends earliest leaves the most space for subsequent intervals, thereby maximizing the number of intervals kept (i.e., minimizing the number removed).",
      "wg": [
        {
          "t": "留出",
          "en": "leave ... space",
          "ps": "V"
        },
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Intervals, Heap, Priority Queue, Meeting Rooms",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在解決「會議室 II」(Meeting Rooms II) 問題，需要計算舉辦所有會議所需的最少會議室數量。",
        "en": "You are solving the 'Meeting Rooms II' problem and need to calculate the minimum number of conference rooms required to hold all meetings.",
        "wg": [
          {
            "t": "會議室",
            "en": "conference rooms",
            "ps": "N"
          },
          {
            "t": "舉辦",
            "en": "hold",
            "ps": "V"
          }
        ]
      },
      {
        "t": "如果使用最小堆積 (Min-Heap) 來輔助解題，堆積中儲存的元素應該是什麼？",
        "en": "If using a Min-Heap to assist in solving the problem, what elements should be stored in the heap?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "輔助",
            "en": "assist",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 所有會議的起始時間，用來判斷哪個會議最早開始。",
        "en": "(A) The start times of all meetings, to determine which meeting starts earliest.",
        "wg": []
      },
      {
        "t": "(B) 目前正在進行的會議的結束時間，堆積頂端為最早結束的會議。",
        "en": "(B) The end times of meetings currently in progress, with the top of the heap being the meeting that ends earliest.",
        "wg": [
          {
            "t": "正在進行",
            "en": "in progress",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 所有會議的持續時間，用來優先安排短會議。",
        "en": "(C) The duration of all meetings, to prioritize scheduling short meetings.",
        "wg": [
          {
            "t": "優先安排",
            "en": "prioritize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 會議的重疊次數，用來追蹤最大並發量。",
        "en": "(D) The overlap count of meetings, to track the maximum concurrency.",
        "wg": [
          {
            "t": "並發量",
            "en": "concurrency",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "我們將會議依起始時間排序後遍歷。最小堆積用來追蹤已分配房間的會議何時結束。如果新的會議起始時間大於堆積頂端（最早結束的會議），代表可以重複使用該房間（將堆積頂端移除並加入新結束時間）；否則，需要開設新房間（直接加入堆積）。",
      "en": "We iterate through meetings sorted by start time. The Min-Heap tracks when the assigned meetings end. If a new meeting's start time is greater than the heap's top (the meeting ending earliest), it means the room can be reused (pop the top and push the new end time); otherwise, a new room is needed (push to heap).",
      "wg": [
        {
          "t": "分配",
          "en": "assigned",
          "ps": "V"
        },
        {
          "t": "重複使用",
          "en": "reuse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Intervals, Math, Intersection",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Interval A = [startA, endA]\nInterval B = [startB, endB]",
    "question": [
      {
        "t": "給定兩個區間 A 和 B，若已知它們存在重疊部分。",
        "en": "Given two intervals A and B, assuming they are known to overlap.",
        "wg": [
          {
            "t": "已知",
            "en": "assuming / known",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問計算它們「交集區間」(Intersection Interval) 的正確數學公式為何？",
        "en": "What is the correct mathematical formula to calculate their 'Intersection Interval'?",
        "wg": [
          {
            "t": "交集",
            "en": "intersection",
            "ps": "N"
          },
          {
            "t": "公式",
            "en": "formula",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [min(startA, startB), max(endA, endB)]",
        "en": "(A) [min(startA, startB), max(endA, endB)]",
        "wg": []
      },
      {
        "t": "(B) [max(startA, startB), min(endA, endB)]",
        "en": "(B) [max(startA, startB), min(endA, endB)]",
        "wg": []
      },
      {
        "t": "(C) [min(startA, startB), min(endA, endB)]",
        "en": "(C) [min(startA, startB), min(endA, endB)]",
        "wg": []
      },
      {
        "t": "(D) [max(startA, startB), max(endA, endB)]",
        "en": "(D) [max(startA, startB), max(endA, endB)]",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "交集的定義是兩個區間共同擁有的部分。交集的起始點必須是兩者起始點較晚的那一個（max），而結束點必須是兩者結束點較早的那一個（min）。選項 (A) 計算的是聯集 (Union)。",
      "en": "The intersection is defined as the part shared by both intervals. The start point of the intersection must be the later of the two start points (max), and the end point must be the earlier of the two end points (min). Option (A) calculates the Union.",
      "wg": [
        {
          "t": "共同擁有的",
          "en": "shared",
          "ps": "Adj"
        },
        {
          "t": "聯集",
          "en": "Union",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Intervals, Edge Case, Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Interval 1: [1, 5]\nInterval 2: [5, 7]",
    "question": [
      {
        "t": "在處理區間合併問題時，邊界條件的處理非常重要。",
        "en": "Handling boundary conditions is crucial when dealing with interval merging problems.",
        "wg": [
          {
            "t": "邊界條件",
            "en": "boundary conditions",
            "ps": "N"
          },
          {
            "t": "至關重要",
            "en": "crucial",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問區間 `[1, 5]` 和 `[5, 7]` 是否應該被視為重疊並進行合併？如果是，合併後的結果為何？",
        "en": "Should the intervals `[1, 5]` and `[5, 7]` be considered overlapping and merged? If so, what is the result?",
        "wg": [
          {
            "t": "視為",
            "en": "considered",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 不重疊，因為 5 只能屬於其中一個區間。",
        "en": "(A) No overlap, because 5 can only belong to one interval.",
        "wg": []
      },
      {
        "t": "(B) 重疊，合併結果為 `[1, 7]`。",
        "en": "(B) Overlap, and the merged result is `[1, 7]`.",
        "wg": []
      },
      {
        "t": "(C) 重疊，但不需要合併，保留原樣。",
        "en": "(C) Overlap, but no need to merge; keep as is.",
        "wg": []
      },
      {
        "t": "(D) 視題目定義而定，但在 LeetCode 標準區間問題中通常不視為重疊。",
        "en": "(D) Depends on the problem definition, but typically not considered overlapping in standard LeetCode interval problems.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在大多數標準區間問題（如 LeetCode 56. Merge Intervals）中，如果一個區間的結束時間等於下一個區間的起始時間（例如 `end1 == start2`），它們被視為「接觸」並應合併為一個連續區間。因此 `[1, 5]` 和 `[5, 7]` 合併為 `[1, 7]`。",
      "en": "In most standard interval problems (like LeetCode 56. Merge Intervals), if the end time of one interval equals the start time of the next (e.g., `end1 == start2`), they are considered 'touching' and should be merged into a continuous interval. Thus, `[1, 5]` and `[5, 7]` merge into `[1, 7]`.",
      "wg": [
        {
          "t": "接觸",
          "en": "touching",
          "ps": "V"
        },
        {
          "t": "連續的",
          "en": "continuous",
          "ps": "Adj"
        }
      ]
    }
  }
]