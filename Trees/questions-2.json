[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Binary Search Tree, In-order Traversal, Sorting",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個二元搜尋樹 (BST)，您希望輸出所有節點的數值，並確保輸出結果是由小到大排序的。",
        "en": "Given a Binary Search Tree (BST), you want to output the values of all nodes and ensure the result is sorted in ascending order.",
        "wg": [
          {
            "t": "二元搜尋樹",
            "en": "Binary Search Tree",
            "ps": "N"
          },
          {
            "t": "由小到大",
            "en": "ascending order",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問您應該採用哪種樹的走訪 (Traversal) 方式？",
        "en": "Which tree traversal method should you adopt?",
        "wg": [
          {
            "t": "走訪",
            "en": "traversal",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前序走訪 (Pre-order Traversal)",
        "en": "(A) Pre-order Traversal",
        "wg": []
      },
      {
        "t": "(B) 中序走訪 (In-order Traversal)",
        "en": "(B) In-order Traversal",
        "wg": []
      },
      {
        "t": "(C) 後序走訪 (Post-order Traversal)",
        "en": "(C) Post-order Traversal",
        "wg": []
      },
      {
        "t": "(D) 層序走訪 (Level-order Traversal)",
        "en": "(D) Level-order Traversal",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二元搜尋樹的特性是左子樹所有節點小於根節點，右子樹所有節點大於根節點。中序走訪 (左->根->右) 正好能按照數值大小順序訪問所有節點。",
      "en": "The property of a BST is that all nodes in the left subtree are smaller than the root, and all nodes in the right subtree are larger. In-order traversal (Left->Root->Right) visits all nodes exactly in sorted numerical order.",
      "wg": [
        {
          "t": "特性",
          "en": "property",
          "ps": "N"
        },
        {
          "t": "數值",
          "en": "numerical",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Time Complexity, BST, Worst Case, Skewed Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在最差的情況下 (Worst Case)，於二元搜尋樹 (BST) 中搜尋一個特定節點的時間複雜度為何？",
        "en": "In the worst-case scenario, what is the time complexity of searching for a specific node in a Binary Search Tree (BST)?",
        "wg": [
          {
            "t": "最差的情況",
            "en": "worst-case scenario",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設樹中有 n 個節點。",
        "en": "Assume there are n nodes in the tree.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log n)",
        "en": "(B) O(log n)",
        "wg": []
      },
      {
        "t": "(C) O(n)",
        "en": "(C) O(n)",
        "wg": []
      },
      {
        "t": "(D) O(n log n)",
        "en": "(D) O(n log n)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當 BST 退化成歪斜樹 (Skewed Tree，例如每個節點都只有右子節點) 時，其結構類似於連結串列 (Linked List)。此時搜尋需要遍歷所有節點，故時間複雜度為 O(n)。O(log n) 是平衡樹的情況。",
      "en": "When a BST degenerates into a skewed tree (e.g., every node has only a right child), its structure resembles a Linked List. In this case, searching requires traversing all nodes, so the time complexity is O(n). O(log n) applies to balanced trees.",
      "wg": [
        {
          "t": "退化",
          "en": "degenerate",
          "ps": "V"
        },
        {
          "t": "歪斜樹",
          "en": "skewed tree",
          "ps": "N"
        },
        {
          "t": "連結串列",
          "en": "Linked List",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Complete Binary Tree, Array, Heap, Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統，需要使用陣列 (Array) 來緊湊地儲存二元樹，以節省記憶體空間並避免指標開銷。",
        "en": "You are designing a system that needs to use an Array to compactly store a binary tree to save memory space and avoid pointer overhead.",
        "wg": [
          {
            "t": "緊湊地",
            "en": "compactly",
            "ps": "Adv"
          },
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          },
          {
            "t": "開銷",
            "en": "overhead",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問下列哪種二元樹結構最適合這種儲存方式，且不會在陣列中產生大量空洞？",
        "en": "Which of the following binary tree structures is most suitable for this storage method without creating significant gaps in the array?",
        "wg": [
          {
            "t": "空洞",
            "en": "gaps",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 嚴格二元樹 (Strict Binary Tree)",
        "en": "(A) Strict Binary Tree",
        "wg": []
      },
      {
        "t": "(B) 歪斜二元樹 (Skewed Binary Tree)",
        "en": "(B) Skewed Binary Tree",
        "wg": []
      },
      {
        "t": "(C) 完全二元樹 (Complete Binary Tree)",
        "en": "(C) Complete Binary Tree",
        "wg": []
      },
      {
        "t": "(D) 一般二元搜尋樹 (General BST)",
        "en": "(D) General BST",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "完全二元樹的定義是除了最後一層外，其他層節點全滿，且最後一層節點靠左排列。這使得它可以用陣列連續索引 (1 到 n) 完美表示，不會浪費空間，這也是 Heap (堆積) 的實作基礎。",
      "en": "A Complete Binary Tree is defined such that all levels are fully filled except possibly the last, which is filled from the left. This allows it to be perfectly represented by continuous array indices (1 to n) without wasting space, which is also the basis for Heap implementation.",
      "wg": [
        {
          "t": "靠左排列",
          "en": "filled from the left",
          "ps": "Phrase"
        },
        {
          "t": "堆積",
          "en": "Heap",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Memory Management, Recursion, Post-order Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void deleteTree(Node* node) {\n    if (node == NULL) return;\n    // Step 1\n    // Step 2\n    // Step 3: free(node);\n}",
    "question": [
      {
        "t": "若您需要撰寫一個函式來釋放 (free) 二元樹中所有節點佔用的記憶體。",
        "en": "If you need to write a function to free the memory occupied by all nodes in a binary tree.",
        "wg": [
          {
            "t": "釋放",
            "en": "free/deallocate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了安全地刪除節點，避免在存取子節點前就刪除了父節點，您應該採用哪種走訪順序？",
        "en": "To safely delete nodes and avoid deleting a parent before accessing its children, which traversal order should you use?",
        "wg": [
          {
            "t": "存取",
            "en": "accessing",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前序走訪 (Pre-order)",
        "en": "(A) Pre-order",
        "wg": []
      },
      {
        "t": "(B) 中序走訪 (In-order)",
        "en": "(B) In-order",
        "wg": []
      },
      {
        "t": "(C) 後序走訪 (Post-order)",
        "en": "(C) Post-order",
        "wg": []
      },
      {
        "t": "(D) 任何順序皆可",
        "en": "(D) Any order works",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "後序走訪 (左->右->根) 確保在刪除父節點之前，其左右子樹的節點都已經被處理並釋放。若使用前序，父節點被刪除後將無法存取其子節點的指標，導致記憶體洩漏或錯誤。",
      "en": "Post-order traversal (Left->Right->Root) ensures that the nodes in the left and right subtrees are processed and freed before the parent node is deleted. If pre-order is used, deleting the parent first makes it impossible to access the pointers to its children, leading to memory leaks or errors.",
      "wg": [
        {
          "t": "記憶體洩漏",
          "en": "memory leaks",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "BST Validation, Algorithms, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，您被要求驗證一棵樹是否為合法的二元搜尋樹 (BST)。",
        "en": "In an interview, you are asked to validate whether a tree is a valid Binary Search Tree (BST).",
        "wg": [
          {
            "t": "合法的",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為什麼單純檢查「每個節點是否大於其左子節點且小於其右子節點」是不夠的？",
        "en": "Why is it insufficient to simply check if 'every node is greater than its left child and smaller than its right child'?",
        "wg": [
          {
            "t": "單純",
            "en": "simply",
            "ps": "Adv"
          },
          {
            "t": "不夠的",
            "en": "insufficient",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為還需要檢查樹的高度是否平衡。",
        "en": "(A) Because you also need to check if the tree height is balanced.",
        "wg": []
      },
      {
        "t": "(B) 因為這種檢查方式無法處理重複的數值。",
        "en": "(B) Because this checking method cannot handle duplicate values.",
        "wg": []
      },
      {
        "t": "(C) 因為右子樹中的某個節點雖然大於其父節點，但可能小於更上層的祖先節點 (違反 BST 定義)。",
        "en": "(C) Because a node in the right subtree, while larger than its parent, might be smaller than an ancestor node further up (violating the BST definition).",
        "wg": [
          {
            "t": "祖先節點",
            "en": "ancestor node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 這種檢查方式會導致無限遞迴。",
        "en": "(D) This checking method will lead to infinite recursion.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "BST 的定義是：節點必須大於其左子樹中「所有」節點，並小於其右子樹中「所有」節點。僅檢查直接子節點無法保證子樹深處的節點符合上層祖先的範圍限制。",
      "en": "The definition of a BST is: a node must be larger than *all* nodes in its left subtree and smaller than *all* nodes in its right subtree. Checking only immediate children cannot guarantee that nodes deep in the subtrees satisfy the range constraints imposed by upper ancestors.",
      "wg": [
        {
          "t": "範圍限制",
          "en": "range constraints",
          "ps": "N"
        }
      ]
    }
  }
]