[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Tree Properties, Graph Theory, Edges",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於一個包含 N 個節點的樹結構，下列哪一個敘述是永遠正確的？",
        "en": "Regarding a tree structure containing N nodes, which of the following statements is always true?",
        "wg": [
          {
            "t": "節點",
            "en": "node",
            "ps": "N"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它恰好有 N 條邊。",
        "en": "(A) It has exactly N edges.",
        "wg": [
          {
            "t": "邊",
            "en": "edge",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 它恰好有 N-1 條邊，且不包含任何迴圈。",
        "en": "(B) It has exactly N-1 edges and contains no cycles.",
        "wg": [
          {
            "t": "迴圈",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 每個節點都必須至少有兩個子節點。",
        "en": "(C) Every node must have at least two children.",
        "wg": []
      },
      {
        "t": "(D) 這是一個非連通圖。",
        "en": "(D) It is a disconnected graph.",
        "wg": [
          {
            "t": "非連通圖",
            "en": "disconnected graph",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "根據樹的定義，一棵擁有 N 個節點的樹必須是連通的且無迴圈，這意味著它恰好有 N-1 條邊。",
      "en": "By definition, a tree with N nodes must be connected and acyclic, which implies it has exactly N-1 edges.",
      "wg": [
        {
          "t": "連通的",
          "en": "connected",
          "ps": "Adj"
        },
        {
          "t": "無迴圈",
          "en": "acyclic",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "BST, Traversal, Algorithms",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個二元搜尋樹 (BST)，哪種遍歷方式會以升序 (由小到大) 輸出所有元素？",
        "en": "Given a Binary Search Tree (BST), which traversal method outputs all elements in ascending order?",
        "wg": [
          {
            "t": "二元搜尋樹",
            "en": "Binary Search Tree",
            "ps": "N"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          },
          {
            "t": "升序",
            "en": "ascending order",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前序遍歷 (Pre-order Traversal)",
        "en": "(A) Pre-order Traversal",
        "wg": []
      },
      {
        "t": "(B) 中序遍歷 (In-order Traversal)",
        "en": "(B) In-order Traversal",
        "wg": []
      },
      {
        "t": "(C) 後序遍歷 (Post-order Traversal)",
        "en": "(C) Post-order Traversal",
        "wg": []
      },
      {
        "t": "(D) 層序遍歷 (Level-order Traversal)",
        "en": "(D) Level-order Traversal",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在二元搜尋樹中，左子樹的值小於根節點，右子樹的值大於根節點。",
      "en": "In a Binary Search Tree, the left subtree values are smaller than the root, and the right subtree values are larger.",
      "wg": []
    },
    "why_part2": {
      "t": "中序遍歷遵循「左-根-右」的順序，因此能確保輸出的數值是排序過的。",
      "en": "In-order traversal follows the 'Left-Root-Right' order, thus ensuring the output values are sorted.",
      "wg": []
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Time Complexity, BST, Worst Case, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在最差情況下，於一個未經平衡處理的二元搜尋樹 (BST) 中搜尋特定值的時間複雜度為何？",
        "en": "What is the time complexity of searching for a specific value in an unbalanced Binary Search Tree (BST) in the worst case?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst case",
            "ps": "N"
          },
          {
            "t": "未經平衡處理",
            "en": "unbalanced",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "假設該樹共有 n 個節點。",
        "en": "Assume the tree has n nodes.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log n)",
        "en": "(B) O(log n)",
        "wg": []
      },
      {
        "t": "(C) O(n)",
        "en": "(C) O(n)",
        "wg": []
      },
      {
        "t": "(D) O(n log n)",
        "en": "(D) O(n log n)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在最差情況下 (例如依序插入已排序的數據)，BST 會退化成一個連結串列 (Linked List)。",
      "en": "In the worst case (e.g., inserting sorted data sequentially), the BST degrades into a Linked List.",
      "wg": [
        {
          "t": "退化",
          "en": "degrade",
          "ps": "V"
        },
        {
          "t": "連結串列",
          "en": "Linked List",
          "ps": "N"
        }
      ]
    },
    "why_part2": {
      "t": "此時樹的高度為 n，因此搜尋操作需要遍歷每個節點，導致 O(n) 的複雜度。",
      "en": "At this point, the height of the tree is n, so the search operation requires traversing every node, resulting in O(n) complexity.",
      "wg": []
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Binary Tree Types, Definitions, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若一棵二元樹的所有層級都已填滿，除了最後一層可能例外，且最後一層的節點都盡可能靠左排列，這種樹稱為什麼？",
        "en": "If all levels of a binary tree are fully filled except possibly the last level, and the nodes in the last level are arranged as left as possible, what is this tree called?",
        "wg": [
          {
            "t": "層級",
            "en": "level",
            "ps": "N"
          },
          {
            "t": "靠左",
            "en": "as left as possible",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 完滿二元樹 (Full Binary Tree)",
        "en": "(A) Full Binary Tree",
        "wg": [
          {
            "t": "完滿二元樹",
            "en": "Full Binary Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 完美二元樹 (Perfect Binary Tree)",
        "en": "(B) Perfect Binary Tree",
        "wg": [
          {
            "t": "完美二元樹",
            "en": "Perfect Binary Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 完全二元樹 (Complete Binary Tree)",
        "en": "(C) Complete Binary Tree",
        "wg": [
          {
            "t": "完全二元樹",
            "en": "Complete Binary Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 平衡二元樹 (Balanced Binary Tree)",
        "en": "(D) Balanced Binary Tree",
        "wg": [
          {
            "t": "平衡二元樹",
            "en": "Balanced Binary Tree",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這是完全二元樹的標準定義，這類樹常被用於實作二元堆積 (Binary Heap)。",
      "en": "This is the standard definition of a Complete Binary Tree, which is often used to implement Binary Heaps.",
      "wg": [
        {
          "t": "二元堆積",
          "en": "Binary Heap",
          "ps": "N"
        }
      ]
    },
    "why_part2": {
      "t": "完滿二元樹 (Full) 要求節點有 0 或 2 個子節點；完美二元樹 (Perfect) 則要求所有層級全滿。",
      "en": "A Full Binary Tree requires nodes to have 0 or 2 children; a Perfect Binary Tree requires all levels to be completely full.",
      "wg": []
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Tree Terminology, Height vs Depth",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在樹的結構中，對於「節點的高度 (Height)」之定義，下列何者正確？",
        "en": "In a tree structure, which of the following is the correct definition for the 'Height' of a node?",
        "wg": [
          {
            "t": "高度",
            "en": "height",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從根節點到該節點的邊數。",
        "en": "(A) The number of edges from the root to that node.",
        "wg": []
      },
      {
        "t": "(B) 從該節點到最遠葉節點的最長路徑邊數。",
        "en": "(B) The number of edges on the longest path from that node to a leaf.",
        "wg": [
          {
            "t": "最遠",
            "en": "farthest",
            "ps": "Adj"
          },
          {
            "t": "葉節點",
            "en": "leaf",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 該節點擁有的子節點總數。",
        "en": "(C) The total number of children that node has.",
        "wg": []
      },
      {
        "t": "(D) 該節點所在的層級數 (根節點為 1)。",
        "en": "(D) The level number where the node resides (Root is 1).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "高度是從該節點向下延伸到最遠葉節點的距離；而深度 (Depth) 才是從根節點到該節點的距離。",
      "en": "Height is the distance extending down from the node to the farthest leaf; whereas Depth is the distance from the root to the node.",
      "wg": [
        {
          "t": "深度",
          "en": "depth",
          "ps": "N"
        },
        {
          "t": "延伸",
          "en": "extend",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Binary Search Tree, BST, Validation, In-order Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在面試中，您被要求驗證一棵二元樹是否為有效的二元搜尋樹 (BST)。",
        "en": "In an interview, you are asked to validate whether a binary tree is a valid Binary Search Tree (BST).",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "二元搜尋樹",
            "en": "Binary Search Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一項屬性是二元搜尋樹必須滿足的充分必要條件？",
        "en": "Which of the following properties is a necessary and sufficient condition for a Binary Search Tree?",
        "wg": [
          {
            "t": "充分必要條件",
            "en": "necessary and sufficient condition",
            "ps": "N"
          },
          {
            "t": "屬性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對於每個節點，其左子節點的值小於該節點，且右子節點的值大於該節點。",
        "en": "(A) For every node, the value of its left child is less than the node, and the value of its right child is greater than the node.",
        "wg": []
      },
      {
        "t": "(B) 該樹的中序走訪 (In-order Traversal) 結果是一個嚴格遞增的序列。",
        "en": "(B) The result of an In-order Traversal of the tree is a strictly increasing sequence.",
        "wg": [
          {
            "t": "中序走訪",
            "en": "In-order Traversal",
            "ps": "N"
          },
          {
            "t": "嚴格遞增",
            "en": "strictly increasing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 該樹的前序走訪 (Pre-order Traversal) 結果是一個排序好的序列。",
        "en": "(C) The result of a Pre-order Traversal of the tree is a sorted sequence.",
        "wg": [
          {
            "t": "前序走訪",
            "en": "Pre-order Traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 該樹必須是一棵完全二元樹 (Complete Binary Tree)。",
        "en": "(D) The tree must be a Complete Binary Tree.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 是常見的錯誤陷阱，因為它只檢查了直接子節點，而沒有確保整個左子樹的所有節點都小於根節點（以及右子樹大於根節點）。",
      "en": "Option (A) is a common pitfall because it only checks immediate children, without ensuring that all nodes in the left subtree are smaller than the root (and right subtree larger).",
      "wg": [
        {
          "t": "陷阱",
          "en": "pitfall",
          "ps": "N"
        },
        {
          "t": "子樹",
          "en": "subtree",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Time Complexity, BST, Worst Case, Skewed Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設您將一組已經排序好的數據（例如：1, 2, 3, 4, 5）依序插入到一個空的標準二元搜尋樹 (BST) 中。",
        "en": "Suppose you sequentially insert a set of sorted data (e.g., 1, 2, 3, 4, 5) into an empty standard Binary Search Tree (BST).",
        "wg": [
          {
            "t": "依序",
            "en": "sequentially",
            "ps": "Adv"
          },
          {
            "t": "排序好的",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "在這種最差情況下，搜尋特定節點的時間複雜度是多少？",
        "en": "In this worst-case scenario, what is the time complexity for searching for a specific node?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case scenario",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當插入已排序的數據時，BST 會退化成一個歪斜樹 (Skewed Tree)，結構類似於連結串列 (Linked List)。",
      "en": "When inserting sorted data, the BST degenerates into a Skewed Tree, structurally similar to a Linked List.",
      "wg": [
        {
          "t": "退化",
          "en": "degenerate",
          "ps": "V"
        },
        {
          "t": "歪斜樹",
          "en": "Skewed Tree",
          "ps": "N"
        },
        {
          "t": "連結串列",
          "en": "Linked List",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "easy",
    "keywords": "Binary Heap, Array Implementation, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二元堆積 (Binary Heap) 通常使用陣列來實作。",
        "en": "A Binary Heap is typically implemented using an array.",
        "wg": [
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若陣列索引從 0 開始，對於位於索引 `i` 的節點，其父節點 (Parent) 的索引為何？",
        "en": "If the array index starts at 0, what is the index of the parent node for a node located at index `i`?",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          },
          {
            "t": "父節點",
            "en": "parent node",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) floor((i - 1) / 2)",
        "en": "(A) floor((i - 1) / 2)",
        "wg": [
          {
            "t": "高斯符號/向下取整",
            "en": "floor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) i / 2",
        "en": "(B) i / 2",
        "wg": []
      },
      {
        "t": "(C) 2 * i",
        "en": "(C) 2 * i",
        "wg": []
      },
      {
        "t": "(D) 2 * i + 1",
        "en": "(D) 2 * i + 1",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在 0-based 的陣列表示法中，左子節點為 `2i + 1`，右子節點為 `2i + 2`，反推父節點則是 `(i - 1) / 2` 並向下取整。",
      "en": "In a 0-based array representation, the left child is `2i + 1` and the right child is `2i + 2`, so the parent is derived as `(i - 1) / 2` rounded down.",
      "wg": [
        {
          "t": "反推",
          "en": "derive/deduce",
          "ps": "V"
        },
        {
          "t": "向下取整",
          "en": "round down",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Trie, Prefix Tree, Autocomplete, System Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的「自動完成」(Autocomplete) 功能，需要快速查找具有特定前綴的字串。",
        "en": "You are designing an 'Autocomplete' feature for a search engine and need to quickly look up strings with a specific prefix.",
        "wg": [
          {
            "t": "自動完成",
            "en": "Autocomplete",
            "ps": "N"
          },
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種資料結構最適合此應用場景？",
        "en": "Which of the following data structures is most suitable for this application scenario?",
        "wg": [
          {
            "t": "應用場景",
            "en": "application scenario",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 雜湊表 (Hash Map)",
        "en": "(A) Hash Map",
        "wg": []
      },
      {
        "t": "(B) 二元搜尋樹 (BST)",
        "en": "(B) Binary Search Tree (BST)",
        "wg": []
      },
      {
        "t": "(C) 前綴樹 (Trie)",
        "en": "(C) Trie (Prefix Tree)",
        "wg": [
          {
            "t": "前綴樹",
            "en": "Trie",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 堆疊 (Stack)",
        "en": "(D) Stack",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Trie (前綴樹) 專門用於處理字串檢索，能夠在 O(L) 時間內找到所有以特定前綴開頭的單字 (L 為前綴長度)，比 BST 或 Hash Map 更有效率。",
      "en": "Trie is designed for string retrieval and can find all words starting with a specific prefix in O(L) time (where L is the prefix length), making it more efficient than a BST or Hash Map.",
      "wg": [
        {
          "t": "檢索",
          "en": "retrieval",
          "ps": "N"
        },
        {
          "t": "有效率",
          "en": "efficient",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Tree Reconstruction, Traversal, In-order, Pre-order",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要唯一地重建一棵二元樹，必須具備下列哪一組走訪序列？",
        "en": "To uniquely reconstruct a binary tree, which of the following pairs of traversal sequences is required?",
        "wg": [
          {
            "t": "唯一地",
            "en": "uniquely",
            "ps": "Adv"
          },
          {
            "t": "重建",
            "en": "reconstruct",
            "ps": "V"
          },
          {
            "t": "序列",
            "en": "sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設樹中的節點值皆不重複。",
        "en": "Assume that all node values in the tree are unique.",
        "wg": [
          {
            "t": "不重複",
            "en": "unique / non-duplicate",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前序 (Pre-order) 與 後序 (Post-order)",
        "en": "(A) Pre-order and Post-order",
        "wg": []
      },
      {
        "t": "(B) 前序 (Pre-order) 與 中序 (In-order)",
        "en": "(B) Pre-order and In-order",
        "wg": []
      },
      {
        "t": "(C) 僅需 層序 (Level-order)",
        "en": "(C) Level-order only",
        "wg": []
      },
      {
        "t": "(D) 僅需 前序 (Pre-order)",
        "en": "(D) Pre-order only",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "中序走訪 (In-order) 提供了左右子樹的分界點，搭配前序或後序走訪提供的根節點資訊，才能唯一決定樹的結構。",
      "en": "In-order traversal provides the boundary between left and right subtrees; combined with the root information from Pre-order or Post-order, it allows the tree structure to be uniquely determined.",
      "wg": [
        {
          "t": "分界點",
          "en": "boundary / split point",
          "ps": "N"
        },
        {
          "t": "決定",
          "en": "determine",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Binary Search Tree, Validation, Recursion, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": "boolean isValid(Node node) {\n  if (node == null) return true;\n  if (node.left != null && node.left.val >= node.val) return false;\n  if (node.right != null && node.right.val <= node.val) return false;\n  return isValid(node.left) && isValid(node.right);\n}",
    "question": [
      {
        "t": "一位初階工程師寫了上述程式碼來驗證一棵二元樹是否為二元搜尋樹 (BST)。",
        "en": "A junior engineer wrote the above code to validate if a binary tree is a Binary Search Tree (BST).",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "二元搜尋樹",
            "en": "Binary Search Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這段程式碼存在邏輯上的缺陷。",
        "en": "There is a logical flaw in this code.",
        "wg": [
          {
            "t": "缺陷",
            "en": "flaw",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問下列哪種情況會導致此驗證邏輯失敗（誤判為正確）？",
        "en": "Which of the following scenarios would cause this validation logic to fail (incorrectly pass as valid)?",
        "wg": [
          {
            "t": "誤判",
            "en": "misjudge",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當樹是空的時候。",
        "en": "(A) When the tree is empty.",
        "wg": []
      },
      {
        "t": "(B) 當右子樹中有節點的值小於根節點，但大於其直接父節點時。",
        "en": "(B) When a node in the right subtree has a value smaller than the root but larger than its immediate parent.",
        "wg": [
          {
            "t": "直接父節點",
            "en": "immediate parent",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 當左子樹中有節點的值大於根節點，但小於其直接父節點時。",
        "en": "(C) When a node in the left subtree has a value larger than the root but smaller than its immediate parent.",
        "wg": []
      },
      {
        "t": "(D) 選項 (B) 和 (C) 皆是。",
        "en": "(D) Both options (B) and (C).",
        "wg": []
      }
    ],
    "answer": "(D)",
    "why": {
      "t": "該程式碼只檢查了每個節點與其「直接」左右子節點的關係，卻忽略了 BST 的定義要求整個左子樹的所有節點都必須小於根節點，且整個右子樹的所有節點都必須大於根節點。",
      "en": "The code only checks the relationship between each node and its 'immediate' left/right children, ignoring the BST definition which requires all nodes in the left subtree to be smaller than the root, and all nodes in the right subtree to be larger than the root.",
      "wg": [
        {
          "t": "忽略",
          "en": "ignore",
          "ps": "V"
        },
        {
          "t": "定義",
          "en": "definition",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Heap, BST, Time Complexity, Minimum Element",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個系統，需要頻繁地獲取資料集中的最小值。",
        "en": "You are designing a system that needs to frequently access the minimum value in a dataset.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "資料集",
            "en": "dataset",
            "ps": "N"
          }
        ]
      },
      {
        "t": "比較「最小堆積 (Min-Heap)」與「平衡二元搜尋樹 (Balanced BST)」，在獲取最小值 (Peek Minimum) 的時間複雜度上有何差異？",
        "en": "Comparing a 'Min-Heap' and a 'Balanced BST', what is the difference in time complexity for retrieving the minimum value (Peek Minimum)?",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min-Heap",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 兩者皆為 O(1)。",
        "en": "(A) Both are O(1).",
        "wg": []
      },
      {
        "t": "(B) Min-Heap 為 O(1)，Balanced BST 為 O(log N)。",
        "en": "(B) Min-Heap is O(1), Balanced BST is O(log N).",
        "wg": []
      },
      {
        "t": "(C) Min-Heap 為 O(log N)，Balanced BST 為 O(1)。",
        "en": "(C) Min-Heap is O(log N), Balanced BST is O(1).",
        "wg": []
      },
      {
        "t": "(D) 兩者皆為 O(log N)。",
        "en": "(D) Both are O(log N).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 Min-Heap 中，最小值總是位於根節點，因此查看只需 O(1)；而在 BST 中，最小值位於最左側的葉節點，需要遍歷樹的高度，對於平衡樹來說是 O(log N)。",
      "en": "In a Min-Heap, the minimum value is always at the root, so peeking takes O(1); in a BST, the minimum value is at the leftmost leaf node, requiring traversal of the tree's height, which is O(log N) for a balanced tree.",
      "wg": [
        {
          "t": "根節點",
          "en": "root node",
          "ps": "N"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Trie, Prefix Tree, Autocomplete, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作搜尋引擎的「自動完成 (Autocomplete)」功能時，我們通常會儲存大量的字串。",
        "en": "When implementing the 'Autocomplete' feature for a search engine, we usually store a large number of strings.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "自動完成",
            "en": "Autocomplete",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼選擇 Trie (前綴樹) 通常比使用 Hash Table 更適合這個場景？",
        "en": "Why is choosing a Trie (Prefix Tree) generally more suitable for this scenario than using a Hash Table?",
        "wg": [
          {
            "t": "前綴樹",
            "en": "Prefix Tree",
            "ps": "N"
          },
          {
            "t": "適合",
            "en": "suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在插入字串時總是比 Hash Table 快。",
        "en": "(A) Trie is always faster than Hash Table when inserting strings.",
        "wg": []
      },
      {
        "t": "(B) Trie 能夠高效地找出所有具有共同前綴的字串，而 Hash Table 不支援此操作的高效查詢。",
        "en": "(B) Trie can efficiently find all strings with a common prefix, whereas Hash Table does not support efficient queries for this operation.",
        "wg": [
          {
            "t": "共同前綴",
            "en": "common prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Trie 使用的記憶體空間總是比 Hash Table 少。",
        "en": "(C) Trie always uses less memory space than a Hash Table.",
        "wg": []
      },
      {
        "t": "(D) Trie 可以自動平衡，避免最差情況。",
        "en": "(D) Trie can automatically balance itself to avoid worst-case scenarios.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的結構特性使其非常適合處理前綴匹配問題 (Prefix Matching)。Hash Table 雖然尋找單一單字很快，但無法有效率地找出「以特定字串開頭」的所有單字。",
      "en": "The structural characteristics of a Trie make it very suitable for handling Prefix Matching problems. Although a Hash Table is fast for finding a single word, it cannot efficiently find all words that 'start with a specific string'.",
      "wg": [
        {
          "t": "特性",
          "en": "characteristic",
          "ps": "N"
        },
        {
          "t": "匹配",
          "en": "matching",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Tree Traversal, BFS, Queue, Level Order",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若您需要「逐層」列印出一棵二元樹的所有節點（從上到下，從左到右），",
        "en": "If you need to print all nodes of a binary tree 'level by level' (from top to bottom, left to right),",
        "wg": [
          {
            "t": "逐層",
            "en": "level by level",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "您應該採用哪種遍歷演算法，以及搭配哪種輔助資料結構？",
        "en": "which traversal algorithm should you adopt, and with which auxiliary data structure?",
        "wg": [
          {
            "t": "輔助",
            "en": "auxiliary",
            "ps": "Adj"
          },
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 深度優先搜尋 (DFS) 搭配 堆疊 (Stack)。",
        "en": "(A) Depth-First Search (DFS) with a Stack.",
        "wg": [
          {
            "t": "深度優先搜尋",
            "en": "Depth-First Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 廣度優先搜尋 (BFS) 搭配 堆疊 (Stack)。",
        "en": "(B) Breadth-First Search (BFS) with a Stack.",
        "wg": [
          {
            "t": "廣度優先搜尋",
            "en": "Breadth-First Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 廣度優先搜尋 (BFS) 搭配 佇列 (Queue)。",
        "en": "(C) Breadth-First Search (BFS) with a Queue.",
        "wg": [
          {
            "t": "佇列",
            "en": "Queue",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 前序遍歷 (Preorder Traversal) 搭配 陣列 (Array)。",
        "en": "(D) Preorder Traversal with an Array.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "層序遍歷 (Level Order Traversal) 等同於廣度優先搜尋 (BFS)。BFS 使用佇列 (Queue) 來保持先進先出 (FIFO) 的順序，確保當前層的節點處理完後，才處理下一層的子節點。",
      "en": "Level Order Traversal is equivalent to Breadth-First Search (BFS). BFS uses a Queue to maintain First-In-First-Out (FIFO) order, ensuring that nodes at the current level are processed before the child nodes of the next level.",
      "wg": [
        {
          "t": "層序遍歷",
          "en": "Level Order Traversal",
          "ps": "N"
        },
        {
          "t": "先進先出",
          "en": "First-In-First-Out",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "BST, Worst Case, Skewed Tree, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "將一組「已經排序好」的數字（例如：1, 2, 3, 4, 5）依序插入到一個空的、沒有平衡機制的二元搜尋樹 (Naive BST) 中。",
        "en": "Insert a set of 'already sorted' numbers (e.g., 1, 2, 3, 4, 5) sequentially into an empty, naive Binary Search Tree (without balancing mechanisms).",
        "wg": [
          {
            "t": "已經排序好",
            "en": "already sorted",
            "ps": "Adj"
          },
          {
            "t": "依序",
            "en": "sequentially",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "這會導致樹的結構變成什麼樣子，且搜尋的時間複雜度會退化成多少？",
        "en": "What structure will the tree result in, and to what will the search time complexity degenerate?",
        "wg": [
          {
            "t": "退化",
            "en": "degenerate",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 成為一棵完全二元樹 (Complete Binary Tree)，搜尋時間為 O(log N)。",
        "en": "(A) Becomes a Complete Binary Tree, search time is O(log N).",
        "wg": []
      },
      {
        "t": "(B) 成為一棵傾斜樹 (Skewed Tree) 類似鏈結串列，搜尋時間為 O(N)。",
        "en": "(B) Becomes a Skewed Tree resembling a Linked List, search time is O(N).",
        "wg": [
          {
            "t": "傾斜樹",
            "en": "Skewed Tree",
            "ps": "N"
          },
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 樹會自動旋轉平衡，搜尋時間保持 O(log N)。",
        "en": "(C) The tree will automatically rotate to balance, keeping search time at O(log N).",
        "wg": []
      },
      {
        "t": "(D) 插入會失敗，因為 BST 不允許插入排序好的資料。",
        "en": "(D) Insertion will fail because BST does not allow inserting sorted data.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在沒有平衡機制的情況下，依序插入排序好的資料會導致每個新節點都加在同一個方向（例如全部在右邊），使樹退化成鏈結串列 (Linked List)，導致高度為 N，搜尋效率降為 O(N)。",
      "en": "Without balancing mechanisms, inserting sorted data sequentially causes every new node to be added in the same direction (e.g., all to the right), causing the tree to degenerate into a Linked List, resulting in a height of N and reducing search efficiency to O(N).",
      "wg": [
        {
          "t": "平衡機制",
          "en": "balancing mechanism",
          "ps": "N"
        },
        {
          "t": "效率",
          "en": "efficiency",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Trie, Prefix Tree, Autocomplete, String Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的「自動完成」(Autocomplete) 功能，需要快速查找具有特定前綴的所有單字。",
        "en": "You are designing an 'Autocomplete' feature for a search engine and need to quickly look up all words with a specific prefix.",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          },
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "與雜湊表 (Hash Table) 相比，為什麼 Trie (前綴樹) 是這個場景下更佳的選擇？",
        "en": "Compared to a Hash Table, why is a Trie (Prefix Tree) a better choice for this scenario?",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Table",
            "ps": "N"
          },
          {
            "t": "場景",
            "en": "scenario",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在插入單字時的時間複雜度總是優於雜湊表。",
        "en": "(A) Trie always has better time complexity for inserting words than a Hash Table.",
        "wg": []
      },
      {
        "t": "(B) Trie 能夠在 O(L) 時間內找到所有以特定字串為前綴的單字 (L 為前綴長度)，而雜湊表需遍歷所有鍵。",
        "en": "(B) Trie can find all words with a specific prefix in O(L) time (where L is the prefix length), whereas a Hash Table requires iterating through all keys.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) Trie 佔用的記憶體空間總是比雜湊表少。",
        "en": "(C) Trie always consumes less memory space than a Hash Table.",
        "wg": []
      },
      {
        "t": "(D) Trie 不需要處理雜湊碰撞的問題，因此尋找單一單字的速度總是比雜湊表快。",
        "en": "(D) Trie does not need to handle hash collisions, so looking up a single word is always faster than a Hash Table.",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "hash collision",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雜湊表雖然在精確查找上很快 (平均 O(L))，但不支援高效的前綴查詢；若要找出所有此前綴的字，必須掃描整個資料表。Trie 的結構天生適合前綴匹配，能直接導航到前綴節點並展開子樹。",
      "en": "While Hash Tables are fast for exact lookups (average O(L)), they do not support efficient prefix queries; finding all words with a prefix would require scanning the entire table. The structure of a Trie is naturally suited for prefix matching, allowing direct navigation to the prefix node and expanding the subtree.",
      "wg": [
        {
          "t": "精確查找",
          "en": "exact lookup",
          "ps": "N"
        },
        {
          "t": "天生適合",
          "en": "naturally suited",
          "ps": "Adj Phr"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "Segment Tree, Range Query, Update, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個整數陣列，您需要頻繁地執行兩個操作：更新特定索引的值，以及查詢特定範圍內的元素總和。",
        "en": "Given an integer array, you need to frequently perform two operations: update the value at a specific index, and query the sum of elements within a specific range.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了使這兩個操作的時間複雜度都達到 O(log N)，您應該選擇哪種資料結構？",
        "en": "To achieve a time complexity of O(log N) for both operations, which data structure should you choose?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前綴和陣列 (Prefix Sum Array)。",
        "en": "(A) Prefix Sum Array.",
        "wg": []
      },
      {
        "t": "(B) 雜湊表 (Hash Map)。",
        "en": "(B) Hash Map.",
        "wg": []
      },
      {
        "t": "(C) 線段樹 (Segment Tree)。",
        "en": "(C) Segment Tree.",
        "wg": [
          {
            "t": "線段樹",
            "en": "Segment Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 連結串列 (Linked List)。",
        "en": "(D) Linked List.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "前綴和陣列雖然查詢是 O(1)，但更新需要 O(N)。線段樹 (或 Binary Indexed Tree) 能夠在 O(log N) 的時間內同時完成範圍查詢與單點更新，是處理區間問題的最佳選擇。",
      "en": "Although Prefix Sum Arrays offer O(1) queries, updates require O(N). A Segment Tree (or Binary Indexed Tree) can perform both range queries and point updates in O(log N) time, making it the optimal choice for interval problems.",
      "wg": [
        {
          "t": "區間",
          "en": "interval",
          "ps": "N"
        },
        {
          "t": "最佳選擇",
          "en": "optimal choice",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "B+ Tree, Database, Disk I/O, Indexing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在關聯式資料庫中，索引通常使用 B+ Tree 而不是一般的二元搜尋樹 (BST) 或 AVL Tree。",
        "en": "In relational databases, indexes typically use B+ Trees instead of standard Binary Search Trees (BST) or AVL Trees.",
        "wg": [
          {
            "t": "關聯式資料庫",
            "en": "relational database",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "主要原因與下列何者最相關？",
        "en": "Which of the following is the most relevant reason?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) B+ Tree 的實作程式碼比 AVL Tree 簡單。",
        "en": "(A) The implementation code for B+ Trees is simpler than that of AVL Trees.",
        "wg": []
      },
      {
        "t": "(B) B+ Tree 具有較高的分支度 (Fan-out)，能降低樹的高度，進而減少磁碟 I/O 次數。",
        "en": "(B) B+ Trees have a higher fan-out, which reduces the height of the tree, thereby decreasing disk I/O operations.",
        "wg": [
          {
            "t": "分支度",
            "en": "fan-out",
            "ps": "N"
          },
          {
            "t": "磁碟 I/O",
            "en": "disk I/O",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) B+ Tree 支援遞迴搜尋，而 BST 不支援。",
        "en": "(C) B+ Trees support recursive search, while BSTs do not.",
        "wg": []
      },
      {
        "t": "(D) B+ Tree 不需要進行平衡操作。",
        "en": "(D) B+ Trees do not require balancing operations.",
        "wg": [
          {
            "t": "平衡操作",
            "en": "balancing operations",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "資料庫資料量大，無法全部載入記憶體。B+ Tree 的節點大小通常對齊磁碟分頁 (Page)，且擁有極高的分支度 (Fan-out)，使樹非常扁平，大幅減少讀取磁碟的次數。",
      "en": "Database volumes are large and cannot be fully loaded into memory. B+ Tree nodes are usually aligned with disk pages and have a very high fan-out, making the tree very flat and significantly reducing the number of disk reads.",
      "wg": [
        {
          "t": "對齊",
          "en": "align",
          "ps": "V"
        },
        {
          "t": "扁平",
          "en": "flat",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Serialization, Traversal, Reconstruction, Binary Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於二元樹的序列化 (Serialization) 與反序列化 (Deserialization)，下列敘述何者正確？",
        "en": "Regarding the serialization and deserialization of binary trees, which of the following statements is correct?",
        "wg": [
          {
            "t": "序列化",
            "en": "serialization",
            "ps": "N"
          },
          {
            "t": "反序列化",
            "en": "deserialization",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 僅使用中序遍歷 (Inorder) 的結果，就可以唯一還原任何二元樹。",
        "en": "(A) Any binary tree can be uniquely reconstructed using only the result of an Inorder traversal.",
        "wg": [
          {
            "t": "唯一還原",
            "en": "uniquely reconstruct",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 若二元樹中包含重複的值，則無法進行序列化。",
        "en": "(B) If the binary tree contains duplicate values, it cannot be serialized.",
        "wg": []
      },
      {
        "t": "(C) 若記錄了空節點 (Null pointers)，僅使用前序遍歷 (Preorder) 即可唯一還原二元樹。",
        "en": "(C) If null pointers are recorded, the binary tree can be uniquely reconstructed using only Preorder traversal.",
        "wg": [
          {
            "t": "空節點",
            "en": "null pointers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 必須同時擁有前序 (Preorder) 與後序 (Postorder) 遍歷結果，才能還原二元樹。",
        "en": "(D) Both Preorder and Postorder traversal results are required to reconstruct a binary tree.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "若不記錄空節點，通常需要兩種遍歷 (如前序+中序) 才能唯一決定一棵樹。但若在序列化字串中明確標記空節點 (例如使用 '#')，則單一的前序遍歷 (或層序遍歷) 就足以包含結構資訊並唯一還原。",
      "en": "If null nodes are not recorded, two traversals (e.g., Preorder + Inorder) are usually needed to uniquely determine a tree. However, if null nodes are explicitly marked in the serialized string (e.g., using '#'), a single Preorder traversal (or Level-order) is sufficient to contain structural information and uniquely reconstruct it.",
      "wg": [
        {
          "t": "明確標記",
          "en": "explicitly mark",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "LCA, BST, Algorithm, Lowest Common Ancestor",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個二元搜尋樹 (BST) 中，尋找兩個節點 p 和 q 的「最近共同祖先」(LCA)。",
        "en": "Find the 'Lowest Common Ancestor' (LCA) of two nodes p and q in a Binary Search Tree (BST).",
        "wg": [
          {
            "t": "最近共同祖先",
            "en": "Lowest Common Ancestor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "利用 BST 的特性，最有效率的判斷邏輯是什麼？",
        "en": "Using the properties of a BST, what is the most efficient logic for determination?",
        "wg": [
          {
            "t": "特性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從根節點開始，第一個數值位於 p 和 q 數值之間 (包含 p 或 q) 的節點即為 LCA。",
        "en": "(A) Starting from the root, the first node whose value lies between the values of p and q (inclusive) is the LCA.",
        "wg": []
      },
      {
        "t": "(B) 必須先計算每個節點的深度，深度最深的共同父節點即為 LCA。",
        "en": "(B) You must first calculate the depth of every node; the common parent with the greatest depth is the LCA.",
        "wg": []
      },
      {
        "t": "(C) 必須將 BST 轉換為陣列，然後尋找 p 和 q 的中間索引。",
        "en": "(C) You must convert the BST into an array and then find the middle index between p and q.",
        "wg": []
      },
      {
        "t": "(D) 必須遍歷整棵樹，建立每個節點的父指標 (Parent Pointer) 才能找到 LCA。",
        "en": "(D) You must traverse the entire tree and establish parent pointers for every node to find the LCA.",
        "wg": [
          {
            "t": "父指標",
            "en": "parent pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "利用 BST 左小右大的特性：如果當前節點比 p 和 q 都大，LCA 在左子樹；如果比 p 和 q 都小，LCA 在右子樹。一旦出現分岔點 (節點值介於 p, q 之間)，該節點即為 LCA，無需遍歷整棵樹。",
      "en": "Leveraging the BST property (left is smaller, right is larger): If the current node is larger than both p and q, the LCA is in the left subtree; if smaller than both, it's in the right subtree. Once a split point is reached (node value is between p and q), that node is the LCA, without needing to traverse the entire tree.",
      "wg": [
        {
          "t": "分岔點",
          "en": "split point",
          "ps": "N"
        },
        {
          "t": "介於...之間",
          "en": "between",
          "ps": "Prep"
        }
      ]
    }
  }
]