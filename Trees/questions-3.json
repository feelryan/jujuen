[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Binary Heap, Array Representation, Indexing, Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個以 0 為起始索引的陣列實作的二元堆積 (Binary Heap) 中，",
        "en": "In a Binary Heap implemented as a 0-indexed array,",
        "wg": [
          {
            "t": "起始索引",
            "en": "0-indexed",
            "ps": "Adj"
          },
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若某個節點位於索引 `i`，且該節點擁有右子節點，",
        "en": "if a node is located at index `i` and it has a right child,",
        "wg": [
          {
            "t": "位於",
            "en": "located at",
            "ps": "V"
          },
          {
            "t": "右子節點",
            "en": "right child",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問其右子節點的索引位置為何？",
        "en": "what is the index position of its right child?",
        "wg": [
          {
            "t": "索引位置",
            "en": "index position",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `2i`",
        "en": "(A) `2i`",
        "wg": []
      },
      {
        "t": "(B) `2i + 1`",
        "en": "(B) `2i + 1`",
        "wg": []
      },
      {
        "t": "(C) `2i + 2`",
        "en": "(C) `2i + 2`",
        "wg": []
      },
      {
        "t": "(D) `i / 2`",
        "en": "(D) `i / 2`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 0-based indexing 的堆積中，左子節點位於 `2i + 1`，右子節點位於 `2i + 2`，而父節點位於 `(i - 1) / 2`。",
      "en": "In a 0-based indexing heap, the left child is at `2i + 1`, the right child is at `2i + 2`, and the parent is at `(i - 1) / 2`.",
      "wg": [
        {
          "t": "父節點",
          "en": "parent node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "hard",
    "keywords": "Trie, Prefix Tree, Autocomplete, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的自動完成 (Autocomplete) 功能，需要快速查找具有特定前綴的所有單字。",
        "en": "You are designing an autocomplete feature for a search engine that needs to quickly look up all words with a specific prefix.",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          },
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於使用雜湊表 (Hash Map)，為什麼 Trie (字首樹) 是更佳的選擇？",
        "en": "Compared to using a Hash Map, why is a Trie (Prefix Tree) a better choice?",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          },
          {
            "t": "字首樹",
            "en": "Prefix Tree",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在最壞情況下的查找時間為 O(1)，比雜湊表快。",
        "en": "(A) Trie has a worst-case lookup time of O(1), which is faster than a Hash Map.",
        "wg": [
          {
            "t": "最壞情況",
            "en": "worst-case",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Trie 能夠在 O(L) 時間內找到共用前綴，其中 L 為前綴長度，且能有效節省儲存共用前綴的空間。",
        "en": "(B) Trie can find shared prefixes in O(L) time, where L is the prefix length, and efficiently saves space by storing shared prefixes.",
        "wg": [
          {
            "t": "共用",
            "en": "shared",
            "ps": "Adj"
          },
          {
            "t": "節省",
            "en": "save",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) Trie 的實作比雜湊表簡單，且不需要處理雜湊碰撞。",
        "en": "(C) Trie implementation is simpler than a Hash Map and does not require handling hash collisions.",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "hash collisions",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Trie 總是比雜湊表佔用更少的記憶體，無論資料分佈為何。",
        "en": "(D) Trie always consumes less memory than a Hash Map, regardless of data distribution.",
        "wg": [
          {
            "t": "無論",
            "en": "regardless of",
            "ps": "Prep"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雜湊表無法有效處理「前綴查詢」，必須遍歷所有鍵值。Trie 專為字串前綴設計，查找複雜度與鍵長有關 (O(L)) 而非資料量 (N)，且透過共用節點節省空間。",
      "en": "Hash Maps cannot efficiently handle 'prefix queries' without traversing all keys. Tries are designed for string prefixes, with lookup complexity related to key length (O(L)) rather than dataset size (N), and save space via shared nodes.",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "複雜度",
          "en": "complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "AVL Tree, Tree Rotation, Balancing, BST",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "考慮一個空的 AVL 樹，依序插入鍵值 10, 20, 30。",
        "en": "Consider an empty AVL Tree where keys 10, 20, and 30 are inserted sequentially.",
        "wg": [
          {
            "t": "依序",
            "en": "sequentially",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "插入 30 後，樹會失去平衡。為了恢復平衡，需要執行哪種旋轉操作？",
        "en": "After inserting 30, the tree becomes unbalanced. Which rotation operation is required to restore balance?",
        "wg": [
          {
            "t": "失去平衡",
            "en": "unbalanced",
            "ps": "Adj"
          },
          {
            "t": "恢復",
            "en": "restore",
            "ps": "V"
          },
          {
            "t": "旋轉",
            "en": "rotation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 右旋轉 (Right Rotation)",
        "en": "(A) Right Rotation",
        "wg": []
      },
      {
        "t": "(B) 左旋轉 (Left Rotation)",
        "en": "(B) Left Rotation",
        "wg": []
      },
      {
        "t": "(C) 先左旋再右旋 (Left-Right Rotation)",
        "en": "(C) Left-Right Rotation",
        "wg": []
      },
      {
        "t": "(D) 先右旋再左旋 (Right-Left Rotation)",
        "en": "(D) Right-Left Rotation",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "插入順序為 10 -> 20 -> 30，導致樹向右傾斜 (Right-Right Case)。節點 10 的平衡因子變為 -2。這需要對根節點進行單次左旋轉 (Left Rotation) 來使 20 成為新的根。",
      "en": "The insertion order 10 -> 20 -> 30 causes the tree to skew right (Right-Right Case). The balance factor of node 10 becomes -2. This requires a single Left Rotation on the root to make 20 the new root.",
      "wg": [
        {
          "t": "傾斜",
          "en": "skew",
          "ps": "V"
        },
        {
          "t": "平衡因子",
          "en": "balance factor",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "BST, LCA, Algorithm, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在二元搜尋樹 (BST) 中尋找兩個節點 `p` 和 `q` 的最低共同祖先 (LCA)，",
        "en": "When finding the Lowest Common Ancestor (LCA) of two nodes `p` and `q` in a Binary Search Tree (BST),",
        "wg": [
          {
            "t": "最低共同祖先",
            "en": "Lowest Common Ancestor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們可以利用 BST 的特性來優化搜尋。",
        "en": "we can utilize the properties of BST to optimize the search.",
        "wg": [
          {
            "t": "特性",
            "en": "properties",
            "ps": "N"
          },
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪一個邏輯正確描述了尋找 LCA 的過程？",
        "en": "Which of the following logic correctly describes the process of finding the LCA?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 如果根節點的值大於 `p` 和 `q` 的值，則 LCA 必在右子樹中。",
        "en": "(A) If the root's value is greater than both `p` and `q`, the LCA must be in the right subtree.",
        "wg": []
      },
      {
        "t": "(B) 如果根節點的值小於 `p` 和 `q` 的值，則 LCA 必在左子樹中。",
        "en": "(B) If the root's value is less than both `p` and `q`, the LCA must be in the left subtree.",
        "wg": []
      },
      {
        "t": "(C) 如果根節點的值介於 `p` 和 `q` 之間 (包含 `p` 或 `q` 等於根節點)，則該根節點即為 LCA。",
        "en": "(C) If the root's value is between `p` and `q` (inclusive if `p` or `q` equals the root), then that root is the LCA.",
        "wg": [
          {
            "t": "介於...之間",
            "en": "between",
            "ps": "Prep"
          },
          {
            "t": "包含",
            "en": "inclusive",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 必須先將 BST 轉換為陣列，才能找到 LCA。",
        "en": "(D) The BST must first be converted to an array to find the LCA.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 BST 中，若兩節點分別位於目前節點的兩側 (一大一小)，或其中之一等於目前節點，則目前節點即為分岔點，也就是 LCA。若兩者都比根小，往左找；若都比根大，往右找。",
      "en": "In a BST, if the two nodes are on opposite sides of the current node (one smaller, one larger), or one equals the current node, then the current node is the split point, i.e., the LCA. If both are smaller than the root, go left; if both are larger, go right.",
      "wg": [
        {
          "t": "分岔點",
          "en": "split point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Red-Black Tree, AVL Tree, Trade-off, System Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您的系統需要頻繁地進行資料的插入與刪除操作，且資料量龐大。",
        "en": "Your system requires frequent data insertion and deletion operations, and the dataset is large.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "龐大",
            "en": "large/massive",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "在選擇自平衡二元搜尋樹時，為什麼通常會優先選擇紅黑樹 (Red-Black Tree) 而非 AVL 樹？",
        "en": "When choosing a self-balancing binary search tree, why is a Red-Black Tree often preferred over an AVL Tree?",
        "wg": [
          {
            "t": "自平衡",
            "en": "self-balancing",
            "ps": "Adj"
          },
          {
            "t": "優先選擇",
            "en": "preferred",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 紅黑樹的查詢速度比 AVL 樹快。",
        "en": "(A) Red-Black Trees have faster lookup speeds than AVL Trees.",
        "wg": []
      },
      {
        "t": "(B) 紅黑樹不需要儲存額外的平衡資訊。",
        "en": "(B) Red-Black Trees do not need to store extra balance information.",
        "wg": []
      },
      {
        "t": "(C) AVL 樹的平衡條件較嚴格，導致插入和刪除時需要更多次的旋轉操作。",
        "en": "(C) AVL Trees have stricter balancing conditions, leading to more rotation operations during insertions and deletions.",
        "wg": [
          {
            "t": "嚴格",
            "en": "strict",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 紅黑樹保證左右子樹的高度差不超過 1。",
        "en": "(D) Red-Black Trees guarantee that the height difference between left and right subtrees is no more than 1.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "AVL 樹維持嚴格平衡 (高度差 <= 1)，查詢極快但維護成本高。紅黑樹是「寬鬆平衡」，允許路徑長度差達兩倍，這使得插入/刪除時所需的旋轉次數較少，適合寫入頻繁的場景。",
      "en": "AVL Trees maintain strict balance (height diff <= 1), offering fast lookups but high maintenance cost. Red-Black Trees are 'loosely balanced', allowing path lengths to differ by up to 2x, which requires fewer rotations during insert/delete, making them suitable for write-heavy scenarios.",
      "wg": [
        {
          "t": "維護成本",
          "en": "maintenance cost",
          "ps": "N"
        },
        {
          "t": "寬鬆",
          "en": "loose",
          "ps": "Adj"
        }
      ]
    }
  }
]