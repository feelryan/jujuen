[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Trie, Prefix Tree, Autocomplete, String Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的自動完成系統，需要快速查找具有特定前綴的所有單字。",
        "en": "You are designing an autocomplete system for a search engine that needs to quickly look up all words with a specific prefix.",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          },
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "相較於雜湊表 (Hash Map)，為什麼 Trie (前綴樹) 是更合適的資料結構？",
        "en": "Compared to a Hash Map, why is a Trie (Prefix Tree) a more suitable data structure?",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          },
          {
            "t": "合適的",
            "en": "suitable",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在查找完全匹配的單字時總是比雜湊表快。",
        "en": "(A) A Trie is always faster than a Hash Map when looking up exact matches.",
        "wg": []
      },
      {
        "t": "(B) Trie 能夠在 O(L) 時間內找到所有具備共同前綴的單字 (L 為前綴長度)，而雜湊表不支援高效的前綴查詢。",
        "en": "(B) A Trie can find all words with a common prefix in O(L) time (where L is the prefix length), whereas a Hash Map does not support efficient prefix queries.",
        "wg": [
          {
            "t": "共同前綴",
            "en": "common prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Trie 使用的記憶體空間總是比雜湊表少。",
        "en": "(C) A Trie always uses less memory space than a Hash Map.",
        "wg": []
      },
      {
        "t": "(D) Trie 不需要處理雜湊碰撞的問題，因此實作上比雜湊表簡單。",
        "en": "(D) A Trie does not need to handle hash collisions, so it is simpler to implement than a Hash Map.",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "hash collision",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的結構特性使其非常適合處理字串前綴問題。雖然雜湊表在完全匹配查詢上通常是 O(1)，但它無法有效處理「以某字串開頭」的查詢，這通常需要遍歷所有鍵值。",
      "en": "The structural characteristics of a Trie make it ideal for handling string prefix problems. While a Hash Map is typically O(1) for exact match queries, it cannot efficiently handle 'starts with' queries, which usually requires iterating through all keys.",
      "wg": [
        {
          "t": "遍歷",
          "en": "iterate",
          "ps": "V"
        },
        {
          "t": "結構特性",
          "en": "structural characteristics",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "B+ Tree, Database, Indexing, Disk I/O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在關聯式資料庫中，索引通常使用 B+ Tree 而不是二元搜尋樹 (BST) 或紅黑樹。",
        "en": "In relational databases, indexes typically use B+ Trees instead of Binary Search Trees (BST) or Red-Black Trees.",
        "wg": [
          {
            "t": "關聯式資料庫",
            "en": "relational database",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "主要原因與下列何者最相關？",
        "en": "Which of the following is the most relevant primary reason?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) B+ Tree 的實作比紅黑樹簡單。",
        "en": "(A) The implementation of B+ Trees is simpler than Red-Black Trees.",
        "wg": []
      },
      {
        "t": "(B) B+ Tree 具有較高的分支因子 (Branching Factor)，能顯著降低樹的高度，進而減少磁碟 I/O 次數。",
        "en": "(B) B+ Trees have a higher branching factor, which significantly reduces the height of the tree, thereby reducing disk I/O operations.",
        "wg": [
          {
            "t": "分支因子",
            "en": "branching factor",
            "ps": "N"
          },
          {
            "t": "磁碟 I/O",
            "en": "disk I/O",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) B+ Tree 支援 O(1) 的隨機存取。",
        "en": "(C) B+ Trees support O(1) random access.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 二元搜尋樹無法儲存重複的鍵值。",
        "en": "(D) Binary Search Trees cannot store duplicate keys.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "資料庫索引主要儲存在磁碟上，讀取磁碟 (I/O) 的成本極高。B+ Tree 透過每個節點儲存多個鍵值 (高分支因子) 來讓樹變得非常扁平，極大化地減少了尋找資料時所需的磁碟讀取次數。",
      "en": "Database indexes are primarily stored on disk, where read costs (I/O) are very high. B+ Trees keep the tree very flat by storing multiple keys per node (high branching factor), maximizing the reduction of disk reads required to find data.",
      "wg": [
        {
          "t": "扁平",
          "en": "flat",
          "ps": "Adj"
        },
        {
          "t": "極大化",
          "en": "maximize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Segment Tree, Range Query, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您有一個包含 N 個整數的陣列，需要頻繁執行兩項操作：更新特定索引的值，以及計算特定範圍 [L, R] 的總和。",
        "en": "You have an array of N integers and need to frequently perform two operations: update the value at a specific index, and calculate the sum of a specific range [L, R].",
        "wg": [
          {
            "t": "頻繁",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "特定範圍",
            "en": "specific range",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若使用線段樹 (Segment Tree)，這兩項操作的時間複雜度分別為何？",
        "en": "If using a Segment Tree, what are the time complexities for these two operations respectively?",
        "wg": [
          {
            "t": "線段樹",
            "en": "Segment Tree",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 更新: O(1), 範圍和: O(N)",
        "en": "(A) Update: O(1), Range Sum: O(N)",
        "wg": []
      },
      {
        "t": "(B) 更新: O(N), 範圍和: O(1)",
        "en": "(B) Update: O(N), Range Sum: O(1)",
        "wg": []
      },
      {
        "t": "(C) 更新: O(log N), 範圍和: O(log N)",
        "en": "(C) Update: O(log N), Range Sum: O(log N)",
        "wg": []
      },
      {
        "t": "(D) 更新: O(1), 範圍和: O(1)",
        "en": "(D) Update: O(1), Range Sum: O(1)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "若使用單純陣列，更新是 O(1) 但範圍和是 O(N)；若使用前綴和陣列，範圍和是 O(1) 但更新是 O(N)。線段樹提供了一種平衡方案，讓這兩項操作都能在 O(log N) 內完成。",
      "en": "Using a simple array, updates are O(1) but range sums are O(N); using a prefix sum array, range sums are O(1) but updates are O(N). A Segment Tree provides a balanced solution where both operations can be completed in O(log N).",
      "wg": [
        {
          "t": "前綴和",
          "en": "prefix sum",
          "ps": "N"
        },
        {
          "t": "平衡方案",
          "en": "balanced solution",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Binary Heap, Array Representation, Priority Queue",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二元堆積 (Binary Heap) 通常使用陣列來實作。",
        "en": "A Binary Heap is typically implemented using an array.",
        "wg": [
          {
            "t": "二元堆積",
            "en": "Binary Heap",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "在一個從索引 0 開始的陣列中，若某個節點位於索引 `i`，其左子節點和右子節點的索引分別為何？",
        "en": "In a 0-indexed array, if a node is located at index `i`, what are the indices of its left child and right child respectively?",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 左: 2i, 右: 2i + 1",
        "en": "(A) Left: 2i, Right: 2i + 1",
        "wg": []
      },
      {
        "t": "(B) 左: 2i + 1, 右: 2i + 2",
        "en": "(B) Left: 2i + 1, Right: 2i + 2",
        "wg": []
      },
      {
        "t": "(C) 左: i + 1, 右: i + 2",
        "en": "(C) Left: i + 1, Right: i + 2",
        "wg": []
      },
      {
        "t": "(D) 左: i / 2, 右: (i / 2) + 1",
        "en": "(D) Left: i / 2, Right: (i / 2) + 1",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在 0-indexed (以 0 為基底) 的陣列表示法中，根節點在 0。對於任意節點 i，其左子節點位於 2i + 1，右子節點位於 2i + 2。若是以 1 為基底，則為 2i 與 2i + 1。",
      "en": "In a 0-indexed array representation, the root is at 0. For any node i, its left child is at 2i + 1 and its right child is at 2i + 2. If it were 1-indexed, they would be 2i and 2i + 1.",
      "wg": [
        {
          "t": "以...為基底",
          "en": "...-based / ...-indexed",
          "ps": "Adj"
        },
        {
          "t": "任意節點",
          "en": "arbitrary node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Tree Traversal, Serialization, Reconstruction",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要將一棵二元樹序列化 (Serialize) 並確保能唯一地重建 (Reconstruct) 回原本的結構 (假設不儲存 null 標記)，",
        "en": "To serialize a binary tree and ensure it can be uniquely reconstructed back to its original structure (assuming null markers are not stored),",
        "wg": [
          {
            "t": "序列化",
            "en": "serialize",
            "ps": "V"
          },
          {
            "t": "重建",
            "en": "reconstruct",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪種遍歷組合是**不足夠**的？",
        "en": "Which of the following traversal combinations is **insufficient**?",
        "wg": [
          {
            "t": "不足夠的",
            "en": "insufficient",
            "ps": "Adj"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 中序 (Inorder) 與 前序 (Preorder)",
        "en": "(A) Inorder and Preorder",
        "wg": []
      },
      {
        "t": "(B) 中序 (Inorder) 與 後序 (Postorder)",
        "en": "(B) Inorder and Postorder",
        "wg": []
      },
      {
        "t": "(C) 前序 (Preorder) 與 後序 (Postorder)",
        "en": "(C) Preorder and Postorder",
        "wg": []
      },
      {
        "t": "(D) 以上組合皆可唯一重建",
        "en": "(D) All combinations above allow unique reconstruction",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "前序與後序遍歷的組合無法唯一決定一棵二元樹，因為無法區分一個節點是左子節點還是右子節點 (例如：根節點有一個子節點時，無法確定其左右位置)。必須包含中序遍歷才能確定左右子樹的邊界。",
      "en": "The combination of Preorder and Postorder traversals cannot uniquely determine a binary tree because it cannot distinguish whether a node is a left child or a right child (e.g., when a root has one child, its side is ambiguous). Inorder traversal is required to define the boundaries of left and right subtrees.",
      "wg": [
        {
          "t": "區分",
          "en": "distinguish",
          "ps": "V"
        },
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        },
        {
          "t": "模糊不清/歧義",
          "en": "ambiguous",
          "ps": "Adj"
        }
      ]
    }
  }
]