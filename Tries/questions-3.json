[
  {
    "no": "11",
    "level": "hard",
    "keywords": "Trie, Space Complexity, Radix Tree, Compression",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在標準的 Trie (字首樹) 中，若儲存大量具有長公共前綴或長單一分支路徑的字串，可能會導致空間浪費。",
        "en": "In a standard Trie, storing a large number of strings with long common prefixes or long single-branch paths can lead to wasted space.",
        "wg": [
          {
            "t": "公共前綴",
            "en": "common prefix",
            "ps": "N"
          },
          {
            "t": "單一分支",
            "en": "single-branch",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了優化空間使用率，我們可以將只有一個子節點的連續節點合併。",
        "en": "To optimize space usage, we can merge consecutive nodes that have only one child.",
        "wg": [
          {
            "t": "連續節點",
            "en": "consecutive nodes",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問這種優化後的資料結構通常被稱為什麼？",
        "en": "What is this optimized data structure commonly called?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) AVL Tree (AVL 樹)",
        "en": "(A) AVL Tree",
        "wg": []
      },
      {
        "t": "(B) Radix Tree (基數樹) 或 Patricia Trie",
        "en": "(B) Radix Tree or Patricia Trie",
        "wg": []
      },
      {
        "t": "(C) Segment Tree (線段樹)",
        "en": "(C) Segment Tree",
        "wg": []
      },
      {
        "t": "(D) Suffix Array (後綴陣列)",
        "en": "(D) Suffix Array",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Radix Tree (或稱 Patricia Trie) 是一種壓縮的 Trie，它透過合併只有單一子節點的路徑來減少節點數量，從而顯著降低空間複雜度。",
      "en": "A Radix Tree (or Patricia Trie) is a compressed Trie that reduces the number of nodes by merging paths with single children, thereby significantly reducing space complexity.",
      "wg": [
        {
          "t": "壓縮",
          "en": "compressed",
          "ps": "Adj"
        },
        {
          "t": "空間複雜度",
          "en": "space complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Trie, Autocomplete, System Design, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的自動完成 (Autocomplete) 系統。",
        "en": "You are designing an autocomplete system for a search engine.",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當使用者輸入前綴時，系統需要快速回傳該前綴下最熱門的 5 個關鍵字。",
        "en": "When a user types a prefix, the system needs to quickly return the top 5 most popular keywords under that prefix.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "熱門",
            "en": "popular",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了達到最低的查詢延遲 (Latency)，下列哪種 Trie 的實作策略最為合適？",
        "en": "To achieve the lowest query latency, which of the following Trie implementation strategies is most appropriate?",
        "wg": [
          {
            "t": "查詢延遲",
            "en": "query latency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 在每個 Trie 節點上執行深度優先搜尋 (DFS) 以找出所有可能的單字，然後進行排序。",
        "en": "(A) Perform Depth-First Search (DFS) at each Trie node to find all possible words, then sort them.",
        "wg": [
          {
            "t": "深度優先搜尋",
            "en": "Depth-First Search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 在每個 Trie 節點中預先儲存或快取該子樹中最熱門的 5 個關鍵字列表。",
        "en": "(B) Pre-store or cache a list of the top 5 most popular keywords in that subtree at each Trie node.",
        "wg": [
          {
            "t": "預先儲存",
            "en": "pre-store",
            "ps": "V"
          },
          {
            "t": "快取",
            "en": "cache",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用雜湊表 (Hash Map) 儲存所有前綴與其對應的熱門關鍵字，完全不使用 Trie。",
        "en": "(C) Use a Hash Map to store all prefixes and their corresponding popular keywords, without using a Trie at all.",
        "wg": []
      },
      {
        "t": "(D) 僅在葉節點 (Leaf Node) 儲存熱門度分數，查詢時遍歷整個子樹。",
        "en": "(D) Store popularity scores only at leaf nodes and traverse the entire subtree during a query.",
        "wg": [
          {
            "t": "葉節點",
            "en": "leaf node",
            "ps": "N"
          },
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (B) 是以空間換取時間的最佳策略。若在查詢時才進行遍歷 (DFS) 和排序 (選項 A 和 D)，當資料量大時會非常緩慢。雖然選項 (C) 查詢快，但空間消耗過大且無法處理模糊匹配。",
      "en": "Option (B) is the best strategy for trading space for time. Performing traversal (DFS) and sorting at query time (Options A and D) is too slow for large datasets. While Option (C) is fast, it consumes excessive space and cannot handle fuzzy matching.",
      "wg": [
        {
          "t": "以空間換取時間",
          "en": "trading space for time",
          "ps": "Phrase"
        },
        {
          "t": "模糊匹配",
          "en": "fuzzy matching",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Trie, Bitwise Operations, XOR, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n  TrieNode[] children = new TrieNode[2]; // 0 and 1\n}",
    "question": [
      {
        "t": "給定一個非負整數陣列，我們希望找出陣列中任意兩個數字進行 XOR 運算後的所謂「最大異或值」。",
        "en": "Given an array of non-negative integers, we want to find the \"Maximum XOR value\" obtained by XORing any two numbers in the array.",
        "wg": [
          {
            "t": "最大異或值",
            "en": "Maximum XOR value",
            "ps": "N"
          },
          {
            "t": "非負整數",
            "en": "non-negative integers",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用二進位 Trie (Binary Trie) 可以有效地解決此問題。",
        "en": "Using a Binary Trie can effectively solve this problem.",
        "wg": [
          {
            "t": "二進位",
            "en": "binary",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "在建構好 Trie 後，對於每個數字進行查詢以尋找最佳匹配時，應採取什麼樣的貪婪策略 (Greedy Strategy)？",
        "en": "After constructing the Trie, what greedy strategy should be adopted when querying each number to find the best match?",
        "wg": [
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          },
          {
            "t": "最佳匹配",
            "en": "best match",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 盡可能走向與當前位元 (Bit) 相同的路徑 (0 對 0, 1 對 1)。",
        "en": "(A) Try to go to the path identical to the current bit (0 to 0, 1 to 1).",
        "wg": []
      },
      {
        "t": "(B) 盡可能走向與當前位元 (Bit) 相反的路徑 (0 對 1, 1 對 0)。",
        "en": "(B) Try to go to the path opposite to the current bit (0 to 1, 1 to 0).",
        "wg": [
          {
            "t": "相反",
            "en": "opposite",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 總是優先走向代表 '1' 的分支。",
        "en": "(C) Always prioritize the branch representing '1'.",
        "wg": []
      },
      {
        "t": "(D) 隨機選擇路徑，並回溯尋找最大值。",
        "en": "(D) Randomly select a path and backtrack to find the maximum.",
        "wg": [
          {
            "t": "回溯",
            "en": "backtrack",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "XOR 運算的特性是「相同為 0，不同為 1」。為了最大化結果，我們希望高位元盡可能是 1。因此，策略是盡可能選擇與當前數字位元「相反」的路徑，這樣 XOR 結果在該位元就會是 1。",
      "en": "The property of XOR is 'same is 0, different is 1'. To maximize the result, we want the most significant bits to be 1. Therefore, the strategy is to choose the path 'opposite' to the current number's bit whenever possible, so the XOR result at that bit becomes 1.",
      "wg": [
        {
          "t": "高位元",
          "en": "most significant bits",
          "ps": "N"
        },
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Trie, Implementation, Array vs Map, Memory",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 TrieNode 時，我們通常有兩種儲存子節點的方式：使用固定大小的陣列 (如 `Node[26]`) 或使用雜湊表 (如 `HashMap<Char, Node>`)。",
        "en": "When implementing a TrieNode, we typically have two ways to store children: using a fixed-size array (e.g., `Node[26]`) or using a Hash Map (e.g., `HashMap<Char, Node>`).",
        "wg": [
          {
            "t": "固定大小",
            "en": "fixed-size",
            "ps": "Adj"
          },
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於這兩種實作方式的比較，下列敘述何者正確？",
        "en": "Regarding the comparison of these two implementations, which of the following statements is true?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用陣列總是比雜湊表節省記憶體，因為雜湊表有額外的物件開銷。",
        "en": "(A) Using an array always saves more memory than a Hash Map because Hash Maps have object overhead.",
        "wg": [
          {
            "t": "開銷",
            "en": "overhead",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用雜湊表在字元集 (Character Set) 很大且資料稀疏 (Sparse) 時較省空間。",
        "en": "(B) Using a Hash Map saves more space when the character set is large and the data is sparse.",
        "wg": [
          {
            "t": "字元集",
            "en": "character set",
            "ps": "N"
          },
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 使用陣列的查詢時間複雜度為 O(1)，而雜湊表為 O(log N)。",
        "en": "(C) The query time complexity for an array is O(1), while for a Hash Map it is O(log N).",
        "wg": []
      },
      {
        "t": "(D) 陣列實作無法支援非英文字母的字元。",
        "en": "(D) Array implementation cannot support non-English characters.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若字元集很大 (例如 Unicode)，宣告固定大陣列會浪費大量空間儲存 `null` 指標。雜湊表僅儲存存在的子節點，適合稀疏資料。選項 (A) 錯誤，因為稀疏時陣列浪費更多；選項 (C) 錯誤，雜湊表平均查詢也是 O(1)。",
      "en": "If the character set is large (e.g., Unicode), declaring a large fixed array wastes significant space storing `null` pointers. A Hash Map only stores existing children, making it suitable for sparse data. Option (A) is wrong because arrays waste more when sparse; Option (C) is wrong as Hash Map average lookup is also O(1).",
      "wg": [
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        },
        {
          "t": "宣告",
          "en": "declare",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "Trie, Wildcard Search, DFS, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": "search(node, word, index)",
    "question": [
      {
        "t": "我們需要在 Trie 中實作支援萬用字元 `.` 的搜尋功能，其中 `.` 可以代表任意一個字元。",
        "en": "We need to implement a search function in a Trie that supports the wildcard character `.`, where `.` can represent any single character.",
        "wg": [
          {
            "t": "萬用字元",
            "en": "wildcard character",
            "ps": "N"
          },
          {
            "t": "任意",
            "en": "arbitrary/any",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "當演算法遇到 `.` 時，應該採取什麼操作？",
        "en": "What action should the algorithm take when it encounters a `.`?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接跳過當前層級，檢查下一個字元。",
        "en": "(A) Skip the current level directly and check the next character.",
        "wg": []
      },
      {
        "t": "(B) 遍歷當前節點的所有非空子節點，並對每個子節點遞迴執行搜尋。",
        "en": "(B) Iterate through all non-null children of the current node and recursively search each child.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          },
          {
            "t": "非空",
            "en": "non-null",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 僅檢查第一個子節點，因為 `.` 只匹配一個字元。",
        "en": "(C) Check only the first child node, because `.` matches only one character.",
        "wg": []
      },
      {
        "t": "(D) 回傳 False，因為 Trie 不支援模糊搜尋。",
        "en": "(D) Return False, because Tries do not support fuzzy search.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當遇到萬用字元 `.` 時，我們無法確定應該走哪條路徑，因此必須嘗試所有可能的路徑。這意味著需要遍歷當前節點的所有子節點，並對它們進行遞迴搜尋 (Backtracking/DFS)。",
      "en": "When a wildcard `.` is encountered, we cannot determine which path to take, so we must try all possible paths. This means iterating through all children of the current node and performing a recursive search (Backtracking/DFS) on them.",
      "wg": [
        {
          "t": "嘗試",
          "en": "attempt",
          "ps": "V"
        },
        {
          "t": "回溯",
          "en": "backtracking",
          "ps": "N"
        }
      ]
    }
  }
]