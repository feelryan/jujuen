[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Trie, Time Complexity, Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在標準的 Trie（前綴樹）資料結構中，搜尋一個長度為 L 的單字是否存在，其時間複雜度為何？",
        "en": "In a standard Trie (Prefix Tree) data structure, what is the time complexity to search for the existence of a word of length L?",
        "wg": [
          {
            "t": "前綴樹",
            "en": "Prefix Tree",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設字典中總共有 N 個單字。",
        "en": "Assume there are a total of N words in the dictionary.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(L)",
        "en": "(B) O(L)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N * L)",
        "en": "(D) O(N * L)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的搜尋效能僅與要搜尋的單字長度 (L) 成正比，因為我們只需要遍歷該單字的字元節點。",
      "en": "The search performance of a Trie is proportional only to the length of the word being searched (L), as we only need to traverse the character nodes of that word.",
      "wg": [
        {
          "t": "成正比",
          "en": "proportional",
          "ps": "Adj"
        },
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Trie, Space Complexity, Memory",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEndOfWord;\n}",
    "question": [
      {
        "t": "觀察上述使用固定大小陣列（長度 26）來儲存子節點的 Trie 實作。",
        "en": "Observe the Trie implementation above that uses a fixed-size array (length 26) to store children nodes.",
        "wg": [
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          },
          {
            "t": "固定大小",
            "en": "fixed-size",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "這種實作方式最主要的缺點是什麼？",
        "en": "What is the main disadvantage of this implementation approach?",
        "wg": [
          {
            "t": "缺點",
            "en": "disadvantage",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 搜尋速度比使用 Hash Map 的節點慢。",
        "en": "(A) Search speed is slower than nodes using a Hash Map.",
        "wg": []
      },
      {
        "t": "(B) 無法處理英文以外的字元。",
        "en": "(B) It cannot handle characters other than English.",
        "wg": []
      },
      {
        "t": "(C) 當資料稀疏時，會造成大量的記憶體浪費。",
        "en": "(C) It causes significant memory waste when the data is sparse.",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          },
          {
            "t": "記憶體浪費",
            "en": "memory waste",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 插入操作的時間複雜度會變成 O(N)。",
        "en": "(D) The time complexity of the insert operation becomes O(N).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "每個節點都預先分配了 26 個指標的空間，但如果單字沒有共用前綴或分佈稀疏，大部分的指標都會是 null，導致空間效率低落。",
      "en": "Each node pre-allocates space for 26 pointers, but if words do not share prefixes or are sparsely distributed, most pointers will be null, leading to poor space efficiency.",
      "wg": [
        {
          "t": "預先分配",
          "en": "pre-allocate",
          "ps": "V"
        },
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "easy",
    "keywords": "Trie, Implementation, Insert",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 Trie 的 `insert(word)` 函式時，當遍歷完 `word` 的所有字元並建立對應節點後，必須執行哪個關鍵步驟？",
        "en": "When implementing the `insert(word)` function in a Trie, what crucial step must be performed after traversing all characters of `word` and creating corresponding nodes?",
        "wg": [
          {
            "t": "關鍵步驟",
            "en": "crucial step",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這個步驟是為了區分該路徑是完整的單字，還是僅為其他單字的前綴。",
        "en": "This step is to distinguish whether the path is a complete word or just a prefix of other words.",
        "wg": [
          {
            "t": "區分",
            "en": "distinguish",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 刪除該節點的所有子節點。",
        "en": "(A) Delete all children of that node.",
        "wg": []
      },
      {
        "t": "(B) 將該節點標記為單字的結尾 (isEndOfWord = true)。",
        "en": "(B) Mark the node as the end of a word (isEndOfWord = true).",
        "wg": [
          {
            "t": "標記",
            "en": "mark",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 回傳根節點 (Root Node)。",
        "en": "(C) Return the Root Node.",
        "wg": []
      },
      {
        "t": "(D) 計算該單字的 Hash 值並儲存。",
        "en": "(D) Calculate and store the Hash value of the word.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的路徑可能同時代表 'apple' 和 'app'。",
      "en": "A path in a Trie might represent both 'apple' and 'app'.",
      "wg": []
    },
    "why_continued": {
      "t": "如果不標記 'app' 的最後一個 'p' 節點為結尾，搜尋 'app' 時會誤以為它只是前綴而非完整單字。",
      "en": "If the last 'p' node of 'app' is not marked as an end, searching for 'app' would mistakenly identify it only as a prefix rather than a complete word.",
      "wg": [
        {
          "t": "誤以為",
          "en": "mistakenly identify",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Trie, Autocomplete, Application",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的「自動完成」(Autocomplete) 功能。",
        "en": "You are designing an 'Autocomplete' feature for a search engine.",
        "wg": [
          {
            "t": "自動完成",
            "en": "Autocomplete",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當使用者輸入前綴字串 \"pre\" 時，系統需要快速回傳所有以 \"pre\" 開頭的熱門單字。",
        "en": "When a user inputs the prefix string \"pre\", the system needs to quickly return all popular words starting with \"pre\".",
        "wg": [
          {
            "t": "熱門單字",
            "en": "popular words",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用 Trie 實作此功能時，一般的演算法流程為何？",
        "en": "When implementing this feature using a Trie, what is the general algorithmic flow?",
        "wg": [
          {
            "t": "演算法流程",
            "en": "algorithmic flow",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遍歷整棵樹，檢查每個節點是否包含 \"pre\"。",
        "en": "(A) Traverse the entire tree and check if each node contains \"pre\".",
        "wg": []
      },
      {
        "t": "(B) 先定位到代表 \"pre\" 最後一個字元的節點，然後對該節點的子樹進行遍歷（如 DFS）以收集所有單字。",
        "en": "(B) First locate the node representing the last character of \"pre\", then traverse its subtree (e.g., DFS) to collect all words.",
        "wg": [
          {
            "t": "定位",
            "en": "locate",
            "ps": "V"
          },
          {
            "t": "子樹",
            "en": "subtree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用二元搜尋法在 Trie 中尋找 \"pre\"。",
        "en": "(C) Use binary search to find \"pre\" in the Trie.",
        "wg": []
      },
      {
        "t": "(D) 將所有單字存入 Hash Map，並遍歷所有 Key 來比對前綴。",
        "en": "(D) Store all words in a Hash Map and iterate through all Keys to match the prefix.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是 Trie 最典型的應用場景。",
      "en": "This is the most typical application scenario for a Trie.",
      "wg": []
    },
    "why_continued": {
      "t": "一旦到達前綴的最後一個節點，該節點下的所有後代節點必然都包含該前綴，因此只需搜尋該子樹即可，效率遠高於掃描全表。",
      "en": "Once the last node of the prefix is reached, all descendant nodes under that node inevitably contain that prefix, so only that subtree needs to be searched, which is much more efficient than scanning the entire table.",
      "wg": [
        {
          "t": "後代節點",
          "en": "descendant nodes",
          "ps": "N"
        },
        {
          "t": "掃描全表",
          "en": "scanning the entire table",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Trie, HashMap, Comparison",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在「前綴搜尋」(Prefix Search) 的場景下，為什麼 Trie 通常比 Hash Map 更具優勢？",
        "en": "In the context of 'Prefix Search', why is a Trie usually more advantageous than a Hash Map?",
        "wg": [
          {
            "t": "具優勢",
            "en": "advantageous",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在儲存任何資料時都比 Hash Map 節省記憶體。",
        "en": "(A) Tries always save more memory than Hash Maps when storing any data.",
        "wg": []
      },
      {
        "t": "(B) Hash Map 無法在 O(L) 時間內找到所有以特定前綴開頭的鍵，通常需要 O(N) 掃描。",
        "en": "(B) Hash Maps cannot find all keys starting with a specific prefix in O(L) time; they usually require an O(N) scan.",
        "wg": [
          {
            "t": "掃描",
            "en": "scan",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Trie 的實作比 Hash Map 簡單許多。",
        "en": "(C) The implementation of a Trie is much simpler than that of a Hash Map.",
        "wg": []
      },
      {
        "t": "(D) Hash Map 不支援字串作為鍵值 (Key)。",
        "en": "(D) Hash Maps do not support strings as keys.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Hash Map 擅長「精確比對」(Exact Match)，但對於前綴查詢，Hash Map 必須檢查所有項目（或依賴額外的排序結構），而 Trie 天生就是依據前綴結構儲存的。",
      "en": "Hash Maps excel at 'Exact Match', but for prefix queries, a Hash Map must check all items (or rely on additional sorting structures), whereas a Trie inherently stores data based on prefix structure.",
      "wg": [
        {
          "t": "精確比對",
          "en": "Exact Match",
          "ps": "N"
        },
        {
          "t": "天生",
          "en": "inherently",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "easy",
    "keywords": "Time Complexity, Search, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在標準的 Trie (字典樹) 中搜尋一個特定的單字時，其時間複雜度主要取決於什麼因素？",
        "en": "When searching for a specific word in a standard Trie (Prefix Tree), what factor primarily determines the time complexity?",
        "wg": [
          {
            "t": "取決於",
            "en": "depends on",
            "ps": "V"
          },
          {
            "t": "因素",
            "en": "factor",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設字典中有 N 個單字，而要搜尋的單字長度為 L。",
        "en": "Assume there are N words in the dictionary, and the length of the word being searched is L.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N) - 與字典中的單字總數成正比。",
        "en": "(A) O(N) - Proportional to the total number of words in the dictionary.",
        "wg": [
          {
            "t": "成正比",
            "en": "proportional to",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) O(L) - 與被搜尋單字的長度成正比。",
        "en": "(B) O(L) - Proportional to the length of the word being searched.",
        "wg": []
      },
      {
        "t": "(C) O(N * L) - 需要遍歷所有單字並比對字元。",
        "en": "(C) O(N * L) - Requires traversing all words and comparing characters.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) O(1) - 透過雜湊計算可立即找到。",
        "en": "(D) O(1) - Can be found instantly via hash calculation.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的搜尋效率極高，因為它只需要按照目標單字的字元路徑向下遍歷。操作次數僅與單字的長度 L 有關，與字典中儲存了多少單字 (N) 無關。",
      "en": "Trie search is highly efficient because it only requires traversing down the path of the target word's characters. The number of operations depends only on the length of the word L, not on how many words (N) are stored in the dictionary.",
      "wg": [
        {
          "t": "操作次數",
          "en": "number of operations",
          "ps": "N"
        },
        {
          "t": "無關",
          "en": "independent of",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Space Complexity, Optimization, Radix Tree",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Trie 的一個主要缺點是空間消耗較大，特別是當儲存的字串具有很長的公共前綴但分支稀疏時。",
        "en": "A major disadvantage of Tries is high space consumption, especially when stored strings have long common prefixes but sparse branching.",
        "wg": [
          {
            "t": "缺點",
            "en": "disadvantage",
            "ps": "N"
          },
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪種資料結構是 Trie 的變體，透過合併只有一個子節點的節點來優化空間？",
        "en": "Which of the following data structures is a variant of the Trie that optimizes space by merging nodes that have only one child?",
        "wg": [
          {
            "t": "變體",
            "en": "variant",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merging",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Binary Search Tree (二元搜尋樹)。",
        "en": "(A) Binary Search Tree.",
        "wg": []
      },
      {
        "t": "(B) Radix Tree (基數樹) 或 Compressed Trie (壓縮字典樹)。",
        "en": "(B) Radix Tree or Compressed Trie.",
        "wg": []
      },
      {
        "t": "(C) Hash Map (雜湊表)。",
        "en": "(C) Hash Map.",
        "wg": []
      },
      {
        "t": "(D) Balanced Tree (平衡樹)。",
        "en": "(D) Balanced Tree.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Radix Tree (或稱 PATRICIA trie) 透過將連續的單一子節點路徑壓縮成一個邊或節點來減少空間浪費，這解決了標準 Trie 在稀疏資料下的空間問題。",
      "en": "A Radix Tree (or PATRICIA trie) reduces space waste by compressing paths of continuous single child nodes into a single edge or node, addressing the space issue of standard Tries with sparse data.",
      "wg": [
        {
          "t": "連續的",
          "en": "continuous",
          "ps": "Adj"
        },
        {
          "t": "解決",
          "en": "address",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Autocomplete, Implementation, Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在實作一個「自動完成」(Autocomplete) 功能。",
        "en": "You are implementing an 'Autocomplete' feature.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當使用者輸入前綴 \"app\" 時，系統應該回傳 \"apple\", \"apply\", \"appetite\" 等建議。",
        "en": "When a user types the prefix 'app', the system should return suggestions like 'apple', 'apply', 'appetite'.",
        "wg": [
          {
            "t": "建議",
            "en": "suggestions",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在 Trie 中找到代表最後一個字元 'p' 的節點後，接下來應該採取什麼步驟？",
        "en": "After finding the node representing the last character 'p' in the Trie, what step should be taken next?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 回傳該節點儲存的值並結束。",
        "en": "(A) Return the value stored in that node and terminate.",
        "wg": []
      },
      {
        "t": "(B) 從根節點重新開始搜尋所有以 'a' 開頭的單字。",
        "en": "(B) Restart the search from the root node for all words starting with 'a'.",
        "wg": []
      },
      {
        "t": "(C) 對以該節點為根的子樹進行遍歷 (如 DFS)，收集所有標記為單字結尾的節點。",
        "en": "(C) Perform a traversal (like DFS) on the subtree rooted at that node to collect all nodes marked as end-of-word.",
        "wg": [
          {
            "t": "子樹",
            "en": "subtree",
            "ps": "N"
          },
          {
            "t": "收集",
            "en": "collect",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 檢查該節點是否為葉節點，如果是則回傳該單字。",
        "en": "(D) Check if the node is a leaf node, and if so, return the word.",
        "wg": [
          {
            "t": "葉節點",
            "en": "leaf node",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "找到前綴節點僅是第一步。為了提供自動完成建議，必須遍歷該節點下的所有後代 (Descendants)，找出所有可能的完整單字。",
      "en": "Finding the prefix node is only the first step. To provide autocomplete suggestions, you must traverse all descendants of that node to find all possible complete words.",
      "wg": [
        {
          "t": "後代",
          "en": "descendants",
          "ps": "N"
        },
        {
          "t": "完整的",
          "en": "complete",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Implementation, Data Structure, Array vs Map",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n    // Option A\n    TrieNode[] children = new TrieNode[26];\n    // Option B\n    Map<Character, TrieNode> children = new HashMap<>();\n}",
    "question": [
      {
        "t": "在實作 TrieNode 時，關於儲存子節點的資料結構選擇（如程式碼片段所示），下列敘述何者正確？",
        "en": "When implementing a TrieNode, regarding the choice of data structure for storing child nodes (as shown in the code snippet), which of the following statements is true?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用陣列 (Option A) 比較節省空間，因為不需要儲存鍵值 (Key)。",
        "en": "(A) Using an array (Option A) saves more space because keys do not need to be stored.",
        "wg": []
      },
      {
        "t": "(B) 使用雜湊表 (Option B) 在字元集範圍很大 (如 Unicode) 且分支稀疏時，空間效率較佳。",
        "en": "(B) Using a Hash Map (Option B) is more space-efficient when the character set range is large (e.g., Unicode) and branching is sparse.",
        "wg": [
          {
            "t": "字元集",
            "en": "character set",
            "ps": "N"
          },
          {
            "t": "空間效率",
            "en": "space-efficient",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 使用陣列 (Option A) 的存取速度比雜湊表慢，因為需要計算索引。",
        "en": "(C) Access speed of using an array (Option A) is slower than a Hash Map because index calculation is required.",
        "wg": []
      },
      {
        "t": "(D) 兩者在空間和時間複雜度上完全相同。",
        "en": "(D) Both are identical in terms of space and time complexity.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "固定大小的陣列 (如 size 26) 存取速度最快 (O(1)) 但會浪費空間儲存 null 指標。若字元集很大 (如所有 Unicode)，陣列會過大，此時使用 Map 僅儲存存在的子節點會更節省空間。",
      "en": "Fixed-size arrays (e.g., size 26) have the fastest access speed (O(1)) but waste space storing null pointers. If the character set is large (e.g., all Unicode), the array becomes too large, so using a Map to store only existing child nodes is more space-efficient.",
      "wg": [
        {
          "t": "指標",
          "en": "pointers",
          "ps": "N"
        },
        {
          "t": "存在的",
          "en": "existing",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Deletion, Logic, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在 Trie 中刪除單字 \"cat\"，但字典中同時存在單字 \"cats\"。",
        "en": "Deleting the word 'cat' from a Trie, while the word 'cats' also exists in the dictionary.",
        "wg": [
          {
            "t": "刪除",
            "en": "deleting",
            "ps": "V"
          },
          {
            "t": "同時",
            "en": "simultaneously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "正確的刪除邏輯應該是如何？",
        "en": "What should be the correct deletion logic?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 刪除 'c', 'a', 't' 三個節點。",
        "en": "(A) Delete the three nodes 'c', 'a', and 't'.",
        "wg": []
      },
      {
        "t": "(B) 僅將 't' 節點的 `isEndOfWord` (是否為單字結尾) 標記設為 false，不刪除任何節點。",
        "en": "(B) Only set the `isEndOfWord` flag of the 't' node to false, without deleting any nodes.",
        "wg": [
          {
            "t": "標記",
            "en": "flag",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 刪除 't' 節點，保留 'c' 和 'a'。",
        "en": "(C) Delete the 't' node, keeping 'c' and 'a'.",
        "wg": []
      },
      {
        "t": "(D) 刪除整個 Trie 並重新建立。",
        "en": "(D) Delete the entire Trie and rebuild it.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "因為 \"cats\" 依賴於 \"cat\" 的路徑 (即 't' 節點還有子節點 's')，所以不能物理刪除 't' 節點。必須僅取消其「單字結尾」的標記，以確保較長的單字不受影響。",
      "en": "Since 'cats' relies on the path of 'cat' (meaning the 't' node has a child node 's'), the 't' node cannot be physically deleted. You must only unmark its 'end of word' flag to ensure longer words are not affected.",
      "wg": [
        {
          "t": "依賴於",
          "en": "relies on",
          "ps": "V"
        },
        {
          "t": "物理刪除",
          "en": "physically delete",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Trie, Autocomplete, Prefix Search, Data Structures",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在為一個搜尋引擎設計「自動完成」功能，系統需要根據使用者輸入的前幾個字元快速建議相關關鍵字。",
        "en": "You are designing an 'autocomplete' feature for a search engine, where the system needs to quickly suggest relevant keywords based on the first few characters entered by the user.",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          },
          {
            "t": "搜尋引擎",
            "en": "search engine",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在比較雜湊表 (Hash Table) 與字典樹 (Trie) 時，為什麼字典樹通常是實作此功能的較佳選擇？",
        "en": "When comparing a Hash Table and a Trie, why is a Trie usually the better choice for implementing this feature?",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Table",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 字典樹在查找完全匹配的字串時，時間複雜度總是優於雜湊表。",
        "en": "(A) A Trie always has better time complexity than a Hash Table when looking up exact string matches.",
        "wg": [
          {
            "t": "完全匹配",
            "en": "exact match",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 字典樹可以有效率地遍歷所有共享相同前綴的字串，而雜湊表不支援有序的前綴查找。",
        "en": "(B) A Trie can efficiently traverse all strings sharing the same prefix, whereas a Hash Table does not support ordered prefix lookups.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "共享",
            "en": "share",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 字典樹使用的記憶體空間總是比雜湊表少。",
        "en": "(C) A Trie always uses less memory space than a Hash Table.",
        "wg": []
      },
      {
        "t": "(D) 字典樹不需要處理雜湊碰撞 (Hash Collision) 的問題，因此插入速度總是比較快。",
        "en": "(D) A Trie does not need to handle Hash Collisions, so insertion speed is always faster.",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "Hash Collision",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "雜湊表適合「精確查找」，但無法有效找出「以特定字串為開頭」的所有項目。字典樹的結構本質上就是將相同前綴聚合在一起，因此非常適合前綴匹配與自動完成。",
      "en": "Hash Tables are suitable for 'exact lookups' but cannot efficiently find all items 'starting with a specific string'. The structure of a Trie inherently aggregates common prefixes, making it ideal for prefix matching and autocomplete.",
      "wg": [
        {
          "t": "精確查找",
          "en": "exact lookup",
          "ps": "N"
        },
        {
          "t": "聚合",
          "en": "aggregate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Trie, Time Complexity, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設有一個包含 N 個單字的字典樹，且最長的單字長度為 L。",
        "en": "Assume there is a Trie containing N words, and the maximum length of a word is L.",
        "wg": []
      },
      {
        "t": "在該字典樹中搜尋一個長度為 K 的特定單字，其最差情況的時間複雜度為何？",
        "en": "What is the worst-case time complexity to search for a specific word of length K in this Trie?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case",
            "ps": "Adj"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N)",
        "en": "(A) O(N)",
        "wg": []
      },
      {
        "t": "(B) O(L)",
        "en": "(B) O(L)",
        "wg": []
      },
      {
        "t": "(C) O(K)",
        "en": "(C) O(K)",
        "wg": []
      },
      {
        "t": "(D) O(log N)",
        "en": "(D) O(log N)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在字典樹中搜尋單字時，我們依序遍歷該單字的每一個字元。因此，所需的時間與目標單字的長度 K 成正比，與字典中單字的總數 N 無直接關係。",
      "en": "When searching for a word in a Trie, we traverse each character of the word sequentially. Therefore, the time required is proportional to the length of the target word K, and is not directly related to the total number of words N in the dictionary.",
      "wg": [
        {
          "t": "依序",
          "en": "sequentially",
          "ps": "Adv"
        },
        {
          "t": "成正比",
          "en": "proportional",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Trie, Deletion, Memory Management",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Trie contains: ['car', 'cart']\nOperation: delete('car')",
    "question": [
      {
        "t": "考慮一個字典樹目前包含 'car' 和 'cart' 兩個單字。",
        "en": "Consider a Trie that currently contains the two words 'car' and 'cart'.",
        "wg": []
      },
      {
        "t": "當我們執行刪除 'car' 的操作時，下列哪種處理方式是正確且安全的？",
        "en": "When we execute the operation to delete 'car', which of the following handling methods is correct and safe?",
        "wg": [
          {
            "t": "處理方式",
            "en": "handling method",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 刪除代表 'c'、'a'、'r' 的所有節點。",
        "en": "(A) Delete all nodes representing 'c', 'a', and 'r'.",
        "wg": []
      },
      {
        "t": "(B) 僅移除代表 'r' 的節點，保留 'c' 和 'a'。",
        "en": "(B) Remove only the node representing 'r', keeping 'c' and 'a'.",
        "wg": []
      },
      {
        "t": "(C) 將代表 'r' 的節點之 `isEndOfWord` (或 `isLeaf`) 標記設為 false，但不移除任何節點。",
        "en": "(C) Set the `isEndOfWord` (or `isLeaf`) flag of the node representing 'r' to false, but do not remove any nodes.",
        "wg": [
          {
            "t": "標記",
            "en": "flag",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 刪除整個字典樹並重新建立只包含 'cart' 的樹。",
        "en": "(D) Delete the entire Trie and rebuild a tree containing only 'cart'.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "因為 'car' 是 'cart' 的前綴，'r' 節點雖然不再是 'car' 的結尾，但它仍然是通往 't' (cart 的結尾) 的必經路徑。因此只能取消結尾標記，不能物理刪除節點，否則會破壞 'cart' 的結構。",
      "en": "Since 'car' is a prefix of 'cart', the 'r' node is no longer the end of 'car', but it is still a necessary path to 't' (the end of 'cart'). Therefore, we can only unmark the end-of-word flag and cannot physically delete the node; otherwise, the structure of 'cart' would be destroyed.",
      "wg": [
        {
          "t": "前綴",
          "en": "prefix",
          "ps": "N"
        },
        {
          "t": "必經路徑",
          "en": "necessary path",
          "ps": "N"
        },
        {
          "t": "物理刪除",
          "en": "physically delete",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Trie, Space Optimization, Radix Tree, Compressed Trie",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "標準字典樹 (Standard Trie) 在儲存大量具有長前綴且分支稀疏的字串 (例如 URL) 時，可能會浪費大量記憶體。",
        "en": "A Standard Trie may waste a significant amount of memory when storing a large number of strings with long prefixes and sparse branching (e.g., URLs).",
        "wg": [
          {
            "t": "分支稀疏",
            "en": "sparse branching",
            "ps": "Adj"
          },
          {
            "t": "浪費",
            "en": "waste",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪種資料結構是字典樹的變體，專門透過「壓縮單一子節點的路徑」來解決此空間問題？",
        "en": "Which of the following data structures is a variant of the Trie, specifically designed to solve this space issue by 'compressing paths of single child nodes'?",
        "wg": [
          {
            "t": "變體",
            "en": "variant",
            "ps": "N"
          },
          {
            "t": "壓縮",
            "en": "compressing",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 二元搜尋樹 (Binary Search Tree)",
        "en": "(A) Binary Search Tree",
        "wg": []
      },
      {
        "t": "(B) 基數樹 (Radix Tree / Patricia Trie)",
        "en": "(B) Radix Tree (Patricia Trie)",
        "wg": []
      },
      {
        "t": "(C) 雜湊映射 (HashMap)",
        "en": "(C) HashMap",
        "wg": []
      },
      {
        "t": "(D) 堆積 (Heap)",
        "en": "(D) Heap",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "基數樹 (Radix Tree) 或壓縮字典樹會將只有一個子節點的連續節點合併成一個節點 (例如將 'h'-'t'-'t'-'p' 合併為 'http')，大幅減少節點數量並節省記憶體。",
      "en": "A Radix Tree (or Compressed Trie) merges consecutive nodes that have only one child into a single node (e.g., merging 'h'-'t'-'t'-'p' into 'http'), significantly reducing the number of nodes and saving memory.",
      "wg": [
        {
          "t": "連續節點",
          "en": "consecutive nodes",
          "ps": "N"
        },
        {
          "t": "合併",
          "en": "merge",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Trie, Bitwise Operations, XOR, Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [3, 10, 5, 25, 2, 8]\nGoal: Find max(a XOR b)",
    "question": [
      {
        "t": "在一個整數陣列中，若要找出任意兩個數字進行 XOR (互斥或) 運算後的最大值。",
        "en": "In an integer array, if you want to find the maximum value obtained by XORing any two numbers.",
        "wg": [
          {
            "t": "互斥或",
            "en": "XOR (exclusive OR)",
            "ps": "N"
          },
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們可以利用「二元字典樹 (Binary Trie)」來優化此問題。請問在建構與搜尋該樹時，應該從數字的哪一個位元 (Bit) 開始處理？",
        "en": "We can use a 'Binary Trie' to optimize this problem. When constructing and searching this tree, from which bit of the numbers should we start processing?",
        "wg": [
          {
            "t": "優化",
            "en": "optimize",
            "ps": "V"
          },
          {
            "t": "建構",
            "en": "constructing",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 最低有效位 (LSB, Least Significant Bit)",
        "en": "(A) Least Significant Bit (LSB)",
        "wg": []
      },
      {
        "t": "(B) 最高有效位 (MSB, Most Significant Bit)",
        "en": "(B) Most Significant Bit (MSB)",
        "wg": []
      },
      {
        "t": "(C) 隨機選擇一位元",
        "en": "(C) Randomly selected bit",
        "wg": []
      },
      {
        "t": "(D) 中間的位元",
        "en": "(D) The middle bit",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "為了最大化 XOR 的結果，我們希望高位元盡可能為 1。因此，必須從最高有效位 (MSB) 開始處理，並在 Trie 中貪婪地尋找與當前位元相反的路徑 (0 對 1，1 對 0)。",
      "en": "To maximize the XOR result, we want the higher bits to be 1 as much as possible. Therefore, we must start processing from the Most Significant Bit (MSB) and greedily look for the path in the Trie that is opposite to the current bit (0 vs 1, 1 vs 0).",
      "wg": [
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        },
        {
          "t": "貪婪地",
          "en": "greedily",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "hard",
    "keywords": "Space Optimization, Radix Tree, Patricia Trie, Compression",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在標準的 Trie 實作中，如果我們儲存大量具有長共同前綴且分支稀疏的字串（例如 URL），會導致空間浪費。",
        "en": "In a standard Trie implementation, storing a large number of strings with long common prefixes and sparse branching (e.g., URLs) results in wasted space.",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          },
          {
            "t": "分支",
            "en": "branching",
            "ps": "N"
          },
          {
            "t": "空間浪費",
            "en": "wasted space",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了優化這種情況下的記憶體使用，我們通常會將只有一個子節點的連續路徑合併為單一節點。",
        "en": "To optimize memory usage in this scenario, we often merge consecutive paths that have only one child into a single node.",
        "wg": [
          {
            "t": "連續路徑",
            "en": "consecutive paths",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          }
        ]
      },
      {
        "t": "這種優化後的資料結構稱為什麼？",
        "en": "What is this optimized data structure called?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Suffix Tree (後綴樹)",
        "en": "(A) Suffix Tree",
        "wg": []
      },
      {
        "t": "(B) Radix Tree (基數樹) 或 Patricia Trie",
        "en": "(B) Radix Tree or Patricia Trie",
        "wg": []
      },
      {
        "t": "(C) AVL Tree (AVL 樹)",
        "en": "(C) AVL Tree",
        "wg": []
      },
      {
        "t": "(D) B+ Tree (B+ 樹)",
        "en": "(D) B+ Tree",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Radix Tree（或稱 Patricia Trie）是 Trie 的一種壓縮變體，它通過合併只有一個子節點的節點來減少樹的高度並節省空間，特別適合處理長字串且分支較少的情況。",
      "en": "A Radix Tree (or Patricia Trie) is a compressed variant of a Trie that reduces tree height and saves space by merging nodes that have only one child, making it particularly suitable for long strings with sparse branching.",
      "wg": [
        {
          "t": "變體",
          "en": "variant",
          "ps": "N"
        },
        {
          "t": "壓縮",
          "en": "compressed",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Time Complexity, Hash Table, Worst Case, Collision",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "比較 Trie 與雜湊表 (Hash Table) 在字串查找上的效能。",
        "en": "Compare the performance of a Trie versus a Hash Table for string lookups.",
        "wg": [
          {
            "t": "查找",
            "en": "lookup",
            "ps": "N"
          },
          {
            "t": "效能",
            "en": "performance",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設字串長度為 K，雖然雜湊表平均查找時間為 O(K)（計算雜湊值），但在最壞情況下可能退化。",
        "en": "Assuming a string length of K, although the Hash Table has an average lookup time of O(K) (calculating the hash), it can degrade in the worst case.",
        "wg": [
          {
            "t": "退化",
            "en": "degrade",
            "ps": "V"
          },
          {
            "t": "最壞情況",
            "en": "worst case",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為何在極端情況下，Trie 的查找時間保證可能優於雜湊表？",
        "en": "Why might the lookup time guarantee of a Trie be superior to a Hash Table in extreme cases?",
        "wg": [
          {
            "t": "保證",
            "en": "guarantee",
            "ps": "N"
          },
          {
            "t": "極端情況",
            "en": "extreme cases",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 不需要計算雜湊值，且沒有雜湊碰撞 (Hash Collision) 的問題，最壞時間複雜度始終為 O(K)。",
        "en": "(A) Tries do not require hash calculation and have no hash collision issues; the worst-case time complexity is always O(K).",
        "wg": [
          {
            "t": "雜湊碰撞",
            "en": "hash collision",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Trie 的空間複雜度總是比雜湊表低，因此快取 (Cache) 效率較高。",
        "en": "(B) The space complexity of a Trie is always lower than that of a Hash Table, resulting in higher cache efficiency.",
        "wg": [
          {
            "t": "快取",
            "en": "cache",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 雜湊表無法處理包含 Unicode 字元的字串。",
        "en": "(C) Hash Tables cannot handle strings containing Unicode characters.",
        "wg": []
      },
      {
        "t": "(D) Trie 可以在 O(1) 時間內找到字串，與長度無關。",
        "en": "(D) Tries can find a string in O(1) time, regardless of length.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "雜湊表在發生大量碰撞時，查找時間可能退化為 O(N)（取決於實作，如鏈結串列長度），而 Trie 的查找時間嚴格取決於鍵長 K，即 O(K)，提供了更穩定的最壞情況保證。",
      "en": "When many collisions occur, Hash Table lookup time can degrade to O(N) (depending on implementation, e.g., linked list length), whereas Trie lookup time strictly depends on the key length K, i.e., O(K), providing a more stable worst-case guarantee.",
      "wg": [
        {
          "t": "嚴格取決於",
          "en": "strictly depends on",
          "ps": "Phrase"
        },
        {
          "t": "穩定的",
          "en": "stable",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Networking, IP Routing, Longest Prefix Match, Binary Trie",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在網路路由器的實作中，需要根據 IP 位址決定封包的轉送路徑。",
        "en": "In the implementation of network routers, the forwarding path of a packet needs to be determined based on the IP address.",
        "wg": [
          {
            "t": "路由器",
            "en": "router",
            "ps": "N"
          },
          {
            "t": "轉送路徑",
            "en": "forwarding path",
            "ps": "N"
          }
        ]
      },
      {
        "t": "路由表通常使用 CIDR (Classless Inter-Domain Routing) 格式，且必須遵循「最長前綴匹配」(Longest Prefix Match) 原則。",
        "en": "Routing tables typically use CIDR (Classless Inter-Domain Routing) format and must follow the 'Longest Prefix Match' principle.",
        "wg": [
          {
            "t": "最長前綴匹配",
            "en": "Longest Prefix Match",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種 Trie 的變體最適合用來高效解決這個問題？",
        "en": "Which variant of the Trie is best suited to efficiently solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 26 叉 Trie (26-ary Trie)",
        "en": "(A) 26-ary Trie",
        "wg": []
      },
      {
        "t": "(B) 二元 Trie (Binary Trie) 或 1-bit Trie",
        "en": "(B) Binary Trie or 1-bit Trie",
        "wg": []
      },
      {
        "t": "(C) 雜湊映射 (HashMap)",
        "en": "(C) HashMap",
        "wg": []
      },
      {
        "t": "(D) 堆積 (Heap)",
        "en": "(D) Heap",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "IP 位址本質上是二進位數據（0 和 1）。使用二元 Trie（每個節點代表一個位元）可以高效地遍歷 IP 的位元流，並在路徑上標記路由規則，非常適合尋找最長的匹配前綴。",
      "en": "IP addresses are inherently binary data (0s and 1s). Using a Binary Trie (where each node represents a bit) allows efficient traversal of the IP bitstream and marking routing rules along the path, making it ideal for finding the longest matching prefix.",
      "wg": [
        {
          "t": "本質上",
          "en": "inherently",
          "ps": "Adv"
        },
        {
          "t": "位元流",
          "en": "bitstream",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "System Design, Autocomplete, Optimization, Metadata",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個搜尋引擎的「自動完成」(Autocomplete) 功能。",
        "en": "You are designing an 'Autocomplete' feature for a search engine.",
        "wg": [
          {
            "t": "自動完成",
            "en": "Autocomplete",
            "ps": "N"
          }
        ]
      },
      {
        "t": "系統需要在大規模數據集中，根據使用者輸入的前綴，快速回傳「熱門度最高」的 5 個關鍵字。",
        "en": "The system needs to quickly return the top 5 'most popular' keywords based on the prefix entered by the user from a large dataset.",
        "wg": [
          {
            "t": "熱門度",
            "en": "popularity",
            "ps": "N"
          },
          {
            "t": "大規模",
            "en": "large-scale",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "為了將查詢延遲降至最低，您應該如何在 Trie 節點中儲存資料？",
        "en": "To minimize query latency, how should you store data within the Trie nodes?",
        "wg": [
          {
            "t": "延遲",
            "en": "latency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 僅在葉節點 (Leaf Node) 儲存完整關鍵字與頻率，查詢時遍歷所有子樹並即時排序。",
        "en": "(A) Store complete keywords and frequencies only at leaf nodes; traverse all subtrees and sort in real-time during query.",
        "wg": [
          {
            "t": "即時",
            "en": "real-time",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 在每個 Trie 節點中預先快取經過該節點的「Top K 熱門關鍵字」列表。",
        "en": "(B) Pre-cache a list of the 'Top K popular keywords' that pass through that node in each Trie node.",
        "wg": [
          {
            "t": "預先快取",
            "en": "pre-cache",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用關聯式資料庫 (RDBMS) 的 LIKE 語法取代 Trie。",
        "en": "(C) Use the LIKE syntax of a Relational Database (RDBMS) instead of a Trie.",
        "wg": []
      },
      {
        "t": "(D) 在 Trie 節點中只儲存字元，查詢後將所有匹配結果傳送到客戶端進行排序。",
        "en": "(D) Store only characters in Trie nodes; send all matching results to the client for sorting after the query.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "即時遍歷整個子樹並排序 (選項 A) 在數據量大時太慢。最佳做法是犧牲寫入時間與空間，在每個節點維護該前綴下最熱門的 K 個結果，這樣讀取時僅需 O(1) 或 O(K) 時間即可回傳。",
      "en": "Traversing the entire subtree and sorting in real-time (Option A) is too slow for large datasets. The best practice is to trade write time and space by maintaining the top K most popular results for that prefix at each node, allowing O(1) or O(K) retrieval time.",
      "wg": [
        {
          "t": "犧牲",
          "en": "trade / sacrifice",
          "ps": "V"
        },
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Deletion, Algorithm, Memory Management, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "關於從 Trie 中刪除一個字串的操作，下列敘述何者正確？",
        "en": "Which of the following statements regarding deleting a string from a Trie is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設我們要刪除的字串確實存在於 Trie 中。",
        "en": "Assume the string we want to delete definitely exists in the Trie.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 必須刪除代表該字串最後一個字元的節點，然後由上而下刪除所有父節點。",
        "en": "(A) Must delete the node representing the last character of the string, then delete all parent nodes from top to bottom.",
        "wg": [
          {
            "t": "由上而下",
            "en": "top to bottom",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 僅需將代表該字串結尾節點的 `isEnd` (或 `isWord`) 標記設為 false 即可，不應移除任何節點以免破壞結構。",
        "en": "(B) Simply set the `isEnd` (or `isWord`) flag of the node representing the end of the string to false; do not remove any nodes to avoid breaking the structure.",
        "wg": []
      },
      {
        "t": "(C) 應將 `isEnd` 設為 false，若該節點無其他子節點，則應將其移除，並遞迴地向上檢查父節點是否也需要移除。",
        "en": "(C) Should set `isEnd` to false, and if the node has no other children, remove it and recursively check upwards if parent nodes also need removal.",
        "wg": [
          {
            "t": "遞迴地",
            "en": "recursively",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 刪除操作在 Trie 中是不允許的，只能重新建立整棵樹。",
        "en": "(D) Deletion operations are not allowed in a Trie; the entire tree must be rebuilt.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "雖然選項 (B) (Lazy Deletion) 是可行的，但會導致記憶體洩漏。標準且完整的刪除邏輯 (選項 C) 包含「修剪」不再需要的路徑：從底部開始，如果一個節點既不是單字的結尾也沒有其他子節點，就應該被釋放，以節省空間。",
      "en": "While Option (B) (Lazy Deletion) is feasible, it leads to memory leaks. The standard and complete deletion logic (Option C) involves 'pruning' paths that are no longer needed: starting from the bottom, if a node is neither the end of a word nor has other children, it should be freed to save space.",
      "wg": [
        {
          "t": "記憶體洩漏",
          "en": "memory leak",
          "ps": "N"
        },
        {
          "t": "修剪",
          "en": "pruning",
          "ps": "V"
        }
      ]
    }
  }
]