[
  {
    "no": "1",
    "level": "hard",
    "keywords": "Bitwise Trie, XOR, Algorithm, Binary Representation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個非負整數陣列，您需要找出其中任意兩個數字進行 XOR 運算後的最大值。",
        "en": "Given an array of non-negative integers, you need to find the maximum value obtained by XORing any two numbers.",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "N"
          },
          {
            "t": "運算",
            "en": "operation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了在優於 O(N^2) 的時間複雜度內解決此問題，應該如何設計 Trie 的結構與搜尋策略？",
        "en": "To solve this problem with a time complexity better than O(N^2), how should the Trie structure and search strategy be designed?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "搜尋策略",
            "en": "search strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將每個數字轉換為二進位字串，建立標準 Trie，並尋找最長共同前綴。",
        "en": "(A) Convert each number to a binary string, build a standard Trie, and find the longest common prefix.",
        "wg": [
          {
            "t": "二進位字串",
            "en": "binary string",
            "ps": "N"
          },
          {
            "t": "最長共同前綴",
            "en": "longest common prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 建立一個二進位 Trie (Binary Trie)，對每個數字進行查詢時，盡可能選擇與當前位元相反的路徑。",
        "en": "(B) Build a Binary Trie, and for each number query, choose the path opposite to the current bit whenever possible.",
        "wg": [
          {
            "t": "位元",
            "en": "bit",
            "ps": "N"
          },
          {
            "t": "相反的",
            "en": "opposite",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 使用 26 個字母的 Trie 儲存數字的字串形式，並遍歷所有葉節點。",
        "en": "(C) Use a 26-letter Trie to store the string representation of numbers and traverse all leaf nodes.",
        "wg": [
          {
            "t": "葉節點",
            "en": "leaf node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 建立 Trie 後，計算每個節點的子節點數量，選擇分支最多的路徑。",
        "en": "(D) After building the Trie, count the number of children for each node and choose the path with the most branches.",
        "wg": [
          {
            "t": "分支",
            "en": "branch",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "要最大化 XOR 值，我們希望高位元盡可能為 1。因此在 Trie 中查詢時，若當前位元是 0，我們希望走往 1 的分支（反之亦然），這樣該位元的 XOR 結果就會是 1。這是一種貪婪演算法策略。",
      "en": "To maximize the XOR value, we want the most significant bits to be 1. Therefore, when querying the Trie, if the current bit is 0, we want to take the branch for 1 (and vice versa), so the XOR result for that bit becomes 1. This is a greedy algorithm strategy.",
      "wg": [
        {
          "t": "最大化",
          "en": "maximize",
          "ps": "V"
        },
        {
          "t": "貪婪演算法",
          "en": "greedy algorithm",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Space Optimization, Compression, Radix Tree, Patricia Trie",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 Trie 時，若資料集包含許多具有很長共同前綴但分支稀疏的字串（例如 URL 路徑），標準 Trie 可能會浪費大量記憶體。",
        "en": "When implementing a Trie, if the dataset contains many strings with long common prefixes but sparse branching (e.g., URL paths), a standard Trie might waste a lot of memory.",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          },
          {
            "t": "浪費",
            "en": "waste",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪種變體結構最適合用來解決這個空間效率問題？",
        "en": "Which of the following variant structures is best suited to solve this space efficiency problem?",
        "wg": [
          {
            "t": "變體",
            "en": "variant",
            "ps": "N"
          },
          {
            "t": "空間效率",
            "en": "space efficiency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Suffix Trie (後綴樹)",
        "en": "(A) Suffix Trie",
        "wg": [
          {
            "t": "後綴",
            "en": "suffix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Hash Map (雜湊表)",
        "en": "(B) Hash Map",
        "wg": []
      },
      {
        "t": "(C) Radix Tree / Patricia Trie (基數樹)",
        "en": "(C) Radix Tree / Patricia Trie",
        "wg": [
          {
            "t": "基數",
            "en": "radix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Binary Search Tree (二元搜尋樹)",
        "en": "(D) Binary Search Tree",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Radix Tree（或稱 Patricia Trie）透過合併只有一個子節點的連續節點來壓縮路徑，這對於長字串且分支較少的情況能顯著減少節點數量並節省空間。",
      "en": "A Radix Tree (or Patricia Trie) compresses paths by merging consecutive nodes that have only one child. This significantly reduces the number of nodes and saves space for long strings with sparse branching.",
      "wg": [
        {
          "t": "合併",
          "en": "merge",
          "ps": "V"
        },
        {
          "t": "顯著",
          "en": "significantly",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "System Design, Autocomplete, Optimization, Caching",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計搜尋引擎的「自動完成」(Autocomplete) 功能。",
        "en": "You are designing the 'Autocomplete' feature for a search engine.",
        "wg": [
          {
            "t": "搜尋引擎",
            "en": "search engine",
            "ps": "N"
          },
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          }
        ]
      },
      {
        "t": "系統需要根據使用者輸入的前綴，快速回傳熱門度最高的前 5 個關鍵字。",
        "en": "The system needs to quickly return the top 5 most popular keywords based on the prefix entered by the user.",
        "wg": [
          {
            "t": "熱門度",
            "en": "popularity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了達到最低的查詢延遲，您應該如何在 Trie 節點中儲存資料？",
        "en": "To achieve the lowest query latency, how should you store data within the Trie nodes?",
        "wg": [
          {
            "t": "延遲",
            "en": "latency",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每個節點僅儲存字元，查詢時遍歷該節點下的所有子樹，收集所有單字後再進行排序。",
        "en": "(A) Store only characters in each node; upon query, traverse all subtrees under that node, collect all words, and then sort them.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 在每個節點中預先儲存經過該節點的熱門度最高的前 k 個單字（或其 ID）。",
        "en": "(B) Pre-store the top-k most popular words (or their IDs) that pass through that node in each node.",
        "wg": [
          {
            "t": "預先儲存",
            "en": "pre-store",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用 Hash Map 儲存所有前綴與對應的熱門單字列表，完全不使用 Trie。",
        "en": "(C) Use a Hash Map to store all prefixes and their corresponding lists of popular words, without using a Trie at all.",
        "wg": []
      },
      {
        "t": "(D) 僅在葉節點儲存熱門度資訊，查詢時使用廣度優先搜尋 (BFS) 尋找最近的單字。",
        "en": "(D) Store popularity information only at leaf nodes and use Breadth-First Search (BFS) to find the nearest words during query.",
        "wg": [
          {
            "t": "廣度優先搜尋",
            "en": "Breadth-First Search",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 和 (D) 需要在查詢當下遍歷大量節點，效能太差。選項 (B) 透過空間換取時間，在寫入時維護每個節點的 Top-k 列表，使得讀取時間複雜度降為 O(1)（僅需讀取該節點的列表），最適合高併發的自動完成系統。",
      "en": "Options (A) and (D) require traversing many nodes at query time, resulting in poor performance. Option (B) trades space for time by maintaining a Top-k list at each node during writes, reducing read time complexity to O(1) (just reading the list from the node), which is best suited for high-concurrency autocomplete systems.",
      "wg": [
        {
          "t": "高併發",
          "en": "high-concurrency",
          "ps": "Adj"
        },
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Wildcard Matching, DFS, Search Algorithm, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n  Map<Character, TrieNode> children;\n  boolean isEnd;\n}",
    "question": [
      {
        "t": "您需要實作一個支援「萬用字元」搜尋的字典。",
        "en": "You need to implement a dictionary that supports 'wildcard' search.",
        "wg": [
          {
            "t": "萬用字元",
            "en": "wildcard",
            "ps": "N"
          }
        ]
      },
      {
        "t": "符號 `.` 可以代表任何一個字母。例如搜尋 `b.d` 可以匹配 `bad`、`bed` 等。",
        "en": "The symbol `.` can represent any single letter. For example, searching for `b.d` can match `bad`, `bed`, etc.",
        "wg": [
          {
            "t": "匹配",
            "en": "match",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當搜尋函式遇到 `.` 時，應該採取什麼操作？",
        "en": "What action should be taken when the search function encounters a `.`?",
        "wg": [
          {
            "t": "遇到",
            "en": "encounter",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接跳過當前層級，檢查下一層是否為單字結尾。",
        "en": "(A) Skip the current level directly and check if the next level is the end of a word.",
        "wg": [
          {
            "t": "跳過",
            "en": "skip",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 遍歷當前節點的所有子節點，對每一個子節點遞迴呼叫搜尋函式處理剩餘的字串。",
        "en": "(B) Iterate through all children of the current node and recursively call the search function on each child for the remaining string.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursively",
            "ps": "Adv"
          },
          {
            "t": "剩餘的",
            "en": "remaining",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 隨機選擇一個子節點繼續搜尋。",
        "en": "(C) Randomly select one child node to continue the search.",
        "wg": []
      },
      {
        "t": "(D) 回傳 False，因為 Trie 不支援模糊搜尋。",
        "en": "(D) Return False, because Trie does not support fuzzy search.",
        "wg": [
          {
            "t": "模糊搜尋",
            "en": "fuzzy search",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當遇到萬用字元 `.` 時，代表當前位置可以是任何字元，因此必須檢查當前節點的所有存在分支（子節點），只要其中任何一條路徑能成功匹配剩餘字串，整個搜尋就回傳 True。",
      "en": "When a wildcard `.` is encountered, it means the current position can be any character. Therefore, all existing branches (children) of the current node must be checked. If any of these paths successfully match the remaining string, the entire search returns True.",
      "wg": [
        {
          "t": "分支",
          "en": "branch",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Prefix Count, Time Complexity, Hash Map vs Trie",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設我們需要頻繁地計算「有多少個單字是以某個字串 P 為前綴」。",
        "en": "Suppose we need to frequently count 'how many words start with a certain string P as a prefix'.",
        "wg": [
          {
            "t": "頻繁地",
            "en": "frequently",
            "ps": "Adv"
          },
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "比較使用 Trie 與使用 Hash Map (儲存所有完整單字) 的做法，下列敘述何者正確？",
        "en": "Comparing the use of a Trie versus a Hash Map (storing all complete words), which of the following statements is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Hash Map 較快，因為可以在 O(1) 時間內找到前綴。",
        "en": "(A) Hash Map is faster because it can find the prefix in O(1) time.",
        "wg": []
      },
      {
        "t": "(B) Trie 較快，若在節點維護計數，可在 O(L) 時間內得知結果 (L 為前綴長度)；Hash Map 則需遍歷所有 Key。",
        "en": "(B) Trie is faster; if counts are maintained at nodes, the result is known in O(L) time (L is prefix length); Hash Map requires iterating through all keys.",
        "wg": [
          {
            "t": "維護",
            "en": "maintain",
            "ps": "V"
          },
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 兩者效率相同，都是 O(L)。",
        "en": "(C) Both have the same efficiency, which is O(L).",
        "wg": []
      },
      {
        "t": "(D) Hash Map 較佳，因為 Trie 佔用的空間一定比 Hash Map 大。",
        "en": "(D) Hash Map is better because Trie always consumes more space than Hash Map.",
        "wg": [
          {
            "t": "佔用",
            "en": "consume",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Hash Map 只能快速檢查「完整鍵值」是否存在，無法直接查詢「前綴」。若用 Hash Map 解決此問題，必須遍歷所有鍵值檢查是否以 P 開頭（極慢）。Trie 則可直接沿著前綴路徑走到對應節點，讀取該節點紀錄的子樹單字數量 (Count)，效率極高。",
      "en": "Hash Maps can only quickly check if a 'complete key' exists, not directly query a 'prefix'. To solve this with a Hash Map, one would have to iterate through all keys to check if they start with P (very slow). A Trie can directly traverse the prefix path to the corresponding node and read the count of words in that subtree, which is highly efficient.",
      "wg": [
        {
          "t": "完整鍵值",
          "en": "complete key",
          "ps": "N"
        },
        {
          "t": "極高",
          "en": "highly",
          "ps": "Adv"
        }
      ]
    }
  }
]