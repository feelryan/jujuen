[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Trie, Time Complexity, Search, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在標準的前綴樹 (Trie) 中，搜尋一個長度為 L 的單字，其時間複雜度為何？",
        "en": "In a standard Trie, what is the time complexity to search for a word of length L?",
        "wg": [
          {
            "t": "前綴樹",
            "en": "Trie",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設字典中共有 N 個單字。",
        "en": "Assume there are N words in the dictionary.",
        "wg": [
          {
            "t": "字典",
            "en": "dictionary",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(L)",
        "en": "(B) O(L)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N * L)",
        "en": "(D) O(N * L)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的搜尋效能取決於單字的長度 (L)，而非字典中的單字總數 (N)。我們只需要遍歷單字中的每個字元，每個字元對應樹中的一層，因此複雜度為 O(L)。",
      "en": "The search performance of a Trie depends on the length of the word (L), not the total number of words in the dictionary (N). We only need to traverse each character of the word, with each character corresponding to a level in the tree, so the complexity is O(L).",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "字元",
          "en": "character",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Trie, Implementation, Prefix, startsWith",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEndOfWord = false;\n}",
    "question": [
      {
        "t": "您正在實作一個 Trie 類別，並需要實作 `startsWith(String prefix)` 方法。",
        "en": "You are implementing a Trie class and need to implement the `startsWith(String prefix)` method.",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "與 `search(String word)` 方法相比，`startsWith` 的主要判斷邏輯差異是什麼？",
        "en": "Compared to the `search(String word)` method, what is the main difference in the logic for `startsWith`?",
        "wg": [
          {
            "t": "判斷邏輯",
            "en": "logic",
            "ps": "N"
          },
          {
            "t": "差異",
            "en": "difference",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `startsWith` 需要遍歷完整個樹狀結構。",
        "en": "(A) `startsWith` needs to traverse the entire tree structure.",
        "wg": []
      },
      {
        "t": "(B) `startsWith` 在最後一個節點必須檢查 `isEndOfWord` 是否為真。",
        "en": "(B) `startsWith` must check if `isEndOfWord` is true at the last node.",
        "wg": []
      },
      {
        "t": "(C) `startsWith` 只要能順利遍歷完前綴的所有字元即可回傳真，無需檢查 `isEndOfWord`。",
        "en": "(C) `startsWith` returns true as long as it can successfully traverse all characters of the prefix, without needing to check `isEndOfWord`.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) `startsWith` 的時間複雜度比 `search` 高。",
        "en": "(D) The time complexity of `startsWith` is higher than `search`.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "`search` 方法要求精確匹配，因此遍歷完單字後必須確認最後一個節點標記為單字結尾 (isEndOfWord = true)。而 `startsWith` 僅需確認該前綴路徑存在於樹中，即便該節點不是一個完整單字的結尾，也應回傳真。",
      "en": "The `search` method requires an exact match, so after traversing the word, it must confirm that the last node is marked as the end of a word (isEndOfWord = true). However, `startsWith` only needs to confirm that the prefix path exists in the tree; it should return true even if the node is not the end of a complete word.",
      "wg": [
        {
          "t": "精確匹配",
          "en": "exact match",
          "ps": "N"
        },
        {
          "t": "路徑",
          "en": "path",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Trie, Space Optimization, Radix Tree, Compression",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "標準的 Trie 在儲存稀疏資料時可能會浪費大量記憶體空間。",
        "en": "A standard Trie can waste a significant amount of memory when storing sparse data.",
        "wg": [
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          },
          {
            "t": "記憶體空間",
            "en": "memory space",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一種資料結構是 Trie 的變體，透過合併只有一個子節點的節點來最佳化空間？",
        "en": "Which of the following data structures is a variation of the Trie that optimizes space by merging nodes that have only one child?",
        "wg": [
          {
            "t": "變體",
            "en": "variation",
            "ps": "N"
          },
          {
            "t": "合併",
            "en": "merge",
            "ps": "V"
          },
          {
            "t": "最佳化",
            "en": "optimize",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Binary Search Tree (BST)",
        "en": "(A) Binary Search Tree (BST)",
        "wg": []
      },
      {
        "t": "(B) Radix Tree (Patricia Trie)",
        "en": "(B) Radix Tree (Patricia Trie)",
        "wg": []
      },
      {
        "t": "(C) AVL Tree",
        "en": "(C) AVL Tree",
        "wg": []
      },
      {
        "t": "(D) Hash Map",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Radix Tree (或稱 Patricia Trie) 是一種壓縮的前綴樹。它將只有單一子節點的路徑合併，使得邊 (Edge) 可以代表字串而非單一字元，從而大幅減少節點數量並節省空間。",
      "en": "A Radix Tree (or Patricia Trie) is a compressed Trie. It merges paths that have only a single child node, allowing edges to represent strings instead of single characters, thereby significantly reducing the number of nodes and saving space.",
      "wg": [
        {
          "t": "壓縮",
          "en": "compressed",
          "ps": "Adj"
        },
        {
          "t": "邊",
          "en": "edge",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Trie, Deletion, Memory Management, Recursion",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在 Trie 中刪除一個單字時，必須小心處理節點的移除。",
        "en": "When deleting a word in a Trie, node removal must be handled carefully.",
        "wg": [
          {
            "t": "刪除",
            "en": "delete",
            "ps": "V"
          },
          {
            "t": "移除",
            "en": "removal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列關於刪除操作的敘述，何者是正確的？",
        "en": "Which of the following statements about the deletion operation is correct?",
        "wg": [
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只要將該單字最後一個節點的 `isEndOfWord` 設為 false 即可，永遠不需要刪除實際節點。",
        "en": "(A) Simply setting `isEndOfWord` to false for the last node of the word is sufficient; actual nodes never need to be deleted.",
        "wg": []
      },
      {
        "t": "(B) 刪除單字時，必須從根節點開始刪除所有路徑上的節點。",
        "en": "(B) When deleting a word, all nodes on the path must be deleted starting from the root.",
        "wg": []
      },
      {
        "t": "(C) 只有當一個節點沒有其他子節點，且該節點不是其他單字的結尾時，才能將其從記憶體中移除。",
        "en": "(C) A node can only be removed from memory if it has no other children and is not the end of another word.",
        "wg": [
          {
            "t": "子節點",
            "en": "children nodes",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 刪除操作的時間複雜度為 O(1)。",
        "en": "(D) The time complexity of the deletion operation is O(1).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "若僅將 `isEndOfWord` 設為 false (選項 A)，會留下無用的節點佔用記憶體。正確的做法是由下而上遞迴檢查：如果節點不再標記為單字結尾且沒有任何子節點，則該節點是多餘的，應該被移除。如果節點仍有子節點（代表是其他長單字的前綴），則只能取消結尾標記而不能刪除節點。",
      "en": "Simply setting `isEndOfWord` to false (Option A) leaves useless nodes consuming memory. The correct approach is to check recursively bottom-up: if a node is no longer marked as the end of a word and has no children, it is redundant and should be removed. If the node still has children (meaning it is a prefix for other longer words), you can only unmark the end flag but cannot delete the node.",
      "wg": [
        {
          "t": "多餘的",
          "en": "redundant",
          "ps": "Adj"
        },
        {
          "t": "遞迴",
          "en": "recursively",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Trie, Hash Table, Comparison, System Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在設計一個自動完成 (Autocomplete) 系統時，為什麼通常會選擇 Trie 而不是 Hash Table？",
        "en": "When designing an Autocomplete system, why is a Trie usually chosen over a Hash Table?",
        "wg": [
          {
            "t": "自動完成",
            "en": "Autocomplete",
            "ps": "N"
          },
          {
            "t": "選擇",
            "en": "choose",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 在查找完全匹配的單字時總是比 Hash Table 快。",
        "en": "(A) A Trie is always faster than a Hash Table when looking up exact matches.",
        "wg": [
          {
            "t": "完全匹配",
            "en": "exact match",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Trie 佔用的記憶體空間總是比 Hash Table 少。",
        "en": "(B) A Trie always consumes less memory space than a Hash Table.",
        "wg": []
      },
      {
        "t": "(C) Trie 能夠高效地找到所有共用同一前綴的單字，而 Hash Table 不支援高效的前綴查詢。",
        "en": "(C) A Trie can efficiently find all words sharing the same prefix, whereas a Hash Table does not support efficient prefix queries.",
        "wg": [
          {
            "t": "共用",
            "en": "share",
            "ps": "V"
          },
          {
            "t": "查詢",
            "en": "query",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Trie 實作起來比 Hash Table 簡單。",
        "en": "(D) A Trie is simpler to implement than a Hash Table.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Hash Table 擅長精確查找 (O(1))，但無法理解字串之間的關聯性。若要用 Hash Table 找前綴，必須掃描所有鍵值。Trie 的結構天生就是依照前綴組織的，因此極度適合自動完成這類需要「找出所有以 X 開頭的字」的場景。",
      "en": "Hash Tables excel at exact lookups (O(1)) but do not understand the relationships between strings. To find prefixes with a Hash Table, you would have to scan all keys. The structure of a Trie is inherently organized by prefixes, making it extremely suitable for scenarios like autocomplete that need to \"find all words starting with X\".",
      "wg": [
        {
          "t": "關聯性",
          "en": "relationship",
          "ps": "N"
        },
        {
          "t": "掃描",
          "en": "scan",
          "ps": "V"
        }
      ]
    }
  }
]