[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Autocomplete, Prefix Search, Efficiency",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在設計搜尋引擎的「自動完成」功能時，為什麼 Trie 通常比雜湊表（Hash Table）更受青睞？",
        "en": "When designing the 'autocomplete' feature for a search engine, why is a Trie usually preferred over a Hash Table?",
        "wg": [
          {
            "t": "自動完成",
            "en": "autocomplete",
            "ps": "N"
          },
          {
            "t": "受青睞",
            "en": "preferred",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請考量查詢所有具有特定前綴字串的情況。",
        "en": "Please consider the scenario of querying all strings with a specific prefix.",
        "wg": [
          {
            "t": "前綴",
            "en": "prefix",
            "ps": "N"
          },
          {
            "t": "情況",
            "en": "scenario",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 的插入速度總是比雜湊表快。",
        "en": "(A) Trie insertion speed is always faster than a Hash Table.",
        "wg": []
      },
      {
        "t": "(B) Trie 可以有效率地遍歷所有共用相同前綴的單字，而雜湊表需要掃描所有鍵值。",
        "en": "(B) Tries can efficiently traverse all words sharing the same prefix, whereas a Hash Table needs to scan all keys.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          },
          {
            "t": "掃描",
            "en": "scan",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) Trie 使用的記憶體空間總是比雜湊表少。",
        "en": "(C) Tries always use less memory space than Hash Tables.",
        "wg": []
      },
      {
        "t": "(D) Trie 支援 O(1) 時間複雜度的隨機存取。",
        "en": "(D) Tries support random access with O(1) time complexity.",
        "wg": [
          {
            "t": "隨機存取",
            "en": "random access",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Trie 的結構將具有相同前綴的單字儲存在相同的路徑上，這使得尋找所有以特定字串開頭的單字非常高效（只需遍歷該前綴的子樹）。",
      "en": "The structure of a Trie stores words with the same prefix along the same path, making it very efficient to find all words starting with a specific string (just traversing the subtree of that prefix).",
      "wg": [
        {
          "t": "路徑",
          "en": "path",
          "ps": "N"
        },
        {
          "t": "子樹",
          "en": "subtree",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Time Complexity, Search, String Length",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設有一個包含 N 個單字的 Trie，其中最長的單字長度為 L。",
        "en": "Assume there is a Trie containing N words, where the length of the longest word is L.",
        "wg": []
      },
      {
        "t": "在最差情況下，搜尋一個長度為 K 的特定單字所需的時間複雜度是多少？",
        "en": "In the worst-case scenario, what is the time complexity required to search for a specific word of length K?",
        "wg": [
          {
            "t": "最差情況",
            "en": "worst-case scenario",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(N)",
        "en": "(A) O(N)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(K)",
        "en": "(C) O(K)",
        "wg": []
      },
      {
        "t": "(D) O(N * K)",
        "en": "(D) O(N * K)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 Trie 中搜尋單字時，我們只需根據單字的每個字元逐層向下移動。因此，操作次數與單字的長度 K 成正比，與字典中單字的總數 N 無關。",
      "en": "When searching for a word in a Trie, we simply move down level by level based on each character of the word. Therefore, the number of operations is proportional to the length of the word K, and is independent of the total number of words N in the dictionary.",
      "wg": [
        {
          "t": "成正比",
          "en": "proportional to",
          "ps": "AdjPhrase"
        },
        {
          "t": "無關",
          "en": "independent of",
          "ps": "AdjPhrase"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Implementation, Memory, Array, Hash Map",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class TrieNode {\n    // Option 1: TrieNode[] children = new TrieNode[26];\n    // Option 2: Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEndOfWord;\n}",
    "question": [
      {
        "t": "在實作 Trie 節點時，您可以選擇使用固定大小的陣列（如 size 26）或雜湊表（Hash Map）來儲存子節點。",
        "en": "When implementing a Trie node, you can choose to use a fixed-size array (e.g., size 26) or a Hash Map to store child nodes.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "固定大小",
            "en": "fixed-size",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "關於這兩種方法的權衡，下列敘述何者正確？",
        "en": "Regarding the trade-off between these two methods, which of the following statements is true?",
        "wg": [
          {
            "t": "權衡",
            "en": "trade-off",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 陣列實作通常比較節省記憶體，因為沒有雜湊表的開銷。",
        "en": "(A) Array implementation is usually more memory-efficient because there is no Hash Map overhead.",
        "wg": [
          {
            "t": "開銷",
            "en": "overhead",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 雜湊表實作在字元集很大（如 Unicode）且資料稀疏時，比陣列更節省空間。",
        "en": "(B) Hash Map implementation is more space-efficient than arrays when the character set is large (e.g., Unicode) and the data is sparse.",
        "wg": [
          {
            "t": "字元集",
            "en": "character set",
            "ps": "N"
          },
          {
            "t": "稀疏",
            "en": "sparse",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 陣列實作的查詢速度比雜湊表慢，因為需要遍歷陣列。",
        "en": "(C) Array implementation has slower query speeds than Hash Maps because it requires traversing the array.",
        "wg": []
      },
      {
        "t": "(D) 兩者在空間複雜度上完全相同。",
        "en": "(D) Both have exactly the same space complexity.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "固定陣列（如長度 26）在節點分支很少時會浪費大量空間儲存 null 指標；而雜湊表僅儲存實際存在的子節點，適合稀疏資料或大型字元集。",
      "en": "Fixed arrays (e.g., length 26) waste a lot of space storing null pointers when node branching is minimal; whereas Hash Maps only store actually existing child nodes, making them suitable for sparse data or large character sets.",
      "wg": [
        {
          "t": "分支",
          "en": "branching",
          "ps": "N"
        },
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "hard",
    "keywords": "Deletion, Logic, Edge Cases",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在 Trie 中刪除單字 \"apple\" 時，若 Trie 中同時存在單字 \"app\"，正確的處理邏輯為何？",
        "en": "When deleting the word 'apple' from a Trie, if the word 'app' also exists in the Trie, what is the correct handling logic?",
        "wg": [
          {
            "t": "處理邏輯",
            "en": "handling logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 刪除 'l' 和 'e' 的節點，並保留 'a', 'p', 'p' 節點，且確保最後一個 'p' 的 isEndOfWord 標記保持為 true。",
        "en": "(A) Delete the nodes for 'l' and 'e', keep the nodes for 'a', 'p', 'p', and ensure the isEndOfWord flag of the last 'p' remains true.",
        "wg": [
          {
            "t": "保留",
            "en": "keep",
            "ps": "V"
          },
          {
            "t": "標記",
            "en": "flag",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 刪除整條路徑上的所有節點（a, p, p, l, e）。",
        "en": "(B) Delete all nodes along the entire path (a, p, p, l, e).",
        "wg": []
      },
      {
        "t": "(C) 僅將 'e' 節點的 isEndOfWord 設為 false，不刪除任何節點。",
        "en": "(C) Only set the isEndOfWord of the 'e' node to false, without deleting any nodes.",
        "wg": []
      },
      {
        "t": "(D) 刪除 'e' 節點，並將 'l' 節點的 isEndOfWord 設為 true。",
        "en": "(D) Delete the 'e' node and set the isEndOfWord of the 'l' node to true.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "刪除 \"apple\" 時，我們應該從下往上刪除不再需要的節點（'e' 和 'l'）。由於 \"app\" 是另一個有效單字，我們必須保留 'a', 'p', 'p' 路徑，且不能修改最後一個 'p' 的結束標記。",
      "en": "When deleting 'apple', we should delete nodes that are no longer needed from the bottom up ('e' and 'l'). Since 'app' is another valid word, we must preserve the 'a', 'p', 'p' path and must not modify the end flag of the last 'p'.",
      "wg": [
        {
          "t": "不再需要的",
          "en": "no longer needed",
          "ps": "AdjPhrase"
        },
        {
          "t": "有效單字",
          "en": "valid word",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Comparison, Space Complexity, Overhead",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "相較於將字串儲存在單純的陣列或列表（List）中，使用標準 Trie 儲存字串集合的主要缺點是什麼？",
        "en": "Compared to storing strings in a simple array or List, what is the main disadvantage of using a standard Trie to store a set of strings?",
        "wg": [
          {
            "t": "字串集合",
            "en": "set of strings",
            "ps": "N"
          },
          {
            "t": "缺點",
            "en": "disadvantage",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請忽略搜尋速度，僅專注於記憶體結構。",
        "en": "Please ignore search speed and focus only on memory structure.",
        "wg": [
          {
            "t": "記憶體結構",
            "en": "memory structure",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Trie 無法處理包含重複字元的字串。",
        "en": "(A) Tries cannot handle strings containing duplicate characters.",
        "wg": []
      },
      {
        "t": "(B) Trie 的節點指標（Pointers/References）會帶來顯著的額外記憶體開銷，特別是當前綴共用較少時。",
        "en": "(B) The node pointers (References) in a Trie incur significant additional memory overhead, especially when there is little prefix sharing.",
        "wg": [
          {
            "t": "顯著的",
            "en": "significant",
            "ps": "Adj"
          },
          {
            "t": "額外記憶體開銷",
            "en": "additional memory overhead",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Trie 必須儲存完整的字串副本在每個節點中。",
        "en": "(C) Tries must store a full copy of the string in every node.",
        "wg": [
          {
            "t": "副本",
            "en": "copy",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Trie 的深度受到記憶體堆疊（Stack）大小的嚴格限制。",
        "en": "(D) The depth of a Trie is strictly limited by the memory stack size.",
        "wg": [
          {
            "t": "嚴格限制",
            "en": "strictly limited",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "標準 Trie 的每個節點都需要儲存指向子節點的指標（或參考）。如果字串集合沒有太多共同前綴，這些大量的節點物件與指標所佔用的記憶體，往往遠大於直接儲存字元本身的空間。",
      "en": "Each node in a standard Trie needs to store pointers (or references) to child nodes. If the set of strings does not have many common prefixes, the memory occupied by these numerous node objects and pointers is often much larger than the space used to store the characters themselves.",
      "wg": [
        {
          "t": "共同前綴",
          "en": "common prefixes",
          "ps": "N"
        },
        {
          "t": "佔用",
          "en": "occupied",
          "ps": "V"
        }
      ]
    }
  }
]