[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Data Structure, Stack, LIFO, Concept",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "堆疊 (Stack) 是一種遵循特定操作順序的線性資料結構。",
        "en": "A Stack is a linear data structure that follows a particular order in which the operations are performed.",
        "wg": [
          {
            "t": "線性資料結構",
            "en": "linear data structure",
            "ps": "N"
          },
          {
            "t": "遵循",
            "en": "follows",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問下列哪一個縮寫最能準確描述堆疊的行為特性？",
        "en": "Which of the following acronyms most accurately describes the behavioral characteristic of a Stack?",
        "wg": [
          {
            "t": "縮寫",
            "en": "acronym",
            "ps": "N"
          },
          {
            "t": "行為特性",
            "en": "behavioral characteristic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) FIFO (先進先出)",
        "en": "(A) FIFO (First-In, First-Out)",
        "wg": []
      },
      {
        "t": "(B) LIFO (後進先出)",
        "en": "(B) LIFO (Last-In, First-Out)",
        "wg": []
      },
      {
        "t": "(C) LRU (最近最少使用)",
        "en": "(C) LRU (Least Recently Used)",
        "wg": []
      },
      {
        "t": "(D) RANDOM (隨機存取)",
        "en": "(D) RANDOM (Random Access)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "堆疊運作於「後進先出」原則，意味著最後被加入的元素會是第一個被移除的。",
      "en": "A Stack operates on the 'Last-In, First-Out' principle, meaning the element added last is the first one to be removed.",
      "wg": [
        {
          "t": "原則",
          "en": "principle",
          "ps": "N"
        },
        {
          "t": "移除",
          "en": "removed",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Stack, Implementation, Linked List, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若您使用「單向連結串列 (Singly Linked List)」來實作堆疊，且希望 `push` (推入) 與 `pop` (彈出) 操作的時間複雜度皆為 O(1)。",
        "en": "If you are implementing a Stack using a 'Singly Linked List' and want both `push` and `pop` operations to have a time complexity of O(1).",
        "wg": [
          {
            "t": "單向連結串列",
            "en": "Singly Linked List",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "您應該選擇在連結串列的哪一端進行操作？",
        "en": "At which end of the linked list should you perform the operations?",
        "wg": [
          {
            "t": "端",
            "en": "end",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 僅在尾端 (Tail) 進行操作。",
        "en": "(A) Perform operations only at the Tail.",
        "wg": []
      },
      {
        "t": "(B) 僅在前端 (Head) 進行操作。",
        "en": "(B) Perform operations only at the Head.",
        "wg": []
      },
      {
        "t": "(C) Push 在前端，Pop 在尾端。",
        "en": "(C) Push at the Head, Pop at the Tail.",
        "wg": []
      },
      {
        "t": "(D) Push 在尾端，Pop 在前端。",
        "en": "(D) Push at the Tail, Pop at the Head.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在單向連結串列的前端 (Head) 插入或刪除節點只需要更新頭部指標，時間複雜度為 O(1)；若在尾端進行 Pop 操作，需要遍歷整個串列以找到倒數第二個節點來更新尾部指標，時間複雜度為 O(n)。",
      "en": "Inserting or deleting nodes at the Head of a singly linked list only requires updating the head pointer, resulting in O(1) complexity; performing a Pop at the Tail requires traversing the list to find the second-to-last node to update the tail pointer, resulting in O(n) complexity.",
      "wg": [
        {
          "t": "遍歷",
          "en": "traversing",
          "ps": "V"
        },
        {
          "t": "倒數第二個",
          "en": "second-to-last",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Stack, Operation, Tracing, Code Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Stack<Integer> s = new Stack<>();\ns.push(10);\ns.push(20);\ns.pop();\ns.push(30);\ns.push(40);\ns.pop();",
    "question": [
      {
        "t": "考慮上述的堆疊操作程式碼片段。",
        "en": "Consider the code snippet of stack operations above.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在執行完所有操作後，堆疊頂端 (Top) 的元素為何？",
        "en": "What is the element at the Top of the stack after all operations are executed?",
        "wg": [
          {
            "t": "堆疊頂端",
            "en": "Top of the stack",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 10",
        "en": "(A) 10",
        "wg": []
      },
      {
        "t": "(B) 20",
        "en": "(B) 20",
        "wg": []
      },
      {
        "t": "(C) 30",
        "en": "(C) 30",
        "wg": []
      },
      {
        "t": "(D) 40",
        "en": "(D) 40",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "操作順序如下：推入 10，推入 20 (堆疊：10, 20)，彈出 20 (堆疊：10)，推入 30 (堆疊：10, 30)，推入 40 (堆疊：10, 30, 40)，彈出 40 (堆疊：10, 30)。因此頂端元素為 30。",
      "en": "The sequence is: Push 10, Push 20 (Stack: 10, 20), Pop 20 (Stack: 10), Push 30 (Stack: 10, 30), Push 40 (Stack: 10, 30, 40), Pop 40 (Stack: 10, 30). Thus, the top element is 30.",
      "wg": [
        {
          "t": "順序",
          "en": "sequence",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Stack, Min Stack, Algorithm Design, Optimization",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您被要求設計一個 `MinStack` 資料結構，除了標準的堆疊操作外，還支援一個 `getMin()` 函式。",
        "en": "You are asked to design a `MinStack` data structure that supports a `getMin()` function in addition to standard stack operations.",
        "wg": [
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "`getMin()` 必須在 O(1) 時間內回傳堆疊中的最小元素。",
        "en": "`getMin()` must return the minimum element in the stack in O(1) time.",
        "wg": [
          {
            "t": "回傳",
            "en": "return",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪種實作策略最合適？",
        "en": "Which of the following implementation strategies is most appropriate?",
        "wg": [
          {
            "t": "實作策略",
            "en": "implementation strategies",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用一個變數 `min_val` 儲存最小值，每次 `pop` 時若移除的是最小值，則遍歷堆疊重新尋找。",
        "en": "(A) Use a variable `min_val` to store the minimum; if the minimum is removed during `pop`, traverse the stack to find the new minimum.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用輔助堆疊 (Auxiliary Stack) 同步儲存當前的最小值。",
        "en": "(B) Use an Auxiliary Stack to synchronously store the current minimum value.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "Auxiliary Stack",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 在每次 `push` 時將堆疊排序。",
        "en": "(C) Sort the stack every time a `push` occurs.",
        "wg": []
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 來追蹤所有元素的頻率。",
        "en": "(D) Use a Hash Map to track the frequency of all elements.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用輔助堆疊可以在 O(1) 時間內存取最小值。當推入新元素時，若該元素小於等於輔助堆疊頂端的值，則同時推入輔助堆疊；彈出時若值相同則同時彈出。選項 (A) 在最差情況下的 pop 操作會退化成 O(n)。",
      "en": "Using an auxiliary stack allows accessing the minimum in O(1) time. When pushing a new element, if it is less than or equal to the top of the auxiliary stack, push it there as well; pop from both if values match. Option (A) degrades to O(n) for pop operations in the worst case.",
      "wg": [
        {
          "t": "退化",
          "en": "degrades",
          "ps": "V"
        },
        {
          "t": "最差情況",
          "en": "worst case",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Stack, Applications, Recursion, Memory",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "堆疊溢位 (Stack Overflow) 是一個常見的執行期錯誤。",
        "en": "Stack Overflow is a common runtime error.",
        "wg": [
          {
            "t": "執行期錯誤",
            "en": "runtime error",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在程式開發中，下列哪種情況最容易導致此錯誤發生？",
        "en": "In software development, which of the following scenarios is most likely to cause this error?",
        "wg": [
          {
            "t": "情況",
            "en": "scenarios",
            "ps": "N"
          },
          {
            "t": "導致",
            "en": "cause",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 宣告了過多的全域變數 (Global Variables)。",
        "en": "(A) Declaring too many Global Variables.",
        "wg": []
      },
      {
        "t": "(B) 函式遞迴呼叫過深且缺乏終止條件。",
        "en": "(B) Function recursion is too deep and lacks a termination condition.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          },
          {
            "t": "終止條件",
            "en": "termination condition",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 動態分配了過大的記憶體區塊 (例如大型陣列) 但未釋放。",
        "en": "(C) Dynamically allocating large memory blocks (e.g., large arrays) without freeing them.",
        "wg": [
          {
            "t": "動態分配",
            "en": "dynamically allocating",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 讀取了超出陣列範圍的索引。",
        "en": "(D) Accessing an index out of the array bounds.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "函式呼叫的上下文 (Context) 儲存在呼叫堆疊 (Call Stack) 中。無限或過深的遞迴會耗盡堆疊記憶體空間，導致 Stack Overflow。選項 (C) 通常導致 Heap 記憶體不足 (Out of Memory)，而非 Stack Overflow。",
      "en": "Function call contexts are stored in the Call Stack. Infinite or excessively deep recursion exhausts the stack memory space, leading to a Stack Overflow. Option (C) typically causes Heap memory exhaustion (Out of Memory), not Stack Overflow.",
      "wg": [
        {
          "t": "上下文",
          "en": "contexts",
          "ps": "N"
        },
        {
          "t": "耗盡",
          "en": "exhausts",
          "ps": "V"
        }
      ]
    }
  }
]