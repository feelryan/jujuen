[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Data Structure, LIFO, Concept",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "堆疊 (Stack) 是一種遵循特定操作順序的線性資料結構。",
        "en": "A Stack is a linear data structure that follows a particular order in which the operations are performed.",
        "wg": [
          {
            "t": "線性資料結構",
            "en": "linear data structure",
            "ps": "N"
          },
          {
            "t": "遵循",
            "en": "follow",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問下列哪一個縮寫最能準確描述堆疊的運作原則？",
        "en": "Which of the following acronyms most accurately describes the working principle of a Stack?",
        "wg": [
          {
            "t": "縮寫",
            "en": "acronym",
            "ps": "N"
          },
          {
            "t": "運作原則",
            "en": "working principle",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) FIFO (先進先出)",
        "en": "(A) FIFO (First-In, First-Out)",
        "wg": []
      },
      {
        "t": "(B) LIFO (後進先出)",
        "en": "(B) LIFO (Last-In, First-Out)",
        "wg": []
      },
      {
        "t": "(C) GIGO (垃圾進，垃圾出)",
        "en": "(C) GIGO (Garbage-In, Garbage-Out)",
        "wg": []
      },
      {
        "t": "(D) LRU (最近最少使用)",
        "en": "(D) LRU (Least Recently Used)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "堆疊的運作就像一疊盤子，最後放上去的盤子必須最先被拿走，這稱為後進先出 (LIFO)。FIFO 是佇列 (Queue) 的特性。",
      "en": "A stack works like a stack of plates; the last plate placed on top must be removed first, which is called Last-In, First-Out (LIFO). FIFO is a characteristic of a Queue.",
      "wg": [
        {
          "t": "後進先出",
          "en": "Last-In, First-Out",
          "ps": "N"
        },
        {
          "t": "佇列",
          "en": "Queue",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Time Complexity, Big O, Push, Pop",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個標準的堆疊實作中 (不論是使用陣列或連結串列)，",
        "en": "In a standard stack implementation (whether using an array or a linked list),",
        "wg": [
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          },
          {
            "t": "連結串列",
            "en": "linked list",
            "ps": "N"
          }
        ]
      },
      {
        "t": "執行 `push` (推入) 和 `pop` (彈出) 操作的時間複雜度通常是多少？",
        "en": "what is the typical time complexity for `push` and `pop` operations?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(n)",
        "en": "(B) O(n)",
        "wg": []
      },
      {
        "t": "(C) O(log n)",
        "en": "(C) O(log n)",
        "wg": []
      },
      {
        "t": "(D) Push 是 O(1)，Pop 是 O(n)",
        "en": "(D) Push is O(1), Pop is O(n)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "堆疊只在頂端進行操作，不需要遍歷整個資料結構，因此推入和彈出都是常數時間 O(1)。",
      "en": "Stack operations occur only at the top and do not require traversing the entire data structure, so both push and pop are constant time O(1).",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Algorithm, Application, Parentheses Matching",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Example: \"{ [ ( ) ] }\"",
    "question": [
      {
        "t": "您正在撰寫一個演算法來驗證一段程式碼中的括號是否成對且平衡。",
        "en": "You are writing an algorithm to validate if the parentheses in a piece of code are paired and balanced.",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "平衡",
            "en": "balanced",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "遇到左括號時將其存入，遇到右括號時檢查是否與最近存入的左括號匹配。",
        "en": "When an opening bracket is encountered, it is stored; when a closing bracket is encountered, it checks for a match with the most recently stored opening bracket.",
        "wg": [
          {
            "t": "匹配",
            "en": "match",
            "ps": "V"
          },
          {
            "t": "最近",
            "en": "recently",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "請問最適合解決此問題的資料結構是什麼？",
        "en": "Which data structure is most suitable for solving this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 佇列 (Queue)",
        "en": "(A) Queue",
        "wg": []
      },
      {
        "t": "(B) 雜湊表 (Hash Map)",
        "en": "(B) Hash Map",
        "wg": []
      },
      {
        "t": "(C) 堆疊 (Stack)",
        "en": "(C) Stack",
        "wg": []
      },
      {
        "t": "(D) 二元樹 (Binary Tree)",
        "en": "(D) Binary Tree",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "括號匹配問題要求「最後遇到的左括號」必須與「最先遇到的右括號」匹配，這完全符合 LIFO 特性，因此堆疊是最佳選擇。",
      "en": "The parentheses matching problem requires that the \"last encountered opening bracket\" matches the \"first encountered closing bracket,\" which perfectly fits the LIFO characteristic, making Stack the best choice.",
      "wg": [
        {
          "t": "特性",
          "en": "characteristic",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Recursion, Memory, Stack Overflow",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void recursiveFunction() {\n    recursiveFunction();\n}",
    "question": [
      {
        "t": "當一個遞迴函式沒有設定終止條件 (Base Case) 而無限呼叫自己時，",
        "en": "When a recursive function calls itself infinitely without a base case,",
        "wg": [
          {
            "t": "遞迴函式",
            "en": "recursive function",
            "ps": "N"
          },
          {
            "t": "終止條件",
            "en": "base case",
            "ps": "N"
          }
        ]
      },
      {
        "t": "通常會導致下列哪種錯誤？",
        "en": "which of the following errors does it typically cause?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 記憶體流失 (Memory Leak)",
        "en": "(A) Memory Leak",
        "wg": []
      },
      {
        "t": "(B) 堆疊溢位 (Stack Overflow)",
        "en": "(B) Stack Overflow",
        "wg": []
      },
      {
        "t": "(C) 堆積損毀 (Heap Corruption)",
        "en": "(C) Heap Corruption",
        "wg": []
      },
      {
        "t": "(D) 緩衝區溢位 (Buffer Overflow)",
        "en": "(D) Buffer Overflow",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "函式呼叫的資訊 (如區域變數、返回位址) 儲存在「呼叫堆疊 (Call Stack)」中。無限遞迴會耗盡堆疊空間，導致 Stack Overflow。",
      "en": "Function call information (such as local variables and return addresses) is stored in the \"Call Stack\". Infinite recursion exhausts the stack space, causing a Stack Overflow.",
      "wg": [
        {
          "t": "呼叫堆疊",
          "en": "Call Stack",
          "ps": "N"
        },
        {
          "t": "耗盡",
          "en": "exhaust",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "hard",
    "keywords": "Min Stack, Optimization, Algorithm Design",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "面試官要求您設計一個 `MinStack` 類別，除了標準的 `push` 和 `pop` 之外，",
        "en": "The interviewer asks you to design a `MinStack` class which, in addition to standard `push` and `pop`,",
        "wg": [
          {
            "t": "類別",
            "en": "class",
            "ps": "N"
          }
        ]
      },
      {
        "t": "還需要支援 `getMin()` 函式以隨時取得當前堆疊中的最小值。",
        "en": "supports a `getMin()` function to retrieve the minimum element in the current stack at any time.",
        "wg": [
          {
            "t": "取得",
            "en": "retrieve",
            "ps": "V"
          }
        ]
      },
      {
        "t": "若要求所有操作 (包含 `getMin`) 的時間複雜度皆為 O(1)，最佳的實作策略為何？",
        "en": "If all operations (including `getMin`) are required to have O(1) time complexity, what is the best implementation strategy?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用一個變數 `min_val` 儲存最小值，每次 pop 時若移除最小值則重新遍歷堆疊。",
        "en": "(A) Use a variable `min_val` to store the minimum. If the minimum is removed during pop, traverse the stack to find the new minimum.",
        "wg": [
          {
            "t": "變數",
            "en": "variable",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用輔助堆疊 (Auxiliary Stack) 同步儲存當前的最小值。",
        "en": "(B) Use an auxiliary stack to synchronously store the current minimum value.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 在每次 push 後對堆疊進行排序。",
        "en": "(C) Sort the stack after every push.",
        "wg": []
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 記錄每個數字出現的次數。",
        "en": "(D) Use a Hash Map to record the frequency of each number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "選項 (A) 在 pop 時可能需要 O(n)，選項 (C) 排序需要 O(n log n)。使用輔助堆疊可以在 push 時同步記錄當下的最小值，確保 `getMin` 為 O(1)。",
      "en": "Option (A) might take O(n) during pop, and option (C) takes O(n log n) for sorting. Using an auxiliary stack allows recording the current minimum synchronously during push, ensuring `getMin` is O(1).",
      "wg": [
        {
          "t": "排序",
          "en": "sorting",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Stack, Dynamic Array, Time Complexity, Amortized Analysis",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當使用動態陣列 (Dynamic Array) 實作堆疊 (Stack) 時，",
        "en": "When implementing a Stack using a Dynamic Array,",
        "wg": [
          {
            "t": "動態陣列",
            "en": "Dynamic Array",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "大多數的 push 操作時間複雜度為 O(1)，但在特定情況下會變為 O(n)。",
        "en": "most push operations have a time complexity of O(1), but in specific cases, it becomes O(n).",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這種 O(n) 的情況發生在什麼時候？",
        "en": "When does this O(n) scenario occur?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當堆疊為空並嘗試 pop 時。",
        "en": "(A) When the stack is empty and a pop is attempted.",
        "wg": []
      },
      {
        "t": "(B) 當底層陣列已滿，需要重新分配記憶體並複製元素時。",
        "en": "(B) When the underlying array is full, requiring memory reallocation and copying of elements.",
        "wg": [
          {
            "t": "底層",
            "en": "underlying",
            "ps": "Adj"
          },
          {
            "t": "重新分配",
            "en": "reallocation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 當推入的元素是 null 或 undefined 時。",
        "en": "(C) When the pushed element is null or undefined.",
        "wg": []
      },
      {
        "t": "(D) 當堆疊中包含不同資料類型的元素時。",
        "en": "(D) When the stack contains elements of different data types.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "動態陣列在容量不足時，需要建立一個更大的新陣列並將舊資料複製過去，這個過程需要 O(n) 的時間。但在攤銷分析 (Amortized Analysis) 下，平均時間複雜度仍視為 O(1)。",
      "en": "When a dynamic array runs out of capacity, it needs to create a larger new array and copy the old data over, which takes O(n) time. However, under amortized analysis, the average time complexity is still considered O(1).",
      "wg": [
        {
          "t": "容量",
          "en": "capacity",
          "ps": "N"
        },
        {
          "t": "攤銷分析",
          "en": "amortized analysis",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "easy",
    "keywords": "Stack, Algorithm, Valid Parentheses, String Manipulation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: \"{ [ ( ) ] }\"",
    "question": [
      {
        "t": "給定一個包含括號的字串，您需要驗證括號的順序是否有效。",
        "en": "Given a string containing parentheses, you need to validate if the order of parentheses is valid.",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "括號",
            "en": "parentheses",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這是一個經典的面試題，通常使用堆疊 (Stack) 來解決。",
        "en": "This is a classic interview question typically solved using a Stack.",
        "wg": []
      },
      {
        "t": "請問在此演算法中，遇到「右括號」 (如 ']', '}') 時應該執行什麼操作？",
        "en": "In this algorithm, what operation should be performed when a 'closing bracket' (e.g., ']', '}') is encountered?",
        "wg": [
          {
            "t": "右括號",
            "en": "closing bracket",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將右括號推入堆疊中。",
        "en": "(A) Push the closing bracket onto the stack.",
        "wg": []
      },
      {
        "t": "(B) 檢查堆疊是否為空；若不為空，則彈出頂端元素並檢查是否匹配。",
        "en": "(B) Check if the stack is empty; if not, pop the top element and check if it matches.",
        "wg": [
          {
            "t": "匹配",
            "en": "match",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 計算堆疊中元素的總數量。",
        "en": "(C) Count the total number of elements in the stack.",
        "wg": []
      },
      {
        "t": "(D) 清空整個堆疊。",
        "en": "(D) Clear the entire stack.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "堆疊用於儲存尚未匹配的左括號。遇到右括號時，必須檢查堆疊頂端的左括號是否與其對應；若匹配則消除 (Pop)，否則字串無效。",
      "en": "The stack is used to store unmatched opening brackets. When a closing bracket is encountered, you must check if the opening bracket at the top of the stack corresponds to it; if they match, eliminate (Pop) it, otherwise the string is invalid.",
      "wg": [
        {
          "t": "對應",
          "en": "correspond",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Stack, Design, Min Stack, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class MinStack {\n  push(x) { ... }\n  pop() { ... }\n  top() { ... }\n  getMin() { ... }\n}",
    "question": [
      {
        "t": "您被要求設計一個 `MinStack` 類別，除了標準的堆疊操作外，",
        "en": "You are asked to design a `MinStack` class that, in addition to standard stack operations,",
        "wg": []
      },
      {
        "t": "還需要支援 `getMin()` 方法，該方法能在 O(1) 時間內回傳堆疊中的最小值。",
        "en": "supports a `getMin()` method which retrieves the minimum element in the stack in O(1) time.",
        "wg": [
          {
            "t": "回傳",
            "en": "retrieve",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了達成此目標，最常見且有效的實作策略是什麼？",
        "en": "To achieve this goal, what is the most common and effective implementation strategy?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 在每次 `push` 或 `pop` 後，對堆疊內的陣列進行排序。",
        "en": "(A) Sort the array inside the stack after every `push` or `pop`.",
        "wg": []
      },
      {
        "t": "(B) 使用一個變數 `min_val` 儲存最小值，若該值被彈出則重新掃描堆疊。",
        "en": "(B) Use a variable `min_val` to store the minimum value, and rescan the stack if that value is popped.",
        "wg": [
          {
            "t": "掃描",
            "en": "scan",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 維護一個同步的「輔助堆疊」，專門用來儲存當前的最小值序列。",
        "en": "(C) Maintain a synchronized 'auxiliary stack' specifically to store the sequence of current minimum values.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronized",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 來記錄每個元素的出現次數。",
        "en": "(D) Use a Hash Map to record the frequency of each element.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "單純使用變數無法處理最小值被 pop 後的狀況 (需要知道第二小的值)。使用輔助堆疊，每次 push 時同步存入當前最小值，pop 時同步移除，能確保 `getMin` 始終為 O(1)。",
      "en": "Simply using a variable cannot handle the situation where the minimum value is popped (you need to know the second smallest value). Using an auxiliary stack to store the current minimum synchronously on every push, and removing it on pop, ensures `getMin` is always O(1).",
      "wg": [
        {
          "t": "第二小",
          "en": "second smallest",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Stack, Recursion, Memory Management, Stack Overflow",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def recursive_function():\n    return recursive_function()",
    "question": [
      {
        "t": "在程式執行期間，函式呼叫 (Function Call) 的資訊是儲存在「呼叫堆疊」(Call Stack) 中的。",
        "en": "During program execution, Function Call information is stored in the 'Call Stack'.",
        "wg": [
          {
            "t": "呼叫堆疊",
            "en": "Call Stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果一個遞迴函式沒有設定終止條件 (Base Case)，導致無限遞迴，",
        "en": "If a recursive function does not have a Base Case set, leading to infinite recursion,",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          },
          {
            "t": "終止條件",
            "en": "Base Case",
            "ps": "N"
          }
        ]
      },
      {
        "t": "最終會拋出什麼錯誤？",
        "en": "what error will eventually be thrown?",
        "wg": [
          {
            "t": "拋出",
            "en": "throw",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Memory Leak (記憶體洩漏)",
        "en": "(A) Memory Leak",
        "wg": []
      },
      {
        "t": "(B) Stack Overflow (堆疊溢位)",
        "en": "(B) Stack Overflow",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "Stack Overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Null Pointer Exception (空指標異常)",
        "en": "(C) Null Pointer Exception",
        "wg": []
      },
      {
        "t": "(D) Time Limit Exceeded (超出時間限制)",
        "en": "(D) Time Limit Exceeded",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "每次函式呼叫都會在記憶體的堆疊區段建立一個 Stack Frame。無限遞迴會耗盡分配給堆疊的固定記憶體空間，導致 Stack Overflow。",
      "en": "Every function call creates a Stack Frame in the stack segment of memory. Infinite recursion exhausts the fixed memory space allocated to the stack, resulting in a Stack Overflow.",
      "wg": [
        {
          "t": "堆疊區段",
          "en": "stack segment",
          "ps": "N"
        },
        {
          "t": "耗盡",
          "en": "exhaust",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Stack, Expression Evaluation, Reverse Polish Notation, Postfix",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Expression: 3 4 + 2 *",
    "question": [
      {
        "t": "逆波蘭表示法 (Reverse Polish Notation, RPN) 是一種將運算子寫在運算元後面的數學表示法。",
        "en": "Reverse Polish Notation (RPN) is a mathematical notation where operators follow their operands.",
        "wg": [
          {
            "t": "運算子",
            "en": "operator",
            "ps": "N"
          },
          {
            "t": "運算元",
            "en": "operand",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用堆疊來計算後綴表達式 `3 4 + 2 *` 的結果時，",
        "en": "When using a stack to evaluate the postfix expression `3 4 + 2 *`,",
        "wg": [
          {
            "t": "後綴表達式",
            "en": "postfix expression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "運算的順序與最終結果為何？",
        "en": "what is the order of operations and the final result?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 先算 4+2，再乘以 3，結果為 18。",
        "en": "(A) Calculate 4+2 first, then multiply by 3. Result is 18.",
        "wg": []
      },
      {
        "t": "(B) 先算 3+4，再乘以 2，結果為 14。",
        "en": "(B) Calculate 3+4 first, then multiply by 2. Result is 14.",
        "wg": []
      },
      {
        "t": "(C) 先算 2*4，再加 3，結果為 11。",
        "en": "(C) Calculate 2*4 first, then add 3. Result is 11.",
        "wg": []
      },
      {
        "t": "(D) 堆疊操作順序錯誤，無法計算。",
        "en": "(D) The stack operation order is incorrect; it cannot be evaluated.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "RPN 的計算邏輯是：遇到數字則 Push，遇到運算子則 Pop 兩個數字進行運算並將結果 Push 回去。順序：Push 3, Push 4 -> 遇 '+' -> Pop 4, 3 -> 算 3+4=7 -> Push 7 -> Push 2 -> 遇 '*' -> Pop 2, 7 -> 算 7*2=14。",
      "en": "The logic for RPN evaluation is: Push when a number is encountered; when an operator is encountered, Pop two numbers, perform the operation, and Push the result back. Order: Push 3, Push 4 -> meet '+' -> Pop 4, 3 -> Calc 3+4=7 -> Push 7 -> Push 2 -> meet '*' -> Pop 2, 7 -> Calc 7*2=14.",
      "wg": []
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Stack, Monotonic Stack, Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個整數陣列代表每日的股票價格，您需要找出每一天之後，第一個價格高於當天的日子距離幾天。",
        "en": "Given an integer array representing daily stock prices, you need to find out how many days wait until the first day with a higher price for each day.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "N"
          },
          {
            "t": "股票價格",
            "en": "stock price",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果想要在 O(N) 的時間複雜度內解決此問題，應該使用哪種資料結構與演算法技巧？",
        "en": "If you want to solve this problem within O(N) time complexity, which data structure and algorithmic technique should be used?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          },
          {
            "t": "演算法技巧",
            "en": "algorithmic technique",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用雜湊表 (Hash Map) 記錄每個價格出現的次數。",
        "en": "(A) Use a Hash Map to record the frequency of each price.",
        "wg": [
          {
            "t": "雜湊表",
            "en": "Hash Map",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 使用雙迴圈 (Nested Loops) 暴力搜尋。",
        "en": "(B) Use nested loops for brute-force search.",
        "wg": [
          {
            "t": "暴力搜尋",
            "en": "brute-force search",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 使用單調堆疊 (Monotonic Stack) 維護遞減序列。",
        "en": "(C) Use a Monotonic Stack to maintain a decreasing sequence.",
        "wg": [
          {
            "t": "單調堆疊",
            "en": "Monotonic Stack",
            "ps": "N"
          },
          {
            "t": "遞減序列",
            "en": "decreasing sequence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 使用優先佇列 (Priority Queue) 進行排序。",
        "en": "(D) Use a Priority Queue for sorting.",
        "wg": [
          {
            "t": "優先佇列",
            "en": "Priority Queue",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "此為典型的「下一個更大元素」(Next Greater Element) 問題。透過維護一個單調遞減堆疊，當遇到比堆疊頂端更大的元素時，即可確定堆疊頂端元素的答案，從而達到 O(N) 的效率。",
      "en": "This is a classic 'Next Greater Element' problem. By maintaining a monotonically decreasing stack, when an element larger than the stack top is encountered, the answer for the stack top element is determined, achieving O(N) efficiency.",
      "wg": [
        {
          "t": "下一個更大元素",
          "en": "Next Greater Element",
          "ps": "N"
        },
        {
          "t": "堆疊頂端",
          "en": "stack top",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "Stack, Expression Evaluation, Postfix, RPN",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"5\", \"1\", \"2\", \"+\", \"4\", \"*\", \"+\", \"3\", \"-\"]",
    "question": [
      {
        "t": "您正在開發一個計算機程式，該程式使用堆疊來評估逆波蘭表示法 (Reverse Polish Notation, RPN) 的算術運算式。",
        "en": "You are developing a calculator program that uses a stack to evaluate arithmetic expressions in Reverse Polish Notation (RPN).",
        "wg": [
          {
            "t": "逆波蘭表示法",
            "en": "Reverse Polish Notation",
            "ps": "N"
          },
          {
            "t": "算術運算式",
            "en": "arithmetic expression",
            "ps": "N"
          }
        ]
      },
      {
        "t": "根據上方提供的輸入陣列，運算結束後堆疊中剩下的最終結果為何？",
        "en": "Based on the input array provided above, what is the final result remaining in the stack after the operation is completed?",
        "wg": [
          {
            "t": "輸入陣列",
            "en": "input array",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 14",
        "en": "(A) 14",
        "wg": []
      },
      {
        "t": "(B) 9",
        "en": "(B) 9",
        "wg": []
      },
      {
        "t": "(C) 21",
        "en": "(C) 21",
        "wg": []
      },
      {
        "t": "(D) 11",
        "en": "(D) 11",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "運算過程如下：1+2=3 -> 3*4=12 -> 5+12=17 -> 17-3=14。RPN 的特性是遇到運算子時，彈出堆疊頂端的兩個數字進行運算，並將結果推回堆疊。",
      "en": "The calculation process is: 1+2=3 -> 3*4=12 -> 5+12=17 -> 17-3=14. The characteristic of RPN is that when an operator is encountered, the top two numbers are popped from the stack for calculation, and the result is pushed back.",
      "wg": [
        {
          "t": "運算子",
          "en": "operator",
          "ps": "N"
        },
        {
          "t": "彈出",
          "en": "pop",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Stack, Recursion, DFS, Memory Management",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理極深層的樹狀結構遍歷時，使用遞迴 (Recursion) 方式實作深度優先搜尋 (DFS) 可能會導致堆疊溢位 (Stack Overflow)。",
        "en": "When processing extremely deep tree structure traversals, implementing Depth-First Search (DFS) using recursion may lead to a Stack Overflow.",
        "wg": [
          {
            "t": "樹狀結構",
            "en": "tree structure",
            "ps": "N"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          },
          {
            "t": "堆疊溢位",
            "en": "Stack Overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了避免此問題並將演算法改為迭代 (Iterative) 版本，您應該明確使用哪種資料結構來模擬系統的呼叫堆疊？",
        "en": "To avoid this issue and convert the algorithm to an iterative version, which data structure should you explicitly use to simulate the system's call stack?",
        "wg": [
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          },
          {
            "t": "呼叫堆疊",
            "en": "call stack",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 佇列 (Queue)",
        "en": "(A) Queue",
        "wg": []
      },
      {
        "t": "(B) 堆疊 (Stack)",
        "en": "(B) Stack",
        "wg": []
      },
      {
        "t": "(C) 連結串列 (Linked List)",
        "en": "(C) Linked List",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遞迴的本質是利用系統的呼叫堆疊來儲存狀態。若要將遞迴轉為迭代並模擬 DFS 的後進先出 (LIFO) 行為，必須使用顯式的堆疊 (Stack) 資料結構。",
      "en": "The essence of recursion is using the system's call stack to store state. To convert recursion to iteration and simulate the Last-In-First-Out (LIFO) behavior of DFS, an explicit Stack data structure must be used.",
      "wg": [
        {
          "t": "顯式的",
          "en": "explicit",
          "ps": "Adj"
        },
        {
          "t": "後進先出",
          "en": "Last-In-First-Out",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Stack, System Design, Optimization, Min Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "面試官要求您設計一個特殊的堆疊類別，除了標準的 `push` 和 `pop` 操作外，還需要支援 `getMin()` 函式。",
        "en": "The interviewer asks you to design a special stack class that, in addition to standard `push` and `pop` operations, also supports a `getMin()` function.",
        "wg": [
          {
            "t": "面試官",
            "en": "interviewer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該 `getMin()` 函式必須在 O(1) 的時間複雜度內回傳目前堆疊中的最小值。",
        "en": "The `getMin()` function must return the minimum value currently in the stack within O(1) time complexity.",
        "wg": [
          {
            "t": "最小值",
            "en": "minimum value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種實作策略最符合此需求？",
        "en": "Which of the following implementation strategies best meets this requirement?",
        "wg": [
          {
            "t": "實作策略",
            "en": "implementation strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次呼叫 `getMin` 時遍歷整個堆疊尋找最小值。",
        "en": "(A) Iterate through the entire stack to find the minimum whenever `getMin` is called.",
        "wg": [
          {
            "t": "遍歷",
            "en": "iterate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用一個額外的輔助堆疊，同步儲存每個狀態下的當前最小值。",
        "en": "(B) Use an additional auxiliary stack to synchronously store the current minimum value at each state.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 在堆疊內部維持一個排序的陣列。",
        "en": "(C) Maintain a sorted array inside the stack.",
        "wg": []
      },
      {
        "t": "(D) 使用一個變數記錄最小值，但在 `pop` 移除最小值時重新掃描堆疊。",
        "en": "(D) Use a variable to record the minimum, but rescan the stack when the minimum value is removed by `pop`.",
        "wg": [
          {
            "t": "重新掃描",
            "en": "rescan",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用輔助堆疊 (Auxiliary Stack) 可以在每次 push 時，將當前元素與目前的最小值比較並存入輔助堆疊。這樣 `getMin` 僅需查看輔助堆疊的頂端即可達到 O(1)，且 `pop` 時也能同步移除過期的最小值狀態。",
      "en": "Using an auxiliary stack allows comparing the current element with the current minimum and storing it in the auxiliary stack upon each push. This way, `getMin` only needs to peek at the top of the auxiliary stack to achieve O(1), and the expired minimum state is synchronously removed upon `pop`.",
      "wg": [
        {
          "t": "過期的",
          "en": "expired",
          "ps": "Adj"
        },
        {
          "t": "查看",
          "en": "peek",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "easy",
    "keywords": "Stack, Real-world Application, Browser History",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "網頁瀏覽器的「上一頁」(Back) 與「下一頁」(Forward) 功能是堆疊應用的經典案例。",
        "en": "The 'Back' and 'Forward' features of a web browser are classic examples of stack applications.",
        "wg": [
          {
            "t": "經典案例",
            "en": "classic example",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要實作這兩個功能，最直觀的設計通常需要使用幾個堆疊？",
        "en": "To implement these two features, how many stacks are typically required in the most intuitive design?",
        "wg": [
          {
            "t": "直觀的",
            "en": "intuitive",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 一個堆疊：僅儲存上一頁紀錄。",
        "en": "(A) One stack: Only stores the back history.",
        "wg": []
      },
      {
        "t": "(B) 兩個堆疊：一個儲存上一頁歷史，另一個儲存下一頁歷史。",
        "en": "(B) Two stacks: One stores back history, and the other stores forward history.",
        "wg": [
          {
            "t": "歷史",
            "en": "history",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 三個堆疊：分別儲存首頁、上一頁與下一頁。",
        "en": "(C) Three stacks: Separately store homepage, back, and forward pages.",
        "wg": []
      },
      {
        "t": "(D) 不需要堆疊，使用佇列 (Queue) 即可。",
        "en": "(D) No stack needed; a Queue is sufficient.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當使用者按下「上一頁」時，當前頁面會被推入「下一頁堆疊」並從「上一頁堆疊」彈出；反之亦然。因此需要兩個堆疊來分別維護這兩個方向的導覽歷史。",
      "en": "When the user clicks 'Back', the current page is pushed onto the 'Forward Stack' and popped from the 'Back Stack'; and vice versa. Therefore, two stacks are needed to maintain the navigation history in both directions.",
      "wg": [
        {
          "t": "導覽",
          "en": "navigation",
          "ps": "N"
        },
        {
          "t": "反之亦然",
          "en": "vice versa",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "hard",
    "keywords": "Stack, Monotonic Stack, Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個整數陣列代表每日溫度，您需要回傳一個陣列，說明每一天需要等待幾天才能觀測到更高的溫度。",
        "en": "Given an array of integers representing daily temperatures, you need to return an array indicating how many days you have to wait to observe a higher temperature.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "array of integers",
            "ps": "N"
          },
          {
            "t": "觀測",
            "en": "observe",
            "ps": "V"
          }
        ]
      },
      {
        "t": "如果未來沒有更高的溫度，則該位置填入 0。",
        "en": "If there is no future day for which this is possible, put 0 instead.",
        "wg": []
      },
      {
        "t": "為了達到 O(N) 的時間複雜度，您應該使用哪種資料結構與技巧？",
        "en": "To achieve O(N) time complexity, which data structure and technique should you use?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 優先佇列 (Priority Queue)",
        "en": "(A) Priority Queue",
        "wg": []
      },
      {
        "t": "(B) 單調堆疊 (Monotonic Stack)",
        "en": "(B) Monotonic Stack",
        "wg": [
          {
            "t": "單調",
            "en": "monotonic",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 雙向佇列 (Deque)",
        "en": "(C) Deque",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "單調堆疊可以用來尋找陣列中元素的「下一個更大元素」。透過維護一個遞減的堆疊，當遇到比堆疊頂端更大的元素時，我們就能確定堆疊中元素的答案，每個元素最多進出堆疊一次，故為 O(N)。",
      "en": "A Monotonic Stack can be used to find the 'next greater element' for elements in an array. By maintaining a decreasing stack, when we encounter an element larger than the stack top, we can determine the answer for the elements in the stack. Each element is pushed and popped at most once, resulting in O(N).",
      "wg": [
        {
          "t": "遞減",
          "en": "decreasing",
          "ps": "Adj"
        },
        {
          "t": "堆疊頂端",
          "en": "stack top",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Stack, System Design, Optimization, Min Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要設計一個堆疊，除了支援標準的 push、pop 和 top 操作外，還需要支援在常數時間 O(1) 內檢索最小元素 (getMin)。",
        "en": "You need to design a stack that supports retrieving the minimum element (getMin) in constant time O(1), in addition to the standard push, pop, and top operations.",
        "wg": [
          {
            "t": "檢索",
            "en": "retrieve",
            "ps": "V"
          },
          {
            "t": "常數時間",
            "en": "constant time",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪種實作策略最為合適？",
        "en": "Which of the following implementation strategies is most appropriate?",
        "wg": [
          {
            "t": "實作策略",
            "en": "implementation strategy",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用一個變數 `min_val` 儲存當前最小值，每次 push 時更新。",
        "en": "(A) Use a variable `min_val` to store the current minimum and update it on every push.",
        "wg": []
      },
      {
        "t": "(B) 每次呼叫 getMin 時，對堆疊內的內容進行排序。",
        "en": "(B) Sort the contents of the stack every time getMin is called.",
        "wg": []
      },
      {
        "t": "(C) 使用一個輔助堆疊，同步儲存當前堆疊狀態下的最小值。",
        "en": "(C) Use an auxiliary stack to synchronously store the minimum value corresponding to the current stack state.",
        "wg": [
          {
            "t": "輔助",
            "en": "auxiliary",
            "ps": "Adj"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 使用雜湊表來記錄每個元素出現的次數。",
        "en": "(D) Use a hash map to record the frequency of each element.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "僅使用單一變數無法處理 pop 操作後回復上一個最小值的需求。使用輔助堆疊 (Min Stack) 可以在 push 時將當前最小值壓入，pop 時同步移除，確保 getMin 始終為 O(1)。排序會導致 O(N log N)，不符合要求。",
      "en": "Using a single variable cannot handle the need to revert to the previous minimum after a pop operation. Using an auxiliary stack (Min Stack) allows pushing the current minimum during a push and removing it synchronously during a pop, ensuring getMin is always O(1). Sorting would result in O(N log N), which does not meet the requirement.",
      "wg": [
        {
          "t": "回復",
          "en": "revert",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Stack, Recursion, Memory, Stack Overflow",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def recursive_dfs(node):\n    if not node: return\n    recursive_dfs(node.left)\n    recursive_dfs(node.right)",
    "question": [
      {
        "t": "在處理極深層的樹狀結構或圖形遍歷時，使用上述遞迴程式碼可能會導致程式崩潰。",
        "en": "When processing extremely deep tree structures or graph traversals, using the recursive code above may cause the program to crash.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          },
          {
            "t": "崩潰",
            "en": "crash",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問這是什麼原因造成的，以及最佳的解決方案是什麼？",
        "en": "What is the cause of this, and what is the best solution?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 記憶體洩漏 (Memory Leak)；應手動釋放記憶體。",
        "en": "(A) Memory Leak; memory should be manually released.",
        "wg": [
          {
            "t": "記憶體洩漏",
            "en": "memory leak",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 堆疊溢位 (Stack Overflow)；應改用顯式堆疊 (Explicit Stack) 進行迭代。",
        "en": "(B) Stack Overflow; should switch to iteration using an explicit stack.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "stack overflow",
            "ps": "N"
          },
          {
            "t": "顯式",
            "en": "explicit",
            "ps": "Adj"
          },
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 堆積溢位 (Heap Overflow)；應增加虛擬記憶體。",
        "en": "(C) Heap Overflow; should increase virtual memory.",
        "wg": []
      },
      {
        "t": "(D) 時間複雜度過高；應改用廣度優先搜尋 (BFS)。",
        "en": "(D) Time complexity is too high; should switch to Breadth-First Search (BFS).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遞迴呼叫會佔用系統的呼叫堆疊 (Call Stack)，當遞迴深度過深時會導致空間耗盡 (Stack Overflow)。解決方案是將遞迴改寫為使用堆疊資料結構的迭代迴圈，將記憶體使用轉移到堆積 (Heap) 上，其空間通常遠大於呼叫堆疊。",
      "en": "Recursive calls consume the system's Call Stack. When the recursion depth is too deep, it leads to space exhaustion (Stack Overflow). The solution is to rewrite the recursion into an iterative loop using a stack data structure, shifting memory usage to the Heap, which typically has much more space than the Call Stack.",
      "wg": [
        {
          "t": "呼叫堆疊",
          "en": "call stack",
          "ps": "N"
        },
        {
          "t": "耗盡",
          "en": "exhaustion",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Stack, Expression Evaluation, RPN",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"4\", \"13\", \"5\", \"/\", \"+\"]",
    "question": [
      {
        "t": "逆波蘭表示法 (Reverse Polish Notation, RPN) 是一種數學表達式寫法，運算子位於運算元之後。",
        "en": "Reverse Polish Notation (RPN) is a mathematical notation in which operators follow their operands.",
        "wg": [
          {
            "t": "逆波蘭表示法",
            "en": "Reverse Polish Notation",
            "ps": "N"
          },
          {
            "t": "運算子",
            "en": "operator",
            "ps": "N"
          },
          {
            "t": "運算元",
            "en": "operand",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用堆疊來計算上述 RPN 表達式的值，正確的步驟為何？",
        "en": "Using a stack to evaluate the RPN expression above, what is the correct procedure?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 遇到數字則 push，遇到運算子則 pop 兩個數字進行運算，並將結果 push 回去。",
        "en": "(A) Push when encountering a number; pop two numbers when encountering an operator to perform the calculation, and push the result back.",
        "wg": []
      },
      {
        "t": "(B) 遇到運算子則 push，遇到數字則 pop 進行運算。",
        "en": "(B) Push when encountering an operator; pop when encountering a number to perform the calculation.",
        "wg": []
      },
      {
        "t": "(C) 將所有元素 push 進堆疊，最後再一次全部 pop 出來計算。",
        "en": "(C) Push all elements into the stack, then pop them all out at the end to calculate.",
        "wg": []
      },
      {
        "t": "(D) 使用兩個堆疊，一個存數字，一個存運算子。",
        "en": "(D) Use two stacks, one for numbers and one for operators.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "RPN 的計算邏輯是：遍歷表達式，遇到數字壓入堆疊；遇到運算子時，從堆疊彈出頂部兩個數字進行運算（注意順序），然後將結果壓回堆疊。最終堆疊中剩下的唯一數字即為結果。範例運算：13/5=2, 4+2=6。",
      "en": "The logic for RPN evaluation is: traverse the expression, push numbers onto the stack; when an operator is encountered, pop the top two numbers from the stack to perform the operation (mind the order), and push the result back. The single number remaining in the stack is the result. Example calculation: 13/5=2, 4+2=6.",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Stack, Queue, Data Structure Implementation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要使用佇列 (Queue) 來實作堆疊 (Stack) 的功能，下列敘述何者正確？",
        "en": "If you want to implement the functionality of a Stack using Queues, which of the following statements is true?",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 只需要一個佇列即可，且 push 和 pop 操作都能達到 O(1)。",
        "en": "(A) Only one queue is needed, and both push and pop operations can achieve O(1).",
        "wg": []
      },
      {
        "t": "(B) 至少需要兩個佇列，且 push 或 pop 其中一個操作的時間複雜度必須為 O(N)。",
        "en": "(B) At least two queues (or one with rotation) are needed, and the time complexity of either push or pop must be O(N).",
        "wg": [
          {
            "t": "旋轉",
            "en": "rotation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 無法使用佇列來實作堆疊，因為兩者結構完全相反。",
        "en": "(C) It is impossible to implement a Stack using Queues because their structures are completely opposite.",
        "wg": []
      },
      {
        "t": "(D) 可以實作，但空間複雜度會變成 O(N^2)。",
        "en": "(D) It can be implemented, but the space complexity will become O(N^2).",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "佇列是先進先出 (FIFO)，堆疊是後進先出 (LIFO)。要模擬堆疊，必須在 push 時將新元素移到佇列前端（O(N)），或者在 pop 時將除了最後一個元素外的所有元素移到另一個佇列（O(N)）。無法兩者皆為 O(1)。",
      "en": "Queues are First-In-First-Out (FIFO), while Stacks are Last-In-First-Out (LIFO). To simulate a stack, you must either move the new element to the front of the queue during push (O(N)), or move all elements except the last one to another queue during pop (O(N)). It is impossible for both to be O(1).",
      "wg": [
        {
          "t": "模擬",
          "en": "simulate",
          "ps": "V"
        },
        {
          "t": "前端",
          "en": "front",
          "ps": "N"
        }
      ]
    }
  }
]