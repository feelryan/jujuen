[
  {
    "no": "6",
    "level": "easy",
    "keywords": "Data Structure, Stack, Time Complexity, Linked List",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若使用單向鏈結串列 (Singly Linked List) 來實作堆疊 (Stack)，且始終在串列的頭部 (Head) 進行操作。",
        "en": "If a Stack is implemented using a Singly Linked List, and operations are always performed at the Head of the list.",
        "wg": [
          {
            "t": "單向鏈結串列",
            "en": "Singly Linked List",
            "ps": "N"
          },
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問執行 `push` (推入) 與 `pop` (彈出) 操作的最差時間複雜度分別為何？",
        "en": "What are the worst-case time complexities for the `push` and `pop` operations, respectively?",
        "wg": [
          {
            "t": "最差時間複雜度",
            "en": "worst-case time complexity",
            "ps": "N"
          },
          {
            "t": "推入",
            "en": "push",
            "ps": "V"
          },
          {
            "t": "彈出",
            "en": "pop",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Push: O(1), Pop: O(1)",
        "en": "(A) Push: O(1), Pop: O(1)",
        "wg": []
      },
      {
        "t": "(B) Push: O(1), Pop: O(n)",
        "en": "(B) Push: O(1), Pop: O(n)",
        "wg": []
      },
      {
        "t": "(C) Push: O(n), Pop: O(1)",
        "en": "(C) Push: O(n), Pop: O(1)",
        "wg": []
      },
      {
        "t": "(D) Push: O(n), Pop: O(n)",
        "en": "(D) Push: O(n), Pop: O(n)",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在鏈結串列的頭部新增或移除節點僅涉及指標的更新，不需要遍歷整個串列，因此這兩個操作的時間複雜度皆為常數時間 O(1)。",
      "en": "Adding or removing a node at the head of a linked list only involves updating pointers and does not require traversing the entire list, so the time complexity for both operations is constant time O(1).",
      "wg": [
        {
          "t": "遍歷",
          "en": "traverse",
          "ps": "V"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        },
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Stack, Algorithm, Valid Parentheses, String Processing",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Example Input: \"{[()]}\"",
    "question": [
      {
        "t": "您正在撰寫一個演算法來驗證程式碼中的括號 (如 `()`, `{}`, `[]`) 是否正確配對。",
        "en": "You are writing an algorithm to validate if parentheses (such as `()`, `{}`, `[]`) in code are correctly balanced.",
        "wg": [
          {
            "t": "驗證",
            "en": "validate",
            "ps": "V"
          },
          {
            "t": "配對",
            "en": "balanced",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "遇到左括號時將其存入，遇到右括號時檢查是否與最近存入的左括號匹配。",
        "en": "When a left parenthesis is encountered, it is stored; when a right parenthesis is encountered, it checks for a match with the most recently stored left parenthesis.",
        "wg": [
          {
            "t": "匹配",
            "en": "match",
            "ps": "V"
          },
          {
            "t": "最近",
            "en": "recently",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "請問最適合此場景的資料結構為何？",
        "en": "Which data structure is most suitable for this scenario?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 佇列 (Queue)",
        "en": "(A) Queue",
        "wg": []
      },
      {
        "t": "(B) 堆疊 (Stack)",
        "en": "(B) Stack",
        "wg": []
      },
      {
        "t": "(C) 雜湊表 (Hash Map)",
        "en": "(C) Hash Map",
        "wg": []
      },
      {
        "t": "(D) 優先佇列 (Priority Queue)",
        "en": "(D) Priority Queue",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "括號匹配問題具有「後進先出」(LIFO) 的特性，最近遇到的左括號必須最先被閉合，這正是堆疊 (Stack) 的典型應用場景。",
      "en": "The parenthesis matching problem has a 'Last-In, First-Out' (LIFO) characteristic, where the most recently encountered left parenthesis must be closed first, which is a typical use case for a Stack.",
      "wg": [
        {
          "t": "典型",
          "en": "typical",
          "ps": "Adj"
        },
        {
          "t": "閉合",
          "en": "closed",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Stack, Min Stack, Optimization, Auxiliary Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "面試官要求您設計一個 `MinStack` 類別，除了標準的 `push` 和 `pop` 操作外，還必須支援 `getMin()`。",
        "en": "The interviewer asks you to design a `MinStack` class that supports `getMin()` in addition to the standard `push` and `pop` operations.",
        "wg": [
          {
            "t": "類別",
            "en": "class",
            "ps": "N"
          }
        ]
      },
      {
        "t": "要求 `getMin()` 必須在 O(1) 時間內回傳當前堆疊中的最小值。",
        "en": "The requirement is that `getMin()` must return the minimum value in the current stack in O(1) time.",
        "wg": [
          {
            "t": "當前",
            "en": "current",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪種實作策略最為適當？",
        "en": "Which of the following implementation strategies is most appropriate?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          },
          {
            "t": "適當",
            "en": "appropriate",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次呼叫 `getMin` 時對堆疊內容進行排序。",
        "en": "(A) Sort the stack contents every time `getMin` is called.",
        "wg": [
          {
            "t": "排序",
            "en": "sort",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用一個變數 `min_val` 儲存最小值，但在 `pop` 移除最小值後需要重新遍歷堆疊。",
        "en": "(B) Use a variable `min_val` to store the minimum, but re-traverse the stack after `pop` removes the minimum.",
        "wg": [
          {
            "t": "變數",
            "en": "variable",
            "ps": "N"
          },
          {
            "t": "重新遍歷",
            "en": "re-traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 使用第二個「輔助堆疊」同步儲存當前的最小值序列。",
        "en": "(C) Use a second 'auxiliary stack' to synchronously store the sequence of current minimum values.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "N"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 使用雜湊表來記錄每個元素的出現次數。",
        "en": "(D) Use a hash map to record the frequency of each element.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "使用輔助堆疊 (Auxiliary Stack) 可以在每次 `push` 時同步記錄當下的最小值；當 `pop` 時也同步移除，這樣能確保 `getMin` 始終為 O(1) 且不需重新掃描。",
      "en": "Using an auxiliary stack allows recording the current minimum at each `push`; when `pop` occurs, it is also removed synchronously, ensuring `getMin` is always O(1) without rescan.",
      "wg": [
        {
          "t": "重新掃描",
          "en": "rescan",
          "ps": "V"
        },
        {
          "t": "確保",
          "en": "ensure",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Stack, Dynamic Array, Amortized Analysis, Resizing",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當使用動態陣列 (Dynamic Array) 實作堆疊時，若陣列容量已滿，下一次 `push` 操作會觸發擴容 (Resizing)。",
        "en": "When implementing a Stack using a Dynamic Array, if the array capacity is full, the next `push` operation triggers resizing.",
        "wg": [
          {
            "t": "動態陣列",
            "en": "Dynamic Array",
            "ps": "N"
          },
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          },
          {
            "t": "擴容",
            "en": "resizing",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於此特定操作的時間複雜度與整體「攤銷」(Amortized) 複雜度，下列敘述何者正確？",
        "en": "Regarding the time complexity of this specific operation and the overall 'amortized' complexity, which of the following statements is correct?",
        "wg": [
          {
            "t": "攤銷",
            "en": "amortized",
            "ps": "Adj"
          },
          {
            "t": "敘述",
            "en": "statement",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 該次操作為 O(n)，但平均而言每個 push 操作為 O(1)。",
        "en": "(A) That specific operation is O(n), but on average each push operation is O(1).",
        "wg": []
      },
      {
        "t": "(B) 該次操作為 O(1)，且平均而言每個 push 操作為 O(1)。",
        "en": "(B) That specific operation is O(1), and on average each push operation is O(1).",
        "wg": []
      },
      {
        "t": "(C) 該次操作為 O(n)，且平均而言每個 push 操作為 O(n)。",
        "en": "(C) That specific operation is O(n), and on average each push operation is O(n).",
        "wg": []
      },
      {
        "t": "(D) 該次操作為 O(log n)，且平均而言每個 push 操作為 O(1)。",
        "en": "(D) That specific operation is O(log n), and on average each push operation is O(1).",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "擴容時需要複製原有 n 個元素到新陣列，故該次操作為 O(n)；但透過倍增容量策略，這些成本分攤到多次操作中，使得攤銷複雜度保持在 O(1)。",
      "en": "Resizing requires copying n existing elements to the new array, so that specific operation is O(n); however, with the capacity doubling strategy, these costs are distributed over many operations, keeping the amortized complexity at O(1).",
      "wg": [
        {
          "t": "複製",
          "en": "copy",
          "ps": "V"
        },
        {
          "t": "倍增",
          "en": "doubling",
          "ps": "V"
        },
        {
          "t": "分攤",
          "en": "distribute/amortize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "hard",
    "keywords": "Stack, Recursion, Memory Management, Stack Overflow",
    "parentNo": null,
    "images": null,
    "codeSnippet": "def factorial(n):\n    if n == 0: return 1\n    return n * factorial(n - 1)",
    "question": [
      {
        "t": "考慮上述的遞迴函式 `factorial`。",
        "en": "Consider the recursive function `factorial` above.",
        "wg": [
          {
            "t": "遞迴函式",
            "en": "recursive function",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若呼叫 `factorial(100000)` 導致程式崩潰並出現錯誤，最可能的原因與下列哪個概念直接相關？",
        "en": "If calling `factorial(100000)` causes the program to crash with an error, which of the following concepts is most directly related to the cause?",
        "wg": [
          {
            "t": "崩潰",
            "en": "crash",
            "ps": "V"
          },
          {
            "t": "直接相關",
            "en": "directly related",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 堆積溢位 (Heap Overflow)，因為變數佔用過多動態記憶體。",
        "en": "(A) Heap Overflow, because variables occupy too much dynamic memory.",
        "wg": [
          {
            "t": "堆積",
            "en": "Heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 堆疊溢位 (Stack Overflow)，因為呼叫堆疊 (Call Stack) 超過系統限制。",
        "en": "(B) Stack Overflow, because the Call Stack exceeded system limits.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "Stack Overflow",
            "ps": "N"
          },
          {
            "t": "呼叫堆疊",
            "en": "Call Stack",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 時間複雜度過高，導致 CPU 執行逾時。",
        "en": "(C) Time complexity is too high, causing CPU execution timeout.",
        "wg": [
          {
            "t": "逾時",
            "en": "timeout",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 整數溢位 (Integer Overflow)，因為計算結果超過整數範圍。",
        "en": "(D) Integer Overflow, because the calculation result exceeds the integer range.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遞迴函式的每一次呼叫都會在系統的「呼叫堆疊」中推入一個新的堆疊框 (Stack Frame)。當遞迴深度過深時，會耗盡堆疊空間，導致 Stack Overflow。",
      "en": "Every call of a recursive function pushes a new Stack Frame onto the system's 'Call Stack'. When the recursion depth is too deep, it exhausts the stack space, resulting in a Stack Overflow.",
      "wg": [
        {
          "t": "堆疊框",
          "en": "Stack Frame",
          "ps": "N"
        },
        {
          "t": "耗盡",
          "en": "exhaust",
          "ps": "V"
        },
        {
          "t": "深度",
          "en": "depth",
          "ps": "N"
        }
      ]
    }
  }
]