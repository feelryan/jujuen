[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Stack, Data Structure Implementation, Array vs Linked List, Memory Management",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個需要極低延遲的即時系統，且必須實作一個堆疊 (Stack) 來管理任務。",
        "en": "You are designing a real-time system requiring ultra-low latency and must implement a Stack to manage tasks.",
        "wg": [
          {
            "t": "極低延遲",
            "en": "ultra-low latency",
            "ps": "NP"
          },
          {
            "t": "即時系統",
            "en": "real-time system",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "該堆疊的最大深度無法預測，且系統無法承受因陣列調整大小 (Resizing) 所帶來的偶發性效能抖動。",
        "en": "The maximum depth of the stack is unpredictable, and the system cannot tolerate the occasional performance jitter caused by array resizing.",
        "wg": [
          {
            "t": "調整大小",
            "en": "resizing",
            "ps": "Gerund"
          },
          {
            "t": "效能抖動",
            "en": "performance jitter",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "下列哪種實作方式最適合此情境？",
        "en": "Which of the following implementations is most suitable for this scenario?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用動態陣列 (Dynamic Array) 實作，並設定較大的初始容量。",
        "en": "(A) Implement using a Dynamic Array with a large initial capacity.",
        "wg": [
          {
            "t": "動態陣列",
            "en": "Dynamic Array",
            "ps": "NP"
          },
          {
            "t": "初始容量",
            "en": "initial capacity",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 使用鏈結串列 (Linked List) 實作，每次 Push 時動態分配節點。",
        "en": "(B) Implement using a Linked List, dynamically allocating nodes on each Push.",
        "wg": [
          {
            "t": "鏈結串列",
            "en": "Linked List",
            "ps": "NP"
          },
          {
            "t": "動態分配",
            "en": "dynamically allocating",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(C) 使用固定大小的陣列 (Fixed-size Array) 並實作循環佇列邏輯。",
        "en": "(C) Use a Fixed-size Array and implement circular queue logic.",
        "wg": [
          {
            "t": "循環佇列",
            "en": "circular queue",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(D) 使用雜湊表 (Hash Map) 來儲存堆疊元素以加快存取速度。",
        "en": "(D) Use a Hash Map to store stack elements to speed up access.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "題目強調無法預測深度且不能接受 Resizing (擴容) 帶來的延遲。動態陣列在擴容時需要複製整個陣列，會導致 O(N) 的時間複雜度突波。鏈結串列雖然有額外的記憶體指標開銷，但其 Push/Pop 操作保證是嚴格的 O(1)，不會發生擴容複製，符合低延遲且深度未知的需求。",
      "en": "The problem emphasizes unpredictable depth and intolerance for latency from resizing. Dynamic arrays require copying the entire array during expansion, causing an O(N) time complexity spike. While Linked Lists have overhead for memory pointers, their Push/Pop operations are strictly O(1) without resizing events, fitting the low-latency and unknown depth requirements.",
      "wg": [
        {
          "t": "擴容",
          "en": "expansion/resizing",
          "ps": "N"
        },
        {
          "t": "突波",
          "en": "spike",
          "ps": "N"
        },
        {
          "t": "指標開銷",
          "en": "pointer overhead",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Stack, Min Stack, Algorithm Design, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "class MinStack {\n  push(val) { ... }\n  pop() { ... }\n  top() { ... }\n  getMin() { ... }\n}",
    "question": [
      {
        "t": "在面試中，您被要求設計一個 `MinStack` 類別，除了支援標準的 `push`、`pop` 和 `top` 操作外，還需要支援 `getMin` 操作。",
        "en": "In an interview, you are asked to design a `MinStack` class that supports `getMin` in addition to the standard `push`, `pop`, and `top` operations.",
        "wg": []
      },
      {
        "t": "要求所有操作（包含 `getMin`）的時間複雜度都必須是 O(1)。",
        "en": "It is required that the time complexity for all operations (including `getMin`) must be O(1).",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "下列哪種設計策略最能滿足此需求？",
        "en": "Which of the following design strategies best meets this requirement?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 使用一個變數 `min_val` 記錄最小值，每次 `pop` 時若移除了最小值，則重新遍歷堆疊尋找新的最小值。",
        "en": "(A) Use a variable `min_val` to track the minimum. If the minimum is removed during `pop`, traverse the stack to find the new minimum.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 在內部維護一個排序的陣列 (Sorted Array)，`getMin` 直接回傳第一個元素。",
        "en": "(B) Maintain an internal Sorted Array, where `getMin` directly returns the first element.",
        "wg": []
      },
      {
        "t": "(C) 使用兩個堆疊：一個主堆疊儲存資料，另一個輔助堆疊同步儲存當前的最小值。",
        "en": "(C) Use two stacks: a main stack for data and an auxiliary stack to synchronously store the current minimum values.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "NP"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 使用最小堆積 (Min Heap) 來儲存所有元素。",
        "en": "(D) Use a Min Heap to store all elements.",
        "wg": [
          {
            "t": "最小堆積",
            "en": "Min Heap",
            "ps": "NP"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "選項 (A) 在 `pop` 時可能需要 O(N) 掃描；選項 (B) 的 `push` 為了維持排序需要 O(N)；選項 (D) 的 `push` 和 `pop` 對於堆積來說是 O(log N)。唯有選項 (C) 使用輔助堆疊，每次 Push 時將當前值與輔助堆疊頂端較小者推入輔助堆疊，能保證所有操作皆為 O(1)。",
      "en": "Option (A) may require O(N) scanning during `pop`; Option (B) requires O(N) during `push` to maintain order; Option (D) has O(log N) for `push` and `pop` operations in a heap. Only Option (C), using an auxiliary stack to push the smaller of the current value and the auxiliary stack's top, guarantees O(1) for all operations.",
      "wg": [
        {
          "t": "掃描",
          "en": "scanning",
          "ps": "Gerund"
        },
        {
          "t": "維持排序",
          "en": "maintain order",
          "ps": "VP"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Stack, System Design, Browser History, Back/Forward",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在為瀏覽器實作「上一頁」與「下一頁」的功能。",
        "en": "You are implementing the 'Back' and 'Forward' buttons for a web browser.",
        "wg": []
      },
      {
        "t": "當使用者訪問新頁面時，「下一頁」的歷史紀錄應該被清空。",
        "en": "When a user visits a new page, the history for the 'Forward' button should be cleared.",
        "wg": [
          {
            "t": "清空",
            "en": "cleared",
            "ps": "V"
          }
        ]
      },
      {
        "t": "請問使用哪種資料結構組合最適合管理這兩個導覽歷史紀錄？",
        "en": "Which combination of data structures is most suitable for managing these two navigation histories?",
        "wg": [
          {
            "t": "導覽",
            "en": "navigation",
            "ps": "N"
          },
          {
            "t": "組合",
            "en": "combination",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 單一佇列 (Queue)。",
        "en": "(A) A single Queue.",
        "wg": []
      },
      {
        "t": "(B) 兩個堆疊 (Two Stacks)。",
        "en": "(B) Two Stacks.",
        "wg": []
      },
      {
        "t": "(C) 環狀緩衝區 (Circular Buffer)。",
        "en": "(C) A Circular Buffer.",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)。",
        "en": "(D) A Hash Map.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "瀏覽器的導覽行為符合「後進先出」(LIFO) 的特性。使用兩個堆疊：一個 `BackStack` 存過去的頁面，一個 `ForwardStack` 存被回退的頁面。點擊上一頁時，從 `BackStack` Pop 並 Push 到 `ForwardStack`；訪問新頁面時，Push 到 `BackStack` 並清空 `ForwardStack`。",
      "en": "Browser navigation behavior fits the 'Last-In, First-Out' (LIFO) characteristic. Using two stacks: a `BackStack` for past pages and a `ForwardStack` for reverted pages. Clicking 'Back' pops from `BackStack` and pushes to `ForwardStack`; visiting a new page pushes to `BackStack` and clears `ForwardStack`.",
      "wg": [
        {
          "t": "後進先出",
          "en": "Last-In, First-Out (LIFO)",
          "ps": "NP"
        },
        {
          "t": "回退",
          "en": "reverted",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Stack, Recursion, Stack Overflow, Debugging",
    "parentNo": null,
    "images": null,
    "codeSnippet": "void recursiveFunction() {\n    int x = 10;\n    recursiveFunction();\n}",
    "question": [
      {
        "t": "觀察上方的 C++/Java 風格程式碼片段。",
        "en": "Observe the C++/Java style code snippet above.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "執行此函式最終會導致 `StackOverflowError` 或 Segmentation Fault。",
        "en": "Executing this function will eventually cause a `StackOverflowError` or Segmentation Fault.",
        "wg": []
      },
      {
        "t": "請問從計算機結構與記憶體管理的角度來看，發生此錯誤的根本原因是什麼？",
        "en": "From the perspective of computer architecture and memory management, what is the root cause of this error?",
        "wg": [
          {
            "t": "計算機結構",
            "en": "computer architecture",
            "ps": "NP"
          },
          {
            "t": "根本原因",
            "en": "root cause",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 程式建立過多物件，導致 Heap 記憶體耗盡。",
        "en": "(A) The program creates too many objects, causing Heap memory exhaustion.",
        "wg": [
          {
            "t": "耗盡",
            "en": "exhaustion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 遞迴呼叫沒有終止條件，導致 Call Stack 空間被持續推入的 Stack Frame 填滿。",
        "en": "(B) The recursive call lacks a base case, causing the Call Stack space to be filled with continuously pushed Stack Frames.",
        "wg": [
          {
            "t": "終止條件",
            "en": "base case",
            "ps": "NP"
          },
          {
            "t": "堆疊框架",
            "en": "Stack Frame",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 變數 `x` 重複宣告導致編譯器錯誤。",
        "en": "(C) Repeated declaration of variable `x` causes a compiler error.",
        "wg": []
      },
      {
        "t": "(D) CPU 無法處理如此快速的函式呼叫切換。",
        "en": "(D) The CPU cannot handle such rapid function call switching.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "每次函式呼叫都會在記憶體的 Stack 區域產生一個新的 Stack Frame (包含區域變數、返回位址等)。由於缺乏終止條件 (Base Case)，遞迴無限進行，直到 Stack 記憶體區域被用光，這與 Heap 記憶體無關。",
      "en": "Each function call creates a new Stack Frame (containing local variables, return address, etc.) in the Stack memory region. Due to the lack of a base case, the recursion continues infinitely until the Stack memory region is exhausted. This is unrelated to Heap memory.",
      "wg": [
        {
          "t": "區域變數",
          "en": "local variables",
          "ps": "NP"
        },
        {
          "t": "返回位址",
          "en": "return address",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Stack, Monotonic Stack, Algorithm, Next Greater Element",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個整數陣列代表每日氣溫，您需要回傳一個新陣列，其中每個元素代表「還要幾天才能等到更溫暖的天氣」。",
        "en": "Given an array of integers representing daily temperatures, you need to return a new array where each element represents 'how many days until a warmer temperature'.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "array of integers",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "若之後都沒有更高溫，則填入 0。",
        "en": "If there is no future day for which this is possible, put 0.",
        "wg": []
      },
      {
        "t": "為了在 O(N) 時間複雜度內解決此問題，應使用下列哪種資料結構技巧？",
        "en": "To solve this problem within O(N) time complexity, which of the following data structure techniques should be used?",
        "wg": [
          {
            "t": "技巧",
            "en": "technique",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 雙重迴圈暴力法 (Brute Force)。",
        "en": "(A) Nested loop Brute Force.",
        "wg": [
          {
            "t": "暴力法",
            "en": "Brute Force",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 單調堆疊 (Monotonic Stack)。",
        "en": "(B) Monotonic Stack.",
        "wg": [
          {
            "t": "單調堆疊",
            "en": "Monotonic Stack",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 優先佇列 (Priority Queue)。",
        "en": "(C) Priority Queue.",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map) 記錄次數。",
        "en": "(D) Hash Map to count occurrences.",
        "wg": [
          {
            "t": "次數",
            "en": "occurrences",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是經典的「下一個更大元素」(Next Greater Element) 問題。使用單調遞減堆疊 (Monotonic Decreasing Stack) 儲存索引，當遇到比堆疊頂端溫度高的日子時，即可算出堆疊頂端那天的等待天數並將其 Pop 出去，確保每個元素最多進出堆疊一次，達到 O(N)。",
      "en": "This is a classic 'Next Greater Element' problem. Using a Monotonic Decreasing Stack to store indices allows you to calculate the waiting days for the top element whenever a warmer day is encountered (popping it off). This ensures each element is pushed and popped at most once, achieving O(N).",
      "wg": [
        {
          "t": "單調遞減",
          "en": "monotonic decreasing",
          "ps": "Adj"
        },
        {
          "t": "索引",
          "en": "indices",
          "ps": "N"
        }
      ]
    }
  }
]