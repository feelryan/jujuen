[
  {
    "no": "16",
    "level": "medium",
    "keywords": "Stack, Monotonic Stack, Algorithm, Time Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要針對一個整數陣列，找出每個元素右邊第一個比它大的數字（Next Greater Element）。",
        "en": "You need to find the first number larger than the current element to its right (Next Greater Element) for an integer array.",
        "wg": [
          {
            "t": "整數陣列",
            "en": "integer array",
            "ps": "NP"
          },
          {
            "t": "元素",
            "en": "element",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為了達到 O(N) 的時間複雜度，哪種資料結構最為合適？",
        "en": "To achieve O(N) time complexity, which data structure is most suitable?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "NP"
          },
          {
            "t": "資料結構",
            "en": "data structure",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 最小堆積 (Min-Heap)",
        "en": "(A) Min-Heap",
        "wg": []
      },
      {
        "t": "(B) 單調堆疊 (Monotonic Stack)",
        "en": "(B) Monotonic Stack",
        "wg": [
          {
            "t": "單調堆疊",
            "en": "monotonic stack",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 雙向佇列 (Deque)",
        "en": "(C) Deque",
        "wg": []
      },
      {
        "t": "(D) 雜湊表 (Hash Map)",
        "en": "(D) Hash Map",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "單調堆疊可以維護元素的遞減順序，當遇到較大的元素時，即可確定堆疊中較小元素的「下一個較大值」，每個元素最多進出堆疊一次，故為 O(N)。",
      "en": "A monotonic stack can maintain a decreasing order of elements; when a larger element is encountered, it determines the 'next greater element' for the smaller ones in the stack, ensuring each element is pushed and popped at most once, resulting in O(N).",
      "wg": [
        {
          "t": "遞減順序",
          "en": "decreasing order",
          "ps": "NP"
        },
        {
          "t": "維護",
          "en": "maintain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "easy",
    "keywords": "Stack, Application, Browser History",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "網頁瀏覽器通常具備「上一頁」與「下一頁」的導航功能。",
        "en": "Web browsers typically feature 'Back' and 'Forward' navigation capabilities.",
        "wg": [
          {
            "t": "導航功能",
            "en": "navigation capabilities",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "若要實作此功能，最常使用哪種資料結構組合？",
        "en": "Which combination of data structures is most commonly used to implement this feature?",
        "wg": [
          {
            "t": "實作",
            "en": "implement",
            "ps": "V"
          },
          {
            "t": "組合",
            "en": "combination",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 單一佇列 (Queue)",
        "en": "(A) Single Queue",
        "wg": []
      },
      {
        "t": "(B) 兩個堆疊 (Two Stacks)",
        "en": "(B) Two Stacks",
        "wg": []
      },
      {
        "t": "(C) 環狀緩衝區 (Circular Buffer)",
        "en": "(C) Circular Buffer",
        "wg": []
      },
      {
        "t": "(D) 二元搜尋樹 (BST)",
        "en": "(D) Binary Search Tree (BST)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "使用兩個堆疊最為直觀：一個堆疊儲存歷史紀錄 (History Stack) 以支援「上一頁」，另一個儲存被回退的頁面 (Forward Stack) 以支援「下一頁」。",
      "en": "Using two stacks is the most intuitive: one stack stores history (History Stack) to support 'Back', and the other stores popped pages (Forward Stack) to support 'Forward'.",
      "wg": [
        {
          "t": "直觀",
          "en": "intuitive",
          "ps": "Adj"
        },
        {
          "t": "回退",
          "en": "popped/reverted",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Stack, Design, Optimization, Min Stack",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您被要求設計一個特殊的堆疊 (Min Stack)，除了標準的 push 和 pop 操作外，還需要支援 `getMin()`。",
        "en": "You are asked to design a special stack (Min Stack) that, in addition to standard push and pop operations, supports `getMin()`.",
        "wg": [
          {
            "t": "標準的",
            "en": "standard",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "`getMin()` 必須在 O(1) 時間內回傳堆疊中目前的最小值。",
        "en": "`getMin()` must return the current minimum value in the stack in O(1) time.",
        "wg": [
          {
            "t": "回傳",
            "en": "return",
            "ps": "V"
          }
        ]
      },
      {
        "t": "下列哪種實作策略是正確的？",
        "en": "Which of the following implementation strategies is correct?",
        "wg": [
          {
            "t": "實作策略",
            "en": "implementation strategy",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 每次呼叫 `getMin` 時遍歷整個堆疊尋找最小值。",
        "en": "(A) Traverse the entire stack to find the minimum whenever `getMin` is called.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traverse",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 使用一個額外的變數儲存最小值，pop 時若移除該值則不更新。",
        "en": "(B) Use an extra variable to store the minimum; do not update if that value is removed during pop.",
        "wg": []
      },
      {
        "t": "(C) 使用一個輔助堆疊，同步儲存當前堆疊狀態下的最小值。",
        "en": "(C) Use an auxiliary stack to synchronously store the minimum value corresponding to the current stack state.",
        "wg": [
          {
            "t": "輔助堆疊",
            "en": "auxiliary stack",
            "ps": "NP"
          },
          {
            "t": "同步",
            "en": "synchronously",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(D) 將堆疊內部的資料隨時保持排序狀態。",
        "en": "(D) Keep the data inside the stack sorted at all times.",
        "wg": [
          {
            "t": "排序",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "使用輔助堆疊可以在每次 push 時，將當前值與輔助堆疊頂端的最小值比較並存入較小者，確保 `getMin` 為 O(1) 且 pop 時能正確還原前一個最小值狀態。",
      "en": "Using an auxiliary stack allows comparing the current value with the top of the auxiliary stack on every push and storing the smaller one, ensuring `getMin` is O(1) and the previous minimum state is correctly restored upon pop.",
      "wg": [
        {
          "t": "還原",
          "en": "restore",
          "ps": "V"
        },
        {
          "t": "狀態",
          "en": "state",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Stack, Recursion, DFS, Memory",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在處理極深層的樹狀結構或圖形遍歷時，遞迴 (Recursion) 可能導致堆疊溢位 (Stack Overflow)。",
        "en": "When processing extremely deep tree structures or graph traversals, recursion may lead to a Stack Overflow.",
        "wg": [
          {
            "t": "堆疊溢位",
            "en": "Stack Overflow",
            "ps": "NP"
          },
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要將遞迴演算法轉換為迭代 (Iterative) 版本以避免此問題，通常會使用哪種資料結構來模擬系統呼叫堆疊？",
        "en": "To convert a recursive algorithm to an iterative version to avoid this issue, which data structure is typically used to simulate the system call stack?",
        "wg": [
          {
            "t": "迭代",
            "en": "iterative",
            "ps": "Adj"
          },
          {
            "t": "模擬",
            "en": "simulate",
            "ps": "V"
          },
          {
            "t": "系統呼叫堆疊",
            "en": "system call stack",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 佇列 (Queue)",
        "en": "(A) Queue",
        "wg": []
      },
      {
        "t": "(B) 堆疊 (Stack)",
        "en": "(B) Stack",
        "wg": []
      },
      {
        "t": "(C) 連結串列 (Linked List)",
        "en": "(C) Linked List",
        "wg": []
      },
      {
        "t": "(D) 優先權佇列 (Priority Queue)",
        "en": "(D) Priority Queue",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "遞迴的本質是利用系統的呼叫堆疊 (Call Stack) 來保存狀態，因此將其轉為迭代時，需使用顯式的堆疊 (Explicit Stack) 來模擬後進先出 (LIFO) 的行為。",
      "en": "The essence of recursion is using the system's Call Stack to save state, so when converting to iteration, an explicit Stack is needed to simulate the Last-In-First-Out (LIFO) behavior.",
      "wg": [
        {
          "t": "顯式的",
          "en": "explicit",
          "ps": "Adj"
        },
        {
          "t": "本質",
          "en": "essence",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "hard",
    "keywords": "Stack, Expression Evaluation, Postfix, RPN",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [\"4\", \"13\", \"5\", \"/\", \"+\"]",
    "question": [
      {
        "t": "給定一個逆波蘭表示法 (Reverse Polish Notation, RPN) 的算術運算式陣列。",
        "en": "Given an array representing an arithmetic expression in Reverse Polish Notation (RPN).",
        "wg": [
          {
            "t": "逆波蘭表示法",
            "en": "Reverse Polish Notation",
            "ps": "NP"
          },
          {
            "t": "算術運算式",
            "en": "arithmetic expression",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "當程式讀取到運算子（如 `/` 或 `+`）時，堆疊應執行什麼操作？",
        "en": "When the program encounters an operator (such as `/` or `+`), what operation should the stack perform?",
        "wg": [
          {
            "t": "運算子",
            "en": "operator",
            "ps": "N"
          },
          {
            "t": "遇到",
            "en": "encounter",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將運算子推入堆疊，等待下一個數字。",
        "en": "(A) Push the operator onto the stack and wait for the next number.",
        "wg": []
      },
      {
        "t": "(B) 彈出堆疊頂端的一個數字，與當前運算子進行計算，再將結果推回。",
        "en": "(B) Pop one number from the top of the stack, calculate with the current operator, and push the result back.",
        "wg": []
      },
      {
        "t": "(C) 彈出堆疊頂端的兩個數字，進行計算，將結果推回堆疊。",
        "en": "(C) Pop two numbers from the top of the stack, perform the calculation, and push the result back onto the stack.",
        "wg": [
          {
            "t": "彈出",
            "en": "pop",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 清空堆疊並重新開始計算。",
        "en": "(D) Clear the stack and restart the calculation.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "在 RPN 計算中，運算子需要兩個運算元。這兩個運算元位於堆疊的最頂端，因此需彈出兩個數字進行運算，並將計算結果放回堆疊供後續使用。",
      "en": "In RPN evaluation, an operator requires two operands. These operands are at the top of the stack, so two numbers must be popped to perform the calculation, and the result is pushed back for subsequent use.",
      "wg": [
        {
          "t": "運算元",
          "en": "operand",
          "ps": "N"
        },
        {
          "t": "後續使用",
          "en": "subsequent use",
          "ps": "NP"
        }
      ]
    }
  }
]