[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Dijkstra, Shortest Path, Negative Weights, Greedy Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在尋找加權圖的最短路徑時，為什麼 Dijkstra 演算法不能處理帶有負權重的邊？",
        "en": "When finding the shortest path in a weighted graph, why can't Dijkstra's algorithm handle edges with negative weights?",
        "wg": [
          {
            "t": "加權圖",
            "en": "weighted graph",
            "ps": "N"
          },
          {
            "t": "負權重",
            "en": "negative weights",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出最準確描述其演算法限制的原因。",
        "en": "Please select the reason that most accurately describes the limitation of the algorithm.",
        "wg": [
          {
            "t": "限制",
            "en": "limitation",
            "ps": "N"
          },
          {
            "t": "準確",
            "en": "accurately",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為 Dijkstra 使用深度優先搜尋 (DFS)，無法回溯修正路徑。",
        "en": "(A) Because Dijkstra uses Depth-First Search (DFS) and cannot backtrack to correct the path.",
        "wg": [
          {
            "t": "回溯",
            "en": "backtrack",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 因為 Dijkstra 是一種貪婪演算法，它假設一旦節點被標記為已訪問，其最短路徑就已確定。",
        "en": "(B) Because Dijkstra is a greedy algorithm, assuming that once a node is marked as visited, its shortest path is determined.",
        "wg": [
          {
            "t": "貪婪演算法",
            "en": "greedy algorithm",
            "ps": "N"
          },
          {
            "t": "已訪問",
            "en": "visited",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 因為負權重會導致整數溢位錯誤。",
        "en": "(C) Because negative weights cause integer overflow errors.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "integer overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 因為 Dijkstra 的時間複雜度對於負權重圖來說太高。",
        "en": "(D) Because Dijkstra's time complexity is too high for graphs with negative weights.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 演算法基於貪婪策略，假設路徑長度只會增加不會減少。",
      "en": "Dijkstra's algorithm is based on a greedy strategy, assuming that path length only increases and never decreases.",
      "wg": [
        {
          "t": "貪婪策略",
          "en": "greedy strategy",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Cycle Detection, Dependency Resolution",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個構建系統 (Build System) 來決定編譯任務的執行順序，這些任務之間具有依賴關係。",
        "en": "You are designing a build system to determine the execution order of compilation tasks, which have dependencies on each other.",
        "wg": [
          {
            "t": "構建系統",
            "en": "build system",
            "ps": "N"
          },
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果任務依賴圖中存在循環依賴，下列哪種演算法最適合用來檢測此狀況並在無循環時產生排序？",
        "en": "If there are circular dependencies in the task dependency graph, which of the following algorithms is best suited to detect this condition and generate an order if no cycle exists?",
        "wg": [
          {
            "t": "循環依賴",
            "en": "circular dependencies",
            "ps": "N"
          },
          {
            "t": "檢測",
            "en": "detect",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Prim 演算法 (Prim's Algorithm)。",
        "en": "(A) Prim's Algorithm.",
        "wg": []
      },
      {
        "t": "(B) 拓撲排序 (Topological Sort) 結合 Kahn 演算法。",
        "en": "(B) Topological Sort combined with Kahn's Algorithm.",
        "wg": [
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Floyd-Warshall 演算法。",
        "en": "(C) Floyd-Warshall Algorithm.",
        "wg": []
      },
      {
        "t": "(D) 二元搜尋樹 (Binary Search Tree) 插入。",
        "en": "(D) Binary Search Tree insertion.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "拓撲排序專門用於有向無環圖 (DAG) 的線性排序。",
      "en": "Topological sort is specifically designed for the linear ordering of Directed Acyclic Graphs (DAG).",
      "wg": [
        {
          "t": "有向無環圖",
          "en": "Directed Acyclic Graphs",
          "ps": "N"
        },
        {
          "t": "線性排序",
          "en": "linear ordering",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Union-Find, Disjoint Set, Path Compression, Amortized Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": "function find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x]) // ???\n    return parent[x]",
    "question": [
      {
        "t": "在並查集 (Union-Find) 資料結構中，上述程式碼片段展示了一種優化技術。",
        "en": "In the Union-Find (Disjoint Set) data structure, the code snippet above demonstrates an optimization technique.",
        "wg": [
          {
            "t": "並查集",
            "en": "Union-Find",
            "ps": "N"
          },
          {
            "t": "優化技術",
            "en": "optimization technique",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這種技術的名稱是什麼，以及它如何影響操作的時間複雜度？",
        "en": "What is the name of this technique, and how does it affect the time complexity of operations?",
        "wg": [
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 按秩合併 (Union by Rank)；它將樹的高度保持在對數級別。",
        "en": "(A) Union by Rank; it keeps the tree height at a logarithmic level.",
        "wg": [
          {
            "t": "按秩合併",
            "en": "Union by Rank",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 路徑壓縮 (Path Compression)；它將後續查詢的均攤時間複雜度降低至接近常數。",
        "en": "(B) Path Compression; it reduces the amortized time complexity of subsequent queries to nearly constant.",
        "wg": [
          {
            "t": "路徑壓縮",
            "en": "Path Compression",
            "ps": "N"
          },
          {
            "t": "均攤",
            "en": "amortized",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 循環檢測 (Cycle Detection)；它防止無限遞迴。",
        "en": "(C) Cycle Detection; it prevents infinite recursion.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 記憶化搜尋 (Memoization)；它將複雜度降低至 O(N)。",
        "en": "(D) Memoization; it reduces complexity to O(N).",
        "wg": [
          {
            "t": "記憶化",
            "en": "Memoization",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "程式碼中的 `parent[x] = find(parent[x])` 是路徑壓縮的實作，它將節點直接連接到根節點，極大扁平化了樹的結構。",
      "en": "The code `parent[x] = find(parent[x])` is the implementation of Path Compression, which connects nodes directly to the root, significantly flattening the tree structure.",
      "wg": [
        {
          "t": "扁平化",
          "en": "flattening",
          "ps": "V"
        },
        {
          "t": "實作",
          "en": "implementation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "MST, Prim, Kruskal, Dense Graph, Sparse Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您需要為一個非常稠密的圖 (Dense Graph) 尋找最小生成樹 (MST)，其中邊的數量接近頂點數量的平方 ($E \\approx V^2$)。",
        "en": "You need to find the Minimum Spanning Tree (MST) for a very dense graph, where the number of edges is close to the square of the number of vertices ($E \\approx V^2$).",
        "wg": [
          {
            "t": "稠密",
            "en": "dense",
            "ps": "Adj"
          },
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          },
          {
            "t": "頂點",
            "en": "vertices",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在這種情況下，通常推薦使用哪種演算法？",
        "en": "In this scenario, which algorithm is generally recommended?",
        "wg": [
          {
            "t": "推薦",
            "en": "recommended",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Kruskal 演算法，因為它基於邊進行排序。",
        "en": "(A) Kruskal's algorithm, because it sorts based on edges.",
        "wg": []
      },
      {
        "t": "(B) Prim 演算法 (使用陣列或斐波那契堆積)，因為它主要依賴於頂點數量。",
        "en": "(B) Prim's algorithm (using an array or Fibonacci heap), because it relies primarily on the number of vertices.",
        "wg": [
          {
            "t": "斐波那契堆積",
            "en": "Fibonacci heap",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) Bellman-Ford 演算法，因為它能處理所有邊。",
        "en": "(C) Bellman-Ford algorithm, because it handles all edges.",
        "wg": []
      },
      {
        "t": "(D) 兩者效能相同，沒有區別。",
        "en": "(D) Both perform equally well; there is no difference.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Kruskal 的複雜度為 $O(E \\log E)$，在稠密圖中 $E$ 很大，效能較差；Prim 使用適當資料結構時，複雜度與 $V$ 關係更密切 ($O(V^2)$ 或 $O(E + V \\log V)$)，在稠密圖中更具優勢。",
      "en": "Kruskal's complexity is $O(E \\log E)$, which performs poorly in dense graphs where $E$ is large; Prim's, with appropriate data structures, relates more to $V$ ($O(V^2)$ or $O(E + V \\log V)$), making it advantageous for dense graphs.",
      "wg": [
        {
          "t": "效能",
          "en": "performance",
          "ps": "N"
        },
        {
          "t": "優勢",
          "en": "advantageous",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Bellman-Ford, Negative Cycle, Relaxation, Shortest Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Bellman-Ford 演算法可以用來檢測圖中是否存在負權重環 (Negative Weight Cycle)。",
        "en": "The Bellman-Ford algorithm can be used to detect the presence of negative weight cycles in a graph.",
        "wg": [
          {
            "t": "負權重環",
            "en": "negative weight cycle",
            "ps": "N"
          },
          {
            "t": "檢測",
            "en": "detect",
            "ps": "V"
          }
        ]
      },
      {
        "t": "其檢測的機制是什麼？",
        "en": "What is the mechanism for this detection?",
        "wg": [
          {
            "t": "機制",
            "en": "mechanism",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 如果在進行 $V-1$ 次鬆弛 (Relaxation) 後，仍有邊可以被鬆弛，則存在負權重環。",
        "en": "(A) If edges can still be relaxed after $V-1$ iterations of relaxation, then a negative weight cycle exists.",
        "wg": [
          {
            "t": "鬆弛",
            "en": "relaxation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 如果所有邊的權重總和為負數，則存在負權重環。",
        "en": "(B) If the sum of all edge weights is negative, then a negative weight cycle exists.",
        "wg": []
      },
      {
        "t": "(C) 如果演算法執行時間超過預期，則存在負權重環。",
        "en": "(C) If the algorithm execution time exceeds expectations, then a negative weight cycle exists.",
        "wg": []
      },
      {
        "t": "(D) 如果使用了優先佇列 (Priority Queue) 且佇列無法清空，則存在負權重環。",
        "en": "(D) If a Priority Queue is used and cannot be emptied, then a negative weight cycle exists.",
        "wg": [
          {
            "t": "優先佇列",
            "en": "Priority Queue",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在沒有負環的圖中，最短路徑最多包含 $V-1$ 條邊。如果在第 $V$ 次迭代時仍能更新距離，表示存在負環讓路徑可以無限縮短。",
      "en": "In a graph without negative cycles, the shortest path contains at most $V-1$ edges. If distances can still be updated in the $V$-th iteration, it indicates a negative cycle allows the path to be shortened infinitely.",
      "wg": [
        {
          "t": "迭代",
          "en": "iteration",
          "ps": "N"
        },
        {
          "t": "無限縮短",
          "en": "shortened infinitely",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "medium",
    "keywords": "Dijkstra, Shortest Path, Negative Weights, Greedy Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在尋找加權圖的最短路徑時，為什麼 Dijkstra 演算法不能處理帶有負權重邊的圖？",
        "en": "When finding the shortest path in a weighted graph, why can't Dijkstra's algorithm handle graphs with negative weight edges?",
        "wg": [
          {
            "t": "加權圖",
            "en": "weighted graph",
            "ps": "N"
          },
          {
            "t": "負權重邊",
            "en": "negative weight edges",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出最準確描述其失敗原因的選項。",
        "en": "Please select the option that most accurately describes the reason for its failure.",
        "wg": [
          {
            "t": "準確",
            "en": "accurately",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 演算法的時間複雜度太高，無法處理負數運算。",
        "en": "(A) The time complexity of Dijkstra's algorithm is too high to handle negative number operations.",
        "wg": []
      },
      {
        "t": "(B) Dijkstra 演算法基於貪婪策略，一旦節點被標記為已訪問，就假設找到了最短路徑，而負邊可能會推翻這個假設。",
        "en": "(B) Dijkstra's algorithm is based on a greedy strategy; once a node is marked as visited, it assumes the shortest path is found, but negative edges might invalidate this assumption.",
        "wg": [
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          },
          {
            "t": "推翻",
            "en": "invalidate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 負權重邊會導致優先佇列 (Priority Queue) 崩潰。",
        "en": "(C) Negative weight edges will cause the Priority Queue to crash.",
        "wg": [
          {
            "t": "優先佇列",
            "en": "Priority Queue",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) Dijkstra 演算法只能用於無向圖，而負權重通常出現在有向圖中。",
        "en": "(D) Dijkstra's algorithm can only be used on undirected graphs, while negative weights usually appear in directed graphs.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 演算法是貪婪的 (Greedy)，它假設路徑只會越加越長。",
      "en": "Dijkstra's algorithm is greedy; it assumes that paths only get longer as you add edges.",
      "wg": [
        {
          "t": "貪婪的",
          "en": "greedy",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Topological Sort, DAG, Cycle Detection, Dependency Resolution",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個構建系統 (Build System) 來決定編譯任務的執行順序。",
        "en": "You are designing a build system to determine the execution order of compilation tasks.",
        "wg": [
          {
            "t": "構建系統",
            "en": "build system",
            "ps": "N"
          },
          {
            "t": "執行順序",
            "en": "execution order",
            "ps": "N"
          }
        ]
      },
      {
        "t": "如果任務之間的依賴關係形成了一個有向環 (Directed Cycle)，嘗試執行拓撲排序 (Topological Sort) 會發生什麼情況？",
        "en": "If the dependencies between tasks form a directed cycle, what happens when you attempt to perform a Topological Sort?",
        "wg": [
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          },
          {
            "t": "有向環",
            "en": "directed cycle",
            "ps": "N"
          },
          {
            "t": "拓撲排序",
            "en": "Topological Sort",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 演算法會自動移除造成環的邊並產生排序。",
        "en": "(A) The algorithm will automatically remove the edges causing the cycle and generate a sort.",
        "wg": []
      },
      {
        "t": "(B) 演算法會陷入無限迴圈。",
        "en": "(B) The algorithm will enter an infinite loop.",
        "wg": []
      },
      {
        "t": "(C) 無法產生包含所有節點的有效線性排序，因為拓撲排序僅適用於有向無環圖 (DAG)。",
        "en": "(C) It cannot generate a valid linear ordering containing all nodes because Topological Sort is only applicable to Directed Acyclic Graphs (DAGs).",
        "wg": [
          {
            "t": "線性排序",
            "en": "linear ordering",
            "ps": "N"
          },
          {
            "t": "有向無環圖",
            "en": "Directed Acyclic Graphs",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 演算法會忽略環中的節點，只對其他節點進行排序。",
        "en": "(D) The algorithm will ignore the nodes in the cycle and only sort the other nodes.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "拓撲排序的定義是針對有向無環圖 (DAG)。如果有環存在，則無法滿足所有依賴條件 (例如 A 依賴 B，B 依賴 A)，因此不存在有效的拓撲排序。",
      "en": "Topological Sort is defined for Directed Acyclic Graphs (DAGs). If a cycle exists, not all dependencies can be satisfied (e.g., A depends on B, B depends on A), so no valid topological sort exists.",
      "wg": [
        {
          "t": "滿足",
          "en": "satisfy",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "MST, Kruskal's Algorithm, Union-Find, Disjoint Set",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 Kruskal 演算法以尋找最小生成樹 (MST) 時，我們通常會使用並查集 (Union-Find / Disjoint Set) 資料結構。",
        "en": "When implementing Kruskal's algorithm to find the Minimum Spanning Tree (MST), we typically use the Union-Find (Disjoint Set) data structure.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          },
          {
            "t": "並查集",
            "en": "Union-Find",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問在此演算法中，並查集的主要用途是什麼？",
        "en": "What is the primary purpose of the Union-Find data structure in this algorithm?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對圖中的所有邊依照權重進行排序。",
        "en": "(A) To sort all edges in the graph by weight.",
        "wg": []
      },
      {
        "t": "(B) 快速判斷加入一條邊是否會形成環 (Cycle)，即檢查兩個節點是否已屬於同一個連通分量。",
        "en": "(B) To quickly determine if adding an edge will form a cycle, i.e., checking if two nodes already belong to the same connected component.",
        "wg": [
          {
            "t": "連通分量",
            "en": "connected component",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 計算從起點到所有其他節點的最短路徑。",
        "en": "(C) To calculate the shortest paths from a starting node to all other nodes.",
        "wg": []
      },
      {
        "t": "(D) 儲存已訪問過的節點以避免重複遍歷。",
        "en": "(D) To store visited nodes to avoid repeated traversal.",
        "wg": [
          {
            "t": "遍歷",
            "en": "traversal",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Kruskal 演算法按權重從小到大選邊，若加入的邊連接了兩個已經連通的節點，則會形成環。並查集能高效地檢查 (Find) 和合併 (Union) 連通分量。",
      "en": "Kruskal's algorithm selects edges from smallest to largest weight. If an added edge connects two nodes that are already connected, a cycle is formed. Union-Find efficiently checks (Find) and merges (Union) connected components.",
      "wg": [
        {
          "t": "合併",
          "en": "merge",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Bellman-Ford, Relaxation, Dynamic Programming, Shortest Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "Bellman-Ford 演算法透過重複「鬆弛 (Relax)」邊來尋找最短路徑。",
        "en": "The Bellman-Ford algorithm finds shortest paths by repeatedly 'relaxing' edges.",
        "wg": [
          {
            "t": "鬆弛",
            "en": "relax",
            "ps": "V"
          }
        ]
      },
      {
        "t": "對於一個包含 V 個頂點的圖，為什麼該演算法的主迴圈通常需要執行 V-1 次？",
        "en": "For a graph with V vertices, why does the main loop of the algorithm typically need to run V-1 times?",
        "wg": [
          {
            "t": "頂點",
            "en": "vertices",
            "ps": "N"
          },
          {
            "t": "主迴圈",
            "en": "main loop",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為圖中可能存在 V-1 個負權重環。",
        "en": "(A) Because there might be V-1 negative weight cycles in the graph.",
        "wg": []
      },
      {
        "t": "(B) 為了確保每個邊都被訪問至少一次。",
        "en": "(B) To ensure every edge is visited at least once.",
        "wg": []
      },
      {
        "t": "(C) 因為在沒有負環的圖中，任意兩點間的最短路徑最多包含 V-1 條邊。",
        "en": "(C) Because in a graph without negative cycles, the shortest path between any two nodes contains at most V-1 edges.",
        "wg": [
          {
            "t": "任意",
            "en": "any",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 這是為了配合二元樹的高度限制。",
        "en": "(D) This is to accommodate the height limit of a binary tree.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "簡單路徑 (不含重複節點) 在 V 個頂點的圖中最多只有 V-1 條邊。每次迭代，演算法保證最短路徑至少向外延伸一條邊。",
      "en": "A simple path (without repeated nodes) in a graph with V vertices has at most V-1 edges. Each iteration, the algorithm guarantees the shortest path extends by at least one edge.",
      "wg": [
        {
          "t": "簡單路徑",
          "en": "simple path",
          "ps": "N"
        },
        {
          "t": "迭代",
          "en": "iteration",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "A* Search, Heuristic, Admissibility, Pathfinding",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "A* 搜尋演算法使用啟發式函數 $h(n)$ 來估計從節點 $n$ 到目標的成本。",
        "en": "The A* search algorithm uses a heuristic function $h(n)$ to estimate the cost from node $n$ to the goal.",
        "wg": [
          {
            "t": "啟發式函數",
            "en": "heuristic function",
            "ps": "N"
          },
          {
            "t": "估計",
            "en": "estimate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為了保證 A* 找到的是最短路徑 (最佳解)，$h(n)$ 必須具備什麼性質？",
        "en": "To guarantee that A* finds the shortest path (optimal solution), what property must $h(n)$ possess?",
        "wg": [
          {
            "t": "最佳解",
            "en": "optimal solution",
            "ps": "N"
          },
          {
            "t": "性質",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 一致性 (Consistency)：$h(n)$ 必須始終為 0。",
        "en": "(A) Consistency: $h(n)$ must always be 0.",
        "wg": []
      },
      {
        "t": "(B) 可容許性 (Admissibility)：$h(n)$ 永遠不能高估到達目標的實際成本。",
        "en": "(B) Admissibility: $h(n)$ must never overestimate the actual cost to reach the goal.",
        "wg": [
          {
            "t": "可容許性",
            "en": "Admissibility",
            "ps": "N"
          },
          {
            "t": "高估",
            "en": "overestimate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 複雜性 (Complexity)：$h(n)$ 的計算必須非常耗時以確保準確。",
        "en": "(C) Complexity: The calculation of $h(n)$ must be very time-consuming to ensure accuracy.",
        "wg": []
      },
      {
        "t": "(D) 隨機性 (Randomness)：$h(n)$ 應該包含隨機因素以避免陷入局部最佳。",
        "en": "(D) Randomness: $h(n)$ should include a random factor to avoid getting stuck in local optima.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若 $h(n)$ 高估了成本，A* 可能會誤以為某條路徑太貴而忽略它，導致錯過真正的最短路徑。可容許性 (Admissibility) 確保了演算法的樂觀性。",
      "en": "If $h(n)$ overestimates the cost, A* might mistakenly think a path is too expensive and ignore it, causing it to miss the actual shortest path. Admissibility ensures the algorithm's optimism.",
      "wg": [
        {
          "t": "忽略",
          "en": "ignore",
          "ps": "V"
        },
        {
          "t": "樂觀性",
          "en": "optimism",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "hard",
    "keywords": "Shortest Path, Bellman-Ford, Negative Cycles, Arbitrage",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在為一個金融交易系統設計演算法，目的是在不同貨幣的匯率圖中尋找套利機會。",
        "en": "You are designing an algorithm for a financial trading system to find arbitrage opportunities within a graph of currency exchange rates.",
        "wg": [
          {
            "t": "套利",
            "en": "arbitrage",
            "ps": "N"
          },
          {
            "t": "匯率",
            "en": "exchange rates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在這個圖中，節點代表貨幣，邊的權重代表轉換匯率的對數（經過轉換後可能出現負權重）。",
        "en": "In this graph, nodes represent currencies, and edge weights represent the logarithm of exchange rates (which may result in negative weights after transformation).",
        "wg": [
          {
            "t": "對數",
            "en": "logarithm",
            "ps": "N"
          },
          {
            "t": "負權重",
            "en": "negative weights",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要偵測圖中是否存在「無限獲利」的迴圈（即負權重環），您應該使用哪種演算法？",
        "en": "To detect if there is an 'infinite profit' loop (i.e., a negative weight cycle) in the graph, which algorithm should you use?",
        "wg": [
          {
            "t": "負權重環",
            "en": "negative weight cycle",
            "ps": "N"
          },
          {
            "t": "偵測",
            "en": "detect",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 演算法",
        "en": "(A) Dijkstra's Algorithm",
        "wg": []
      },
      {
        "t": "(B) Bellman-Ford 演算法",
        "en": "(B) Bellman-Ford Algorithm",
        "wg": []
      },
      {
        "t": "(C) Prim 演算法",
        "en": "(C) Prim's Algorithm",
        "wg": []
      },
      {
        "t": "(D) Kruskal 演算法",
        "en": "(D) Kruskal's Algorithm",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Bellman-Ford 演算法能夠處理帶有負權重邊的圖，並且可以偵測負權重環（Negative Cycles）。Dijkstra 演算法假設所有邊的權重皆為非負數，遇到負權重邊時可能會產生錯誤結果，且無法偵測負環；Prim 和 Kruskal 是用於尋找最小生成樹（MST）的演算法，不適用於最短路徑或套利偵測問題。",
      "en": "The Bellman-Ford algorithm can handle graphs with negative edge weights and is capable of detecting negative weight cycles. Dijkstra's algorithm assumes all edge weights are non-negative and may yield incorrect results with negative edges, nor can it detect negative cycles. Prim's and Kruskal's algorithms are for finding Minimum Spanning Trees (MST) and are not applicable to shortest path or arbitrage detection problems.",
      "wg": [
        {
          "t": "最小生成樹",
          "en": "Minimum Spanning Tree",
          "ps": "N"
        },
        {
          "t": "非負數",
          "en": "non-negative",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "All-Pairs Shortest Path, Floyd-Warshall, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": "for (k = 0; k < V; k++) {\n  for (i = 0; i < V; i++) {\n    for (j = 0; j < V; j++) {\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n  }\n}",
    "question": [
      {
        "t": "考慮上述的程式碼片段，這是哪一個圖論演算法的核心邏輯？",
        "en": "Consider the code snippet above; which graph theory algorithm's core logic does this represent?",
        "wg": [
          {
            "t": "核心邏輯",
            "en": "core logic",
            "ps": "N"
          },
          {
            "t": "片段",
            "en": "snippet",
            "ps": "N"
          }
        ]
      },
      {
        "t": "該演算法的主要用途是什麼？",
        "en": "What is the primary use case of this algorithm?",
        "wg": [
          {
            "t": "主要用途",
            "en": "primary use case",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Floyd-Warshall，用於計算所有節點對之間的最短路徑。",
        "en": "(A) Floyd-Warshall, used for computing All-Pairs Shortest Paths.",
        "wg": [
          {
            "t": "所有節點對",
            "en": "all-pairs",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Dijkstra，用於計算單一源點到其他節點的最短路徑。",
        "en": "(B) Dijkstra, used for computing Single-Source Shortest Paths.",
        "wg": []
      },
      {
        "t": "(C) Topological Sort，用於排程任務順序。",
        "en": "(C) Topological Sort, used for scheduling task order.",
        "wg": []
      },
      {
        "t": "(D) Union-Find，用於判斷圖的連通性。",
        "en": "(D) Union-Find, used for determining graph connectivity.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "這段程式碼展示了 Floyd-Warshall 演算法的三層迴圈結構，其時間複雜度為 O(V^3)。它利用動態規劃（Dynamic Programming）的概念，透過中間節點 k 來更新節點 i 到節點 j 的最短距離，適用於解決「所有節點對最短路徑」（All-Pairs Shortest Path）問題。",
      "en": "This code snippet demonstrates the three-nested-loop structure of the Floyd-Warshall algorithm, with a time complexity of O(V^3). It uses the concept of Dynamic Programming to update the shortest distance from node i to node j via an intermediate node k, making it suitable for solving the 'All-Pairs Shortest Path' problem.",
      "wg": [
        {
          "t": "動態規劃",
          "en": "Dynamic Programming",
          "ps": "N"
        },
        {
          "t": "中間節點",
          "en": "intermediate node",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Connectivity, Articulation Points, Network Reliability",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在設計一個高可用性的網路拓撲時，我們希望找出網路中的「單點故障」。",
        "en": "When designing a high-availability network topology, we want to identify 'single points of failure' within the network.",
        "wg": [
          {
            "t": "高可用性",
            "en": "high-availability",
            "ps": "N"
          },
          {
            "t": "拓撲",
            "en": "topology",
            "ps": "N"
          },
          {
            "t": "單點故障",
            "en": "single points of failure",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在圖論中，若移除某個頂點（及其連接的邊）後，會導致原本連通的圖變成不連通（即連通分量數量增加），該頂點稱為什麼？",
        "en": "In graph theory, if removing a vertex (and its incident edges) causes a previously connected graph to become disconnected (i.e., the number of connected components increases), what is that vertex called?",
        "wg": [
          {
            "t": "連通分量",
            "en": "connected components",
            "ps": "N"
          },
          {
            "t": "不連通",
            "en": "disconnected",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 匯點 (Sink Vertex)",
        "en": "(A) Sink Vertex",
        "wg": []
      },
      {
        "t": "(B) 關節點 (Articulation Point / Cut Vertex)",
        "en": "(B) Articulation Point / Cut Vertex",
        "wg": [
          {
            "t": "關節點",
            "en": "Articulation Point",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 強連通分量 (Strongly Connected Component)",
        "en": "(C) Strongly Connected Component",
        "wg": []
      },
      {
        "t": "(D) 最小生成樹 (MST)",
        "en": "(D) Minimum Spanning Tree (MST)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "關節點（Articulation Point 或 Cut Vertex）是指在無向圖中，移除該點會導致圖的連通分量增加的頂點，這對應到網路中的單點故障概念。Sink Vertex 通常指有向圖中出度為 0 的點；強連通分量是子圖的概念；MST 是樹結構。",
      "en": "An Articulation Point (or Cut Vertex) is a vertex in an undirected graph whose removal increases the number of connected components, corresponding to the concept of a single point of failure in a network. A Sink Vertex usually refers to a node with zero out-degree in a directed graph; a Strongly Connected Component is a subgraph concept; MST is a tree structure.",
      "wg": [
        {
          "t": "無向圖",
          "en": "undirected graph",
          "ps": "N"
        },
        {
          "t": "出度",
          "en": "out-degree",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "hard",
    "keywords": "Directed Graph, SCC, Tarjan, Kosaraju",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在分析軟體模組的依賴關係時，我們將模組視為節點，依賴關係視為有向邊。",
        "en": "When analyzing dependencies in software modules, we treat modules as nodes and dependencies as directed edges.",
        "wg": [
          {
            "t": "依賴關係",
            "en": "dependencies",
            "ps": "N"
          },
          {
            "t": "有向邊",
            "en": "directed edges",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若一群模組之間存在循環依賴（即彼此互相依賴），這在圖論中對應到什麼結構？",
        "en": "If a group of modules has circular dependencies (i.e., they depend on each other), what structure does this correspond to in graph theory?",
        "wg": [
          {
            "t": "循環依賴",
            "en": "circular dependencies",
            "ps": "N"
          }
        ]
      },
      {
        "t": "通常使用 Tarjan 或 Kosaraju 演算法來找出這些結構。",
        "en": "Tarjan's or Kosaraju's algorithms are typically used to find these structures.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 二分圖 (Bipartite Graph)",
        "en": "(A) Bipartite Graph",
        "wg": []
      },
      {
        "t": "(B) 強連通分量 (Strongly Connected Component, SCC)",
        "en": "(B) Strongly Connected Component (SCC)",
        "wg": [
          {
            "t": "強連通分量",
            "en": "Strongly Connected Component",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 拓撲排序 (Topological Sort)",
        "en": "(C) Topological Sort",
        "wg": []
      },
      {
        "t": "(D) 歐拉路徑 (Eulerian Path)",
        "en": "(D) Eulerian Path",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "強連通分量 (SCC) 是有向圖中的一個最大子圖，其中任意兩個節點都可以互相到達。這正符合循環依賴的定義（A 依賴 B，B 依賴 ... 依賴 A）。拓撲排序只能應用於無環圖 (DAG)，若有循環依賴則無法進行。",
      "en": "A Strongly Connected Component (SCC) is a maximal subgraph in a directed graph where every pair of nodes is mutually reachable. This fits the definition of circular dependencies (A depends on B, B depends on ... depends on A). Topological Sort can only be applied to Directed Acyclic Graphs (DAGs) and fails if circular dependencies exist.",
      "wg": [
        {
          "t": "互相到達",
          "en": "mutually reachable",
          "ps": "Adj"
        },
        {
          "t": "無環圖",
          "en": "acyclic graph",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Network Flow, Max-Flow Min-Cut, Bottleneck",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "根據最大流最小割定理 (Max-Flow Min-Cut Theorem)，在一個流網路中，從源點 (Source) 到匯點 (Sink) 的最大流量等於什麼？",
        "en": "According to the Max-Flow Min-Cut Theorem, in a flow network, what is the maximum flow from the Source to the Sink equal to?",
        "wg": [
          {
            "t": "最大流最小割定理",
            "en": "Max-Flow Min-Cut Theorem",
            "ps": "N"
          },
          {
            "t": "流網路",
            "en": "flow network",
            "ps": "N"
          },
          {
            "t": "源點",
            "en": "Source",
            "ps": "N"
          },
          {
            "t": "匯點",
            "en": "Sink",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 所有邊容量的總和。",
        "en": "(A) The sum of all edge capacities.",
        "wg": [
          {
            "t": "容量",
            "en": "capacities",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 網路中最小割 (Minimum Cut) 的容量。",
        "en": "(B) The capacity of the Minimum Cut in the network.",
        "wg": [
          {
            "t": "最小割",
            "en": "Minimum Cut",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 從源點出發且容量最大的路徑。",
        "en": "(C) The path with the largest capacity starting from the source.",
        "wg": []
      },
      {
        "t": "(D) 網路中節點數量的總和。",
        "en": "(D) The sum of the number of nodes in the network.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最大流最小割定理指出，一個網路的最大流量 (Max Flow) 恰好等於將源點與匯點分開所需的最小割 (Min Cut) 容量。這意味著系統的流量受限於網路中最窄的瓶頸。",
      "en": "The Max-Flow Min-Cut Theorem states that the maximum flow in a network is exactly equal to the capacity of the minimum cut required to separate the source from the sink. This implies that the system's flow is limited by the narrowest bottleneck in the network.",
      "wg": [
        {
          "t": "恰好等於",
          "en": "exactly equal to",
          "ps": "Phr"
        },
        {
          "t": "瓶頸",
          "en": "bottleneck",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "1",
    "level": "hard",
    "keywords": "Network Flow, Max-Flow Min-Cut, Ford-Fulkerson",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "根據最大流最小割定理 (Max-Flow Min-Cut Theorem)，在一個流網絡中，從源點 (Source) 到匯點 (Sink) 的最大流量等於什麼？",
        "en": "According to the Max-Flow Min-Cut Theorem, in a flow network, what is the maximum flow from the Source to the Sink equal to?",
        "wg": [
          {
            "t": "最大流最小割定理",
            "en": "Max-Flow Min-Cut Theorem",
            "ps": "Proper Noun"
          },
          {
            "t": "流網絡",
            "en": "flow network",
            "ps": "N"
          },
          {
            "t": "匯點",
            "en": "Sink",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 所有邊容量的總和。",
        "en": "(A) The sum of the capacities of all edges.",
        "wg": []
      },
      {
        "t": "(B) 網絡中最小割 (Minimum Cut) 的容量。",
        "en": "(B) The capacity of the minimum cut in the network.",
        "wg": [
          {
            "t": "最小割",
            "en": "minimum cut",
            "ps": "N"
          },
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 連接源點的所有邊的容量總和。",
        "en": "(C) The sum of capacities of all edges connected to the source.",
        "wg": []
      },
      {
        "t": "(D) 網絡中最大割 (Maximum Cut) 的容量。",
        "en": "(D) The capacity of the maximum cut in the network.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "最大流最小割定理指出，一個網絡的最大流量等於將源點與匯點分隔開的所有割切 (Cut) 中容量最小的那個割的容量。這意味著系統的瓶頸決定了最大流量。",
      "en": "The Max-Flow Min-Cut theorem states that the maximum flow of a network is equal to the capacity of the minimum cut that separates the source from the sink. This implies that the bottleneck of the system determines the maximum flow.",
      "wg": [
        {
          "t": "割切",
          "en": "cut",
          "ps": "N"
        },
        {
          "t": "瓶頸",
          "en": "bottleneck",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Bipartite Matching, Graph Modeling, Network Flow",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若要將「二分圖最大匹配」問題轉換為「最大流」問題來求解，",
        "en": "To solve the 'Maximum Bipartite Matching' problem by converting it into a 'Max Flow' problem,",
        "wg": [
          {
            "t": "二分圖",
            "en": "bipartite graph",
            "ps": "N"
          },
          {
            "t": "匹配",
            "en": "matching",
            "ps": "N"
          }
        ]
      },
      {
        "t": "我們通常會新增一個超級源點 (Super Source) 和一個超級匯點 (Super Sink)。",
        "en": "we typically add a Super Source and a Super Sink.",
        "wg": [
          {
            "t": "超級源點",
            "en": "Super Source",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問連接這兩個超級節點到原本二分圖節點的邊，其容量應該設定為多少？",
        "en": "What should be the capacity of the edges connecting these super nodes to the original bipartite graph nodes?",
        "wg": [
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 0",
        "en": "(A) 0",
        "wg": []
      },
      {
        "t": "(B) 1",
        "en": "(B) 1",
        "wg": []
      },
      {
        "t": "(C) 無限大 (Infinity)",
        "en": "(C) Infinity",
        "wg": []
      },
      {
        "t": "(D) 該節點的度數 (Degree)",
        "en": "(D) The degree of the node",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "設定容量為 1 是為了強制每個節點在匹配中只能被使用一次（即一對一匹配）。如果容量大於 1，則一個節點可能會被分配給多個對象，這違反了標準匹配的定義。",
      "en": "Setting the capacity to 1 enforces that each node can only be used once in the matching (i.e., one-to-one matching). If the capacity were greater than 1, a node could be assigned to multiple counterparts, violating the definition of standard matching.",
      "wg": [
        {
          "t": "強制",
          "en": "enforce",
          "ps": "V"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "A* Algorithm, Heuristic, Shortest Path",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在 A* 搜尋演算法中，為了保證找到最短路徑（最佳解），啟發式函數 (Heuristic function) $h(n)$ 必須具備什麼特性？",
        "en": "In the A* search algorithm, to guarantee finding the shortest path (optimal solution), what property must the heuristic function $h(n)$ possess?",
        "wg": [
          {
            "t": "啟發式函數",
            "en": "heuristic function",
            "ps": "N"
          },
          {
            "t": "具備",
            "en": "possess",
            "ps": "V"
          }
        ]
      },
      {
        "t": "假設 $h^*(n)$ 是從節點 $n$ 到目標節點的實際最小成本。",
        "en": "Assume $h^*(n)$ is the actual minimal cost from node $n$ to the goal node.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) $h(n)$ 必須大於 $h^*(n)$ (高估)。",
        "en": "(A) $h(n)$ must be greater than $h^*(n)$ (Overestimation).",
        "wg": [
          {
            "t": "高估",
            "en": "overestimation",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) $h(n)$ 必須小於或等於 $h^*(n)$ (可接受性/Admissibility)。",
        "en": "(B) $h(n)$ must be less than or equal to $h^*(n)$ (Admissibility).",
        "wg": [
          {
            "t": "可接受性",
            "en": "admissibility",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) $h(n)$ 必須完全等於 0。",
        "en": "(C) $h(n)$ must be exactly equal to 0.",
        "wg": []
      },
      {
        "t": "(D) $h(n)$ 的值可以是任意正數。",
        "en": "(D) The value of $h(n)$ can be any positive number.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "若啟發式函數 $h(n)$ 從不「高估」到達目標的成本（即 $h(n) \\le h^*(n)$），則稱該啟發式是「可接受的」(Admissible)。這是 A* 演算法保證能找到最佳路徑的必要條件。",
      "en": "If the heuristic function $h(n)$ never 'overestimates' the cost to reach the goal (i.e., $h(n) \\le h^*(n)$), the heuristic is said to be 'admissible'. This is a necessary condition for the A* algorithm to guarantee finding the optimal path.",
      "wg": [
        {
          "t": "必要條件",
          "en": "necessary condition",
          "ps": "N"
        },
        {
          "t": "最佳路徑",
          "en": "optimal path",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "hard",
    "keywords": "Hamiltonian Cycle, Eulerian Path, NP-Complete, Complexity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "下列哪一個圖論問題屬於 NP-Complete 複雜度類別？",
        "en": "Which of the following graph theory problems belongs to the NP-Complete complexity class?",
        "wg": [
          {
            "t": "複雜度類別",
            "en": "complexity class",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 歐拉迴路問題 (Eulerian Circuit Problem)：尋找一條經過每條邊恰好一次並回到起點的路徑。",
        "en": "(A) Eulerian Circuit Problem: Finding a path that visits every edge exactly once and returns to the start.",
        "wg": [
          {
            "t": "歐拉迴路",
            "en": "Eulerian Circuit",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 最小生成樹問題 (Minimum Spanning Tree)：連接所有頂點且權重總和最小。",
        "en": "(B) Minimum Spanning Tree: Connecting all vertices with the minimum total weight.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 漢米爾頓迴路問題 (Hamiltonian Cycle Problem)：尋找一條經過每個頂點恰好一次並回到起點的路徑。",
        "en": "(C) Hamiltonian Cycle Problem: Finding a path that visits every vertex exactly once and returns to the start.",
        "wg": [
          {
            "t": "漢米爾頓迴路",
            "en": "Hamiltonian Cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 最短路徑問題 (Shortest Path Problem)：在加權圖中尋找兩點間成本最低的路徑。",
        "en": "(D) Shortest Path Problem: Finding the lowest cost path between two points in a weighted graph.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "漢米爾頓迴路問題是著名的 NP-Complete 問題，目前沒有已知的多項式時間演算法可解。相對地，歐拉迴路可透過檢查頂點度數在線性時間內解決，MST 和最短路徑也都有多項式時間的解法（如 Prim 或 Dijkstra）。",
      "en": "The Hamiltonian Cycle problem is a famous NP-Complete problem, with no known polynomial-time algorithm. In contrast, Eulerian Circuits can be solved in linear time by checking vertex degrees, and both MST and Shortest Path problems have polynomial-time solutions (like Prim's or Dijkstra's).",
      "wg": [
        {
          "t": "多項式時間",
          "en": "polynomial time",
          "ps": "N"
        },
        {
          "t": "度數",
          "en": "degree",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Strongly Connected Components, SCC, Directed Graph",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在有向圖 (Directed Graph) 中，若一個子圖被稱為「強連通分量」(Strongly Connected Component, SCC)，它必須滿足什麼條件？",
        "en": "In a Directed Graph, if a subgraph is called a 'Strongly Connected Component' (SCC), what condition must it satisfy?",
        "wg": [
          {
            "t": "有向圖",
            "en": "Directed Graph",
            "ps": "N"
          },
          {
            "t": "強連通分量",
            "en": "Strongly Connected Component",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 該子圖中沒有任何環 (Cycle)。",
        "en": "(A) There are no cycles in the subgraph.",
        "wg": [
          {
            "t": "環",
            "en": "cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 該子圖中的任意兩個節點 $u$ 和 $v$，都存在從 $u$ 到 $v$ 以及從 $v$ 到 $u$ 的路徑。",
        "en": "(B) For any two nodes $u$ and $v$ in the subgraph, there exists a path from $u$ to $v$ and from $v$ to $u$.",
        "wg": [
          {
            "t": "任意",
            "en": "arbitrary/any",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 該子圖是一個樹狀結構 (Tree Structure)。",
        "en": "(C) The subgraph is a tree structure.",
        "wg": []
      },
      {
        "t": "(D) 該子圖的所有邊的權重總和最小。",
        "en": "(D) The sum of the weights of all edges in the subgraph is minimal.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "強連通分量的定義是極大的子圖，其中每一對頂點都是雙向可達的（即彼此連通）。選項 (A) 描述的是 DAG 的特性，而非 SCC。",
      "en": "A Strongly Connected Component is defined as a maximal subgraph where every pair of vertices is mutually reachable (i.e., connected in both directions). Option (A) describes a property of a DAG, not an SCC.",
      "wg": [
        {
          "t": "雙向可達",
          "en": "mutually reachable",
          "ps": "Adj"
        },
        {
          "t": "極大",
          "en": "maximal",
          "ps": "Adj"
        }
      ]
    }
  }
]