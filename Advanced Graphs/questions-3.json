[
  {
    "no": "1",
    "level": "medium",
    "keywords": "Dijkstra, Shortest Path, Negative Weights, Greedy Algorithm",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在尋找加權圖的最短路徑時，為什麼 Dijkstra 演算法不能處理帶有負權重的邊？",
        "en": "When finding the shortest path in a weighted graph, why can't Dijkstra's algorithm handle edges with negative weights?",
        "wg": [
          {
            "t": "加權圖",
            "en": "weighted graph",
            "ps": "N"
          },
          {
            "t": "負權重",
            "en": "negative weights",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請選出最準確描述其演算法限制的原因。",
        "en": "Please select the reason that most accurately describes the limitation of the algorithm.",
        "wg": [
          {
            "t": "限制",
            "en": "limitation",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 負權重會導致演算法陷入無窮迴圈。",
        "en": "(A) Negative weights cause the algorithm to enter an infinite loop.",
        "wg": [
          {
            "t": "無窮迴圈",
            "en": "infinite loop",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) Dijkstra 演算法基於貪婪策略，一旦節點被標記為已訪問，就假設已找到最短路徑，無法透過後續的負邊進行修正。",
        "en": "(B) Dijkstra's algorithm is based on a greedy strategy; once a node is marked as visited, it assumes the shortest path is found and cannot be corrected by subsequent negative edges.",
        "wg": [
          {
            "t": "貪婪策略",
            "en": "greedy strategy",
            "ps": "N"
          },
          {
            "t": "修正",
            "en": "correct",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 優先佇列 (Priority Queue) 不支援負數值的儲存。",
        "en": "(C) The Priority Queue does not support storing negative values.",
        "wg": []
      },
      {
        "t": "(D) 負權重會導致圖形變成非連通圖。",
        "en": "(D) Negative weights cause the graph to become a disconnected graph.",
        "wg": [
          {
            "t": "非連通圖",
            "en": "disconnected graph",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Dijkstra 演算法假設一旦從優先佇列中取出節點（即確定了該點的最短距離），該距離就不會再變短。如果存在負權重邊，可能會有一條經過更多節點但總權重更小的路徑在稍後被發現，這違反了 Dijkstra 的貪婪假設。",
      "en": "Dijkstra's algorithm assumes that once a node is extracted from the priority queue (determining its shortest distance), that distance will not decrease. If negative weight edges exist, a path with more nodes but a lower total weight might be discovered later, violating Dijkstra's greedy assumption.",
      "wg": [
        {
          "t": "優先佇列",
          "en": "priority queue",
          "ps": "N"
        },
        {
          "t": "違反",
          "en": "violate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Bellman-Ford, Negative Cycle, Arbitrage, Relaxation",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在設計一個金融交易系統，需要偵測貨幣匯率中是否存在「套利」機會。",
        "en": "You are designing a financial trading system that needs to detect if 'arbitrage' opportunities exist in currency exchange rates.",
        "wg": [
          {
            "t": "套利",
            "en": "arbitrage",
            "ps": "N"
          },
          {
            "t": "匯率",
            "en": "exchange rates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這可以建模為在圖中尋找負權重環 (Negative Weight Cycle)。",
        "en": "This can be modeled as finding a negative weight cycle in a graph.",
        "wg": [
          {
            "t": "建模",
            "en": "model",
            "ps": "V"
          },
          {
            "t": "負權重環",
            "en": "negative weight cycle",
            "ps": "N"
          }
        ]
      },
      {
        "t": "下列哪一個演算法最適合用來解決此問題？",
        "en": "Which of the following algorithms is best suited to solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) Dijkstra 演算法",
        "en": "(A) Dijkstra's Algorithm",
        "wg": []
      },
      {
        "t": "(B) Prim 演算法",
        "en": "(B) Prim's Algorithm",
        "wg": []
      },
      {
        "t": "(C) Bellman-Ford 演算法",
        "en": "(C) Bellman-Ford Algorithm",
        "wg": []
      },
      {
        "t": "(D) Kruskal 演算法",
        "en": "(D) Kruskal's Algorithm",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "Bellman-Ford 演算法可以處理負權重邊，並且能夠偵測圖中是否存在負權重環。若在進行 V-1 次鬆弛後，仍能進一步縮短路徑距離，則表示存在負環。",
      "en": "The Bellman-Ford algorithm can handle negative weight edges and is capable of detecting negative weight cycles in a graph. If the path distance can still be shortened after V-1 relaxations, it indicates the existence of a negative cycle.",
      "wg": [
        {
          "t": "偵測",
          "en": "detect",
          "ps": "V"
        },
        {
          "t": "鬆弛",
          "en": "relaxation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "hard",
    "keywords": "Floyd-Warshall, All-Pairs Shortest Path, Dynamic Programming",
    "parentNo": null,
    "images": null,
    "codeSnippet": "dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])",
    "question": [
      {
        "t": "Floyd-Warshall 演算法用於解決「所有節點對之間的最短路徑」(All-Pairs Shortest Path) 問題。",
        "en": "The Floyd-Warshall algorithm is used to solve the 'All-Pairs Shortest Path' problem.",
        "wg": [
          {
            "t": "所有節點對",
            "en": "all-pairs",
            "ps": "N"
          }
        ]
      },
      {
        "t": "關於此演算法的特性與核心邏輯，下列敘述何者正確？",
        "en": "Which of the following statements about the characteristics and core logic of this algorithm is correct?",
        "wg": [
          {
            "t": "核心邏輯",
            "en": "core logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它使用貪婪演算法 (Greedy)，時間複雜度為 O(V^2)。",
        "en": "(A) It uses a Greedy algorithm with a time complexity of O(V^2).",
        "wg": []
      },
      {
        "t": "(B) 它是一種動態規劃 (Dynamic Programming) 方法，核心轉移方程式依賴於中繼點 k。",
        "en": "(B) It is a Dynamic Programming approach, where the core transition equation relies on an intermediate node k.",
        "wg": [
          {
            "t": "動態規劃",
            "en": "Dynamic Programming",
            "ps": "N"
          },
          {
            "t": "中繼點",
            "en": "intermediate node",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 它無法處理帶有負權重的邊，即使沒有負環。",
        "en": "(C) It cannot handle edges with negative weights, even if there are no negative cycles.",
        "wg": []
      },
      {
        "t": "(D) 它主要使用遞迴與回溯法 (Backtracking) 來實作。",
        "en": "(D) It is primarily implemented using recursion and backtracking.",
        "wg": [
          {
            "t": "回溯法",
            "en": "backtracking",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "Floyd-Warshall 是典型的動態規劃演算法，其狀態轉移方程式 `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])` 透過嘗試所有可能的中繼點 k 來更新 i 到 j 的最短距離。它的時間複雜度為 O(V^3)。",
      "en": "Floyd-Warshall is a classic Dynamic Programming algorithm. Its state transition equation `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])` updates the shortest distance from i to j by trying all possible intermediate nodes k. Its time complexity is O(V^3).",
      "wg": [
        {
          "t": "狀態轉移方程式",
          "en": "state transition equation",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "medium",
    "keywords": "Kruskal, Union-Find, MST, Disjoint Set",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作 Kruskal 演算法以尋找最小生成樹 (MST) 時，我們會依權重由小到大排序所有邊。",
        "en": "When implementing Kruskal's algorithm to find the Minimum Spanning Tree (MST), we sort all edges by weight in ascending order.",
        "wg": [
          {
            "t": "最小生成樹",
            "en": "Minimum Spanning Tree",
            "ps": "N"
          },
          {
            "t": "由小到大",
            "en": "ascending order",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "為了高效地判斷加入一條邊是否會形成環 (Cycle)，通常會搭配哪種資料結構？",
        "en": "To efficiently determine if adding an edge creates a cycle, which data structure is typically used?",
        "wg": [
          {
            "t": "高效地",
            "en": "efficiently",
            "ps": "Adv"
          },
          {
            "t": "形成環",
            "en": "create a cycle",
            "ps": "VP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 雜湊表 (Hash Map)",
        "en": "(A) Hash Map",
        "wg": []
      },
      {
        "t": "(B) 雙向佇列 (Deque)",
        "en": "(B) Deque",
        "wg": []
      },
      {
        "t": "(C) 並查集 (Disjoint Set / Union-Find)",
        "en": "(C) Disjoint Set / Union-Find",
        "wg": [
          {
            "t": "並查集",
            "en": "Disjoint Set",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 二元搜尋樹 (Binary Search Tree)",
        "en": "(D) Binary Search Tree",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "並查集 (Union-Find) 提供了極高效率的 `find` 和 `union` 操作，能在近乎常數時間內判斷兩個節點是否屬於同一個連通分量，從而判斷加入邊是否會形成環。",
      "en": "Union-Find provides highly efficient `find` and `union` operations, allowing us to determine if two nodes belong to the same connected component in nearly constant time, thereby checking if adding an edge would form a cycle.",
      "wg": [
        {
          "t": "連通分量",
          "en": "connected component",
          "ps": "N"
        },
        {
          "t": "常數時間",
          "en": "constant time",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "A* Search, Heuristic, Pathfinding, Graph Traversal",
    "parentNo": null,
    "images": null,
    "codeSnippet": "f(n) = g(n) + h(n)",
    "question": [
      {
        "t": "A* (A-Star) 搜尋演算法廣泛應用於地圖導航與路徑規劃。",
        "en": "The A* (A-Star) search algorithm is widely used in map navigation and pathfinding.",
        "wg": [
          {
            "t": "路徑規劃",
            "en": "pathfinding",
            "ps": "N"
          }
        ]
      },
      {
        "t": "它改進了 Dijkstra 演算法，引入了啟發式函數 (Heuristic Function) `h(n)`。",
        "en": "It improves upon Dijkstra's algorithm by introducing a heuristic function `h(n)`.",
        "wg": [
          {
            "t": "啟發式函數",
            "en": "heuristic function",
            "ps": "N"
          }
        ]
      },
      {
        "t": "在公式 `f(n) = g(n) + h(n)` 中，`h(n)` 代表什麼意義？",
        "en": "In the formula `f(n) = g(n) + h(n)`, what does `h(n)` represent?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 從起點到目前節點 n 的實際代價。",
        "en": "(A) The actual cost from the start node to the current node n.",
        "wg": [
          {
            "t": "實際代價",
            "en": "actual cost",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 從目前節點 n 到目標節點的預估代價。",
        "en": "(B) The estimated cost from the current node n to the goal node.",
        "wg": [
          {
            "t": "預估代價",
            "en": "estimated cost",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 整條路徑的總權重。",
        "en": "(C) The total weight of the entire path.",
        "wg": []
      },
      {
        "t": "(D) 節點 n 的被訪問次數。",
        "en": "(D) The number of times node n has been visited.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "`g(n)` 是從起點到節點 n 的實際成本，而 `h(n)` 是從節點 n 到終點的預估成本（例如直線距離）。A* 利用 `h(n)` 來引導搜尋方向，使其比 Dijkstra 更快找到目標。",
      "en": "`g(n)` is the actual cost from the start to node n, while `h(n)` is the estimated cost from node n to the goal (e.g., straight-line distance). A* uses `h(n)` to guide the search direction, making it find the target faster than Dijkstra.",
      "wg": [
        {
          "t": "引導",
          "en": "guide",
          "ps": "V"
        },
        {
          "t": "直線距離",
          "en": "straight-line distance",
          "ps": "N"
        }
      ]
    }
  }
]