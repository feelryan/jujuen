[
  {
    "no": "6",
    "level": "medium",
    "keywords": "Binary Search, Lower Bound, Duplicates",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int binarySearchFirst(int[] nums, int target) {\n    int low = 0, high = nums.length - 1;\n    int result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] == target) {\n            result = mid;\n            // ???\n        } else if (nums[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return result;\n}",
    "question": [
      {
        "t": "給定一個包含重複元素的已排序陣列，我們希望找到目標值第一次出現的索引。",
        "en": "Given a sorted array containing duplicate elements, we want to find the index of the first occurrence of a target value.",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "NP"
          },
          {
            "t": "第一次出現",
            "en": "first occurrence",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "在上述程式碼的 `// ???` 處，應該填入什麼邏輯才能達成此目標？",
        "en": "What logic should be filled in at `// ???` in the code above to achieve this goal?",
        "wg": [
          {
            "t": "邏輯",
            "en": "logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) break; (直接終止迴圈)",
        "en": "(A) break; (Terminate the loop immediately)",
        "wg": []
      },
      {
        "t": "(B) low = mid + 1; (繼續向右搜尋)",
        "en": "(B) low = mid + 1; (Continue searching to the right)",
        "wg": []
      },
      {
        "t": "(C) high = mid - 1; (繼續向左搜尋)",
        "en": "(C) high = mid - 1; (Continue searching to the left)",
        "wg": []
      },
      {
        "t": "(D) return mid; (直接回傳索引)",
        "en": "(D) return mid; (Return the index immediately)",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當找到目標值時，因為要找的是「第一次」出現的位置，可能左邊還有相同的目標值，因此必須縮小右邊界 (`high = mid - 1`) 繼續往左半部搜尋。",
      "en": "When the target value is found, since we are looking for the 'first' occurrence, there might be identical target values to the left, so we must shrink the right boundary (`high = mid - 1`) and continue searching in the left half.",
      "wg": [
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        },
        {
          "t": "左半部",
          "en": "left half",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "easy",
    "keywords": "Binary Search, Integer Overflow, Best Practices",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在實作二分搜尋法計算中間索引 `mid` 時，為什麼通常建議使用 `mid = low + (high - low) / 2` 而非 `mid = (low + high) / 2`？",
        "en": "When implementing Binary Search to calculate the middle index `mid`, why is it generally recommended to use `mid = low + (high - low) / 2` instead of `mid = (low + high) / 2`?",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "中間索引",
            "en": "middle index",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前者的運算速度比後者快。",
        "en": "(A) The former is computationally faster than the latter.",
        "wg": [
          {
            "t": "運算速度",
            "en": "computational speed",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 前者可以避免當 `low` 和 `high` 都很大時發生整數溢位 (Integer Overflow)。",
        "en": "(B) The former avoids Integer Overflow when both `low` and `high` are very large.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(C) 後者在處理負數索引時會發生錯誤。",
        "en": "(C) The latter causes errors when handling negative indices.",
        "wg": []
      },
      {
        "t": "(D) 兩者完全相同，只是寫法風格不同。",
        "en": "(D) Both are exactly the same, just different coding styles.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `low` 和 `high` 都是接近整數最大值的大數時，`(low + high)` 的結果可能會超過整數型別的上限而導致溢位變成負數，造成程式崩潰或邏輯錯誤；使用 `low + (high - low) / 2` 則能確保計算過程在安全範圍內。",
      "en": "When both `low` and `high` are large numbers close to the maximum integer value, the result of `(low + high)` may exceed the limit of the integer type, causing an overflow to a negative number, leading to a crash or logic error; using `low + (high - low) / 2` ensures the calculation stays within a safe range.",
      "wg": [
        {
          "t": "上限",
          "en": "limit",
          "ps": "N"
        },
        {
          "t": "崩潰",
          "en": "crash",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "medium",
    "keywords": "Binary Search, Search Insert Position, Return Value",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int searchInsert(int[] nums, int target) {\n    int low = 0, high = nums.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] < target) low = mid + 1;\n        else high = mid - 1;\n    }\n    return low;\n}",
    "question": [
      {
        "t": "給定一個排序陣列 `[1, 3, 5, 6]` 與目標值 `2`，執行上述 `searchInsert` 函式。",
        "en": "Given a sorted array `[1, 3, 5, 6]` and a target value `2`, execute the `searchInsert` function above.",
        "wg": []
      },
      {
        "t": "請問函式最後回傳的值是多少，且該值代表什麼意義？",
        "en": "What is the final value returned by the function, and what does that value represent?",
        "wg": [
          {
            "t": "回傳",
            "en": "return",
            "ps": "V"
          },
          {
            "t": "意義",
            "en": "significance/meaning",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 回傳 0，代表目標值小於陣列中所有元素。",
        "en": "(A) Returns 0, representing the target is smaller than all elements.",
        "wg": []
      },
      {
        "t": "(B) 回傳 1，代表若要將目標值插入陣列並保持排序，應插入在索引 1 的位置。",
        "en": "(B) Returns 1, representing that if the target were inserted while maintaining order, it should be at index 1.",
        "wg": [
          {
            "t": "插入",
            "en": "insert",
            "ps": "V"
          },
          {
            "t": "保持排序",
            "en": "maintain order",
            "ps": "VP"
          }
        ]
      },
      {
        "t": "(C) 回傳 2，代表目標值最接近索引 2 的元素。",
        "en": "(C) Returns 2, representing the target is closest to the element at index 2.",
        "wg": []
      },
      {
        "t": "(D) 回傳 -1，代表找不到目標值。",
        "en": "(D) Returns -1, representing the target was not found.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當迴圈結束時，`low` 指標會停在「第一個大於或等於目標值」的元素索引位置，這正是目標值應該被插入的位置以維持排序順序。",
      "en": "When the loop terminates, the `low` pointer stops at the index of the 'first element greater than or equal to the target', which is exactly the position where the target should be inserted to maintain the sorted order.",
      "wg": [
        {
          "t": "指標",
          "en": "pointer",
          "ps": "N"
        },
        {
          "t": "維持",
          "en": "maintain",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Binary Search, Answer Space, Square Root",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二分搜尋法不僅能用於陣列搜尋，也能用於「搜尋答案空間」。",
        "en": "Binary Search can be used not only for array searching but also for 'searching the answer space'.",
        "wg": [
          {
            "t": "答案空間",
            "en": "answer space",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "若要計算一個非負整數 `x` 的整數平方根（例如 `sqrt(8) = 2`），下列哪種二分搜尋策略是正確的？",
        "en": "To calculate the integer square root of a non-negative integer `x` (e.g., `sqrt(8) = 2`), which of the following Binary Search strategies is correct?",
        "wg": [
          {
            "t": "非負整數",
            "en": "non-negative integer",
            "ps": "NP"
          },
          {
            "t": "平方根",
            "en": "square root",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 在 `0` 到 `x` 的範圍內搜尋，若 `mid * mid <= x`，則嘗試更大的值（往右找），並暫存 `mid` 為可能的答案。",
        "en": "(A) Search within the range `0` to `x`. If `mid * mid <= x`, try larger values (search right) and store `mid` as a possible answer.",
        "wg": [
          {
            "t": "暫存",
            "en": "store/cache",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 在 `0` 到 `x` 的範圍內搜尋，若 `mid * mid > x`，則嘗試更大的值（往右找）。",
        "en": "(B) Search within the range `0` to `x`. If `mid * mid > x`, try larger values (search right).",
        "wg": []
      },
      {
        "t": "(C) 搜尋範圍必須是 `0` 到 `x/2`，否則效率太低。",
        "en": "(C) The search range must be `0` to `x/2`, otherwise efficiency is too low.",
        "wg": []
      },
      {
        "t": "(D) 二分搜尋法無法處理非陣列的問題。",
        "en": "(D) Binary Search cannot handle non-array problems.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "我們要找的是滿足 `k^2 <= x` 的最大整數 `k`。當 `mid * mid <= x` 時，`mid` 可能是答案，但也許還有更大的數滿足條件，因此先記錄 `mid` 並將 `low` 設為 `mid + 1` 繼續往右搜尋。",
      "en": "We are looking for the largest integer `k` such that `k^2 <= x`. When `mid * mid <= x`, `mid` is a potential answer, but there might be a larger number that satisfies the condition, so we record `mid` and set `low` to `mid + 1` to continue searching to the right.",
      "wg": [
        {
          "t": "滿足",
          "en": "satisfy",
          "ps": "V"
        },
        {
          "t": "條件",
          "en": "condition",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Binary Search, Peak Index, Mountain Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (low < high) {\n    int mid = low + (high - low) / 2;\n    if (nums[mid] < nums[mid + 1]) {\n        low = mid + 1;\n    } else {\n        high = mid;\n    }\n}",
    "question": [
      {
        "t": "給定一個「山脈陣列」（先遞增後遞減），我們使用上述程式碼來尋找峰值（最大值）的索引。",
        "en": "Given a 'Mountain Array' (increases then decreases), we use the code above to find the index of the peak (maximum value).",
        "wg": [
          {
            "t": "山脈陣列",
            "en": "Mountain Array",
            "ps": "NP"
          },
          {
            "t": "遞增",
            "en": "increase",
            "ps": "V"
          },
          {
            "t": "遞減",
            "en": "decrease",
            "ps": "V"
          },
          {
            "t": "峰值",
            "en": "peak",
            "ps": "N"
          }
        ]
      },
      {
        "t": "為什麼當 `nums[mid] < nums[mid + 1]` 時，我們可以確定峰值一定在 `mid` 的右側？",
        "en": "Why can we be certain that the peak is to the right of `mid` when `nums[mid] < nums[mid + 1]`?",
        "wg": [
          {
            "t": "確定",
            "en": "certain/determine",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為這表示我們目前處於「下坡」階段。",
        "en": "(A) Because this indicates we are currently in the 'downhill' phase.",
        "wg": [
          {
            "t": "下坡",
            "en": "downhill",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 因為這表示我們目前處於「上坡」階段，峰值尚未到達。",
        "en": "(B) Because this indicates we are currently in the 'uphill' phase, and the peak has not been reached yet.",
        "wg": [
          {
            "t": "上坡",
            "en": "uphill",
            "ps": "N"
          },
          {
            "t": "尚未",
            "en": "not yet",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(C) 因為 `mid` 索引總是比 `mid + 1` 小。",
        "en": "(C) Because the index `mid` is always smaller than `mid + 1`.",
        "wg": []
      },
      {
        "t": "(D) 這是錯誤的判斷，峰值可能在左側。",
        "en": "(D) This is an incorrect judgment; the peak could be on the left.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在山脈陣列中，若右邊的元素比當前元素大 (`nums[mid] < nums[mid+1]`)，代表目前的趨勢是上升的，因此最高點（峰值）必然位於當前位置的右方。",
      "en": "In a mountain array, if the element to the right is larger than the current element (`nums[mid] < nums[mid+1]`), it implies an upward trend, so the highest point (peak) must be located to the right of the current position.",
      "wg": [
        {
          "t": "趨勢",
          "en": "trend",
          "ps": "N"
        },
        {
          "t": "必然",
          "en": "inevitably/must",
          "ps": "Adv"
        }
      ]
    }
  }
]