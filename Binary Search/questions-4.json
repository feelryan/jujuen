[
  {
    "no": "16",
    "level": "hard",
    "keywords": "Binary Search on Answer, Optimization, Split Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "low = max(nums)\nhigh = sum(nums)\nwhile low < high:\n    mid = (low + high) // 2\n    if can_split(mid, m):\n        high = mid\n    else:\n        low = mid + 1",
    "question": [
      {
        "t": "這是一個關於「對答案進行二分搜尋」的經典應用。",
        "en": "This is a classic application of 'Binary Search on Answer'.",
        "wg": [
          {
            "t": "對答案進行二分搜尋",
            "en": "Binary Search on Answer",
            "ps": "Phrase"
          }
        ]
      },
      {
        "t": "題目要求將一個非負整數陣列分割成 m 個連續子陣列，目標是讓這些子陣列中「總和最大」的那個值越小越好。",
        "en": "The problem asks to split an array of non-negative integers into m contiguous subarrays, with the goal of minimizing the largest sum among these subarrays.",
        "wg": [
          {
            "t": "連續子陣列",
            "en": "contiguous subarrays",
            "ps": "N"
          },
          {
            "t": "總和最大",
            "en": "largest sum",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "請問在此演算法中，二分搜尋的「搜尋空間」範圍應該如何定義？",
        "en": "How should the 'search space' range for the binary search be defined in this algorithm?",
        "wg": [
          {
            "t": "搜尋空間",
            "en": "search space",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) [0, 陣列長度]",
        "en": "(A) [0, Array Length]",
        "wg": []
      },
      {
        "t": "(B) [陣列中的最小值, 陣列中的最大值]",
        "en": "(B) [Minimum value in array, Maximum value in array]",
        "wg": []
      },
      {
        "t": "(C) [陣列中的最大值, 陣列所有元素總和]",
        "en": "(C) [Maximum value in array, Sum of all elements in array]",
        "wg": []
      },
      {
        "t": "(D) [0, Integer.MAX_VALUE]",
        "en": "(D) [0, Integer.MAX_VALUE]",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "子陣列至少包含一個元素，因此最大總和不可能小於陣列中的單一最大元素（下界）；而當 m=1 時，子陣列即為整個陣列，最大總和為所有元素之和（上界）。",
      "en": "A subarray must contain at least one element, so the largest sum cannot be smaller than the single maximum element in the array (lower bound); when m=1, the subarray is the entire array, so the largest sum is the total sum of all elements (upper bound).",
      "wg": [
        {
          "t": "下界",
          "en": "lower bound",
          "ps": "N"
        },
        {
          "t": "上界",
          "en": "upper bound",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "medium",
    "keywords": "Rotated Sorted Array, Duplicates, Worst Case",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if nums[left] == nums[mid] and nums[mid] == nums[right]:\n    left += 1\n    right -= 1",
    "question": [
      {
        "t": "在「包含重複元素」的旋轉排序陣列中搜尋目標值（例如：`[1, 0, 1, 1, 1]`），我們通常需要處理 `nums[left] == nums[mid] == nums[right]` 的情況。",
        "en": "When searching for a target in a 'rotated sorted array with duplicates' (e.g., `[1, 0, 1, 1, 1]`), we often need to handle the case where `nums[left] == nums[mid] == nums[right]`.",
        "wg": [
          {
            "t": "旋轉排序陣列",
            "en": "rotated sorted array",
            "ps": "NP"
          },
          {
            "t": "重複元素",
            "en": "duplicates",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這種情況會導致演算法的最差時間複雜度退化成什麼？",
        "en": "What does the worst-case time complexity of the algorithm degenerate to in this scenario?",
        "wg": [
          {
            "t": "退化",
            "en": "degenerate",
            "ps": "V"
          },
          {
            "t": "最差時間複雜度",
            "en": "worst-case time complexity",
            "ps": "NP"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(log N)",
        "en": "(A) O(log N)",
        "wg": []
      },
      {
        "t": "(B) O(N)",
        "en": "(B) O(N)",
        "wg": []
      },
      {
        "t": "(C) O(N log N)",
        "en": "(C) O(N log N)",
        "wg": []
      },
      {
        "t": "(D) O(1)",
        "en": "(D) O(1)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當左、中、右三個位置的值相同時，我們無法利用二分法的單調性判斷哪一邊是有序的，只能將左右邊界向內縮減一步。",
      "en": "When the values at the left, middle, and right are the same, we cannot use the monotonicity of binary search to determine which side is sorted, so we can only shrink the left and right boundaries inward by one step.",
      "wg": [
        {
          "t": "單調性",
          "en": "monotonicity",
          "ps": "N"
        },
        {
          "t": "縮減",
          "en": "shrink",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "hard",
    "keywords": "Median, Partitioning, Two Pointers",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "要在兩個已排序陣列 `nums1` 和 `nums2` 中找出中位數，且時間複雜度限制為 O(log(min(m, n)))，我們需要對較短的陣列進行二分搜尋以找到正確的「分割點」。",
        "en": "To find the median of two sorted arrays `nums1` and `nums2` with a time complexity limit of O(log(min(m, n))), we need to perform binary search on the shorter array to find the correct 'partition'.",
        "wg": [
          {
            "t": "中位數",
            "en": "median",
            "ps": "N"
          },
          {
            "t": "分割點",
            "en": "partition",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設我們將兩個陣列分別切成左右兩部分：`L1, R1` 與 `L2, R2`。",
        "en": "Assume we cut both arrays into left and right parts: `L1, R1` and `L2, R2`.",
        "wg": []
      },
      {
        "t": "下列哪一個條件代表我們找到了合法的分割，使得左半部所有元素皆小於等於右半部所有元素？",
        "en": "Which of the following conditions indicates that we have found a valid partition such that all elements in the left half are less than or equal to all elements in the right half?",
        "wg": [
          {
            "t": "合法的",
            "en": "valid",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) L1 <= R1 且 L2 <= R2",
        "en": "(A) L1 <= R1 and L2 <= R2",
        "wg": []
      },
      {
        "t": "(B) L1 <= R2 且 L2 <= R1",
        "en": "(B) L1 <= R2 and L2 <= R1",
        "wg": []
      },
      {
        "t": "(C) L1 == L2 且 R1 == R2",
        "en": "(C) L1 == L2 and R1 == R2",
        "wg": []
      },
      {
        "t": "(D) R1 > L2 且 R2 > L1",
        "en": "(D) R1 > L2 and R2 > L1",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "陣列本身已排序，故 `L1 <= R1` 與 `L2 <= R2` 恆成立；關鍵在於交叉比較，必須確保 `nums1` 的左半部不大於 `nums2` 的右半部，且 `nums2` 的左半部不大於 `nums1` 的右半部。",
      "en": "The arrays are already sorted, so `L1 <= R1` and `L2 <= R2` are always true; the key is the cross-comparison, ensuring that the left half of `nums1` is not greater than the right half of `nums2`, and the left half of `nums2` is not greater than the right half of `nums1`.",
      "wg": [
        {
          "t": "交叉比較",
          "en": "cross-comparison",
          "ps": "N"
        },
        {
          "t": "恆成立",
          "en": "always true",
          "ps": "Phrase"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "medium",
    "keywords": "Matrix, Kth Smallest, Value Range",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個 $N \\times N$ 的矩陣，其中每一列 (row) 和每一行 (column) 都是升序排列。",
        "en": "Given an $N \\times N$ matrix where each row and each column is sorted in ascending order.",
        "wg": [
          {
            "t": "升序排列",
            "en": "sorted in ascending order",
            "ps": "Phrase"
          }
        ]
      },
      {
        "t": "若要找出矩陣中第 K 小的元素，使用二分搜尋法的最佳策略是針對什麼進行搜尋？",
        "en": "To find the Kth smallest element in the matrix, what is the best strategy for binary search to target?",
        "wg": [
          {
            "t": "策略",
            "en": "strategy",
            "ps": "N"
          }
        ]
      },
      {
        "t": "並請選出該策略對應的 `check(mid)` 邏輯。",
        "en": "And please select the corresponding `check(mid)` logic for that strategy.",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 對「矩陣索引 (Index)」搜尋；計算 mid 位置的值是否為第 K 小。",
        "en": "(A) Search on 'Matrix Index'; calculate if the value at mid position is the Kth smallest.",
        "wg": []
      },
      {
        "t": "(B) 對「數值範圍 (Value Range)」搜尋；計算矩陣中有多少個元素小於等於 mid。",
        "en": "(B) Search on 'Value Range'; calculate how many elements in the matrix are less than or equal to mid.",
        "wg": [
          {
            "t": "數值範圍",
            "en": "value range",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 對「對角線元素」搜尋；檢查對角線上第 mid 個元素。",
        "en": "(C) Search on 'Diagonal Elements'; check the mid-th element on the diagonal.",
        "wg": []
      },
      {
        "t": "(D) 將矩陣攤平成一維陣列後進行標準二分搜尋。",
        "en": "(D) Flatten the matrix into a 1D array and perform standard binary search.",
        "wg": [
          {
            "t": "攤平",
            "en": "flatten",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "矩陣索引並無全域順序性，無法直接對索引二分。正確做法是對數值範圍 [min, max] 進行二分，每次計算「小於等於 mid 的元素個數」是否達到 K，利用矩陣行列排序的特性，計數過程可優化至 O(N)。",
      "en": "Matrix indices do not have a global order, so binary search on indices is not possible. The correct approach is to binary search on the value range [min, max], checking if the 'count of elements less than or equal to mid' reaches K. Due to the sorted rows and columns, the counting process can be optimized to O(N).",
      "wg": [
        {
          "t": "全域順序性",
          "en": "global order",
          "ps": "NP"
        },
        {
          "t": "優化",
          "en": "optimize",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Lower Bound, Upper Bound, Library",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [10, 20, 20, 20, 30]\ntarget = 20",
    "question": [
      {
        "t": "在實作二分搜尋或使用標準函式庫時，區分 `lower_bound` 與 `upper_bound` 的行為非常重要。",
        "en": "When implementing binary search or using standard libraries, it is crucial to distinguish the behavior of `lower_bound` and `upper_bound`.",
        "wg": [
          {
            "t": "標準函式庫",
            "en": "standard libraries",
            "ps": "N"
          },
          {
            "t": "區分",
            "en": "distinguish",
            "ps": "V"
          }
        ]
      },
      {
        "t": "給定排序陣列 `[10, 20, 20, 20, 30]` 與目標值 `20`。",
        "en": "Given the sorted array `[10, 20, 20, 20, 30]` and target value `20`.",
        "wg": []
      },
      {
        "t": "請問尋找「第一個大於等於 target 的位置」與「第一個大於 target 的位置」分別會得到哪個索引值 (0-based)？",
        "en": "What are the 0-based indices returned for finding 'the first position greater than or equal to target' and 'the first position greater than target', respectively?",
        "wg": [
          {
            "t": "索引值",
            "en": "indices",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 1 和 3",
        "en": "(A) 1 and 3",
        "wg": []
      },
      {
        "t": "(B) 1 和 4",
        "en": "(B) 1 and 4",
        "wg": []
      },
      {
        "t": "(C) 2 和 4",
        "en": "(C) 2 and 4",
        "wg": []
      },
      {
        "t": "(D) 1 和 5",
        "en": "(D) 1 and 5",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "第一個 `>= 20` 的位置是索引 1 (第一個 20)；第一個 `> 20` 的位置是索引 4 (數值 30)。這是計算重複元素範圍長度的基礎 (4 - 1 = 3 個)。",
      "en": "The first position `>= 20` is index 1 (the first 20); the first position `> 20` is index 4 (value 30). This is the basis for calculating the range length of duplicate elements (4 - 1 = 3 elements).",
      "wg": [
        {
          "t": "重複元素",
          "en": "duplicate elements",
          "ps": "N"
        }
      ]
    }
  }
]