[
  {
    "no": "1",
    "level": "Easy",
    "keywords": "Binary Search, Prerequisites, Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二分搜尋法 (Binary Search) 是一種高效的搜尋演算法，但它對輸入資料有一個嚴格的前提條件。",
        "en": "Binary Search is an efficient search algorithm, but it has a strict prerequisite for the input data.",
        "wg": [
          {
            "t": "前提條件",
            "en": "prerequisite",
            "ps": "N"
          },
          {
            "t": "嚴格的",
            "en": "strict",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "下列哪種情況最適合直接使用二分搜尋法？",
        "en": "Which of the following scenarios is most suitable for directly applying Binary Search?",
        "wg": [
          {
            "t": "直接",
            "en": "directly",
            "ps": "Adv"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 一個未排序的整數陣列。",
        "en": "(A) An unsorted array of integers.",
        "wg": [
          {
            "t": "未排序的",
            "en": "unsorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 一個已排序的單向連結串列 (Singly Linked List)。",
        "en": "(B) A sorted Singly Linked List.",
        "wg": [
          {
            "t": "單向連結串列",
            "en": "Singly Linked List",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 一個已排序的陣列 (Array)。",
        "en": "(C) A sorted Array.",
        "wg": []
      },
      {
        "t": "(D) 一個雜湊表 (Hash Map)。",
        "en": "(D) A Hash Map.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "二分搜尋法依賴隨機存取 (Random Access) 特性來在 O(1) 時間內取得中間元素，且資料必須是有序的。",
      "en": "Binary Search relies on Random Access to retrieve the middle element in O(1) time, and the data must be sorted.",
      "wg": [
        {
          "t": "隨機存取",
          "en": "Random Access",
          "ps": "N"
        },
        {
          "t": "有序的",
          "en": "sorted/ordered",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "Easy",
    "keywords": "Time Complexity, Big O, Efficiency",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "假設有一個包含 N 個元素的已排序陣列。",
        "en": "Assume there is a sorted array containing N elements.",
        "wg": []
      },
      {
        "t": "在最壞的情況下 (Worst Case)，二分搜尋法的時間複雜度是多少？",
        "en": "What is the time complexity of Binary Search in the worst case?",
        "wg": [
          {
            "t": "最壞的情況",
            "en": "worst case",
            "ps": "N"
          },
          {
            "t": "時間複雜度",
            "en": "time complexity",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) O(1)",
        "en": "(A) O(1)",
        "wg": []
      },
      {
        "t": "(B) O(log N)",
        "en": "(B) O(log N)",
        "wg": []
      },
      {
        "t": "(C) O(N)",
        "en": "(C) O(N)",
        "wg": []
      },
      {
        "t": "(D) O(N log N)",
        "en": "(D) O(N log N)",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二分搜尋法每次比較後都會將搜尋範圍減半，因此所需的步驟數與 N 的對數成正比。",
      "en": "Binary Search halves the search space after each comparison, so the number of steps required is proportional to the logarithm of N.",
      "wg": [
        {
          "t": "減半",
          "en": "halve",
          "ps": "V"
        },
        {
          "t": "成正比",
          "en": "proportional to",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "Medium",
    "keywords": "Implementation, Integer Overflow, Best Practice",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = (left + right) / 2;",
    "question": [
      {
        "t": "在實作二分搜尋法計算中間索引 `mid` 時，許多教科書或舊程式碼會使用上述寫法。",
        "en": "When implementing Binary Search to calculate the middle index `mid`, many textbooks or legacy codes use the snippet above.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "中間索引",
            "en": "middle index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "然而，在處理極大的陣列索引時，這行程式碼可能會導致嚴重的錯誤。",
        "en": "However, when dealing with extremely large array indices, this line of code can lead to a serious bug.",
        "wg": [
          {
            "t": "極大的",
            "en": "extremely large",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "請問這個潛在的錯誤是什麼，以及應該如何修正？",
        "en": "What is this potential bug, and how should it be fixed?",
        "wg": [
          {
            "t": "潛在的",
            "en": "potential",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 浮點數誤差；應改用 `floor((left + right) / 2)`。",
        "en": "(A) Floating point error; should change to `floor((left + right) / 2)`.",
        "wg": [
          {
            "t": "浮點數誤差",
            "en": "floating point error",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 整數溢位 (Integer Overflow)；應改用 `left + (right - left) / 2`。",
        "en": "(B) Integer Overflow; should change to `left + (right - left) / 2`.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 記憶體洩漏 (Memory Leak)；應釋放 `mid` 變數。",
        "en": "(C) Memory Leak; should free the `mid` variable.",
        "wg": [
          {
            "t": "記憶體洩漏",
            "en": "Memory Leak",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 邏輯錯誤；應改用 `(left - right) / 2`。",
        "en": "(D) Logic error; should change to `(left - right) / 2`.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `left` 和 `right` 都很大時，`left + right` 的結果可能會超過整數型別的最大值 (如 INT_MAX)，導致溢位變成負數。",
      "en": "When both `left` and `right` are large, the result of `left + right` might exceed the maximum value of the integer type (e.g., INT_MAX), causing an overflow to a negative number.",
      "wg": [
        {
          "t": "整數型別",
          "en": "integer type",
          "ps": "N"
        },
        {
          "t": "超過",
          "en": "exceed",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "Medium",
    "keywords": "Loop Condition, Boundary Check, Algorithm Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int left = 0, right = nums.length - 1;\nwhile (______) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) return mid;\n    else if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n}\nreturn -1;",
    "question": [
      {
        "t": "您正在撰寫一個標準的二分搜尋法來尋找目標值 `target` 的確切位置。",
        "en": "You are writing a standard Binary Search to find the exact position of a `target` value.",
        "wg": [
          {
            "t": "確切位置",
            "en": "exact position",
            "ps": "N"
          }
        ]
      },
      {
        "t": "搜尋區間定義為閉區間 `[left, right]`。",
        "en": "The search interval is defined as a closed interval `[left, right]`.",
        "wg": [
          {
            "t": "閉區間",
            "en": "closed interval",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問 `while` 迴圈的條件應該填入什麼，才能確保所有元素都被檢查到？",
        "en": "What should be filled in the `while` loop condition to ensure all elements are checked?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) left < right",
        "en": "(A) left < right",
        "wg": []
      },
      {
        "t": "(B) left <= right",
        "en": "(B) left <= right",
        "wg": []
      },
      {
        "t": "(C) left != right",
        "en": "(C) left != right",
        "wg": []
      },
      {
        "t": "(D) left + 1 < right",
        "en": "(D) left + 1 < right",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當區間縮小到只剩一個元素時 (即 `left == right`)，該元素仍然需要被檢查。",
      "en": "When the interval shrinks to a single element (i.e., `left == right`), that element still needs to be checked.",
      "wg": [
        {
          "t": "縮小",
          "en": "shrink",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "Medium",
    "keywords": "Duplicates, Lower Bound, Algorithm Variation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (nums[mid] == target) {\n    // What should happen here?\n}",
    "question": [
      {
        "t": "給定一個包含重複元素的已排序陣列，您希望找到目標值 `target` **第一次出現**的索引位置。",
        "en": "Given a sorted array containing duplicate elements, you want to find the index of the **first occurrence** of the `target` value.",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "N"
          },
          {
            "t": "第一次出現",
            "en": "first occurrence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 `nums[mid] == target` 時，為了確保找到最左邊的目標值，應該執行下列哪個動作？",
        "en": "When `nums[mid] == target`, what action should be taken to ensure finding the leftmost target value?",
        "wg": [
          {
            "t": "最左邊的",
            "en": "leftmost",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接回傳 `mid`，因為已經找到目標值。",
        "en": "(A) Return `mid` immediately because the target has been found.",
        "wg": []
      },
      {
        "t": "(B) 設定 `left = mid + 1`，繼續往右邊搜尋。",
        "en": "(B) Set `left = mid + 1` and continue searching to the right.",
        "wg": []
      },
      {
        "t": "(C) 設定 `right = mid - 1`，繼續往左邊搜尋。",
        "en": "(C) Set `right = mid - 1` and continue searching to the left.",
        "wg": []
      },
      {
        "t": "(D) 停止迴圈並回傳 -1。",
        "en": "(D) Stop the loop and return -1.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "為了找到第一次出現的位置，即使找到了目標值，我們仍不能確定它是否是第一個，因此必須縮小右邊界以檢查左半部分是否有更早出現的目標值。",
      "en": "To find the first occurrence, even if the target is found, we cannot be sure it is the first one, so we must shrink the right boundary to check the left half for any earlier occurrences.",
      "wg": [
        {
          "t": "縮小",
          "en": "shrink",
          "ps": "V"
        },
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "6",
    "level": "medium",
    "keywords": "Integer Overflow, Implementation, Best Practice",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = (left + right) / 2;",
    "question": [
      {
        "t": "在實作二分搜尋法時，使用上述程式碼來計算中間索引 (mid) 是一個常見的錯誤。",
        "en": "When implementing Binary Search, using the code above to calculate the middle index (mid) is a common mistake.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          },
          {
            "t": "中間索引",
            "en": "middle index",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請問這個寫法潛在的問題是什麼？以及該如何修正？",
        "en": "What is the potential issue with this approach, and how should it be fixed?",
        "wg": [
          {
            "t": "潛在的",
            "en": "potential",
            "ps": "Adj"
          },
          {
            "t": "修正",
            "en": "fix",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 會造成編譯錯誤；應改為 `mid = (left + right) >> 1`。",
        "en": "(A) It causes a compilation error; change it to `mid = (left + right) >> 1`.",
        "wg": []
      },
      {
        "t": "(B) 當 `left` 和 `right` 都很大時，相加可能導致整數溢位 (Integer Overflow)；應改為 `mid = left + (right - left) / 2`。",
        "en": "(B) When `left` and `right` are both large, adding them may cause Integer Overflow; change it to `mid = left + (right - left) / 2`.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 除法運算效率太低；應改為 `mid = (left + right) * 0.5`。",
        "en": "(C) Division operations are too inefficient; change it to `mid = (left + right) * 0.5`.",
        "wg": []
      },
      {
        "t": "(D) 邏輯上沒有問題，這是標準寫法。",
        "en": "(D) There is no logical issue; this is the standard approach.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在強型別語言 (如 C++ 或 Java) 中，`left + right` 的結果若超過整數最大值 (MAX_INT)，會發生溢位變成負數，導致程式崩潰或邏輯錯誤。`left + (right - left) / 2` 透過先減後加的方式避免了這個問題。",
      "en": "In strongly typed languages (like C++ or Java), if the result of `left + right` exceeds the maximum integer value (MAX_INT), it overflows and becomes negative, causing crashes or logic errors. `left + (right - left) / 2` avoids this by subtracting before adding.",
      "wg": [
        {
          "t": "強型別",
          "en": "strongly typed",
          "ps": "Adj"
        },
        {
          "t": "崩潰",
          "en": "crash",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "7",
    "level": "medium",
    "keywords": "Duplicates, Lower Bound, Algorithm Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, 3, 3, 3, 5], target = 3",
    "question": [
      {
        "t": "給定一個包含重複元素的已排序陣列，如上所示。",
        "en": "Given a sorted array containing duplicate elements, as shown above.",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若我們希望二分搜尋法能找到目標值 `3` 第一次出現的位置 (索引 1)，",
        "en": "If we want Binary Search to find the first occurrence of the target value `3` (index 1),",
        "wg": [
          {
            "t": "第一次出現",
            "en": "first occurrence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "當 `nums[mid] == target` 時，演算法應該如何調整 `left` 或 `right` 指標？",
        "en": "how should the algorithm adjust the `left` or `right` pointers when `nums[mid] == target`?",
        "wg": [
          {
            "t": "指標",
            "en": "pointer",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接回傳 `mid`，因為已經找到目標值。",
        "en": "(A) Return `mid` immediately because the target value has been found.",
        "wg": []
      },
      {
        "t": "(B) 設定 `left = mid + 1`，繼續往右搜尋。",
        "en": "(B) Set `left = mid + 1` and continue searching to the right.",
        "wg": []
      },
      {
        "t": "(C) 設定 `right = mid - 1` (或 `right = mid`)，繼續往左搜尋以尋找更前面的索引。",
        "en": "(C) Set `right = mid - 1` (or `right = mid`) and continue searching to the left to find an earlier index.",
        "wg": [
          {
            "t": "前面的",
            "en": "earlier",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 停止搜尋並回傳 `mid - 1`。",
        "en": "(D) Stop searching and return `mid - 1`.",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "標準的二分搜尋在找到相等值時會立即回傳。若要找「第一個」出現的位置 (Lower Bound)，即使 `nums[mid]` 等於目標值，我們仍需縮小右邊界 (`right`) 往左半部繼續尋找，確認是否還有更小的索引也等於目標值。",
      "en": "Standard Binary Search returns immediately upon finding a match. To find the 'first' occurrence (Lower Bound), even if `nums[mid]` equals the target, we must shrink the right boundary (`right`) and continue searching in the left half to verify if there is a smaller index that also equals the target.",
      "wg": [
        {
          "t": "縮小",
          "en": "shrink",
          "ps": "V"
        },
        {
          "t": "確認",
          "en": "verify",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "8",
    "level": "hard",
    "keywords": "Loop Condition, Termination State, Boundary",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (left <= right) { ... }",
    "question": [
      {
        "t": "在使用 `while (left <= right)` 作為迴圈條件的二分搜尋法中，假設目標值不存在於陣列中。",
        "en": "In a Binary Search using `while (left <= right)` as the loop condition, assume the target value does not exist in the array.",
        "wg": [
          {
            "t": "不存在",
            "en": "does not exist",
            "ps": "V"
          }
        ]
      },
      {
        "t": "當迴圈結束時，`left` 與 `right` 指標的相對關係為何？",
        "en": "What is the relative relationship between the `left` and `right` pointers when the loop terminates?",
        "wg": [
          {
            "t": "相對關係",
            "en": "relative relationship",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `left == right`",
        "en": "(A) `left == right`",
        "wg": []
      },
      {
        "t": "(B) `left == right + 1`",
        "en": "(B) `left == right + 1`",
        "wg": []
      },
      {
        "t": "(C) `left == right - 1`",
        "en": "(C) `left == right - 1`",
        "wg": []
      },
      {
        "t": "(D) `left` 會變成 0，`right` 會變成陣列長度。",
        "en": "(D) `left` becomes 0, and `right` becomes the array length.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當條件為 `left <= right` 時，迴圈終止的條件是 `left > right`。在最後一次迭代中，`left` 和 `right` 可能相等，此時若仍未找到目標，`left` 會加 1 或 `right` 會減 1，導致錯開，最終狀態必為 `left = right + 1`。",
      "en": "When the condition is `left <= right`, the loop terminates when `left > right`. In the final iteration, `left` and `right` might be equal; if the target is still not found, `left` increments or `right` decrements, causing them to cross. The final state must be `left = right + 1`.",
      "wg": [
        {
          "t": "終止",
          "en": "terminate",
          "ps": "V"
        },
        {
          "t": "錯開",
          "en": "cross",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "9",
    "level": "medium",
    "keywords": "Search Insert Position, Return Value, Application",
    "parentNo": null,
    "images": null,
    "codeSnippet": "Input: [1, 3, 5, 6], Target: 2\nOutput: 1",
    "question": [
      {
        "t": "「搜尋插入位置」是一個經典的面試題：若目標值存在，回傳其索引；若不存在，回傳它被依序插入後應該所在的索引。",
        "en": "\"Search Insert Position\" is a classic interview question: if the target exists, return its index; if not, return the index where it would be if it were inserted in order.",
        "wg": [
          {
            "t": "依序",
            "en": "in order",
            "ps": "Adv"
          },
          {
            "t": "插入",
            "en": "inserted",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用標準的 `while (left <= right)` 二分搜尋樣板，若迴圈結束仍未找到目標，應該回傳哪個變數作為插入位置？",
        "en": "Using the standard `while (left <= right)` Binary Search template, if the target is not found after the loop ends, which variable should be returned as the insert position?",
        "wg": [
          {
            "t": "樣板",
            "en": "template",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `mid`",
        "en": "(A) `mid`",
        "wg": []
      },
      {
        "t": "(B) `right`",
        "en": "(B) `right`",
        "wg": []
      },
      {
        "t": "(C) `left`",
        "en": "(C) `left`",
        "wg": []
      },
      {
        "t": "(D) `mid + 1`",
        "en": "(D) `mid + 1`",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當迴圈結束時，`left` 指標會停在「第一個大於目標值」的位置，這正是目標值應該被插入的位置以保持排序順序。`right` 則會停在比目標值小的位置。",
      "en": "When the loop terminates, the `left` pointer stops at the position of the \"first element greater than the target,\" which is exactly where the target should be inserted to maintain sort order. `right` stops at a position smaller than the target.",
      "wg": [
        {
          "t": "保持",
          "en": "maintain",
          "ps": "V"
        },
        {
          "t": "順序",
          "en": "order",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "10",
    "level": "medium",
    "keywords": "Implicit Search Space, First Bad Version, API",
    "parentNo": null,
    "images": null,
    "codeSnippet": "bool isBadVersion(version)",
    "question": [
      {
        "t": "二分搜尋法不僅限於陣列搜尋，也可用於「隱式搜尋空間」。",
        "en": "Binary Search is not limited to array searching; it can also be used on \"implicit search spaces\".",
        "wg": [
          {
            "t": "隱式",
            "en": "implicit",
            "ps": "Adj"
          },
          {
            "t": "空間",
            "en": "space",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設你有版本號 `1` 到 `n`，且有一個 API `isBadVersion(version)` 可以判斷某個版本是否損壞。",
        "en": "Suppose you have version numbers `1` to `n`, and an API `isBadVersion(version)` that determines if a version is corrupted.",
        "wg": [
          {
            "t": "損壞",
            "en": "corrupted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若版本 `k` 壞了，則所有 `k` 之後的版本也都是壞的。請問這符合二分搜尋的什麼特性？",
        "en": "If version `k` is bad, then all versions after `k` are also bad. What property of Binary Search does this satisfy?",
        "wg": [
          {
            "t": "特性",
            "en": "property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 隨機存取性 (Random Access)",
        "en": "(A) Random Access",
        "wg": []
      },
      {
        "t": "(B) 單調性 (Monotonicity)",
        "en": "(B) Monotonicity",
        "wg": [
          {
            "t": "單調性",
            "en": "Monotonicity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 雜湊性 (Hashing)",
        "en": "(C) Hashing",
        "wg": []
      },
      {
        "t": "(D) 遞迴性 (Recursion)",
        "en": "(D) Recursion",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "此問題的結果呈現 `[好, 好, ..., 壞, 壞]` 的分佈，這是一種單調性（從 false 變為 true 且不再變回 false）。只要搜尋空間具備單調性，即使沒有實體陣列，也能使用二分搜尋來找到邊界。",
      "en": "The results of this problem show a distribution of `[Good, Good, ..., Bad, Bad]`, which is a form of monotonicity (changing from false to true and never back). As long as the search space possesses monotonicity, Binary Search can be used to find the boundary even without a physical array.",
      "wg": [
        {
          "t": "分佈",
          "en": "distribution",
          "ps": "N"
        },
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "11",
    "level": "medium",
    "keywords": "Rotated Array, Pivot, Search",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = left + (right - left) / 2;\nif (nums[mid] > nums[right]) {\n    left = mid + 1;\n} else {\n    right = mid;\n}",
    "question": [
      {
        "t": "給定一個原本經過排序但隨後在某個樞紐點進行旋轉的整數陣列（例如 `[3, 4, 5, 1, 2]`），我們希望找到其中的最小值。",
        "en": "Given an integer array that was originally sorted but then rotated at some pivot (e.g., `[3, 4, 5, 1, 2]`), we want to find the minimum value.",
        "wg": [
          {
            "t": "樞紐點",
            "en": "pivot",
            "ps": "N"
          },
          {
            "t": "旋轉",
            "en": "rotated",
            "ps": "V"
          },
          {
            "t": "最小值",
            "en": "minimum value",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請參考上方的程式碼片段，分析為什麼這段邏輯可以正確縮小搜尋範圍。",
        "en": "Please refer to the code snippet above and analyze why this logic correctly narrows down the search range.",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "縮小",
            "en": "narrow down",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當 `nums[mid] > nums[right]` 時，表示最小值一定在 `mid` 的右側（不包含 `mid`），因為左半邊是有序且數值較大的。",
        "en": "(A) When `nums[mid] > nums[right]`, it implies the minimum is strictly to the right of `mid` (excluding `mid`), because the left half is sorted and contains larger values.",
        "wg": [
          {
            "t": "有序",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 必須比較 `nums[mid]` 與 `nums[left]` 才能確定旋轉點的位置。",
        "en": "(B) You must compare `nums[mid]` with `nums[left]` to determine the position of the rotation point.",
        "wg": []
      },
      {
        "t": "(C) 當 `nums[mid] <= nums[right]` 時，最小值一定在 `mid` 的右側。",
        "en": "(C) When `nums[mid] <= nums[right]`, the minimum value is definitely to the right of `mid`.",
        "wg": []
      },
      {
        "t": "(D) 這段程式碼會導致無限迴圈，因為 `right` 被賦值為 `mid` 而不是 `mid - 1`。",
        "en": "(D) This code will cause an infinite loop because `right` is assigned `mid` instead of `mid - 1`.",
        "wg": [
          {
            "t": "無限迴圈",
            "en": "infinite loop",
            "ps": "N"
          },
          {
            "t": "賦值",
            "en": "assigned",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在尋找旋轉排序陣列的最小值時，若 `nums[mid] > nums[right]`，說明中間值大於最右邊的值，這是一種異常情況（未旋轉時應為小於），因此最小值必定位於 `mid` 之後的右半段（`left = mid + 1`）。反之，若 `nums[mid] <= nums[right]`，則右半段是有序的，最小值可能就是 `mid` 或在 `mid` 的左側，故將 `right` 收縮至 `mid`。",
      "en": "When finding the minimum in a rotated sorted array, if `nums[mid] > nums[right]`, the middle value is greater than the rightmost value, which is an anomaly (it should be smaller if not rotated). Thus, the minimum must be in the right half after `mid` (`left = mid + 1`). Conversely, if `nums[mid] <= nums[right]`, the right half is sorted, so the minimum could be `mid` itself or to its left, so we shrink `right` to `mid`.",
      "wg": [
        {
          "t": "異常情況",
          "en": "anomaly",
          "ps": "N"
        },
        {
          "t": "收縮",
          "en": "shrink",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "medium",
    "keywords": "First Bad Version, API, Boundary",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "您正在開發一個軟體版本控制系統，並且有一個 API `isBadVersion(version)` 可以判斷某個版本是否錯誤。",
        "en": "You are developing a software version control system and have an API `isBadVersion(version)` that determines if a version is bad.",
        "wg": [
          {
            "t": "版本控制系統",
            "en": "version control system",
            "ps": "N"
          },
          {
            "t": "判斷",
            "en": "determine",
            "ps": "V"
          }
        ]
      },
      {
        "t": "已知版本從 `1` 到 `n`，且一旦某個版本錯誤，其後續所有版本都會是錯誤的。",
        "en": "Versions range from `1` to `n`, and once a version is bad, all subsequent versions are also bad.",
        "wg": [
          {
            "t": "後續",
            "en": "subsequent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "若要找出「第一個」錯誤的版本，下列哪種二分搜尋法的實作細節是正確的？",
        "en": "To find the 'first' bad version, which of the following implementation details of binary search is correct?",
        "wg": [
          {
            "t": "實作細節",
            "en": "implementation details",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 當 `isBadVersion(mid)` 為 `true` 時，代表找到目標，應立即 `return mid`。",
        "en": "(A) When `isBadVersion(mid)` is `true`, it means the target is found, and you should immediately `return mid`.",
        "wg": []
      },
      {
        "t": "(B) 當 `isBadVersion(mid)` 為 `true` 時，第一個錯誤版本可能在左側或就是 `mid`，因此應設定 `right = mid` 繼續搜尋。",
        "en": "(B) When `isBadVersion(mid)` is `true`, the first bad version could be on the left or be `mid` itself, so set `right = mid` to continue searching.",
        "wg": []
      },
      {
        "t": "(C) 當 `isBadVersion(mid)` 為 `false` 時，應設定 `right = mid - 1`。",
        "en": "(C) When `isBadVersion(mid)` is `false`, you should set `right = mid - 1`.",
        "wg": []
      },
      {
        "t": "(D) 搜尋區間應初始化為 `left = 0`, `right = n - 1`。",
        "en": "(D) The search range should be initialized to `left = 0`, `right = n - 1`.",
        "wg": [
          {
            "t": "初始化",
            "en": "initialized",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這是一個尋找左側邊界（Lower Bound）的問題。當 `isBadVersion(mid)` 為真時，`mid` 可能是第一個錯誤版本，也可能更早的版本就已錯誤，因此不能排除 `mid`，需將搜尋範圍縮小至 `[left, mid]`，即 `right = mid`。若直接回傳，可能會漏掉更前面的錯誤版本。",
      "en": "This is a problem of finding the lower bound. When `isBadVersion(mid)` is true, `mid` could be the first bad version, or an earlier version might already be bad. Therefore, we cannot exclude `mid`. We must narrow the search range to `[left, mid]`, meaning `right = mid`. Returning immediately might miss an earlier bad version.",
      "wg": [
        {
          "t": "左側邊界",
          "en": "lower bound",
          "ps": "N"
        },
        {
          "t": "排除",
          "en": "exclude",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "hard",
    "keywords": "Peak Element, Local Maximum, Gradient",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在一個整數陣列 `nums` 中，峰值元素是指其值嚴格大於左右相鄰元素的元素。",
        "en": "In an integer array `nums`, a peak element is an element that is strictly greater than its neighbors.",
        "wg": [
          {
            "t": "峰值元素",
            "en": "peak element",
            "ps": "N"
          },
          {
            "t": "嚴格大於",
            "en": "strictly greater than",
            "ps": "Adj Phrase"
          },
          {
            "t": "相鄰元素",
            "en": "neighbors",
            "ps": "N"
          }
        ]
      },
      {
        "t": "假設 `nums[-1]` 和 `nums[n]` 被視為負無窮大，且陣列中相鄰元素不相等。",
        "en": "Assume `nums[-1]` and `nums[n]` are considered negative infinity, and adjacent elements in the array are not equal.",
        "wg": [
          {
            "t": "負無窮大",
            "en": "negative infinity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "若要使用 `O(log n)` 時間複雜度找到任意一個峰值，當 `nums[mid] < nums[mid + 1]` 時，下一步該如何移動？",
        "en": "To find any peak with `O(log n)` time complexity, if `nums[mid] < nums[mid + 1]`, how should you move next?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 峰值必定在左側，設定 `right = mid`。",
        "en": "(A) The peak must be on the left side, set `right = mid`.",
        "wg": []
      },
      {
        "t": "(B) 峰值必定在右側，設定 `left = mid + 1`。",
        "en": "(B) The peak must be on the right side, set `left = mid + 1`.",
        "wg": []
      },
      {
        "t": "(C) 無法判斷峰值方向，必須同時搜尋左右兩側。",
        "en": "(C) Cannot determine the direction of the peak; must search both left and right sides.",
        "wg": []
      },
      {
        "t": "(D) 只有當陣列完全排序時才能使用二分搜尋。",
        "en": "(D) Binary search can only be used when the array is fully sorted.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "如果 `nums[mid] < nums[mid + 1]`，表示目前處於一個「上坡」的趨勢。因為右邊界外是負無窮大，所以沿著上坡方向往右走，最終一定會遇到一個峰值（即使是最後一個元素）。因此我們可以放心地捨棄左半邊，往右側搜尋。",
      "en": "If `nums[mid] < nums[mid + 1]`, it indicates we are on an 'uphill' slope. Since the right boundary is effectively negative infinity, moving right along the upward slope guarantees we will eventually hit a peak (even if it's the last element). Therefore, we can safely discard the left half and search to the right.",
      "wg": [
        {
          "t": "趨勢",
          "en": "trend",
          "ps": "N"
        },
        {
          "t": "捨棄",
          "en": "discard",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Search Insert Position, Return Value, Index",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個排序陣列和一個目標值 `target`，如果在陣列中找到目標值則回傳其索引，否則回傳它若被插入時應所在的索引位置。",
        "en": "Given a sorted array and a target value `target`, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
        "wg": [
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          },
          {
            "t": "插入",
            "en": "inserted",
            "ps": "V"
          }
        ]
      },
      {
        "t": "使用標準二分搜尋迴圈 `while (left <= right)` 結束後，若未找到目標值，正確的回傳值通常是什麼？",
        "en": "After the standard binary search loop `while (left <= right)` finishes without finding the target, what is typically the correct return value?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) `right`",
        "en": "(A) `right`",
        "wg": []
      },
      {
        "t": "(B) `left`",
        "en": "(B) `left`",
        "wg": []
      },
      {
        "t": "(C) `mid`",
        "en": "(C) `mid`",
        "wg": []
      },
      {
        "t": "(D) `-1`",
        "en": "(D) `-1`",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `while (left <= right)` 迴圈結束時，`left` 會停在第一個大於 `target` 的元素位置（即插入點），而 `right` 會停在 `left` 的左側（即最後一個小於 `target` 的位置）。因此，`left` 是正確的插入位置。",
      "en": "When the `while (left <= right)` loop terminates, `left` will stop at the first element greater than `target` (the insertion point), while `right` will stop to the left of `left` (the last element smaller than `target`). Therefore, `left` is the correct insertion position.",
      "wg": [
        {
          "t": "迴圈結束",
          "en": "loop terminates",
          "ps": "V Phrase"
        },
        {
          "t": "插入點",
          "en": "insertion point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "hard",
    "keywords": "Binary Search on Answer, Optimization, Monotonicity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "二分搜尋法不僅限於在陣列中查找元素，還常用於「對答案進行二分搜尋」的優化問題。",
        "en": "Binary search is not limited to finding elements in an array; it is also commonly used for optimization problems known as 'Binary Search on Answer'.",
        "wg": [
          {
            "t": "優化問題",
            "en": "optimization problems",
            "ps": "N"
          },
          {
            "t": "對答案進行二分搜尋",
            "en": "Binary Search on Answer",
            "ps": "N Phrase"
          }
        ]
      },
      {
        "t": "例如：求「完成所有任務所需的最小產能 K」。",
        "en": "For example: Find the 'minimum capacity K required to complete all tasks'.",
        "wg": [
          {
            "t": "產能",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "要能夠使用此技巧，問題的解空間必須具備什麼關鍵特性？",
        "en": "To use this technique, what key property must the solution space of the problem possess?",
        "wg": [
          {
            "t": "解空間",
            "en": "solution space",
            "ps": "N"
          },
          {
            "t": "關鍵特性",
            "en": "key property",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 連續性 (Continuity)：解空間必須是連續的實數。",
        "en": "(A) Continuity: The solution space must be continuous real numbers.",
        "wg": [
          {
            "t": "連續性",
            "en": "continuity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 單調性 (Monotonicity)：若產能 K 可行，則所有大於 K 的產能也都可行。",
        "en": "(B) Monotonicity: If capacity K is feasible, then all capacities greater than K are also feasible.",
        "wg": [
          {
            "t": "單調性",
            "en": "monotonicity",
            "ps": "N"
          },
          {
            "t": "可行",
            "en": "feasible",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 對稱性 (Symmetry)：解空間的分佈必須是對稱的。",
        "en": "(C) Symmetry: The distribution of the solution space must be symmetric.",
        "wg": []
      },
      {
        "t": "(D) 有限性 (Finiteness)：解的範圍必須小於 1000。",
        "en": "(D) Finiteness: The range of the solution must be less than 1000.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "「對答案二分」的核心在於解空間具備單調性。如果一個值 `K` 滿足條件（例如能完成任務），那麼任何比 `K` 更強的能力（更大的值）通常也能滿足條件。這使得我們可以將問題轉化為 `True/False` 的判斷，並透過二分法找到滿足條件的最小 `K` 值（即 `False` 轉變為 `True` 的邊界）。",
      "en": "The core of 'Binary Search on Answer' lies in the monotonicity of the solution space. If a value `K` satisfies the condition (e.g., can complete the task), then any capacity stronger than `K` (larger values) usually also satisfies it. This allows us to convert the problem into a `True/False` check and use binary search to find the minimum `K` (the boundary where `False` turns to `True`).",
      "wg": [
        {
          "t": "核心",
          "en": "core",
          "ps": "N"
        },
        {
          "t": "轉化",
          "en": "convert",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "16",
    "level": "medium",
    "keywords": "Rotated Sorted Array, Pivot, Search Logic",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int search(vector<int>& nums, int target) {\n  int left = 0, right = nums.size() - 1;\n  while (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) return mid;\n    // Logic gap here\n  }\n  return -1;\n}",
    "question": [
      {
        "t": "在一個「旋轉排序陣列」（例如 `[4,5,6,7,0,1,2]`）中進行搜尋時，我們需要判斷哪一半是有序的。",
        "en": "When searching in a 'Rotated Sorted Array' (e.g., `[4,5,6,7,0,1,2]`), we need to determine which half is sorted.",
        "wg": [
          {
            "t": "旋轉排序陣列",
            "en": "Rotated Sorted Array",
            "ps": "NP"
          },
          {
            "t": "有序的",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "如果在某次迭代中發現 `nums[left] <= nums[mid]`，這代表了什麼意義？",
        "en": "If in a certain iteration we find that `nums[left] <= nums[mid]`, what does this imply?",
        "wg": [
          {
            "t": "迭代",
            "en": "iteration",
            "ps": "N"
          },
          {
            "t": "代表",
            "en": "imply",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 陣列的右半部（從 `mid` 到 `right`）保證是有序的。",
        "en": "(A) The right half of the array (from `mid` to `right`) is guaranteed to be sorted.",
        "wg": []
      },
      {
        "t": "(B) 陣列的左半部（從 `left` 到 `mid`）保證是有序的。",
        "en": "(B) The left half of the array (from `left` to `mid`) is guaranteed to be sorted.",
        "wg": []
      },
      {
        "t": "(C) 目標值 `target` 一定在左半部。",
        "en": "(C) The target value `target` must be in the left half.",
        "wg": []
      },
      {
        "t": "(D) 旋轉點（pivot）一定位於左半部。",
        "en": "(D) The pivot point must be located in the left half.",
        "wg": [
          {
            "t": "旋轉點",
            "en": "pivot point",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在旋轉排序陣列中，如果 `nums[left] <= nums[mid]`，說明從 `left` 到 `mid` 這段區間沒有包含旋轉點（斷層），因此左半部是嚴格遞增排序的；我們隨後可以檢查 `target` 是否落在這個有序區間內來決定下一步。",
      "en": "In a rotated sorted array, if `nums[left] <= nums[mid]`, it indicates that the range from `left` to `mid` does not contain the pivot (break point), so the left half is strictly increasing; we can then check if the `target` falls within this sorted range to decide the next step.",
      "wg": [
        {
          "t": "斷層",
          "en": "break point",
          "ps": "N"
        },
        {
          "t": "嚴格遞增",
          "en": "strictly increasing",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "17",
    "level": "hard",
    "keywords": "Duplicates, Worst Case Complexity, Degeneration",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "當旋轉排序陣列中包含「重複元素」時（例如 `[2,5,6,0,0,1,2]`），標準的二分搜尋演算法會遇到什麼問題？",
        "en": "When a rotated sorted array contains 'duplicate elements' (e.g., `[2,5,6,0,0,1,2]`), what problem does the standard binary search algorithm encounter?",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicate elements",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "這對最壞情況下的時間複雜度有何影響？",
        "en": "How does this affect the time complexity in the worst case?",
        "wg": [
          {
            "t": "最壞情況",
            "en": "worst case",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 演算法仍然保持 O(log N)，因為我們總是能捨棄一半。",
        "en": "(A) The algorithm remains O(log N) because we can always discard half.",
        "wg": [
          {
            "t": "捨棄",
            "en": "discard",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(B) 演算法會失效並傳回錯誤的索引。",
        "en": "(B) The algorithm will fail and return an incorrect index.",
        "wg": []
      },
      {
        "t": "(C) 無法判斷哪一半是有序的，導致最壞情況退化為 O(N)。",
        "en": "(C) It becomes impossible to determine which half is sorted, causing the worst case to degenerate to O(N).",
        "wg": [
          {
            "t": "退化",
            "en": "degenerate",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(D) 必須先對陣列重新排序，這需要 O(N log N)。",
        "en": "(D) The array must be re-sorted first, which takes O(N log N).",
        "wg": []
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "當 `nums[left] == nums[mid] == nums[right]` 時，我們無法分辨旋轉點在哪一側（無法確定哪邊是有序的），因此只能將邊界縮減一步（如 `left++` 或 `right--`），這在最壞情況下（如全部元素相同）會導致演算法退化成線性搜尋 O(N)。",
      "en": "When `nums[left] == nums[mid] == nums[right]`, we cannot distinguish which side contains the pivot (cannot determine which side is sorted), so we can only shrink the boundary by one step (e.g., `left++` or `right--`), which in the worst case (e.g., all elements are the same) causes the algorithm to degenerate into linear search O(N).",
      "wg": [
        {
          "t": "分辨",
          "en": "distinguish",
          "ps": "V"
        },
        {
          "t": "線性搜尋",
          "en": "linear search",
          "ps": "NP"
        }
      ]
    }
  },
  {
    "no": "18",
    "level": "medium",
    "keywords": "Peak Element, Unsorted Array, Local Maximum",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "給定一個未排序的陣列，其中任意兩個相鄰元素都不相等。",
        "en": "Given an unsorted array where no two adjacent elements are equal.",
        "wg": [
          {
            "t": "未排序",
            "en": "unsorted",
            "ps": "Adj"
          },
          {
            "t": "相鄰",
            "en": "adjacent",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "我們要尋找一個「峰值元素」（大於左右相鄰值的元素）。",
        "en": "We want to find a 'peak element' (an element greater than its left and right neighbors).",
        "wg": [
          {
            "t": "峰值元素",
            "en": "peak element",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "為什麼二分搜尋法可以用於解決這個問題？",
        "en": "Why can binary search be used to solve this problem?",
        "wg": []
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為陣列雖然未完全排序，但局部是有序的。",
        "en": "(A) Because although the array is not fully sorted, it is locally sorted.",
        "wg": [
          {
            "t": "局部",
            "en": "locally",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "(B) 因為我們可以根據上升或下降的趨勢，確定峰值一定存在於較高的一側。",
        "en": "(B) Because we can determine that a peak must exist on the higher side based on the rising or falling trend.",
        "wg": [
          {
            "t": "趨勢",
            "en": "trend",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 只有當陣列是「先升後降」的單峰陣列時才能使用。",
        "en": "(C) It can only be used if the array is a 'unimodal' array that rises then falls.",
        "wg": [
          {
            "t": "單峰",
            "en": "unimodal",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(D) 二分搜尋法不能用於未排序的陣列。",
        "en": "(D) Binary search cannot be used on unsorted arrays.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "如果 `nums[mid] < nums[mid+1]`，表示目前處於「上坡」階段，峰值必定在右側（因為即使一直上升，最後一個元素也會是峰值）；反之若處於「下坡」，峰值在左側。這種利用局部斜率捨棄一半空間的特性使得二分搜尋可行。",
      "en": "If `nums[mid] < nums[mid+1]`, it means we are on an 'uphill' slope, and a peak must exist on the right (since even if it keeps rising, the last element will be a peak); conversely, if on a 'downhill', the peak is on the left. This property of using local slope to discard half the space makes binary search feasible.",
      "wg": [
        {
          "t": "斜率",
          "en": "slope",
          "ps": "N"
        },
        {
          "t": "可行",
          "en": "feasible",
          "ps": "Adj"
        }
      ]
    }
  },
  {
    "no": "19",
    "level": "hard",
    "keywords": "Binary Search on Answer, Optimization, Monotonicity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「最小化最大值」或「最大化最小值」這類最佳化問題時（例如：分割陣列的最大和最小化），我們常使用「對答案進行二分搜尋」。",
        "en": "When solving optimization problems like 'minimize the maximum' or 'maximize the minimum' (e.g., Split Array Largest Sum), we often use 'Binary Search on Answer'.",
        "wg": [
          {
            "t": "最佳化",
            "en": "optimization",
            "ps": "N"
          },
          {
            "t": "對答案進行二分搜尋",
            "en": "Binary Search on Answer",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "此類方法的核心先決條件是什麼？",
        "en": "What is the core prerequisite for this type of method?",
        "wg": [
          {
            "t": "先決條件",
            "en": "prerequisite",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 輸入的陣列必須已經排序。",
        "en": "(A) The input array must already be sorted.",
        "wg": []
      },
      {
        "t": "(B) 答案範圍必須是連續的整數，且檢驗函數具有單調性。",
        "en": "(B) The answer range must be continuous integers, and the verification function must have monotonicity.",
        "wg": [
          {
            "t": "檢驗函數",
            "en": "verification function",
            "ps": "NP"
          },
          {
            "t": "單調性",
            "en": "monotonicity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 問題必須能夠使用動態規劃（Dynamic Programming）解決。",
        "en": "(C) The problem must be solvable using Dynamic Programming.",
        "wg": []
      },
      {
        "t": "(D) 答案必須是陣列中的某個元素。",
        "en": "(D) The answer must be one of the elements in the array.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "這類問題的關鍵在於，如果數值 `x` 是一個可行的解（例如容量 `x` 足夠裝載），那麼所有大於 `x` 的數值通常也都可行（單調性）；這讓我們可以在可能的答案範圍內進行二分搜尋，而不依賴輸入陣列是否排序。",
      "en": "The key to such problems is that if a value `x` is a feasible solution (e.g., capacity `x` is sufficient), then all values greater than `x` are usually also feasible (monotonicity); this allows us to binary search within the range of possible answers, regardless of whether the input array is sorted.",
      "wg": [
        {
          "t": "可行的",
          "en": "feasible",
          "ps": "Adj"
        },
        {
          "t": "依賴",
          "en": "rely on",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "20",
    "level": "medium",
    "keywords": "Integer Overflow, Implementation, Best Practice",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = left + (right - left) / 2;",
    "question": [
      {
        "t": "在實作二分搜尋時，計算中間索引 `mid` 的標準寫法是 `mid = left + (right - left) / 2`。",
        "en": "When implementing binary search, the standard way to calculate the middle index `mid` is `mid = left + (right - left) / 2`.",
        "wg": [
          {
            "t": "實作",
            "en": "implementing",
            "ps": "V"
          }
        ]
      },
      {
        "t": "為什麼這種寫法優於直觀的 `mid = (left + right) / 2`？",
        "en": "Why is this method preferred over the intuitive `mid = (left + right) / 2`?",
        "wg": [
          {
            "t": "直觀的",
            "en": "intuitive",
            "ps": "Adj"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 它可以避免當 `left` 和 `right` 都很大時發生整數溢位（Integer Overflow）。",
        "en": "(A) It prevents Integer Overflow when both `left` and `right` are large.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "NP"
          }
        ]
      },
      {
        "t": "(B) 它的運算速度比加法除法更快。",
        "en": "(B) It computes faster than addition and division.",
        "wg": []
      },
      {
        "t": "(C) 它能確保 `mid` 總是取整數，而後者可能會產生浮點數。",
        "en": "(C) It ensures `mid` is always an integer, whereas the latter might produce a float.",
        "wg": [
          {
            "t": "浮點數",
            "en": "float",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 它能處理負數索引的情況。",
        "en": "(D) It can handle cases with negative indices.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "在固定位數的整數型別（如 C++ 的 `int` 或 Java 的 `int`）中，`left + right` 可能會超過最大正整數範圍導致溢位變成負數；使用 `left + (right - left) / 2` 數學上等價但保證了中間運算過程不會超出 `right` 的範圍。",
      "en": "In fixed-size integer types (like `int` in C++ or Java), `left + right` might exceed the maximum positive integer limit, causing an overflow to a negative number; using `left + (right - left) / 2` is mathematically equivalent but guarantees that intermediate calculations do not exceed the range of `right`.",
      "wg": [
        {
          "t": "固定位數",
          "en": "fixed-size",
          "ps": "Adj"
        },
        {
          "t": "等價",
          "en": "equivalent",
          "ps": "Adj"
        }
      ]
    }
  }
]