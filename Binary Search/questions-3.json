[
  {
    "no": "11",
    "level": "medium",
    "keywords": "Rotated Sorted Array, Pivot, Condition",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = left + (right - left) / 2;\nif (nums[mid] > nums[right]) {\n  left = mid + 1;\n} else {\n  right = mid;\n}",
    "question": [
      {
        "t": "給定一個經過旋轉的排序陣列（例如 `[3, 4, 5, 1, 2]`），我們希望找到其中的最小值。",
        "en": "Given a rotated sorted array (e.g., `[3, 4, 5, 1, 2]`), we want to find the minimum value.",
        "wg": [
          {
            "t": "經過旋轉的",
            "en": "rotated",
            "ps": "Adj"
          },
          {
            "t": "排序陣列",
            "en": "sorted array",
            "ps": "N"
          }
        ]
      },
      {
        "t": "請分析上述程式碼片段，為什麼當 `nums[mid] > nums[right]` 時，我們可以確定最小值位於 `mid` 的右側？",
        "en": "Analyze the code snippet above. Why can we determine that the minimum value lies to the right of `mid` when `nums[mid] > nums[right]`?",
        "wg": [
          {
            "t": "程式碼片段",
            "en": "code snippet",
            "ps": "N"
          },
          {
            "t": "位於",
            "en": "lies",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為 `mid` 比 `right` 大，代表 `mid` 到 `right` 之間是嚴格遞增的，所以最小值不可能在那裡。",
        "en": "(A) Because `mid` is larger than `right`, it implies the range from `mid` to `right` is strictly increasing, so the minimum cannot be there.",
        "wg": [
          {
            "t": "嚴格遞增",
            "en": "strictly increasing",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(B) 因為旋轉陣列的特性，若中間值大於最右邊的值，表示 `mid` 位於左半部的遞增區段，而最小值發生在斷層之後（即右側）。",
        "en": "(B) Due to the property of rotated arrays, if the middle value is greater than the rightmost value, `mid` is in the left increasing segment, and the minimum occurs after the drop (i.e., to the right).",
        "wg": [
          {
            "t": "特性",
            "en": "property",
            "ps": "N"
          },
          {
            "t": "斷層",
            "en": "drop/break",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是一個錯誤的邏輯，最小值應該在 `mid` 的左側。",
        "en": "(C) This is flawed logic; the minimum should be to the left of `mid`.",
        "wg": []
      },
      {
        "t": "(D) 因為 `mid` 是最大值，所以最小值一定在它的對面。",
        "en": "(D) Because `mid` is the maximum value, the minimum must be on the opposite side.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "在旋轉排序陣列中，如果 `nums[mid] > nums[right]`，這意味著從 `mid` 到 `right` 的區間並非連續遞增（出現了旋轉點），因此較小的數值（包含最小值）必然位於 `mid + 1` 到 `right` 之間。",
      "en": "In a rotated sorted array, if `nums[mid] > nums[right]`, it implies the interval from `mid` to `right` is not continuously increasing (the rotation point exists there), so the smaller values (including the minimum) must lie between `mid + 1` and `right`.",
      "wg": [
        {
          "t": "連續遞增",
          "en": "continuously increasing",
          "ps": "Adj"
        },
        {
          "t": "旋轉點",
          "en": "rotation point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "12",
    "level": "hard",
    "keywords": "Binary Search on Answer, Optimization, Monotonicity",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在解決「愛吃香蕉的珂珂 (Koko Eating Bananas)」這類最佳化問題時，我們通常對「速度」或是「容量」進行二分搜尋。",
        "en": "When solving optimization problems like 'Koko Eating Bananas', we often perform binary search on 'speed' or 'capacity'.",
        "wg": [
          {
            "t": "最佳化問題",
            "en": "optimization problems",
            "ps": "N"
          },
          {
            "t": "容量",
            "en": "capacity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "這類題目能夠使用二分搜尋法的核心前提是什麼？",
        "en": "What is the core prerequisite for applying binary search in this type of problem?",
        "wg": [
          {
            "t": "核心前提",
            "en": "core prerequisite",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 輸入的陣列必須是已經排序好的。",
        "en": "(A) The input array must already be sorted.",
        "wg": []
      },
      {
        "t": "(B) 答案的範圍必須在 0 到 100 之間。",
        "en": "(B) The range of the answer must be between 0 and 100.",
        "wg": []
      },
      {
        "t": "(C) 驗證函數（Feasibility Function）對於搜尋空間必須具有單調性。",
        "en": "(C) The verification function (Feasibility Function) must be monotonic with respect to the search space.",
        "wg": [
          {
            "t": "驗證函數",
            "en": "verification function",
            "ps": "N"
          },
          {
            "t": "單調性",
            "en": "monotonicity",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 必須使用遞迴方式實作才能解決。",
        "en": "(D) It must be implemented using recursion to be solved.",
        "wg": [
          {
            "t": "遞迴",
            "en": "recursion",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "這類「對答案進行二分搜尋」的問題，關鍵在於如果某個速度 `k` 可行，則所有大於 `k` 的速度也都可行（單調性）。這讓我們可以拋棄一半的搜尋空間。",
      "en": "The key to 'Binary Search on Answer' problems is that if a certain speed `k` is feasible, then all speeds greater than `k` are also feasible (monotonicity). This allows us to discard half of the search space.",
      "wg": [
        {
          "t": "可行",
          "en": "feasible",
          "ps": "Adj"
        },
        {
          "t": "拋棄",
          "en": "discard",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "13",
    "level": "medium",
    "keywords": "Peak Element, Gradient, Unsorted Array",
    "parentNo": null,
    "images": null,
    "codeSnippet": "while (left < right) {\n  int mid = left + (right - left) / 2;\n  if (nums[mid] < nums[mid + 1]) {\n    left = mid + 1;\n  } else {\n    right = mid;\n  }\n}",
    "question": [
      {
        "t": "尋找峰值元素 (Peak Element) 是一個經典的面試題，題目保證 `nums[i] != nums[i+1]`。",
        "en": "Finding a Peak Element is a classic interview question, where it is guaranteed that `nums[i] != nums[i+1]`.",
        "wg": [
          {
            "t": "峰值",
            "en": "peak",
            "ps": "N"
          },
          {
            "t": "保證",
            "en": "guaranteed",
            "ps": "V"
          }
        ]
      },
      {
        "t": "觀察上述程式碼，為什麼當 `nums[mid] < nums[mid + 1]` 時，我們將搜尋範圍縮小至 `[mid + 1, right]`？",
        "en": "Observing the code above, why do we narrow the search range to `[mid + 1, right]` when `nums[mid] < nums[mid + 1]`?",
        "wg": [
          {
            "t": "縮小",
            "en": "narrow",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為這表示我們處於「上坡」階段，峰值必定出現在右側（或是更遠的右側）。",
        "en": "(A) Because this indicates we are on an 'uphill' slope, a peak must exist to the right (or further right).",
        "wg": [
          {
            "t": "上坡",
            "en": "uphill",
            "ps": "N/Adj"
          }
        ]
      },
      {
        "t": "(B) 因為右邊的數字比較大，所以右邊一定是排序好的。",
        "en": "(B) Because the number on the right is larger, the right side must be sorted.",
        "wg": []
      },
      {
        "t": "(C) 這是隨機選擇的，移動到左側也可以找到峰值。",
        "en": "(C) This is chosen randomly; moving to the left could also find a peak.",
        "wg": []
      },
      {
        "t": "(D) 只有當陣列完全排序時，此邏輯才成立。",
        "en": "(D) This logic holds true only when the array is fully sorted.",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "當 `nums[mid] < nums[mid+1]` 時，表示當前處於上升趨勢。由於題目隱含邊界外為負無限大，沿著上坡方向走必然會遇到一個轉折點（峰值），因此峰值必在右側。",
      "en": "When `nums[mid] < nums[mid+1]`, it indicates an upward trend. Since the problem implies boundaries are negative infinity, following the uphill direction guarantees encountering a turning point (peak), so the peak must be on the right.",
      "wg": [
        {
          "t": "上升趨勢",
          "en": "upward trend",
          "ps": "N"
        },
        {
          "t": "轉折點",
          "en": "turning point",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "14",
    "level": "medium",
    "keywords": "Boundary, Duplicates, Lower Bound",
    "parentNo": null,
    "images": null,
    "codeSnippet": "if (nums[mid] >= target) {\n  right = mid;\n} else {\n  left = mid + 1;\n}",
    "question": [
      {
        "t": "在一個包含重複元素的排序陣列中，我們希望找到目標值 `target` **第一次**出現的位置（Lower Bound）。",
        "en": "In a sorted array containing duplicates, we want to find the **first** occurrence of the target value `target` (Lower Bound).",
        "wg": [
          {
            "t": "重複元素",
            "en": "duplicates",
            "ps": "N"
          },
          {
            "t": "第一次出現",
            "en": "first occurrence",
            "ps": "N"
          }
        ]
      },
      {
        "t": "使用上述判斷邏輯搭配 `while(left < right)`，為什麼當 `nums[mid] == target` 時，我們必須執行 `right = mid` 而不是 `return mid`？",
        "en": "Using the above logic with `while(left < right)`, why must we execute `right = mid` instead of `return mid` when `nums[mid] == target`?",
        "wg": [
          {
            "t": "判斷邏輯",
            "en": "logic / conditional logic",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 因為 `mid` 可能不是第一個出現的位置，我們需要保留這個潛在答案並繼續向左搜尋。",
        "en": "(A) Because `mid` might not be the first occurrence, we need to preserve this potential answer and continue searching to the left.",
        "wg": [
          {
            "t": "潛在答案",
            "en": "potential answer",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(B) 因為直接回傳會導致無窮迴圈。",
        "en": "(B) Because returning immediately would cause an infinite loop.",
        "wg": [
          {
            "t": "無窮迴圈",
            "en": "infinite loop",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 這是語法規定，二分搜尋法不能直接在迴圈內回傳。",
        "en": "(C) This is a syntax rule; binary search cannot return directly inside the loop.",
        "wg": []
      },
      {
        "t": "(D) 為了確保時間複雜度維持在 O(log n)。",
        "en": "(D) To ensure the time complexity remains O(log n).",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "當找到 `target` 時，左邊可能還有相同的 `target`。設定 `right = mid` 可以將搜尋範圍縮小到左半部（包含當前 `mid`），確保不會錯過更左邊的第一次出現。",
      "en": "When `target` is found, there might be identical `target`s to the left. Setting `right = mid` narrows the search scope to the left half (including the current `mid`), ensuring we don't miss an earlier occurrence.",
      "wg": [
        {
          "t": "縮小",
          "en": "narrow / shrink",
          "ps": "V"
        },
        {
          "t": "錯過",
          "en": "miss",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "15",
    "level": "medium",
    "keywords": "2D Matrix, Coordinate Mapping, Sorted Matrix",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int rows = matrix.length;\nint cols = matrix[0].length;\nint left = 0, right = rows * cols - 1;\n// ... inside loop ...\nint mid = left + (right - left) / 2;\nint midValue = matrix[mid / cols][mid % cols];",
    "question": [
      {
        "t": "給定一個 `m x n` 的矩陣，該矩陣每列由左至右排序，且下一列的第一個數字大於上一列的最後一個數字。",
        "en": "Given an `m x n` matrix where each row is sorted from left to right, and the first integer of each row is greater than the last integer of the previous row.",
        "wg": [
          {
            "t": "矩陣",
            "en": "matrix",
            "ps": "N"
          },
          {
            "t": "由左至右",
            "en": "from left to right",
            "ps": "Adv"
          }
        ]
      },
      {
        "t": "上述程式碼試圖將二分搜尋應用於此矩陣。請問 `mid / cols` 和 `mid % cols` 的作用是什麼？",
        "en": "The code snippet above attempts to apply binary search to this matrix. What is the purpose of `mid / cols` and `mid % cols`?",
        "wg": [
          {
            "t": "應用於",
            "en": "apply to",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 將 2D 矩陣座標轉換為 1D 陣列索引以節省記憶體。",
        "en": "(A) Convert 2D matrix coordinates to 1D array indices to save memory.",
        "wg": []
      },
      {
        "t": "(B) 將虛擬的 1D 索引映射回 2D 矩陣的 [列][行] 座標，以便存取數值。",
        "en": "(B) Map a virtual 1D index back to the 2D matrix [row][col] coordinates to access the value.",
        "wg": [
          {
            "t": "虛擬的",
            "en": "virtual",
            "ps": "Adj"
          },
          {
            "t": "映射",
            "en": "map",
            "ps": "V"
          }
        ]
      },
      {
        "t": "(C) 用於計算矩陣的轉置（Transpose）。",
        "en": "(C) Used to calculate the transpose of the matrix.",
        "wg": [
          {
            "t": "轉置",
            "en": "transpose",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 這是錯誤的寫法，應該使用 `mid % rows`。",
        "en": "(D) This is incorrect syntax; `mid % rows` should be used.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "由於矩陣具有全域排序特性，我們可以將其視為一個長度為 `m * n` 的 1D 排序陣列。`mid / cols` 計算所在的列，`mid % cols` 計算所在的行，從而實現標準二分搜尋。",
      "en": "Since the matrix has a global sorted property, we can treat it as a 1D sorted array of length `m * n`. `mid / cols` calculates the row, and `mid % cols` calculates the column, enabling standard binary search.",
      "wg": [
        {
          "t": "全域排序",
          "en": "globally sorted",
          "ps": "Adj"
        },
        {
          "t": "視為",
          "en": "treat as",
          "ps": "V"
        }
      ]
    }
  }
]