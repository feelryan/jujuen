[
  {
    "no": "1",
    "level": "easy",
    "keywords": "Binary Search, Prerequisites, Data Structure",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "在陣列上執行標準二分搜尋法 (Binary Search) 之前，資料必須符合哪項最基本的先決條件？",
        "en": "What is the most fundamental prerequisite for the data before performing a standard Binary Search on an array?",
        "wg": [
          {
            "t": "先決條件",
            "en": "prerequisite",
            "ps": "N"
          },
          {
            "t": "執行",
            "en": "perform",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 陣列中的元素必須是唯一的 (Unique)。",
        "en": "(A) The elements in the array must be unique.",
        "wg": []
      },
      {
        "t": "(B) 陣列必須已經排序 (Sorted)。",
        "en": "(B) The array must be sorted.",
        "wg": [
          {
            "t": "已排序",
            "en": "sorted",
            "ps": "Adj"
          }
        ]
      },
      {
        "t": "(C) 陣列的大小必須是 2 的冪次方。",
        "en": "(C) The size of the array must be a power of 2.",
        "wg": [
          {
            "t": "冪次方",
            "en": "power",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(D) 陣列必須只包含正整數。",
        "en": "(D) The array must contain only positive integers.",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "二分搜尋法的核心邏輯依賴於資料的單調性，透過比較中間值與目標值來排除一半的搜尋空間；若資料未排序，則無法確定目標值位於左側或右側，演算法將失效。",
      "en": "The core logic of Binary Search relies on the monotonicity of the data, eliminating half of the search space by comparing the middle value with the target; if the data is unsorted, it is impossible to determine whether the target lies to the left or right, causing the algorithm to fail.",
      "wg": [
        {
          "t": "單調性",
          "en": "monotonicity",
          "ps": "N"
        },
        {
          "t": "排除",
          "en": "eliminate",
          "ps": "V"
        }
      ]
    }
  },
  {
    "no": "2",
    "level": "medium",
    "keywords": "Binary Search, Integer Overflow, Implementation",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int mid = low + (high - low) / 2;",
    "question": [
      {
        "t": "在實作二分搜尋法計算中間索引 (mid) 時，為什麼通常建議使用 `mid = low + (high - low) / 2` 而非 `mid = (low + high) / 2`？",
        "en": "When calculating the middle index (mid) in Binary Search implementation, why is it generally recommended to use `mid = low + (high - low) / 2` instead of `mid = (low + high) / 2`?",
        "wg": [
          {
            "t": "實作",
            "en": "implementation",
            "ps": "N"
          },
          {
            "t": "索引",
            "en": "index",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 前者的運算速度比後者快。",
        "en": "(A) The former is computationally faster than the latter.",
        "wg": []
      },
      {
        "t": "(B) 前者可以避免整數溢位 (Integer Overflow) 的問題。",
        "en": "(B) The former avoids the issue of Integer Overflow.",
        "wg": [
          {
            "t": "整數溢位",
            "en": "Integer Overflow",
            "ps": "N"
          }
        ]
      },
      {
        "t": "(C) 後者在某些程式語言中會導致語法錯誤。",
        "en": "(C) The latter causes syntax errors in some programming languages.",
        "wg": []
      },
      {
        "t": "(D) 前者能確保結果總是無條件進位。",
        "en": "(D) The former ensures the result is always rounded up.",
        "wg": [
          {
            "t": "無條件進位",
            "en": "round up",
            "ps": "V"
          }
        ]
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當 `low` 和 `high` 都是很大的正整數時，`(low + high)` 可能會超過整數型別 (如 32-bit signed integer) 的最大上限，導致溢位變成負數；而 `low + (high - low) / 2` 則能保證運算過程不會超出 `high` 的範圍。",
      "en": "When both `low` and `high` are large positive integers, `(low + high)` might exceed the maximum limit of the integer type (e.g., 32-bit signed integer), causing an overflow to a negative number; whereas `low + (high - low) / 2` ensures the calculation process does not exceed the range of `high`.",
      "wg": [
        {
          "t": "上限",
          "en": "limit",
          "ps": "N"
        },
        {
          "t": "範圍",
          "en": "range",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "3",
    "level": "medium",
    "keywords": "Binary Search, Boundary Conditions, Loop Invariant",
    "parentNo": null,
    "images": null,
    "codeSnippet": "int left = 0, right = nums.length - 1;\nwhile (______) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) return mid;\n    else if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n}\nreturn -1;",
    "question": [
      {
        "t": "在上述標準的二分搜尋程式碼中，若搜尋區間定義為閉區間 `[left, right]`，`while` 迴圈的條件應該填入什麼，才能確保檢查到所有元素？",
        "en": "In the standard Binary Search code above, if the search interval is defined as a closed interval `[left, right]`, what should be the condition in the `while` loop to ensure all elements are checked?",
        "wg": [
          {
            "t": "閉區間",
            "en": "closed interval",
            "ps": "N"
          },
          {
            "t": "條件",
            "en": "condition",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) left < right",
        "en": "(A) left < right",
        "wg": []
      },
      {
        "t": "(B) left <= right",
        "en": "(B) left <= right",
        "wg": []
      },
      {
        "t": "(C) left != right",
        "en": "(C) left != right",
        "wg": []
      },
      {
        "t": "(D) left + 1 < right",
        "en": "(D) left + 1 < right",
        "wg": []
      }
    ],
    "answer": "(B)",
    "why": {
      "t": "當區間縮小到只剩一個元素時 (即 `left == right`)，該元素仍需被檢查。若使用 `left < right`，迴圈會提早結束，導致最後一個元素被遺漏。",
      "en": "When the interval shrinks to a single element (i.e., `left == right`), that element still needs to be checked. If `left < right` is used, the loop terminates prematurely, causing the last element to be missed.",
      "wg": [
        {
          "t": "遺漏",
          "en": "miss",
          "ps": "V"
        },
        {
          "t": "提早",
          "en": "prematurely",
          "ps": "Adv"
        }
      ]
    }
  },
  {
    "no": "4",
    "level": "easy",
    "keywords": "Binary Search, Time Complexity, Big O",
    "parentNo": null,
    "images": null,
    "codeSnippet": null,
    "question": [
      {
        "t": "若有一個包含 1,000,000 (一百萬) 個已排序元素的陣列，使用二分搜尋法尋找特定目標，最壞情況下大約需要比較多少次？",
        "en": "If there is an array containing 1,000,000 (one million) sorted elements, approximately how many comparisons are needed in the worst-case scenario using Binary Search to find a specific target?",
        "wg": [
          {
            "t": "最壞情況",
            "en": "worst-case scenario",
            "ps": "N"
          },
          {
            "t": "比較",
            "en": "comparison",
            "ps": "N"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 大約 20 次",
        "en": "(A) Approximately 20 times",
        "wg": []
      },
      {
        "t": "(B) 大約 1,000 次",
        "en": "(B) Approximately 1,000 times",
        "wg": []
      },
      {
        "t": "(C) 大約 500,000 次",
        "en": "(C) Approximately 500,000 times",
        "wg": []
      },
      {
        "t": "(D) 大約 1,000,000 次",
        "en": "(D) Approximately 1,000,000 times",
        "wg": []
      }
    ],
    "answer": "(A)",
    "why": {
      "t": "二分搜尋法的時間複雜度為 O(log n)。log2(1,000,000) 大約等於 19.9，因此最壞情況下大約需要比較 20 次。",
      "en": "The time complexity of Binary Search is O(log n). log2(1,000,000) is approximately 19.9, so about 20 comparisons are needed in the worst-case scenario.",
      "wg": [
        {
          "t": "時間複雜度",
          "en": "time complexity",
          "ps": "N"
        }
      ]
    }
  },
  {
    "no": "5",
    "level": "medium",
    "keywords": "Binary Search, Duplicates, Lower Bound",
    "parentNo": null,
    "images": null,
    "codeSnippet": "nums = [1, 2, 4, 4, 4, 6, 7], target = 4",
    "question": [
      {
        "t": "給定上述已排序陣列，若要修改標準二分搜尋法以找出目標值 `4` 的「第一個」出現位置 (索引 2)，當 `nums[mid] == target` 時，應該採取什麼動作？",
        "en": "Given the sorted array above, if you want to modify the standard Binary Search to find the 'first' occurrence of the target `4` (index 2), what action should be taken when `nums[mid] == target`?",
        "wg": [
          {
            "t": "出現位置",
            "en": "occurrence",
            "ps": "N"
          },
          {
            "t": "修改",
            "en": "modify",
            "ps": "V"
          }
        ]
      }
    ],
    "type": "單選題",
    "options": [
      {
        "t": "(A) 直接回傳 mid，結束搜尋。",
        "en": "(A) Return mid immediately and end the search.",
        "wg": []
      },
      {
        "t": "(B) 將 left 移動到 mid + 1，繼續往右搜尋。",
        "en": "(B) Move left to mid + 1 and continue searching to the right.",
        "wg": []
      },
      {
        "t": "(C) 將 right 移動到 mid - 1，繼續往左搜尋。",
        "en": "(C) Move right to mid - 1 and continue searching to the left.",
        "wg": []
      },
      {
        "t": "(D) 停止二分搜尋，改用線性搜尋往左找。",
        "en": "(D) Stop Binary Search and switch to linear search to the left.",
        "wg": [
          {
            "t": "線性搜尋",
            "en": "linear search",
            "ps": "N"
          }
        ]
      }
    ],
    "answer": "(C)",
    "why": {
      "t": "為了找到第一個出現的位置，即使找到了目標值，我們也不能確定它是否為第一個。因此需要縮小右邊界 (`right = mid - 1`) 繼續往左側區間搜尋，看是否還有相同的目標值。",
      "en": "To find the first occurrence, even if the target value is found, we cannot be sure it is the first one. Therefore, we need to shrink the right boundary (`right = mid - 1`) and continue searching in the left interval to see if there are earlier instances of the target.",
      "wg": [
        {
          "t": "邊界",
          "en": "boundary",
          "ps": "N"
        },
        {
          "t": "區間",
          "en": "interval",
          "ps": "N"
        }
      ]
    }
  }
]